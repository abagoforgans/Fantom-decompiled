contract main {




// =====================  Runtime code  =====================


#
#  - harvest()
#  - migrate(address arg1)
#
const name = 'StrategyLenderYieldOptimiser', 0

const apiVersion = '', 0

const weth = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2

const uniswapRouter = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d

const delegatedAssets = 0

const SECONDSPERYEAR = 31556952


array of uint256 metadataURI;
address vaultAddress;
address strategistAddress;
address rewardsAddress;
address keeperAddress;
address wantAddress;
uint256 minReportDelay;
uint256 maxReportDelay;
uint256 profitFactor;
uint256 debtThreshold;
uint8 emergencyExit;
uint256 withdrawalThreshold;
array of address lenders;
uint8 externalOracle;
address wantToEthOracleAddress; offset 8

function metadataURI() payable {
    return metadataURI[0 len metadataURI.length]
}

function debtThreshold() payable {
    return debtThreshold
}

function want() payable {
    return wantAddress
}

function strategist() payable {
    return strategistAddress
}

function maxReportDelay() payable {
    return maxReportDelay
}

function wantToEthOracle() payable {
    return wantToEthOracleAddress
}

function externalOracle() payable {
    return bool(externalOracle)
}

function emergencyExit() payable {
    return bool(emergencyExit)
}

function withdrawalThreshold() payable {
    return withdrawalThreshold
}

function profitFactor() payable {
    return profitFactor
}

function lenders(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < lenders.length
    return lenders[arg1]
}

function minReportDelay() payable {
    return minReportDelay
}

function rewards() payable {
    return rewardsAddress
}

function keeper() payable {
    return keeperAddress
}

function numLenders() payable {
    return lenders.length
}

function vault() payable {
    return vaultAddress
}

function _fallback() payable {
    revert
}

function clone(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require ext_code.size(this.address)
    call this.address.0xd0511842 with:
         gas gas_remaining wei
        args 0, 0, msg.sender, msg.sender, msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    return ext_call.return_data[12 len 20]
}

function setWithdrawalThreshold(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if strategistAddress != msg.sender:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, '!authorized'
    withdrawalThreshold = arg1
}

function setPriceOracle(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if strategistAddress != msg.sender:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, '!authorized'
    wantToEthOracleAddress = arg1
}

function setProfitFactor(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if strategistAddress != msg.sender:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, '!authorized'
    profitFactor = arg1
    emit UpdatedProfitFactor(arg1);
}

function setDebtThreshold(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if strategistAddress != msg.sender:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, '!authorized'
    debtThreshold = arg1
    emit UpdatedDebtThreshold(arg1);
}

function setMinReportDelay(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if strategistAddress != msg.sender:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, '!authorized'
    minReportDelay = arg1
    emit UpdatedMinReportDelay(arg1);
}

function setMaxReportDelay(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if strategistAddress != msg.sender:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, '!authorized'
    maxReportDelay = arg1
    emit UpdatedMaxReportDelay(arg1);
}

function setKeeper(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if strategistAddress != msg.sender:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, '!authorized'
    require arg1
    keeperAddress = arg1
    emit UpdatedKeeper(arg1);
}

function setStrategist(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if strategistAddress != msg.sender:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, '!authorized'
    require arg1
    strategistAddress = arg1
    emit UpdatedStrategist(arg1);
}

function lentTotalAssets() payable {
    mem[64] = 96
    idx = 0
    s = 0
    while idx < lenders.length:
        mem[0] = 12
        require ext_code.size(lenders[idx])
        staticcall lenders[idx].nav() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _15 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if mem[_15] + s < s:
            revert with 0, 'SafeMath: addition overflow'
        idx = idx + 1
        s = mem[_15] + s
        continue 
    return (_16 * lenders.length)
}

function clone(address arg1, address arg2, address arg3, address arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 == arg4
    create contract with 0 wei
                    code: 0x3d602d80600a3d3981f3363d3d373d3d3d363d73, Mask(160, 96, this.address) >> 96, 0x5af43d82803e903d91602b57fd5bf3
    require ext_code.size(address(create.new_address))
    call address(create.new_address).0xf8c8765e with:
         gas gas_remaining wei
        args 0, 0, address(arg2), address(arg3), arg4
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    emit Cloned(address(create.new_address));
    return address(create.new_address)
}

function setEmergencyExit() payable {
    if strategistAddress != msg.sender:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, '!authorized'
    emergencyExit = 1
    require ext_code.size(vaultAddress)
    call vaultAddress.revokeStrategy() with:
         gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    emit EmergencyExitEnabled()
}

function setRewards(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if strategistAddress != msg.sender:
        revert with 0, '!strategist'
    require arg1
    require ext_code.size(vaultAddress)
    call vaultAddress.approve(address rg1, uint256 rg2) with:
         gas gas_remaining wei
        args rewardsAddress, 0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    rewardsAddress = arg1
    require ext_code.size(vaultAddress)
    call vaultAddress.approve(address rg1, uint256 rg2) with:
         gas gas_remaining wei
        args address(arg1), -1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    emit UpdatedRewards(arg1);
}

function addLender(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require ext_code.size(vaultAddress)
    staticcall vaultAddress.governance() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0, '!authorized'
    require ext_code.size(arg1)
    staticcall arg1.strategy() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if ext_call.return_data[12 len 20] != this.address:
        revert with 0, 'Undocked Lender'
    idx = 0
    while idx < lenders.length:
        mem[0] = 12
        if lenders[idx] == arg1:
            revert with 0, 'Already Added'
        idx = idx + 1
        continue 
    lenders.length++
    lenders[lenders.length] = arg1
}

function setMetadataURI(string arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    require arg1.length <= test266151307()
    require arg1 + arg1.length + 36 <= calldata.size
    if strategistAddress != msg.sender:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, '!authorized'
    metadataURI.length = (2 * arg1.length) + 1
    s = 0
    idx = arg1 + 36
    while arg1 + arg1.length + 36 > idx:
        metadataURI[s] = cd[idx]
        s = s + 1
        idx = idx + 32
        continue 
    idx = Mask(251, 0, arg1.length + 31) >> 5
    while metadataURI.length + 31 / 32 > idx:
        metadataURI[idx] = 0
        idx = idx + 1
        continue 
    emit UpdatedMetadataURI(Array(len=arg1.length, data=arg1[all]));
}

function estimatedTotalAssets() payable {
    mem[64] = 96
    idx = 0
    s = 0
    while idx < lenders.length:
        mem[0] = 12
        require ext_code.size(lenders[idx])
        staticcall lenders[idx].nav() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _21 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if mem[_21] + s < s:
            revert with 0, 'SafeMath: addition overflow'
        idx = idx + 1
        s = mem[_21] + s
        continue 
    mem[mem[64] + 4] = this.address
    require ext_code.size(wantAddress)
    staticcall wantAddress.0x70a08231 with:
            gas gas_remaining wei
           args address(this.address)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _22 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    if mem[_22] + (_23 * lenders.length) < _23 * lenders.length:
        revert with 0, 'SafeMath: addition overflow'
    mem[mem[64]] = mem[_22] + (_23 * lenders.length)
    return memory
      from mem[64]
       len 32
}

function isActive() payable {
    require ext_code.size(vaultAddress)
    staticcall vaultAddress.strategies(address rg1) with:
            gas gas_remaining wei
           args this.address
    mem[96 len 288] = ext_call.return_data[0 len 288]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 288
    require bool(ceil32(return_data.size) + 384 <= test266151307())
    mem[64] = ceil32(return_data.size) + 384
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    mem[ceil32(return_data.size) + 128] = ext_call.return_data[32]
    mem[ceil32(return_data.size) + 160] = ext_call.return_data[64]
    mem[ceil32(return_data.size) + 192] = ext_call.return_data[96]
    mem[ceil32(return_data.size) + 224] = ext_call.return_data[128]
    mem[ceil32(return_data.size) + 256] = ext_call.return_data[160]
    mem[ceil32(return_data.size) + 288] = ext_call.return_data[192]
    mem[ceil32(return_data.size) + 320] = ext_call.return_data[224]
    mem[ceil32(return_data.size) + 352] = ext_call.return_data[256]
    if ext_call.return_data[64] > 0:
        return (ext_call.return_data[64] > 0)
    idx = 0
    s = 0
    while idx < lenders.length:
        mem[0] = 12
        require ext_code.size(lenders[idx])
        staticcall lenders[idx].nav() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _37 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if mem[_37] + s < s:
            revert with 0, 'SafeMath: addition overflow'
        idx = idx + 1
        s = mem[_37] + s
        continue 
    mem[mem[64] + 4] = this.address
    require ext_code.size(wantAddress)
    staticcall wantAddress.0x70a08231 with:
            gas gas_remaining wei
           args address(this.address)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _38 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    if mem[_38] + (_39 * lenders.length) < _39 * lenders.length:
        revert with 0, 'SafeMath: addition overflow'
    mem[mem[64]] = mem[_38] + (_39 * lenders.length) > 0
    return memory
      from mem[64]
       len 32
}

function estimatedAPR() payable {
    mem[64] = 96
    idx = 0
    s = 0
    while idx < lenders.length:
        mem[0] = 12
        require ext_code.size(lenders[idx])
        staticcall lenders[idx].nav() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _36 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if mem[_36] + s < s:
            revert with 0, 'SafeMath: addition overflow'
        idx = idx + 1
        s = mem[_36] + s
        continue 
    mem[mem[64] + 4] = this.address
    require ext_code.size(wantAddress)
    staticcall wantAddress.0x70a08231 with:
            gas gas_remaining wei
           args address(this.address)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _37 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _39 = mem[_37]
    if mem[_37] + (_38 * lenders.length) < _38 * lenders.length:
        revert with 0, 'SafeMath: addition overflow'
    if not mem[_37] + (_38 * lenders.length):
        return 0
    idx = 0
    s = 0
    while idx < lenders.length:
        mem[0] = 12
        require ext_code.size(lenders[idx])
        staticcall lenders[idx].weightedApr() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _66 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _68 = mem[_66]
        if mem[_66] + s < s:
            revert with 0, 'SafeMath: addition overflow'
        idx = idx + 1
        s = mem[_66] + s
        continue 
    _61 = mem[64]
    mem[64] = mem[64] + 64
    mem[_61] = 26
    mem[_61 + 32] = 'SafeMath: division by zero'
    if _39 + (_38 * lenders.length):
        return (_68 * lenders.length / _39 + (_38 * lenders.length))
    _65 = mem[64]
    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
    mem[mem[64] + 4] = 32
    mem[mem[64] + 36] = 26
    s = 0
    while lenders.length < 26:
        mem[lenders.length + _65 + 68] = mem[lenders.length + _61 + 32]
        s = lenders.length + 32
        continue 
    if lenders.length > 26:
        mem[_65 + 94] = 0
    revert with memory
      from mem[64]
       len _65 + -mem[64] + 100
}

function estimateAdjustPosition() payable {
    mem[100] = this.address
    require ext_code.size(wantAddress)
    staticcall wantAddress.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(return_data.size) + 96
    require return_data.size >= 32
    idx = 0
    s = 0
    t = -1
    while idx < lenders.length:
        mem[0] = 12
        require ext_code.size(lenders[idx])
        staticcall lenders[idx].hasAssets() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _31 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require mem[_31] == bool(mem[_31])
        if not mem[_31]:
            idx = idx + 1
            s = s
            t = t
            continue 
        require idx < lenders.length
        mem[0] = 12
        require ext_code.size(lenders[idx])
        staticcall lenders[idx].apr() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _41 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _43 = mem[_41]
        if mem[_41] >= t:
            idx = idx + 1
            s = s
            t = t
            continue 
        require idx < lenders.length
        mem[0] = 12
        require ext_code.size(lenders[idx])
        staticcall lenders[idx].nav() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _47 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        idx = idx + 1
        s = mem[_47]
        t = _43
        continue 
    if ext_call.return_data[0] + s < s:
        revert with 0, 'SafeMath: addition overflow'
    idx = 0
    u = 0
    while idx < lenders.length:
        mem[0] = 12
        mem[mem[64] + 4] = ext_call.return_data[0]
        require ext_code.size(lenders[idx])
        staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                gas gas_remaining wei
               args ext_call.return_data[0]
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _56 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if mem[_56] <= u:
            idx = idx + 1
            u = u
            continue 
        idx = idx + 1
        u = mem[_56]
        continue 
    require 0 < lenders.length
    mem[0] = 12
    mem[mem[64] + 4] = ext_call.return_data[0] + s
    require ext_code.size(lenders)
    staticcall lenders.aprAfterDeposit(uint256 rg1) with:
            gas gas_remaining wei
           args (ext_call.return_data[0] + s)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _55 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    return 0, t, 0, mem[_55]
}

function initialize(address arg1, address arg2, address arg3, address arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 == arg4
    if wantAddress:
        revert with 0, 'Strategy already initialized'
    vaultAddress = arg1
    require ext_code.size(arg1)
    staticcall arg1.token() with:
            gas gas_remaining wei
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    wantAddress = ext_call.return_data[12 len 20]
    mem[ceil32(return_data.size) + 100] = this.address
    mem[ceil32(return_data.size) + 132] = arg1
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
            gas gas_remaining wei
           args address(this.address), arg1
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0]:
        revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
    mem[(2 * ceil32(return_data.size)) + 132] = arg1
    mem[(2 * ceil32(return_data.size)) + 164] = -1
    mem[(2 * ceil32(return_data.size)) + 96] = 68
    mem[(2 * ceil32(return_data.size)) + 132 len 28] = address(arg1) << 64
    mem[(2 * ceil32(return_data.size)) + 128 len 4] = approve(address rg1, uint256 rg2)
    mem[(2 * ceil32(return_data.size)) + 196] = 32
    mem[(2 * ceil32(return_data.size)) + 228] = 'SafeERC20: low-level call failed'
    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(ext_call.return_data[0])):
        revert with 0, 'Address: call to non-contract'
    if not ext_code.hash(address(ext_call.return_data[0])):
        revert with 0, 'Address: call to non-contract'
    mem[(2 * ceil32(return_data.size)) + 260 len 96] = approve(address rg1, uint256 rg2), address(arg1) << 64, 0, -1, 0
    mem[(2 * ceil32(return_data.size)) + 328] = 0
    call address(ext_call.return_data[0]) with:
       funct Mask(32, 224, approve(address rg1, uint256 rg2), address(arg1) << 64, 0, -1, 0) >> 224
         gas gas_remaining wei
        args (Mask(512, -288, approve(address rg1, uint256 rg2), address(arg1) << 64, 0, -1, 0) << 288)
    if not return_data.size:
        if not ext_call.success:
            if ext_call.return_data[0]:
                revert with memory
                  from 128
                   len ext_call.return_data[0]
            revert with 0, 'SafeERC20: low-level call failed'
        if ext_call.return_data[0]:
            require ext_call.return_data[0] >= 32
            require mem[128] == bool(mem[128])
            if not mem[128]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    else:
        mem[(2 * ceil32(return_data.size)) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            require mem[(2 * ceil32(return_data.size)) + 292] == bool(mem[(2 * ceil32(return_data.size)) + 292])
            if not mem[(2 * ceil32(return_data.size)) + 292]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    strategistAddress = arg2
    rewardsAddress = arg3
    keeperAddress = arg4
    require ext_code.size(vaultAddress)
    call vaultAddress.approve(address rg1, uint256 rg2) with:
         gas gas_remaining wei
        args address(arg3), -1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
}

function sweep(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require ext_code.size(vaultAddress)
    staticcall vaultAddress.governance() with:
            gas gas_remaining wei
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0, '!authorized'
    if wantAddress == arg1:
        revert with 0, '!want'
    if vaultAddress == arg1:
        revert with 0, '!shares'
    mem[ceil32(return_data.size) + 96] = 1
    mem[ceil32(return_data.size) + 128] = wantAddress
    idx = 0
    while idx < 1:
        require idx < 1
        if arg1 == mem[(32 * idx) + ceil32(return_data.size) + 140 len 20]:
            revert with 0, '!protected'
        idx = idx + 1
        continue 
    require ext_code.size(vaultAddress)
    staticcall vaultAddress.governance() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 160] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[(2 * ceil32(return_data.size)) + 164] = this.address
    require ext_code.size(arg1)
    staticcall arg1.0x70a08231 with:
            gas gas_remaining wei
           args mem[(2 * ceil32(return_data.size)) + 164 len ceil32(return_data.size) + 32]
    mem[(2 * ceil32(return_data.size)) + 160] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    mem[(4 * ceil32(return_data.size)) + 196] = address(ext_call.return_data[0])
    mem[(4 * ceil32(return_data.size)) + 228] = ext_call.return_data[0]
    mem[(4 * ceil32(return_data.size)) + 160] = (5 * ceil32(return_data.size)) + 68
    mem[(4 * ceil32(return_data.size)) + 196 len 28] = address(ext_call.return_data[0]) << 64
    mem[(4 * ceil32(return_data.size)) + 192 len 4] = unknown_0xa9059cbb(?????)
    mem[(4 * ceil32(return_data.size)) + 260] = 32
    mem[(4 * ceil32(return_data.size)) + 292] = 'SafeERC20: low-level call failed'
    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
        revert with 0, 'Address: call to non-contract'
    if not ext_code.hash(arg1):
        revert with 0, 'Address: call to non-contract'
    mem[(4 * ceil32(return_data.size)) + 324 len floor32((5 * ceil32(return_data.size)) + 99)] = unknown_0xa9059cbb(?????), address(ext_call.return_data[0]) << 64, 0, ext_call.return_data[0], mem[(4 * ceil32(return_data.size)) + 260 len floor32((5 * ceil32(return_data.size)) + 99) - 68]
    if floor32((5 * ceil32(return_data.size)) + 99) > (5 * ceil32(return_data.size)) + 68:
        mem[(10 * ceil32(return_data.size)) + 392] = 0
    call arg1.mem[(4 * ceil32(return_data.size)) + 324 len 4] with:
         gas gas_remaining wei
        args mem[(4 * ceil32(return_data.size)) + 328 len (13 * ceil32(return_data.size)) + 64]
    if not return_data.size:
        if not ext_call.success:
            if ext_call.return_data[0]:
                revert with memory
                  from 128
                   len ext_call.return_data[0]
            revert with 0, 'SafeERC20: low-level call failed'
        if ext_call.return_data[0]:
            require ext_call.return_data[0] >= 32
            require mem[128] == bool(mem[128])
            if not mem[128]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    else:
        mem[(4 * ceil32(return_data.size)) + 356 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            require mem[(4 * ceil32(return_data.size)) + 356] == bool(mem[(4 * ceil32(return_data.size)) + 356])
            if not mem[(4 * ceil32(return_data.size)) + 356]:
                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
}

function lendStatuses() payable {
    require lenders.length <= test266151307()
    mem[96] = lenders.length
    mem[64] = (32 * lenders.length) + 128
    if not lenders.length:
        idx = 0
        while idx < lenders.length:
            _97 = mem[64]
            mem[64] = mem[64] + 128
            mem[_97] = 96
            mem[_97 + 32] = 0
            mem[_97 + 64] = 0
            mem[_97 + 96] = 0
            mem[0] = 12
            mem[mem[64]] = 0x8b20217600000000000000000000000000000000000000000000000000000000
            require ext_code.size(lenders[idx])
            staticcall lenders[idx].lenderName() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _106 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _109 = mem[_106]
            require mem[_106] <= test266151307()
            require _106 + mem[_106] + 31 < _106 + return_data.size
            _115 = mem[_106 + mem[_106]]
            require mem[_106 + mem[_106]] <= test266151307()
            require ceil32(mem[_106 + mem[_106]]) + 32 >= 0 and _106 + ceil32(return_data.size) + ceil32(mem[_106 + mem[_106]]) + 32 <= test266151307()
            mem[64] = _106 + ceil32(return_data.size) + ceil32(mem[_106 + mem[_106]]) + 32
            mem[_106 + ceil32(return_data.size)] = _115
            require _109 + _115 + 32 <= return_data.size
            s = 0
            while s < _115:
                mem[s + _106 + ceil32(return_data.size) + 32] = mem[s + _106 + _109 + 32]
                s = s + 32
                continue 
            if ceil32(_115) <= _115:
                mem[_97] = _106 + ceil32(return_data.size)
                require idx < lenders.length
                mem[_97 + 96] = lenders[idx]
                mem[0] = 12
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].nav() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _212 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_97 + 32] = mem[_212]
                require idx < lenders.length
                mem[0] = 12
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].apr() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _232 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_97 + 64] = mem[_232]
            else:
                mem[_115 + _106 + ceil32(return_data.size) + 32] = 0
                mem[_97] = _106 + ceil32(return_data.size)
                require idx < lenders.length
                mem[_97 + 96] = lenders[idx]
                mem[0] = 12
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].nav() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _213 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_97 + 32] = mem[_213]
                require idx < lenders.length
                mem[0] = 12
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].apr() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _233 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_97 + 64] = mem[_233]
            require idx < mem[96]
            mem[(32 * idx) + 128] = _97
            idx = idx + 1
            continue 
        _96 = mem[64]
        mem[mem[64]] = 32
        _98 = mem[96]
        mem[mem[64] + 32] = mem[96]
        idx = 0
        s = 128
        t = mem[64] + (32 * mem[96]) + 64
        u = mem[64] + 64
        while idx < _98:
            mem[u] = t + -_96 - 64
            _189 = mem[s]
            _190 = mem[mem[s]]
            mem[t] = 128
            _193 = mem[_190]
            mem[t + 128] = mem[_190]
            v = 0
            while v < _193:
                mem[v + t + 160] = mem[v + _190 + 32]
                v = v + 32
                continue 
            if ceil32(_193) > _193:
                mem[_193 + t + 160] = 0
            mem[t + 32] = mem[_189 + 32]
            mem[t + 64] = mem[_189 + 64]
            mem[t + 96] = mem[_189 + 108 len 20]
            idx = idx + 1
            s = s + 32
            t = ceil32(_193) + t + 160
            u = u + 32
            continue 
    else:
        mem[64] = (32 * lenders.length) + 256
        mem[(32 * lenders.length) + 128] = 96
        mem[(32 * lenders.length) + 160] = 0
        mem[(32 * lenders.length) + 192] = 0
        mem[(32 * lenders.length) + 224] = 0
        mem[var8001] = (32 * lenders.length) + 128
        s = var8001
        idx = var8002
        while idx - 1:
            mem[64] = mem[64] + 128
            mem[(32 * lenders.length) + 128] = 96
            mem[(32 * lenders.length) + 160] = 0
            mem[(32 * lenders.length) + 192] = 0
            mem[(32 * lenders.length) + 224] = 0
            mem[s + 32] = (32 * lenders.length) + 128
            s = s + 32
            idx = idx - 1
            continue 
        idx = 0
        while idx < lenders.length:
            _273 = mem[64]
            mem[64] = mem[64] + 128
            mem[_273] = 96
            mem[_273 + 32] = 0
            mem[_273 + 64] = 0
            mem[_273 + 96] = 0
            mem[0] = 12
            mem[mem[64]] = 0x8b20217600000000000000000000000000000000000000000000000000000000
            require ext_code.size(lenders[idx])
            staticcall lenders[idx].lenderName() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _288 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _289 = mem[_288]
            require mem[_288] <= test266151307()
            require _288 + mem[_288] + 31 < _288 + return_data.size
            _291 = mem[_288 + mem[_288]]
            require mem[_288 + mem[_288]] <= test266151307()
            require ceil32(mem[_288 + mem[_288]]) + 32 >= 0 and _288 + ceil32(return_data.size) + ceil32(mem[_288 + mem[_288]]) + 32 <= test266151307()
            mem[64] = _288 + ceil32(return_data.size) + ceil32(mem[_288 + mem[_288]]) + 32
            mem[_288 + ceil32(return_data.size)] = _291
            require _289 + _291 + 32 <= return_data.size
            s = 0
            while s < _291:
                mem[s + _288 + ceil32(return_data.size) + 32] = mem[s + _288 + _289 + 32]
                s = s + 32
                continue 
            if ceil32(_291) <= _291:
                mem[_273] = _288 + ceil32(return_data.size)
                require idx < lenders.length
                mem[_273 + 96] = lenders[idx]
                mem[0] = 12
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].nav() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _344 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_273 + 32] = mem[_344]
                require idx < lenders.length
                mem[0] = 12
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].apr() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _354 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_273 + 64] = mem[_354]
            else:
                mem[_291 + _288 + ceil32(return_data.size) + 32] = 0
                mem[_273] = _288 + ceil32(return_data.size)
                require idx < lenders.length
                mem[_273 + 96] = lenders[idx]
                mem[0] = 12
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].nav() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _345 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_273 + 32] = mem[_345]
                require idx < lenders.length
                mem[0] = 12
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].apr() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _355 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_273 + 64] = mem[_355]
            require idx < mem[96]
            mem[(32 * idx) + 128] = _273
            idx = idx + 1
            continue 
        _272 = mem[64]
        mem[mem[64]] = 32
        _274 = mem[96]
        mem[mem[64] + 32] = mem[96]
        idx = 0
        s = 128
        t = mem[64] + (32 * mem[96]) + 64
        u = mem[64] + 64
        while idx < _274:
            mem[u] = t + -_272 - 64
            _324 = mem[s]
            _325 = mem[mem[s]]
            mem[t] = 128
            _328 = mem[_325]
            mem[t + 128] = mem[_325]
            v = 0
            while v < _328:
                mem[v + t + 160] = mem[v + _325 + 32]
                v = v + 32
                continue 
            if ceil32(_328) > _328:
                mem[_328 + t + 160] = 0
            mem[t + 32] = mem[_324 + 32]
            mem[t + 64] = mem[_324 + 64]
            mem[t + 96] = mem[_324 + 108 len 20]
            idx = idx + 1
            s = s + 32
            t = ceil32(_328) + t + 160
            u = u + 32
            continue 
    return memory
      from mem[64]
       len t - mem[64]
}

function estimatedFutureAPR(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require ext_code.size(vaultAddress)
    staticcall vaultAddress.strategies(address rg1) with:
            gas gas_remaining wei
           args this.address
    mem[96 len 288] = ext_call.return_data[0 len 288]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 288
    require bool(ceil32(return_data.size) + 384 <= test266151307())
    mem[64] = ceil32(return_data.size) + 384
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    mem[ceil32(return_data.size) + 128] = ext_call.return_data[32]
    mem[ceil32(return_data.size) + 160] = ext_call.return_data[64]
    mem[ceil32(return_data.size) + 192] = ext_call.return_data[96]
    mem[ceil32(return_data.size) + 224] = ext_call.return_data[128]
    mem[ceil32(return_data.size) + 256] = ext_call.return_data[160]
    mem[ceil32(return_data.size) + 288] = ext_call.return_data[192]
    mem[ceil32(return_data.size) + 320] = ext_call.return_data[224]
    mem[ceil32(return_data.size) + 352] = ext_call.return_data[256]
    if ext_call.return_data[192] >= arg1:
        idx = 0
        s = -1
        while idx < lenders.length:
            mem[0] = 12
            mem[mem[64] + 4] = ext_call.return_data[192] - arg1
            require ext_code.size(lenders[idx])
            staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                    gas gas_remaining wei
                   args (ext_call.return_data[192] - arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _75 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_75] >= s:
                idx = idx + 1
                s = s
                continue 
            idx = idx + 1
            s = mem[_75]
            continue 
        idx = 0
        t = ext_call.return_data[192] - arg1
        while idx < lenders.length:
            require idx < lenders.length
            mem[0] = 12
            require ext_code.size(lenders[idx])
            if idx:
                staticcall lenders[idx].weightedApr() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _157 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_157] < 0:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                t = t
                continue 
            staticcall lenders[idx].nav() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _156 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_156] >= t:
                if s:
                    if t * s / s != t:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if t * s < 0:
                        revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                t = t
                continue 
            if s:
                if mem[_156] * s / s != mem[_156]:
                    revert with 0, 'SafeMath: multiplication overflow'
                if mem[_156] * s < 0:
                    revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            t = mem[_156]
            continue 
        idx = 0
        s = 0
        while idx < lenders.length:
            mem[0] = 12
            require ext_code.size(lenders[idx])
            staticcall lenders[idx].nav() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _260 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_260] + s < s:
                revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            s = mem[_260] + s
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(wantAddress)
        staticcall wantAddress.0x70a08231 with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _265 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if mem[_265] + (_266 * lenders.length) < _266 * lenders.length:
            revert with 0, 'SafeMath: addition overflow'
        if t < 0:
            revert with 0, 'SafeMath: addition overflow'
        if not t + mem[_265] + (_266 * lenders.length):
            revert with 0, 'SafeMath: division by zero', 0
        return (0 / t + mem[_265] + (_266 * lenders.length))
    idx = 0
    s = 0
    t = 0
    while idx < lenders.length:
        mem[0] = 12
        mem[mem[64] + 4] = arg1 - ext_call.return_data[192]
        require ext_code.size(lenders[idx])
        staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                gas gas_remaining wei
               args (arg1 - ext_call.return_data[192])
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _76 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _81 = mem[_76]
        if mem[_76] <= t:
            idx = idx + 1
            s = s
            t = t
            continue 
        require idx < lenders.length
        mem[0] = 12
        require ext_code.size(lenders[idx])
        staticcall lenders[idx].nav() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _89 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        idx = idx + 1
        s = mem[_89]
        t = _81
        continue 
    if arg1 - ext_call.return_data[192] + s < s:
        revert with 0, 'SafeMath: addition overflow'
    if not t:
        idx = 0
        while idx < lenders.length:
            if idx:
                require idx < lenders.length
                mem[0] = 12
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].weightedApr() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _159 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_159] < 0:
                    revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            continue 
        idx = 0
        s = 0
        while idx < lenders.length:
            mem[0] = 12
            require ext_code.size(lenders[idx])
            staticcall lenders[idx].nav() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _264 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_264] + s < s:
                revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            s = mem[_264] + s
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(wantAddress)
        staticcall wantAddress.0x70a08231 with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _269 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if mem[_269] + (_270 * lenders.length) < _270 * lenders.length:
            revert with 0, 'SafeMath: addition overflow'
        if arg1 - ext_call.return_data[192] < 0:
            revert with 0, 'SafeMath: addition overflow'
        if not arg1 - ext_call.return_data[192] + mem[_269] + (_270 * lenders.length):
            revert with 0, 'SafeMath: division by zero', 0
        return (0 / arg1 - ext_call.return_data[192] + mem[_269] + (_270 * lenders.length))
    if (arg1 * t) - (ext_call.return_data[192] * t) + (s * t) / t != arg1 - ext_call.return_data[192] + s:
        revert with 0, 'SafeMath: multiplication overflow'
    idx = 0
    while idx < lenders.length:
        if idx:
            require idx < lenders.length
            mem[0] = 12
            require ext_code.size(lenders[idx])
            staticcall lenders[idx].weightedApr() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _158 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_158] < 0:
                revert with 0, 'SafeMath: addition overflow'
        idx = idx + 1
        continue 
    idx = 0
    u = 0
    while idx < lenders.length:
        mem[0] = 12
        require ext_code.size(lenders[idx])
        staticcall lenders[idx].nav() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _262 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if mem[_262] + u < u:
            revert with 0, 'SafeMath: addition overflow'
        idx = idx + 1
        u = mem[_262] + u
        continue 
    mem[mem[64] + 4] = this.address
    require ext_code.size(wantAddress)
    staticcall wantAddress.0x70a08231 with:
            gas gas_remaining wei
           args address(this.address)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _267 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    if mem[_267] + (_268 * lenders.length) < _268 * lenders.length:
        revert with 0, 'SafeMath: addition overflow'
    if arg1 - ext_call.return_data[192] < 0:
        revert with 0, 'SafeMath: addition overflow'
    if not arg1 - ext_call.return_data[192] + mem[_267] + (_268 * lenders.length):
        revert with 0, 'SafeMath: division by zero', 0
    return ((arg1 * t) - (ext_call.return_data[192] * t) + (s * t) / arg1 - ext_call.return_data[192] + mem[_267] + (_268 * lenders.length))
}

function harvestTrigger(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
        mem[96] = 0
        mem[128] = 0
        mem[160] = 0
        mem[192] = 0
        mem[224] = 0
        mem[256] = 0
        mem[288] = 0
        mem[320] = 0
        mem[352] = 0
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.strategies(address rg1) with:
                gas gas_remaining wei
               args this.address
        mem[384 len 288] = ext_call.return_data[0 len 288]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 288
        require bool(ceil32(return_data.size) + 672 <= test266151307())
        mem[ceil32(return_data.size) + 384] = ext_call.return_data[0]
        mem[ceil32(return_data.size) + 416] = ext_call.return_data[32]
        mem[ceil32(return_data.size) + 448] = ext_call.return_data[64]
        mem[ceil32(return_data.size) + 480] = ext_call.return_data[96]
        mem[ceil32(return_data.size) + 512] = ext_call.return_data[128]
        mem[ceil32(return_data.size) + 544] = ext_call.return_data[160]
        mem[ceil32(return_data.size) + 576] = ext_call.return_data[192]
        mem[ceil32(return_data.size) + 608] = ext_call.return_data[224]
        mem[ceil32(return_data.size) + 640] = ext_call.return_data[256]
        if 0 == ext_call.return_data[32]:
            return 0
        mem[ceil32(return_data.size) + 672] = 30
        mem[ceil32(return_data.size) + 704] = 'SafeMath: subtraction overflow'
        if ext_call.return_data[160] > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if block.timestamp - ext_call.return_data[160] < minReportDelay:
            return 0
        mem[ceil32(return_data.size) + 736] = 30
        mem[ceil32(return_data.size) + 768] = 'SafeMath: subtraction overflow'
        if ext_call.return_data[160] > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if block.timestamp - ext_call.return_data[160] >= maxReportDelay:
            return 1
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.debtOutstanding() with:
                gas gas_remaining wei
        mem[ceil32(return_data.size) + 800] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[64] = (2 * ceil32(return_data.size)) + 800
        require return_data.size >= 32
        if ext_call.return_data[0] > debtThreshold:
            return 1
        idx = 0
        s = 0
        while idx < lenders.length:
            mem[0] = 12
            require ext_code.size(lenders[idx])
            staticcall lenders[idx].nav() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _312 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_312] + s < s:
                revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            s = mem[_312] + s
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(wantAddress)
        staticcall wantAddress.0x70a08231 with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _324 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _328 = mem[_324]
        if mem[_324] + (_325 * lenders.length) < _325 * lenders.length:
            revert with 0, 'SafeMath: addition overflow'
        if debtThreshold < 0:
            revert with 0, 'SafeMath: addition overflow'
        if debtThreshold + mem[_324] + (_325 * lenders.length) < mem[ceil32(return_data.size) + 576]:
            return 1
        if mem[_324] + (_325 * lenders.length) <= mem[ceil32(return_data.size) + 576]:
            require ext_code.size(vaultAddress)
            staticcall vaultAddress.creditAvailable() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _360 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_360] < mem[_360]:
                revert with 0, 'SafeMath: addition overflow'
            if not profitFactor:
                mem[mem[64]] = 0 < mem[_360]
            else:
                if arg1 * profitFactor / profitFactor != arg1:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[mem[64]] = arg1 * profitFactor < mem[_360]
        else:
            _354 = mem[ceil32(return_data.size) + 576]
            _357 = mem[64]
            mem[64] = mem[64] + 64
            mem[_357] = 30
            mem[_357 + 32] = 'SafeMath: subtraction overflow'
            if _354 > _328 + (_325 * lenders.length):
                revert with 0, 'SafeMath: subtraction overflow', 0
            require ext_code.size(vaultAddress)
            staticcall vaultAddress.creditAvailable() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _380 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if _328 + (_325 * lenders.length) - _354 + mem[_380] < mem[_380]:
                revert with 0, 'SafeMath: addition overflow'
            if not profitFactor:
                mem[mem[64]] = 0 < _328 + (_325 * lenders.length) - _354 + mem[_380]
            else:
                if arg1 * profitFactor / profitFactor != arg1:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[mem[64]] = arg1 * profitFactor < _328 + (_325 * lenders.length) - _354 + mem[_380]
    else:
        if wantToEthOracleAddress:
            mem[100] = arg1
            require ext_code.size(wantToEthOracleAddress)
            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                    gas gas_remaining wei
                   args arg1
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[ceil32(return_data.size) + 96] = 0
            mem[ceil32(return_data.size) + 128] = 0
            mem[ceil32(return_data.size) + 160] = 0
            mem[ceil32(return_data.size) + 192] = 0
            mem[ceil32(return_data.size) + 224] = 0
            mem[ceil32(return_data.size) + 256] = 0
            mem[ceil32(return_data.size) + 288] = 0
            mem[ceil32(return_data.size) + 320] = 0
            mem[ceil32(return_data.size) + 352] = 0
            require ext_code.size(vaultAddress)
            staticcall vaultAddress.strategies(address rg1) with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(return_data.size) + 384 len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 288
            require bool((2 * ceil32(return_data.size)) + 672 <= test266151307())
            mem[(2 * ceil32(return_data.size)) + 384] = ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 416] = ext_call.return_data[32]
            mem[(2 * ceil32(return_data.size)) + 448] = ext_call.return_data[64]
            mem[(2 * ceil32(return_data.size)) + 480] = ext_call.return_data[96]
            mem[(2 * ceil32(return_data.size)) + 512] = ext_call.return_data[128]
            mem[(2 * ceil32(return_data.size)) + 544] = ext_call.return_data[160]
            mem[(2 * ceil32(return_data.size)) + 576] = ext_call.return_data[192]
            mem[(2 * ceil32(return_data.size)) + 608] = ext_call.return_data[224]
            mem[(2 * ceil32(return_data.size)) + 640] = ext_call.return_data[256]
            if 0 == ext_call.return_data[32]:
                return 0
            mem[(2 * ceil32(return_data.size)) + 672] = 30
            mem[(2 * ceil32(return_data.size)) + 704] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[160] > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if block.timestamp - ext_call.return_data[160] < minReportDelay:
                return 0
            mem[(2 * ceil32(return_data.size)) + 736] = 30
            mem[(2 * ceil32(return_data.size)) + 768] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[160] > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if block.timestamp - ext_call.return_data[160] >= maxReportDelay:
                return 1
            require ext_code.size(vaultAddress)
            staticcall vaultAddress.debtOutstanding() with:
                    gas gas_remaining wei
            mem[(2 * ceil32(return_data.size)) + 800] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[64] = (4 * ceil32(return_data.size)) + 800
            require return_data.size >= 32
            if ext_call.return_data[0] > debtThreshold:
                return 1
            idx = 0
            s = 0
            while idx < lenders.length:
                mem[0] = 12
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].nav() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _309 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_309] + s < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = mem[_309] + s
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(wantAddress)
            staticcall wantAddress.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _321 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _326 = mem[_321]
            if mem[_321] + (_322 * lenders.length) < _322 * lenders.length:
                revert with 0, 'SafeMath: addition overflow'
            if debtThreshold < 0:
                revert with 0, 'SafeMath: addition overflow'
            if debtThreshold + mem[_321] + (_322 * lenders.length) < mem[(2 * ceil32(return_data.size)) + 576]:
                return 1
            if mem[_321] + (_322 * lenders.length) <= mem[(2 * ceil32(return_data.size)) + 576]:
                require ext_code.size(vaultAddress)
                staticcall vaultAddress.creditAvailable() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _358 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_358] < mem[_358]:
                    revert with 0, 'SafeMath: addition overflow'
                if not profitFactor:
                    mem[mem[64]] = 0 < mem[_358]
                else:
                    if ext_call.return_data[0] * profitFactor / profitFactor != ext_call.return_data[0]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[mem[64]] = ext_call.return_data[0] * profitFactor < mem[_358]
            else:
                _349 = mem[(2 * ceil32(return_data.size)) + 576]
                _355 = mem[64]
                mem[64] = mem[64] + 64
                mem[_355] = 30
                mem[_355 + 32] = 'SafeMath: subtraction overflow'
                if _349 > _326 + (_322 * lenders.length):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                require ext_code.size(vaultAddress)
                staticcall vaultAddress.creditAvailable() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _378 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _326 + (_322 * lenders.length) - _349 + mem[_378] < mem[_378]:
                    revert with 0, 'SafeMath: addition overflow'
                if not profitFactor:
                    mem[mem[64]] = 0 < _326 + (_322 * lenders.length) - _349 + mem[_378]
                else:
                    if ext_call.return_data[0] * profitFactor / profitFactor != ext_call.return_data[0]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[mem[64]] = ext_call.return_data[0] * profitFactor < _326 + (_322 * lenders.length) - _349 + mem[_378]
        else:
            mem[96] = 2
            mem[128 len 64] = call.data[calldata.size len 64]
            mem[192] = 2
            mem[224] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
            mem[256] = wantAddress
            mem[288] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[292] = arg1
            mem[324] = 64
            mem[356] = 2
            idx = 0
            s = 388
            t = 224
            while idx < 2:
                mem[s] = mem[t + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.getAmountsOut(uint256 rg1, address[] rg2) with:
                    gas gas_remaining wei
                   args arg1, Array(len=2, data=mem[388 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[288 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 288
            require return_data.size >= 32
            _323 = mem[288 len 4], Mask(224, 32, arg1) >> 32
            require mem[288 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
            require return_data.size + 288 > mem[288 len 4], Mask(224, 32, arg1) >> 32 + 319
            _327 = mem[mem[288 len 4], Mask(224, 32, arg1) >> 32 + 288]
            require mem[mem[288 len 4], Mask(224, 32, arg1) >> 32 + 288] <= test266151307()
            require (32 * mem[mem[288 len 4], Mask(224, 32, arg1) >> 32 + 288]) + 32 >= 0 and ceil32(return_data.size) + (32 * mem[mem[288 len 4], Mask(224, 32, arg1) >> 32 + 288]) + 320 <= test266151307()
            mem[64] = ceil32(return_data.size) + (32 * mem[mem[288 len 4], Mask(224, 32, arg1) >> 32 + 288]) + 320
            mem[ceil32(return_data.size) + 288] = mem[mem[288 len 4], Mask(224, 32, arg1) >> 32 + 288]
            require return_data.size >= _323 + (32 * _327) + 32
            mem[ceil32(return_data.size) + 320 len 32 * _327] = mem[_323 + 320 len 32 * _327]
            require _327 - 1 < _327
            _512 = mem[(32 * _327 - 1) + ceil32(return_data.size) + 320]
            _517 = mem[64]
            mem[64] = mem[64] + 288
            mem[_517] = 0
            mem[_517 + 32] = 0
            mem[_517 + 64] = 0
            mem[_517 + 96] = 0
            mem[_517 + 128] = 0
            mem[_517 + 160] = 0
            mem[_517 + 192] = 0
            mem[_517 + 224] = 0
            mem[_517 + 256] = 0
            require ext_code.size(vaultAddress)
            staticcall vaultAddress.strategies(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _520 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            _521 = mem[64]
            require mem[64] + 288 >= mem[64] and mem[64] + 288 <= test266151307()
            mem[64] = mem[64] + 288
            mem[_521] = mem[_520]
            mem[_521 + 32] = mem[_520 + 32]
            mem[_521 + 64] = mem[_520 + 64]
            mem[_521 + 96] = mem[_520 + 96]
            mem[_521 + 128] = mem[_520 + 128]
            mem[_521 + 160] = mem[_520 + 160]
            mem[_521 + 192] = mem[_520 + 192]
            mem[_521 + 224] = mem[_520 + 224]
            mem[_521 + 256] = mem[_520 + 256]
            if 0 == mem[_521 + 32]:
                return 0
            _532 = mem[_521 + 160]
            _533 = mem[64]
            mem[64] = mem[64] + 64
            mem[_533] = 30
            mem[_533 + 32] = 'SafeMath: subtraction overflow'
            if _532 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if block.timestamp - _532 < minReportDelay:
                return 0
            _538 = mem[_521 + 160]
            _539 = mem[64]
            mem[64] = mem[64] + 64
            mem[_539] = 30
            mem[_539 + 32] = 'SafeMath: subtraction overflow'
            if _538 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if block.timestamp - _538 >= maxReportDelay:
                return 1
            require ext_code.size(vaultAddress)
            staticcall vaultAddress.debtOutstanding() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _549 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_549] > debtThreshold:
                return 1
            idx = 0
            s = 0
            while idx < lenders.length:
                mem[0] = 12
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].nav() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _615 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _621 = mem[_615]
                if mem[_615] + s < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = mem[_615] + s
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(wantAddress)
            staticcall wantAddress.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _620 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _622 = mem[_620]
            if mem[_620] + (_621 * lenders.length) < _621 * lenders.length:
                revert with 0, 'SafeMath: addition overflow'
            if debtThreshold < 0:
                revert with 0, 'SafeMath: addition overflow'
            if debtThreshold + mem[_620] + (_621 * lenders.length) < mem[_521 + 192]:
                return 1
            if mem[_620] + (_621 * lenders.length) <= mem[_521 + 192]:
                require ext_code.size(vaultAddress)
                staticcall vaultAddress.creditAvailable() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _635 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_635] < mem[_635]:
                    revert with 0, 'SafeMath: addition overflow'
                if not profitFactor:
                    mem[mem[64]] = 0 < mem[_635]
                else:
                    if _512 * profitFactor / profitFactor != _512:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[mem[64]] = _512 * profitFactor < mem[_635]
            else:
                _633 = mem[_521 + 192]
                _634 = mem[64]
                mem[64] = mem[64] + 64
                mem[_634] = 30
                mem[_634 + 32] = 'SafeMath: subtraction overflow'
                if _633 > _622 + (_621 * lenders.length):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                require ext_code.size(vaultAddress)
                staticcall vaultAddress.creditAvailable() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _644 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if _622 + (_621 * lenders.length) - _633 + mem[_644] < mem[_644]:
                    revert with 0, 'SafeMath: addition overflow'
                if not profitFactor:
                    mem[mem[64]] = 0 < _622 + (_621 * lenders.length) - _633 + mem[_644]
                else:
                    if _512 * profitFactor / profitFactor != _512:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[mem[64]] = _512 * profitFactor < _622 + (_621 * lenders.length) - _633 + mem[_644]
    return memory
      from mem[64]
       len 32
}

function withdraw(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if vaultAddress != msg.sender:
        revert with 0, '!vault'
    mem[100] = this.address
    require ext_code.size(wantAddress)
    staticcall wantAddress.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(return_data.size) + 96
    require return_data.size >= 32
    if ext_call.return_data[0] >= arg1:
        mem[ceil32(return_data.size) + 132] = msg.sender
        mem[ceil32(return_data.size) + 164] = arg1
        mem[ceil32(return_data.size) + 96] = 68
        mem[ceil32(return_data.size) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
        mem[ceil32(return_data.size) + 128 len 4] = unknown_0xa9059cbb(?????)
        mem[ceil32(return_data.size) + 196] = 32
        mem[ceil32(return_data.size) + 228] = 'SafeERC20: low-level call failed'
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
            revert with 0, 'Address: call to non-contract'
        if not ext_code.hash(wantAddress):
            revert with 0, 'Address: call to non-contract'
        mem[ceil32(return_data.size) + 260 len 96] = unknown_0xa9059cbb(?????), msg.sender, arg1, 0
        mem[ceil32(return_data.size) + 328] = 0
        call wantAddress with:
           funct Mask(32, 224, unknown_0xa9059cbb(?????), msg.sender, arg1, 0) >> 224
             gas gas_remaining wei
            args (Mask(512, -288, unknown_0xa9059cbb(?????), msg.sender, arg1, 0) << 288)
        if not return_data.size:
            if not ext_call.success:
                if ext_call.return_data[0]:
                    revert with memory
                      from 128
                       len ext_call.return_data[0]
                revert with 0, 'SafeERC20: low-level call failed'
            if ext_call.return_data[0]:
                require ext_call.return_data[0] >= 32
                require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                if not 0, mem[132 len 28]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        else:
            mem[ceil32(return_data.size) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                require mem[ceil32(return_data.size) + 292] == bool(mem[ceil32(return_data.size) + 292])
                if not mem[ceil32(return_data.size) + 292]:
                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    else:
        if not lenders.length:
            if ext_call.return_data[0] < 0:
                revert with 0, 'SafeMath: addition overflow'
            mem[ceil32(return_data.size) + 132] = msg.sender
            if ext_call.return_data[0] < arg1:
                mem[ceil32(return_data.size) + 164] = ext_call.return_data[0]
                mem[ceil32(return_data.size) + 96] = 68
                mem[ceil32(return_data.size) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                mem[ceil32(return_data.size) + 128 len 4] = unknown_0xa9059cbb(?????)
                mem[ceil32(return_data.size) + 196] = 32
                mem[ceil32(return_data.size) + 228] = 'SafeERC20: low-level call failed'
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                if not ext_code.hash(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                mem[ceil32(return_data.size) + 260 len 96] = unknown_0xa9059cbb(?????), msg.sender, ext_call.return_data[0], 0
                mem[ceil32(return_data.size) + 328] = 0
                call wantAddress with:
                   funct Mask(32, 224, unknown_0xa9059cbb(?????), msg.sender, ext_call.return_data[0], 0) >> 224
                     gas gas_remaining wei
                    args (Mask(512, -288, unknown_0xa9059cbb(?????), msg.sender, ext_call.return_data[0], 0) << 288)
            else:
                mem[ceil32(return_data.size) + 164] = arg1
                mem[ceil32(return_data.size) + 96] = 68
                mem[ceil32(return_data.size) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                mem[ceil32(return_data.size) + 128 len 4] = unknown_0xa9059cbb(?????)
                mem[ceil32(return_data.size) + 196] = 32
                mem[ceil32(return_data.size) + 228] = 'SafeERC20: low-level call failed'
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                if not ext_code.hash(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                mem[ceil32(return_data.size) + 260 len 96] = unknown_0xa9059cbb(?????), msg.sender, arg1, 0
                mem[ceil32(return_data.size) + 328] = 0
                call wantAddress with:
                   funct Mask(32, 224, unknown_0xa9059cbb(?????), msg.sender, arg1, 0) >> 224
                     gas gas_remaining wei
                    args (Mask(512, -288, unknown_0xa9059cbb(?????), msg.sender, arg1, 0) << 288)
            if not return_data.size:
                if not ext_call.success:
                    if ext_call.return_data[0]:
                        revert with memory
                          from 128
                           len ext_call.return_data[0]
                    revert with 0, 'SafeERC20: low-level call failed'
                if ext_call.return_data[0]:
                    require ext_call.return_data[0] >= 32
                    require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                    if not 0, mem[132 len 28]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                mem[ceil32(return_data.size) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size:
                    require return_data.size >= 32
                    require mem[ceil32(return_data.size) + 292] == bool(mem[ceil32(return_data.size) + 292])
                    if not mem[ceil32(return_data.size) + 292]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
        else:
            if arg1 - ext_call.return_data[0] < withdrawalThreshold:
                if ext_call.return_data[0] < 0:
                    revert with 0, 'SafeMath: addition overflow'
                mem[ceil32(return_data.size) + 132] = msg.sender
                if ext_call.return_data[0] < arg1:
                    mem[ceil32(return_data.size) + 164] = ext_call.return_data[0]
                    mem[ceil32(return_data.size) + 96] = 68
                    mem[ceil32(return_data.size) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                    mem[ceil32(return_data.size) + 128 len 4] = unknown_0xa9059cbb(?????)
                    mem[ceil32(return_data.size) + 196] = 32
                    mem[ceil32(return_data.size) + 228] = 'SafeERC20: low-level call failed'
                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    if not ext_code.hash(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    mem[ceil32(return_data.size) + 260 len 96] = unknown_0xa9059cbb(?????), msg.sender, ext_call.return_data[0], 0
                    mem[ceil32(return_data.size) + 328] = 0
                    call wantAddress with:
                       funct Mask(32, 224, unknown_0xa9059cbb(?????), msg.sender, ext_call.return_data[0], 0) >> 224
                         gas gas_remaining wei
                        args (Mask(512, -288, unknown_0xa9059cbb(?????), msg.sender, ext_call.return_data[0], 0) << 288)
                else:
                    mem[ceil32(return_data.size) + 164] = arg1
                    mem[ceil32(return_data.size) + 96] = 68
                    mem[ceil32(return_data.size) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
                    mem[ceil32(return_data.size) + 128 len 4] = unknown_0xa9059cbb(?????)
                    mem[ceil32(return_data.size) + 196] = 32
                    mem[ceil32(return_data.size) + 228] = 'SafeERC20: low-level call failed'
                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    if not ext_code.hash(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    mem[ceil32(return_data.size) + 260 len 96] = unknown_0xa9059cbb(?????), msg.sender, arg1, 0
                    mem[ceil32(return_data.size) + 328] = 0
                    call wantAddress with:
                       funct Mask(32, 224, unknown_0xa9059cbb(?????), msg.sender, arg1, 0) >> 224
                         gas gas_remaining wei
                        args (Mask(512, -288, unknown_0xa9059cbb(?????), msg.sender, arg1, 0) << 288)
                if not return_data.size:
                    if not ext_call.success:
                        if ext_call.return_data[0]:
                            revert with memory
                              from 128
                               len ext_call.return_data[0]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if ext_call.return_data[0]:
                        require ext_call.return_data[0] >= 32
                        require 0, mem[132 len 28] == bool(0, mem[132 len 28])
                        if not 0, mem[132 len 28]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    mem[ceil32(return_data.size) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        require mem[ceil32(return_data.size) + 292] == bool(mem[ceil32(return_data.size) + 292])
                        if not mem[ceil32(return_data.size) + 292]:
                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
            else:
                s = 0
                idx = 0
                while idx < arg1 - ext_call.return_data[0]:
                    t = 0
                    u = -1
                    while t < lenders.length:
                        mem[0] = 12
                        require ext_code.size(lenders[t])
                        staticcall lenders[t].hasAssets() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1484 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1484] == bool(mem[_1484])
                        if not mem[_1484]:
                            t = t + 1
                            u = u
                            continue 
                        require t < lenders.length
                        mem[0] = 12
                        require ext_code.size(lenders[t])
                        staticcall lenders[t].apr() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1545 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_1545] >= u:
                            t = t + 1
                            u = u
                            continue 
                        t = t + 1
                        u = mem[_1545]
                        continue 
                    require 0 < lenders.length
                    mem[0] = 12
                    require ext_code.size(lenders)
                    staticcall lenders.hasAssets() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1483 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1483] == bool(mem[_1483])
                    if not mem[_1483]:
                        if ext_call.return_data[0] + idx < idx:
                            revert with 0, 'SafeMath: addition overflow'
                        if ext_call.return_data[0] + idx < arg1:
                            _1615 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = ext_call.return_data[0] + idx
                            _1626 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_1626 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_1626 + 36 len 28]
                            mem[64] = _1615 + 164
                            mem[_1615 + 100] = 32
                            mem[_1615 + 132] = 'SafeERC20: low-level call failed'
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(wantAddress):
                                revert with 0, 'Address: call to non-contract'
                            _1649 = mem[_1626]
                            idx = 0
                            while idx < _1649:
                                mem[idx + _1615 + 164] = mem[idx + _1626 + 32]
                                idx = idx + 32
                                continue 
                            if ceil32(_1649) > _1649:
                                mem[_1649 + _1615 + 164] = 0
                            call wantAddress.mem[_1615 + 164 len 4] with:
                                 gas gas_remaining wei
                                args mem[_1615 + 168 len _1649 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    mem[_1615 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_1615 + 168] = 32
                                    idx = 0
                                    while idx < 32:
                                        mem[idx + _1615 + 232] = mem[idx + _1615 + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 32, mem[_1615 + 232]
                                if mem[96]:
                                    require mem[96] >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            else:
                                mem[_1615 + 164] = return_data.size
                                mem[_1615 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_1615 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_1615 + ceil32(return_data.size) + 169] = 32
                                    idx = 0
                                    while idx < 32:
                                        mem[idx + _1615 + ceil32(return_data.size) + 233] = mem[idx + _1615 + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 32, mem[_1615 + ceil32(return_data.size) + 233]
                                if return_data.size:
                                    require return_data.size >= 32
                                    require mem[_1615 + 196] == bool(mem[_1615 + 196])
                                    if not mem[_1615 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            _1616 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = arg1
                            _1628 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_1628 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_1628 + 36 len 28]
                            mem[64] = _1616 + 164
                            mem[_1616 + 100] = 32
                            mem[_1616 + 132] = 'SafeERC20: low-level call failed'
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(wantAddress):
                                revert with 0, 'Address: call to non-contract'
                            _1650 = mem[_1628]
                            idx = 0
                            while idx < _1650:
                                mem[idx + _1616 + 164] = mem[idx + _1628 + 32]
                                idx = idx + 32
                                continue 
                            if ceil32(_1650) > _1650:
                                mem[_1650 + _1616 + 164] = 0
                            call wantAddress.mem[_1616 + 164 len 4] with:
                                 gas gas_remaining wei
                                args mem[_1616 + 168 len _1650 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    mem[_1616 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_1616 + 168] = 32
                                    idx = 0
                                    while idx < 32:
                                        mem[idx + _1616 + 232] = mem[idx + _1616 + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 32, mem[_1616 + 232]
                                if mem[96]:
                                    require mem[96] >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            else:
                                mem[_1616 + 164] = return_data.size
                                mem[_1616 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_1616 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_1616 + ceil32(return_data.size) + 169] = 32
                                    idx = 0
                                    while idx < 32:
                                        mem[idx + _1616 + ceil32(return_data.size) + 233] = mem[idx + _1616 + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 32, mem[_1616 + ceil32(return_data.size) + 233]
                                if return_data.size:
                                    require return_data.size >= 32
                                    require mem[_1616 + 196] == bool(mem[_1616 + 196])
                                    if not mem[_1616 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        require 0 < lenders.length
                        mem[0] = 12
                        mem[mem[64] + 4] = arg1 - ext_call.return_data[0] - idx
                        require ext_code.size(lenders)
                        call lenders.0x2e1a7d4d with:
                             gas gas_remaining wei
                            args (arg1 - ext_call.return_data[0] - idx)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1571 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1590 = mem[_1571]
                        if mem[_1571] + idx < idx:
                            revert with 0, 'SafeMath: addition overflow'
                        if s + 1 < 6:
                            s = s + 1
                            idx = mem[_1571] + idx
                            continue 
                        if ext_call.return_data[0] < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if ext_call.return_data[0] + mem[_1571] + idx < arg1:
                            _1655 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = ext_call.return_data[0] + _1590 + idx
                            _1659 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_1659 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_1659 + 36 len 28]
                            mem[64] = _1655 + 164
                            mem[_1655 + 100] = 32
                            mem[_1655 + 132] = 'SafeERC20: low-level call failed'
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(wantAddress):
                                revert with 0, 'Address: call to non-contract'
                            _1703 = mem[_1659]
                            idx = 0
                            while idx < _1703:
                                mem[idx + _1655 + 164] = mem[idx + _1659 + 32]
                                idx = idx + 32
                                continue 
                            if ceil32(_1703) > _1703:
                                mem[_1703 + _1655 + 164] = 0
                            call wantAddress.mem[_1655 + 164 len 4] with:
                                 gas gas_remaining wei
                                args mem[_1655 + 168 len _1703 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    mem[_1655 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_1655 + 168] = 32
                                    idx = 0
                                    while idx < 32:
                                        mem[idx + _1655 + 232] = mem[idx + _1655 + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 32, mem[_1655 + 232]
                                if mem[96]:
                                    require mem[96] >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            else:
                                mem[_1655 + 164] = return_data.size
                                mem[_1655 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_1655 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_1655 + ceil32(return_data.size) + 169] = 32
                                    idx = 0
                                    while idx < 32:
                                        mem[idx + _1655 + ceil32(return_data.size) + 233] = mem[idx + _1655 + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 32, mem[_1655 + ceil32(return_data.size) + 233]
                                if return_data.size:
                                    require return_data.size >= 32
                                    require mem[_1655 + 196] == bool(mem[_1655 + 196])
                                    if not mem[_1655 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            _1656 = mem[64]
                            mem[mem[64] + 36] = msg.sender
                            mem[mem[64] + 68] = arg1
                            _1661 = mem[64]
                            mem[mem[64]] = 68
                            mem[64] = mem[64] + 100
                            mem[_1661 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_1661 + 36 len 28]
                            mem[64] = _1656 + 164
                            mem[_1656 + 100] = 32
                            mem[_1656 + 132] = 'SafeERC20: low-level call failed'
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(wantAddress):
                                revert with 0, 'Address: call to non-contract'
                            _1704 = mem[_1661]
                            idx = 0
                            while idx < _1704:
                                mem[idx + _1656 + 164] = mem[idx + _1661 + 32]
                                idx = idx + 32
                                continue 
                            if ceil32(_1704) > _1704:
                                mem[_1704 + _1656 + 164] = 0
                            call wantAddress.mem[_1656 + 164 len 4] with:
                                 gas gas_remaining wei
                                args mem[_1656 + 168 len _1704 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    mem[_1656 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_1656 + 168] = 32
                                    idx = 0
                                    while idx < 32:
                                        mem[idx + _1656 + 232] = mem[idx + _1656 + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 32, mem[_1656 + 232]
                                if mem[96]:
                                    require mem[96] >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            else:
                                mem[_1656 + 164] = return_data.size
                                mem[_1656 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_1656 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[_1656 + ceil32(return_data.size) + 169] = 32
                                    idx = 0
                                    while idx < 32:
                                        mem[idx + _1656 + ceil32(return_data.size) + 233] = mem[idx + _1656 + 132]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 32, 32, mem[_1656 + ceil32(return_data.size) + 233]
                                if return_data.size:
                                    require return_data.size >= 32
                                    require mem[_1656 + 196] == bool(mem[_1656 + 196])
                                    if not mem[_1656 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    return 0
                if ext_call.return_data[0] + idx < idx:
                    revert with 0, 'SafeMath: addition overflow'
                if ext_call.return_data[0] + idx < arg1:
                    _1308 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = ext_call.return_data[0] + idx
                    _1310 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_1308 + 100] = 32
                    mem[_1308 + 132] = 'SafeERC20: low-level call failed'
                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    if not ext_code.hash(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    _1327 = mem[_1310]
                    mem[_1308 + 164 len ceil32(mem[_1310])] = mem[_1310 + 32 len ceil32(mem[_1310])]
                    if ceil32(_1327) > _1327:
                        mem[_1327 + _1308 + 164] = 0
                    call wantAddress with:
                         gas gas_remaining wei
                        args mem[_1308 + 168 len _1327 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_1308 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_1308 + 196] == bool(mem[_1308 + 196])
                            if not mem[_1308 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                else:
                    _1309 = mem[64]
                    mem[mem[64] + 36] = msg.sender
                    mem[mem[64] + 68] = arg1
                    _1312 = mem[64]
                    mem[mem[64]] = 68
                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                    mem[64] = mem[64] + 164
                    mem[_1309 + 100] = 32
                    mem[_1309 + 132] = 'SafeERC20: low-level call failed'
                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    if not ext_code.hash(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    _1328 = mem[_1312]
                    mem[_1309 + 164 len ceil32(mem[_1312])] = mem[_1312 + 32 len ceil32(mem[_1312])]
                    if ceil32(_1328) > _1328:
                        mem[_1328 + _1309 + 164] = 0
                    call wantAddress with:
                         gas gas_remaining wei
                        args mem[_1309 + 168 len _1328 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if mem[96]:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    else:
                        mem[_1309 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            require mem[_1309 + 196] == bool(mem[_1309 + 196])
                            if not mem[_1309 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
    return 0
}

function manualAllocation(address arg1, uint16[] arg2) payable {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require calldata.size > arg1 + 35
    require arg1.length <= test266151307()
    require (32 * arg1.length) + 128 >= 96 and (32 * arg1.length) + 128 <= test266151307()
    mem[64] = (32 * arg1.length) + 128
    mem[96] = arg1.length
    require calldata.size >= arg1 + (64 * arg1.length) + 36
    s = arg1 + 36
    t = 128
    idx = 0
    while idx < arg1.length:
        require calldata.size - s >= 64
        _45 = mem[64]
        require mem[64] + 64 >= mem[64] and mem[64] + 64 <= test266151307()
        mem[64] = mem[64] + 64
        require cd[s] == address(cd[s])
        mem[_45] = cd[s]
        require cd[(s + 32)] == uint16(cd[(s + 32)])
        mem[_45 + 32] = cd[(s + 32)]
        mem[t] = _45
        s = s + 64
        t = t + 32
        idx = idx + 1
        continue 
    if msg.sender == strategistAddress:
        idx = 0
        while idx < lenders.length:
            mem[0] = 12
            require ext_code.size(lenders[idx])
            call lenders[idx].withdrawAll() with:
                 gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _98 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_98] == bool(mem[_98])
            idx = idx + 1
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(wantAddress)
        staticcall wantAddress.0x70a08231 with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _100 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _104 = mem[_100]
        _584 = mem[96]
        idx = 0
        s = 0
        while idx < _584:
            t = 0
            u = 0
            while t < lenders.length:
                require idx < mem[96]
                _607 = mem[mem[(32 * idx) + 128]]
                require t < lenders.length
                mem[0] = 12
                _584 = mem[96]
                if lenders[t] != address(_607):
                    t = t + 1
                    u = u
                    continue 
                t = t + 1
                u = 1
                continue 
            if not u:
                revert with 0, 'NOT LENDER'
            require idx < mem[96]
            _613 = mem[mem[(32 * idx) + 128] + 32]
            if mem[mem[(32 * idx) + 128] + 62 len 2] + s < s:
                revert with 0, 'SafeMath: addition overflow'
            require idx < mem[96]
            _625 = mem[mem[(32 * idx) + 128] + 32]
            if not _104:
                _632 = mem[64]
                mem[64] = mem[64] + 64
                mem[_632] = 26
                mem[_632 + 32] = 'SafeMath: division by zero'
                require idx < mem[96]
                _648 = mem[64]
                mem[mem[64] + 36] = mem[mem[(32 * idx) + 128] + 12 len 20]
                mem[mem[64] + 68] = 0
                _654 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_654 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_654 + 36 len 28]
                mem[64] = _648 + 164
                mem[_648 + 100] = 32
                mem[_648 + 132] = 'SafeERC20: low-level call failed'
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                if not ext_code.hash(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                _675 = mem[_654]
                t = 0
                while t < _675:
                    mem[t + _648 + 164] = mem[t + _654 + 32]
                    _584 = mem[96]
                    t = t + 32
                    continue 
                if ceil32(_675) <= _675:
                    call wantAddress.mem[_648 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_648 + 168 len _675 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_648 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_648 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _648 + 232] = mem[idx + _648 + 132]
                                _584 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_648 + 232]
                        if not mem[96]:
                            require idx < mem[96]
                            _1243 = mem[mem[(32 * idx) + 128]]
                            mem[_648 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1243))
                            call address(_1243).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1387 = mem[mem[(32 * idx) + 128]]
                            mem[_648 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1387))
                            call address(_1387).deposit() with:
                                 gas gas_remaining wei
                    else:
                        mem[64] = _648 + ceil32(return_data.size) + 165
                        mem[_648 + 164] = return_data.size
                        mem[_648 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_648 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_648 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _648 + ceil32(return_data.size) + 233] = mem[idx + _648 + 132]
                                _584 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_648 + ceil32(return_data.size) + 233]
                        if not return_data.size:
                            require idx < mem[96]
                            _1247 = mem[mem[(32 * idx) + 128]]
                            mem[_648 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1247))
                            call address(_1247).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require return_data.size >= 32
                            require mem[_648 + 196] == bool(mem[_648 + 196])
                            if not mem[_648 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1391 = mem[mem[(32 * idx) + 128]]
                            mem[_648 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1391))
                            call address(_1391).deposit() with:
                                 gas gas_remaining wei
                else:
                    mem[_675 + _648 + 164] = 0
                    call wantAddress.mem[_648 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_648 + 168 len _675 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_648 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_648 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _648 + 232] = mem[idx + _648 + 132]
                                _584 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_648 + 232]
                        if not mem[96]:
                            require idx < mem[96]
                            _1251 = mem[mem[(32 * idx) + 128]]
                            mem[_648 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1251))
                            call address(_1251).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1395 = mem[mem[(32 * idx) + 128]]
                            mem[_648 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1395))
                            call address(_1395).deposit() with:
                                 gas gas_remaining wei
                    else:
                        mem[64] = _648 + ceil32(return_data.size) + 165
                        mem[_648 + 164] = return_data.size
                        mem[_648 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_648 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_648 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _648 + ceil32(return_data.size) + 233] = mem[idx + _648 + 132]
                                _584 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_648 + ceil32(return_data.size) + 233]
                        if not return_data.size:
                            require idx < mem[96]
                            _1255 = mem[mem[(32 * idx) + 128]]
                            mem[_648 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1255))
                            call address(_1255).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require return_data.size >= 32
                            require mem[_648 + 196] == bool(mem[_648 + 196])
                            if not mem[_648 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1399 = mem[mem[(32 * idx) + 128]]
                            mem[_648 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1399))
                            call address(_1399).deposit() with:
                                 gas gas_remaining wei
            else:
                if mem[mem[(32 * idx) + 128] + 62 len 2] * _104 / _104 != mem[mem[(32 * idx) + 128] + 62 len 2]:
                    revert with 0, 'SafeMath: multiplication overflow'
                _634 = mem[64]
                mem[64] = mem[64] + 64
                mem[_634] = 26
                mem[_634 + 32] = 'SafeMath: division by zero'
                require idx < mem[96]
                _652 = mem[64]
                mem[mem[64] + 36] = mem[mem[(32 * idx) + 128] + 12 len 20]
                mem[mem[64] + 68] = uint16(_625) * _104 / 1000
                _658 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_658 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_658 + 36 len 28]
                mem[64] = _652 + 164
                mem[_652 + 100] = 32
                mem[_652 + 132] = 'SafeERC20: low-level call failed'
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                if not ext_code.hash(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                _680 = mem[_658]
                t = 0
                while t < _680:
                    mem[t + _652 + 164] = mem[t + _658 + 32]
                    _584 = mem[96]
                    t = t + 32
                    continue 
                if ceil32(_680) <= _680:
                    call wantAddress.mem[_652 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_652 + 168 len _680 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_652 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_652 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _652 + 232] = mem[idx + _652 + 132]
                                _584 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_652 + 232]
                        if not mem[96]:
                            require idx < mem[96]
                            _1227 = mem[mem[(32 * idx) + 128]]
                            mem[_652 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1227))
                            call address(_1227).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1371 = mem[mem[(32 * idx) + 128]]
                            mem[_652 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1371))
                            call address(_1371).deposit() with:
                                 gas gas_remaining wei
                    else:
                        mem[64] = _652 + ceil32(return_data.size) + 165
                        mem[_652 + 164] = return_data.size
                        mem[_652 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_652 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_652 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _652 + ceil32(return_data.size) + 233] = mem[idx + _652 + 132]
                                _584 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_652 + ceil32(return_data.size) + 233]
                        if not return_data.size:
                            require idx < mem[96]
                            _1231 = mem[mem[(32 * idx) + 128]]
                            mem[_652 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1231))
                            call address(_1231).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require return_data.size >= 32
                            require mem[_652 + 196] == bool(mem[_652 + 196])
                            if not mem[_652 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1375 = mem[mem[(32 * idx) + 128]]
                            mem[_652 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1375))
                            call address(_1375).deposit() with:
                                 gas gas_remaining wei
                else:
                    mem[_680 + _652 + 164] = 0
                    call wantAddress.mem[_652 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_652 + 168 len _680 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_652 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_652 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _652 + 232] = mem[idx + _652 + 132]
                                _584 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_652 + 232]
                        if not mem[96]:
                            require idx < mem[96]
                            _1235 = mem[mem[(32 * idx) + 128]]
                            mem[_652 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1235))
                            call address(_1235).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1379 = mem[mem[(32 * idx) + 128]]
                            mem[_652 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1379))
                            call address(_1379).deposit() with:
                                 gas gas_remaining wei
                    else:
                        mem[64] = _652 + ceil32(return_data.size) + 165
                        mem[_652 + 164] = return_data.size
                        mem[_652 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_652 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_652 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _652 + ceil32(return_data.size) + 233] = mem[idx + _652 + 132]
                                _584 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_652 + ceil32(return_data.size) + 233]
                        if not return_data.size:
                            require idx < mem[96]
                            _1239 = mem[mem[(32 * idx) + 128]]
                            mem[_652 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1239))
                            call address(_1239).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require return_data.size >= 32
                            require mem[_652 + 196] == bool(mem[_652 + 196])
                            if not mem[_652 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1383 = mem[mem[(32 * idx) + 128]]
                            mem[_652 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1383))
                            call address(_1383).deposit() with:
                                 gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _584 = mem[96]
            idx = idx + 1
            s = uint16(_613) + s
            continue 
    else:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _49 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require mem[_49] == mem[_49 + 12 len 20]
        if mem[_49 + 12 len 20] != msg.sender:
            revert with 0, '!authorized'
        idx = 0
        while idx < lenders.length:
            mem[0] = 12
            require ext_code.size(lenders[idx])
            call lenders[idx].withdrawAll() with:
                 gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _99 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_99] == bool(mem[_99])
            idx = idx + 1
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(wantAddress)
        staticcall wantAddress.0x70a08231 with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _101 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _105 = mem[_101]
        _585 = mem[96]
        idx = 0
        s = 0
        while idx < _585:
            t = 0
            u = 0
            while t < lenders.length:
                require idx < mem[96]
                _611 = mem[mem[(32 * idx) + 128]]
                require t < lenders.length
                mem[0] = 12
                _585 = mem[96]
                if lenders[t] != address(_611):
                    t = t + 1
                    u = u
                    continue 
                t = t + 1
                u = 1
                continue 
            if not u:
                revert with 0, 'NOT LENDER'
            require idx < mem[96]
            _616 = mem[mem[(32 * idx) + 128] + 32]
            if mem[mem[(32 * idx) + 128] + 62 len 2] + s < s:
                revert with 0, 'SafeMath: addition overflow'
            require idx < mem[96]
            _628 = mem[mem[(32 * idx) + 128] + 32]
            if not _105:
                _633 = mem[64]
                mem[64] = mem[64] + 64
                mem[_633] = 26
                mem[_633 + 32] = 'SafeMath: division by zero'
                require idx < mem[96]
                _651 = mem[64]
                mem[mem[64] + 36] = mem[mem[(32 * idx) + 128] + 12 len 20]
                mem[mem[64] + 68] = 0
                _656 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_656 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_656 + 36 len 28]
                mem[64] = _651 + 164
                mem[_651 + 100] = 32
                mem[_651 + 132] = 'SafeERC20: low-level call failed'
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                if not ext_code.hash(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                _679 = mem[_656]
                t = 0
                while t < _679:
                    mem[t + _651 + 164] = mem[t + _656 + 32]
                    _585 = mem[96]
                    t = t + 32
                    continue 
                if ceil32(_679) <= _679:
                    call wantAddress.mem[_651 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_651 + 168 len _679 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_651 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_651 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _651 + 232] = mem[idx + _651 + 132]
                                _585 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_651 + 232]
                        if not mem[96]:
                            require idx < mem[96]
                            _1275 = mem[mem[(32 * idx) + 128]]
                            mem[_651 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1275))
                            call address(_1275).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1419 = mem[mem[(32 * idx) + 128]]
                            mem[_651 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1419))
                            call address(_1419).deposit() with:
                                 gas gas_remaining wei
                    else:
                        mem[64] = _651 + ceil32(return_data.size) + 165
                        mem[_651 + 164] = return_data.size
                        mem[_651 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_651 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_651 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _651 + ceil32(return_data.size) + 233] = mem[idx + _651 + 132]
                                _585 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_651 + ceil32(return_data.size) + 233]
                        if not return_data.size:
                            require idx < mem[96]
                            _1279 = mem[mem[(32 * idx) + 128]]
                            mem[_651 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1279))
                            call address(_1279).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require return_data.size >= 32
                            require mem[_651 + 196] == bool(mem[_651 + 196])
                            if not mem[_651 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1423 = mem[mem[(32 * idx) + 128]]
                            mem[_651 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1423))
                            call address(_1423).deposit() with:
                                 gas gas_remaining wei
                else:
                    mem[_679 + _651 + 164] = 0
                    call wantAddress.mem[_651 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_651 + 168 len _679 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_651 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_651 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _651 + 232] = mem[idx + _651 + 132]
                                _585 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_651 + 232]
                        if not mem[96]:
                            require idx < mem[96]
                            _1283 = mem[mem[(32 * idx) + 128]]
                            mem[_651 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1283))
                            call address(_1283).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1427 = mem[mem[(32 * idx) + 128]]
                            mem[_651 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1427))
                            call address(_1427).deposit() with:
                                 gas gas_remaining wei
                    else:
                        mem[64] = _651 + ceil32(return_data.size) + 165
                        mem[_651 + 164] = return_data.size
                        mem[_651 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_651 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_651 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _651 + ceil32(return_data.size) + 233] = mem[idx + _651 + 132]
                                _585 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_651 + ceil32(return_data.size) + 233]
                        if not return_data.size:
                            require idx < mem[96]
                            _1287 = mem[mem[(32 * idx) + 128]]
                            mem[_651 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1287))
                            call address(_1287).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require return_data.size >= 32
                            require mem[_651 + 196] == bool(mem[_651 + 196])
                            if not mem[_651 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1431 = mem[mem[(32 * idx) + 128]]
                            mem[_651 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1431))
                            call address(_1431).deposit() with:
                                 gas gas_remaining wei
            else:
                if mem[mem[(32 * idx) + 128] + 62 len 2] * _105 / _105 != mem[mem[(32 * idx) + 128] + 62 len 2]:
                    revert with 0, 'SafeMath: multiplication overflow'
                _636 = mem[64]
                mem[64] = mem[64] + 64
                mem[_636] = 26
                mem[_636 + 32] = 'SafeMath: division by zero'
                require idx < mem[96]
                _653 = mem[64]
                mem[mem[64] + 36] = mem[mem[(32 * idx) + 128] + 12 len 20]
                mem[mem[64] + 68] = uint16(_628) * _105 / 1000
                _661 = mem[64]
                mem[mem[64]] = 68
                mem[64] = mem[64] + 100
                mem[_661 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_661 + 36 len 28]
                mem[64] = _653 + 164
                mem[_653 + 100] = 32
                mem[_653 + 132] = 'SafeERC20: low-level call failed'
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                if not ext_code.hash(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                _683 = mem[_661]
                t = 0
                while t < _683:
                    mem[t + _653 + 164] = mem[t + _661 + 32]
                    _585 = mem[96]
                    t = t + 32
                    continue 
                if ceil32(_683) <= _683:
                    call wantAddress.mem[_653 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_653 + 168 len _683 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_653 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_653 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _653 + 232] = mem[idx + _653 + 132]
                                _585 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_653 + 232]
                        if not mem[96]:
                            require idx < mem[96]
                            _1259 = mem[mem[(32 * idx) + 128]]
                            mem[_653 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1259))
                            call address(_1259).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1403 = mem[mem[(32 * idx) + 128]]
                            mem[_653 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1403))
                            call address(_1403).deposit() with:
                                 gas gas_remaining wei
                    else:
                        mem[64] = _653 + ceil32(return_data.size) + 165
                        mem[_653 + 164] = return_data.size
                        mem[_653 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_653 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_653 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _653 + ceil32(return_data.size) + 233] = mem[idx + _653 + 132]
                                _585 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_653 + ceil32(return_data.size) + 233]
                        if not return_data.size:
                            require idx < mem[96]
                            _1263 = mem[mem[(32 * idx) + 128]]
                            mem[_653 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1263))
                            call address(_1263).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require return_data.size >= 32
                            require mem[_653 + 196] == bool(mem[_653 + 196])
                            if not mem[_653 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1407 = mem[mem[(32 * idx) + 128]]
                            mem[_653 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1407))
                            call address(_1407).deposit() with:
                                 gas gas_remaining wei
                else:
                    mem[_683 + _653 + 164] = 0
                    call wantAddress.mem[_653 + 164 len 4] with:
                         gas gas_remaining wei
                        args mem[_653 + 168 len _683 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if mem[96]:
                                revert with memory
                                  from 128
                                   len mem[96]
                            mem[_653 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_653 + 168] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _653 + 232] = mem[idx + _653 + 132]
                                _585 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_653 + 232]
                        if not mem[96]:
                            require idx < mem[96]
                            _1267 = mem[mem[(32 * idx) + 128]]
                            mem[_653 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1267))
                            call address(_1267).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require mem[96] >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1411 = mem[mem[(32 * idx) + 128]]
                            mem[_653 + 164] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1411))
                            call address(_1411).deposit() with:
                                 gas gas_remaining wei
                    else:
                        mem[64] = _653 + ceil32(return_data.size) + 165
                        mem[_653 + 164] = return_data.size
                        mem[_653 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_653 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[_653 + ceil32(return_data.size) + 169] = 32
                            idx = 0
                            while idx < 32:
                                mem[idx + _653 + ceil32(return_data.size) + 233] = mem[idx + _653 + 132]
                                _585 = mem[96]
                                idx = idx + 32
                                continue 
                            revert with 0, 32, 32, mem[_653 + ceil32(return_data.size) + 233]
                        if not return_data.size:
                            require idx < mem[96]
                            _1271 = mem[mem[(32 * idx) + 128]]
                            mem[_653 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1271))
                            call address(_1271).deposit() with:
                                 gas gas_remaining wei
                        else:
                            require return_data.size >= 32
                            require mem[_653 + 196] == bool(mem[_653 + 196])
                            if not mem[_653 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require idx < mem[96]
                            _1415 = mem[mem[(32 * idx) + 128]]
                            mem[_653 + ceil32(return_data.size) + 165] = 0xd0e30db000000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_1415))
                            call address(_1415).deposit() with:
                                 gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _585 = mem[96]
            idx = idx + 1
            s = uint16(_616) + s
            continue 
    if s != 1000:
        revert with 0, 'SHARE!=1000'
}

function tend() payable {
    require ext_code.size(vaultAddress)
    if msg.sender == keeperAddress:
        staticcall vaultAddress.debtOutstanding() with:
                gas gas_remaining wei
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not emergencyExit:
            if lenders.length:
                mem[ceil32(return_data.size) + 100] = this.address
                require ext_code.size(wantAddress)
                staticcall wantAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (2 * ceil32(return_data.size)) + 96
                require return_data.size >= 32
                idx = 0
                s = 0
                t = -1
                while idx < lenders.length:
                    mem[0] = 12
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].hasAssets() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _185 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_185] == bool(mem[_185])
                    if not mem[_185]:
                        idx = idx + 1
                        s = s
                        t = t
                        continue 
                    require idx < lenders.length
                    mem[0] = 12
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].apr() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _235 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _245 = mem[_235]
                    if mem[_235] >= t:
                        idx = idx + 1
                        s = s
                        t = t
                        continue 
                    require idx < lenders.length
                    mem[0] = 12
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].nav() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _265 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 1
                    s = mem[_265]
                    t = _245
                    continue 
                if ext_call.return_data[0] + s < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = 0
                u = 0
                while idx < lenders.length:
                    mem[0] = 12
                    mem[mem[64] + 4] = ext_call.return_data[0]
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                            gas gas_remaining wei
                           args ext_call.return_data[0]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _306 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_306] <= u:
                        idx = idx + 1
                        u = u
                        continue 
                    idx = idx + 1
                    u = mem[_306]
                    continue 
                require 0 < lenders.length
                mem[0] = 12
                mem[mem[64] + 4] = ext_call.return_data[0] + s
                require ext_code.size(lenders)
                staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                        gas gas_remaining wei
                       args (ext_call.return_data[0] + s)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _305 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_305] <= t:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(wantAddress)
                    staticcall wantAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _355 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _365 = mem[_355]
                    if mem[_355]:
                        require 0 < lenders.length
                        mem[0] = 12
                        _380 = mem[64]
                        mem[mem[64] + 36] = lenders
                        mem[mem[64] + 68] = _365
                        _390 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                        mem[64] = mem[64] + 164
                        mem[_380 + 100] = 32
                        mem[_380 + 132] = 'SafeERC20: low-level call failed'
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                            revert with 0, 'Address: call to non-contract'
                        if not ext_code.hash(wantAddress):
                            revert with 0, 'Address: call to non-contract'
                        _440 = mem[_390]
                        mem[_380 + 164 len ceil32(mem[_390])] = mem[_390 + 32 len ceil32(mem[_390])]
                        if ceil32(_440) > _440:
                            mem[_440 + _380 + 164] = 0
                        call wantAddress with:
                             gas gas_remaining wei
                            args mem[_380 + 168 len _440 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if mem[96]:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[_380 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_380 + 196] == bool(mem[_380 + 196])
                                if not mem[_380 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        require 0 < lenders.length
                        require ext_code.size(lenders)
                        call lenders.deposit() with:
                             gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                else:
                    require 0 < lenders.length
                    mem[0] = 12
                    require ext_code.size(lenders)
                    call lenders.withdrawAll() with:
                         gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _350 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_350] == bool(mem[_350])
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(wantAddress)
                    staticcall wantAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _392 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _410 = mem[_392]
                    if mem[_392]:
                        require 0 < lenders.length
                        mem[0] = 12
                        _420 = mem[64]
                        mem[mem[64] + 36] = lenders
                        mem[mem[64] + 68] = _410
                        _441 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                        mem[64] = mem[64] + 164
                        mem[_420 + 100] = 32
                        mem[_420 + 132] = 'SafeERC20: low-level call failed'
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                            revert with 0, 'Address: call to non-contract'
                        if not ext_code.hash(wantAddress):
                            revert with 0, 'Address: call to non-contract'
                        _510 = mem[_441]
                        mem[_420 + 164 len ceil32(mem[_441])] = mem[_441 + 32 len ceil32(mem[_441])]
                        if ceil32(_510) > _510:
                            mem[_510 + _420 + 164] = 0
                        call wantAddress with:
                             gas gas_remaining wei
                            args mem[_420 + 168 len _510 - 4]
                        if not return_data.size:
                            if not ext_call.success:
                                if mem[96]:
                                    revert with memory
                                      from 128
                                       len mem[96]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if mem[96]:
                                require mem[96] >= 32
                                require mem[128] == bool(mem[128])
                                if not mem[128]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        else:
                            mem[_420 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                require mem[_420 + 196] == bool(mem[_420 + 196])
                                if not mem[_420 + 196]:
                                    revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                        require 0 < lenders.length
                        require ext_code.size(lenders)
                        call lenders.deposit() with:
                             gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
    else:
        if msg.sender == strategistAddress:
            staticcall vaultAddress.debtOutstanding() with:
                    gas gas_remaining wei
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not emergencyExit:
                if lenders.length:
                    mem[ceil32(return_data.size) + 100] = this.address
                    require ext_code.size(wantAddress)
                    staticcall wantAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = (2 * ceil32(return_data.size)) + 96
                    require return_data.size >= 32
                    idx = 0
                    s = 0
                    t = -1
                    while idx < lenders.length:
                        mem[0] = 12
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].hasAssets() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _186 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_186] == bool(mem[_186])
                        if not mem[_186]:
                            idx = idx + 1
                            s = s
                            t = t
                            continue 
                        require idx < lenders.length
                        mem[0] = 12
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].apr() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _236 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _246 = mem[_236]
                        if mem[_236] >= t:
                            idx = idx + 1
                            s = s
                            t = t
                            continue 
                        require idx < lenders.length
                        mem[0] = 12
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].nav() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _266 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 1
                        s = mem[_266]
                        t = _246
                        continue 
                    if ext_call.return_data[0] + s < s:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = 0
                    u = 0
                    while idx < lenders.length:
                        mem[0] = 12
                        mem[mem[64] + 4] = ext_call.return_data[0]
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                                gas gas_remaining wei
                               args ext_call.return_data[0]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _308 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_308] <= u:
                            idx = idx + 1
                            u = u
                            continue 
                        idx = idx + 1
                        u = mem[_308]
                        continue 
                    require 0 < lenders.length
                    mem[0] = 12
                    mem[mem[64] + 4] = ext_call.return_data[0] + s
                    require ext_code.size(lenders)
                    staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                            gas gas_remaining wei
                           args (ext_call.return_data[0] + s)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _307 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_307] <= t:
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _356 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _366 = mem[_356]
                        if mem[_356]:
                            require 0 < lenders.length
                            mem[0] = 12
                            _382 = mem[64]
                            mem[mem[64] + 36] = lenders
                            mem[mem[64] + 68] = _366
                            _393 = mem[64]
                            mem[mem[64]] = 68
                            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                            mem[64] = mem[64] + 164
                            mem[_382 + 100] = 32
                            mem[_382 + 132] = 'SafeERC20: low-level call failed'
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(wantAddress):
                                revert with 0, 'Address: call to non-contract'
                            _443 = mem[_393]
                            mem[_382 + 164 len ceil32(mem[_393])] = mem[_393 + 32 len ceil32(mem[_393])]
                            if ceil32(_443) > _443:
                                mem[_443 + _382 + 164] = 0
                            call wantAddress with:
                                 gas gas_remaining wei
                                args mem[_382 + 168 len _443 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if mem[96]:
                                    require mem[96] >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            else:
                                mem[_382 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    require mem[_382 + 196] == bool(mem[_382 + 196])
                                    if not mem[_382 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require 0 < lenders.length
                            require ext_code.size(lenders)
                            call lenders.deposit() with:
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                    else:
                        require 0 < lenders.length
                        mem[0] = 12
                        require ext_code.size(lenders)
                        call lenders.withdrawAll() with:
                             gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _351 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_351] == bool(mem[_351])
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _395 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _411 = mem[_395]
                        if mem[_395]:
                            require 0 < lenders.length
                            mem[0] = 12
                            _421 = mem[64]
                            mem[mem[64] + 36] = lenders
                            mem[mem[64] + 68] = _411
                            _444 = mem[64]
                            mem[mem[64]] = 68
                            mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                            mem[64] = mem[64] + 164
                            mem[_421 + 100] = 32
                            mem[_421 + 132] = 'SafeERC20: low-level call failed'
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(wantAddress):
                                revert with 0, 'Address: call to non-contract'
                            _511 = mem[_444]
                            mem[_421 + 164 len ceil32(mem[_444])] = mem[_444 + 32 len ceil32(mem[_444])]
                            if ceil32(_511) > _511:
                                mem[_511 + _421 + 164] = 0
                            call wantAddress with:
                                 gas gas_remaining wei
                                args mem[_421 + 168 len _511 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if mem[96]:
                                        revert with memory
                                          from 128
                                           len mem[96]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if mem[96]:
                                    require mem[96] >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            else:
                                mem[_421 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    require mem[_421 + 196] == bool(mem[_421 + 196])
                                    if not mem[_421 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            require 0 < lenders.length
                            require ext_code.size(lenders)
                            call lenders.deposit() with:
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
        else:
            staticcall vaultAddress.governance() with:
                    gas gas_remaining wei
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(vaultAddress)
            if msg.sender == ext_call.return_data[12 len 20]:
                staticcall vaultAddress.debtOutstanding() with:
                        gas gas_remaining wei
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not emergencyExit:
                    if lenders.length:
                        mem[(2 * ceil32(return_data.size)) + 100] = this.address
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = (4 * ceil32(return_data.size)) + 96
                        require return_data.size >= 32
                        idx = 0
                        s = 0
                        t = -1
                        while idx < lenders.length:
                            mem[0] = 12
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].hasAssets() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _187 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_187] == bool(mem[_187])
                            if not mem[_187]:
                                idx = idx + 1
                                s = s
                                t = t
                                continue 
                            require idx < lenders.length
                            mem[0] = 12
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].apr() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _237 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _247 = mem[_237]
                            if mem[_237] >= t:
                                idx = idx + 1
                                s = s
                                t = t
                                continue 
                            require idx < lenders.length
                            mem[0] = 12
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].nav() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _267 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            idx = idx + 1
                            s = mem[_267]
                            t = _247
                            continue 
                        if ext_call.return_data[0] + s < s:
                            revert with 0, 'SafeMath: addition overflow'
                        idx = 0
                        u = 0
                        while idx < lenders.length:
                            mem[0] = 12
                            mem[mem[64] + 4] = ext_call.return_data[0]
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args ext_call.return_data[0]
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _310 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_310] <= u:
                                idx = idx + 1
                                u = u
                                continue 
                            idx = idx + 1
                            u = mem[_310]
                            continue 
                        require 0 < lenders.length
                        mem[0] = 12
                        mem[mem[64] + 4] = ext_call.return_data[0] + s
                        require ext_code.size(lenders)
                        staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                                gas gas_remaining wei
                               args (ext_call.return_data[0] + s)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _309 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_309] <= t:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _357 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _367 = mem[_357]
                            if mem[_357]:
                                require 0 < lenders.length
                                mem[0] = 12
                                _384 = mem[64]
                                mem[mem[64] + 36] = lenders
                                mem[mem[64] + 68] = _367
                                _396 = mem[64]
                                mem[mem[64]] = 68
                                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                mem[64] = mem[64] + 164
                                mem[_384 + 100] = 32
                                mem[_384 + 132] = 'SafeERC20: low-level call failed'
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(wantAddress):
                                    revert with 0, 'Address: call to non-contract'
                                _446 = mem[_396]
                                mem[_384 + 164 len ceil32(mem[_396])] = mem[_396 + 32 len ceil32(mem[_396])]
                                if ceil32(_446) > _446:
                                    mem[_446 + _384 + 164] = 0
                                call wantAddress with:
                                     gas gas_remaining wei
                                    args mem[_384 + 168 len _446 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if mem[96]:
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        require mem[128] == bool(mem[128])
                                        if not mem[128]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                else:
                                    mem[_384 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        require mem[_384 + 196] == bool(mem[_384 + 196])
                                        if not mem[_384 + 196]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                require 0 < lenders.length
                                require ext_code.size(lenders)
                                call lenders.deposit() with:
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                        else:
                            require 0 < lenders.length
                            mem[0] = 12
                            require ext_code.size(lenders)
                            call lenders.withdrawAll() with:
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _352 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_352] == bool(mem[_352])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _398 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _412 = mem[_398]
                            if mem[_398]:
                                require 0 < lenders.length
                                mem[0] = 12
                                _422 = mem[64]
                                mem[mem[64] + 36] = lenders
                                mem[mem[64] + 68] = _412
                                _447 = mem[64]
                                mem[mem[64]] = 68
                                mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                mem[64] = mem[64] + 164
                                mem[_422 + 100] = 32
                                mem[_422 + 132] = 'SafeERC20: low-level call failed'
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(wantAddress):
                                    revert with 0, 'Address: call to non-contract'
                                _512 = mem[_447]
                                mem[_422 + 164 len ceil32(mem[_447])] = mem[_447 + 32 len ceil32(mem[_447])]
                                if ceil32(_512) > _512:
                                    mem[_512 + _422 + 164] = 0
                                call wantAddress with:
                                     gas gas_remaining wei
                                    args mem[_422 + 168 len _512 - 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if mem[96]:
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if mem[96]:
                                        require mem[96] >= 32
                                        require mem[128] == bool(mem[128])
                                        if not mem[128]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                else:
                                    mem[_422 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        require mem[_422 + 196] == bool(mem[_422 + 196])
                                        if not mem[_422 + 196]:
                                            revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                require 0 < lenders.length
                                require ext_code.size(lenders)
                                call lenders.deposit() with:
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
            else:
                staticcall vaultAddress.guardian() with:
                        gas gas_remaining wei
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                require ext_code.size(vaultAddress)
                if msg.sender == ext_call.return_data[12 len 20]:
                    staticcall vaultAddress.debtOutstanding() with:
                            gas gas_remaining wei
                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not emergencyExit:
                        if lenders.length:
                            mem[(4 * ceil32(return_data.size)) + 100] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 96
                            require return_data.size >= 32
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _188 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_188] == bool(mem[_188])
                                if not mem[_188]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _238 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _248 = mem[_238]
                                if mem[_238] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _268 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_268]
                                t = _248
                                continue 
                            if ext_call.return_data[0] + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 12
                                mem[mem[64] + 4] = ext_call.return_data[0]
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _312 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_312] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_312]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 12
                            mem[mem[64] + 4] = ext_call.return_data[0] + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args (ext_call.return_data[0] + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _311 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_311] <= t:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _358 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _368 = mem[_358]
                                if mem[_358]:
                                    require 0 < lenders.length
                                    mem[0] = 12
                                    _386 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _368
                                    _399 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                    mem[64] = mem[64] + 164
                                    mem[_386 + 100] = 32
                                    mem[_386 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _449 = mem[_399]
                                    mem[_386 + 164 len ceil32(mem[_399])] = mem[_399 + 32 len ceil32(mem[_399])]
                                    if ceil32(_449) > _449:
                                        mem[_449 + _386 + 164] = 0
                                    call wantAddress with:
                                         gas gas_remaining wei
                                        args mem[_386 + 168 len _449 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_386 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_386 + 196] == bool(mem[_386 + 196])
                                            if not mem[_386 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                            else:
                                require 0 < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders)
                                call lenders.withdrawAll() with:
                                     gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _353 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_353] == bool(mem[_353])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _401 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _413 = mem[_401]
                                if mem[_401]:
                                    require 0 < lenders.length
                                    mem[0] = 12
                                    _423 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _413
                                    _450 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                    mem[64] = mem[64] + 164
                                    mem[_423 + 100] = 32
                                    mem[_423 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _513 = mem[_450]
                                    mem[_423 + 164 len ceil32(mem[_450])] = mem[_450 + 32 len ceil32(mem[_450])]
                                    if ceil32(_513) > _513:
                                        mem[_513 + _423 + 164] = 0
                                    call wantAddress with:
                                         gas gas_remaining wei
                                        args mem[_423 + 168 len _513 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_423 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_423 + 196] == bool(mem[_423 + 196])
                                            if not mem[_423 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                else:
                    staticcall vaultAddress.management() with:
                            gas gas_remaining wei
                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if ext_call.return_data[12 len 20] != msg.sender:
                        revert with 0, '!authorized'
                    require ext_code.size(vaultAddress)
                    staticcall vaultAddress.debtOutstanding() with:
                            gas gas_remaining wei
                    mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not emergencyExit:
                        if lenders.length:
                            mem[(6 * ceil32(return_data.size)) + 100] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = (7 * ceil32(return_data.size)) + 96
                            require return_data.size >= 32
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _189 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_189] == bool(mem[_189])
                                if not mem[_189]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _239 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _249 = mem[_239]
                                if mem[_239] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _269 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_269]
                                t = _249
                                continue 
                            if ext_call.return_data[0] + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 12
                                mem[mem[64] + 4] = ext_call.return_data[0]
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _314 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_314] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_314]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 12
                            mem[mem[64] + 4] = ext_call.return_data[0] + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args (ext_call.return_data[0] + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _313 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_313] <= t:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _359 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _369 = mem[_359]
                                if mem[_359]:
                                    require 0 < lenders.length
                                    mem[0] = 12
                                    _388 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _369
                                    _402 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                    mem[64] = mem[64] + 164
                                    mem[_388 + 100] = 32
                                    mem[_388 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _452 = mem[_402]
                                    mem[_388 + 164 len ceil32(mem[_402])] = mem[_402 + 32 len ceil32(mem[_402])]
                                    if ceil32(_452) > _452:
                                        mem[_452 + _388 + 164] = 0
                                    call wantAddress with:
                                         gas gas_remaining wei
                                        args mem[_388 + 168 len _452 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_388 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_388 + 196] == bool(mem[_388 + 196])
                                            if not mem[_388 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                            else:
                                require 0 < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders)
                                call lenders.withdrawAll() with:
                                     gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _354 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_354] == bool(mem[_354])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _404 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _414 = mem[_404]
                                if mem[_404]:
                                    require 0 < lenders.length
                                    mem[0] = 12
                                    _424 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _414
                                    _453 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[mem[64] + 32 len 4] = unknown_0xa9059cbb(?????)
                                    mem[64] = mem[64] + 164
                                    mem[_424 + 100] = 32
                                    mem[_424 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _514 = mem[_453]
                                    mem[_424 + 164 len ceil32(mem[_453])] = mem[_453 + 32 len ceil32(mem[_453])]
                                    if ceil32(_514) > _514:
                                        mem[_514 + _424 + 164] = 0
                                    call wantAddress with:
                                         gas gas_remaining wei
                                        args mem[_424 + 168 len _514 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_424 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_424 + 196] == bool(mem[_424 + 196])
                                            if not mem[_424 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
}

function forceRemoveLender(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if msg.sender == strategistAddress:
        idx = 0
        while idx < lenders.length:
            mem[0] = 12
            if lenders[idx] != arg1:
                idx = idx + 1
                continue 
            require idx < lenders.length
            require ext_code.size(lenders[idx])
            call lenders[idx].withdrawAll() with:
                 gas gas_remaining wei
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if idx == lenders.length - 1:
                require lenders.length
                mem[0] = 12
                lenders[lenders.length] = 0
                lenders.length--
                mem[ceil32(return_data.size) + 100] = this.address
                require ext_code.size(wantAddress)
                staticcall wantAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] > 0:
                    if not emergencyExit:
                        if lenders.length:
                            mem[(2 * ceil32(return_data.size)) + 100] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = (4 * ceil32(return_data.size)) + 96
                            require return_data.size >= 32
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _311 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_311] == bool(mem[_311])
                                if not mem[_311]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _351 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _359 = mem[_351]
                                if mem[_351] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _375 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_375]
                                t = _359
                                continue 
                            if ext_call.return_data[0] + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 12
                                mem[mem[64] + 4] = ext_call.return_data[0]
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _408 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_408] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_408]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 12
                            mem[mem[64] + 4] = ext_call.return_data[0] + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args (ext_call.return_data[0] + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _407 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_407] <= t:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _447 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _455 = mem[_447]
                                if mem[_447]:
                                    require 0 < lenders.length
                                    mem[0] = 12
                                    _467 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _455
                                    _475 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_475 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_475 + 36 len 28]
                                    mem[64] = _467 + 164
                                    mem[_467 + 100] = 32
                                    mem[_467 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _515 = mem[_475]
                                    idx = 0
                                    while idx < _515:
                                        mem[idx + _467 + 164] = mem[idx + _475 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_515) > _515:
                                        mem[_515 + _467 + 164] = 0
                                    call wantAddress.mem[_467 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_467 + 168 len _515 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_467 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_467 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _467 + 232] = mem[idx + _467 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_467 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_467 + 164] = return_data.size
                                        mem[_467 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_467 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_467 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _467 + ceil32(return_data.size) + 233] = mem[idx + _467 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_467 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_467 + 196] == bool(mem[_467 + 196])
                                            if not mem[_467 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                            else:
                                require 0 < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders)
                                call lenders.withdrawAll() with:
                                     gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _443 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_443] == bool(mem[_443])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _477 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _491 = mem[_477]
                                if mem[_477]:
                                    require 0 < lenders.length
                                    mem[0] = 12
                                    _499 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _491
                                    _516 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_516 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_516 + 36 len 28]
                                    mem[64] = _499 + 164
                                    mem[_499 + 100] = 32
                                    mem[_499 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _571 = mem[_516]
                                    idx = 0
                                    while idx < _571:
                                        mem[idx + _499 + 164] = mem[idx + _516 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_571) > _571:
                                        mem[_571 + _499 + 164] = 0
                                    call wantAddress.mem[_499 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_499 + 168 len _571 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_499 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_499 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _499 + 232] = mem[idx + _499 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_499 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_499 + 164] = return_data.size
                                        mem[_499 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_499 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_499 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _499 + ceil32(return_data.size) + 233] = mem[idx + _499 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_499 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_499 + 196] == bool(mem[_499 + 196])
                                            if not mem[_499 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
            else:
                require lenders.length - 1 < lenders.length
                require idx < lenders.length
                lenders[idx] = lenders[lenders.length]
                require lenders.length
                mem[0] = 12
                lenders[lenders.length] = 0
                lenders.length--
                mem[ceil32(return_data.size) + 100] = this.address
                require ext_code.size(wantAddress)
                staticcall wantAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] > 0:
                    if not emergencyExit:
                        if lenders.length:
                            mem[(2 * ceil32(return_data.size)) + 100] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = (4 * ceil32(return_data.size)) + 96
                            require return_data.size >= 32
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _312 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_312] == bool(mem[_312])
                                if not mem[_312]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _352 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _360 = mem[_352]
                                if mem[_352] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _376 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_376]
                                t = _360
                                continue 
                            if ext_call.return_data[0] + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 12
                                mem[mem[64] + 4] = ext_call.return_data[0]
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _410 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_410] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_410]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 12
                            mem[mem[64] + 4] = ext_call.return_data[0] + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args (ext_call.return_data[0] + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _409 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_409] <= t:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _448 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _456 = mem[_448]
                                if mem[_448]:
                                    require 0 < lenders.length
                                    mem[0] = 12
                                    _469 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _456
                                    _478 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_478 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_478 + 36 len 28]
                                    mem[64] = _469 + 164
                                    mem[_469 + 100] = 32
                                    mem[_469 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _518 = mem[_478]
                                    idx = 0
                                    while idx < _518:
                                        mem[idx + _469 + 164] = mem[idx + _478 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_518) > _518:
                                        mem[_518 + _469 + 164] = 0
                                    call wantAddress.mem[_469 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_469 + 168 len _518 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_469 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_469 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _469 + 232] = mem[idx + _469 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_469 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_469 + 164] = return_data.size
                                        mem[_469 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_469 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_469 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _469 + ceil32(return_data.size) + 233] = mem[idx + _469 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_469 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_469 + 196] == bool(mem[_469 + 196])
                                            if not mem[_469 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                            else:
                                require 0 < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders)
                                call lenders.withdrawAll() with:
                                     gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _444 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_444] == bool(mem[_444])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _480 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _492 = mem[_480]
                                if mem[_480]:
                                    require 0 < lenders.length
                                    mem[0] = 12
                                    _500 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _492
                                    _519 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_519 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_519 + 36 len 28]
                                    mem[64] = _500 + 164
                                    mem[_500 + 100] = 32
                                    mem[_500 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _572 = mem[_519]
                                    idx = 0
                                    while idx < _572:
                                        mem[idx + _500 + 164] = mem[idx + _519 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_572) > _572:
                                        mem[_572 + _500 + 164] = 0
                                    call wantAddress.mem[_500 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_500 + 168 len _572 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_500 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_500 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _500 + 232] = mem[idx + _500 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_500 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_500 + 164] = return_data.size
                                        mem[_500 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_500 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_500 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _500 + ceil32(return_data.size) + 233] = mem[idx + _500 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_500 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_500 + 196] == bool(mem[_500 + 196])
                                            if not mem[_500 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
    else:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(return_data.size) + 96
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, '!authorized'
        idx = 0
        while idx < lenders.length:
            mem[0] = 12
            if lenders[idx] != arg1:
                idx = idx + 1
                continue 
            require idx < lenders.length
            require ext_code.size(lenders[idx])
            call lenders[idx].withdrawAll() with:
                 gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if idx == lenders.length - 1:
                require lenders.length
                mem[0] = 12
                lenders[lenders.length] = 0
                lenders.length--
                mem[(2 * ceil32(return_data.size)) + 100] = this.address
                require ext_code.size(wantAddress)
                staticcall wantAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] > 0:
                    if not emergencyExit:
                        if lenders.length:
                            mem[(4 * ceil32(return_data.size)) + 100] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 96
                            require return_data.size >= 32
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _313 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_313] == bool(mem[_313])
                                if not mem[_313]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _353 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _361 = mem[_353]
                                if mem[_353] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _377 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_377]
                                t = _361
                                continue 
                            if ext_call.return_data[0] + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 12
                                mem[mem[64] + 4] = ext_call.return_data[0]
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _412 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_412] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_412]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 12
                            mem[mem[64] + 4] = ext_call.return_data[0] + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args (ext_call.return_data[0] + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _411 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_411] <= t:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _449 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _457 = mem[_449]
                                if mem[_449]:
                                    require 0 < lenders.length
                                    mem[0] = 12
                                    _471 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _457
                                    _481 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_481 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_481 + 36 len 28]
                                    mem[64] = _471 + 164
                                    mem[_471 + 100] = 32
                                    mem[_471 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _521 = mem[_481]
                                    idx = 0
                                    while idx < _521:
                                        mem[idx + _471 + 164] = mem[idx + _481 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_521) > _521:
                                        mem[_521 + _471 + 164] = 0
                                    call wantAddress.mem[_471 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_471 + 168 len _521 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_471 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_471 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _471 + 232] = mem[idx + _471 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_471 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_471 + 164] = return_data.size
                                        mem[_471 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_471 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_471 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _471 + ceil32(return_data.size) + 233] = mem[idx + _471 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_471 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_471 + 196] == bool(mem[_471 + 196])
                                            if not mem[_471 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                            else:
                                require 0 < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders)
                                call lenders.withdrawAll() with:
                                     gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _445 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_445] == bool(mem[_445])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _483 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _493 = mem[_483]
                                if mem[_483]:
                                    require 0 < lenders.length
                                    mem[0] = 12
                                    _501 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _493
                                    _522 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_522 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_522 + 36 len 28]
                                    mem[64] = _501 + 164
                                    mem[_501 + 100] = 32
                                    mem[_501 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _573 = mem[_522]
                                    idx = 0
                                    while idx < _573:
                                        mem[idx + _501 + 164] = mem[idx + _522 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_573) > _573:
                                        mem[_573 + _501 + 164] = 0
                                    call wantAddress.mem[_501 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_501 + 168 len _573 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_501 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_501 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _501 + 232] = mem[idx + _501 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_501 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_501 + 164] = return_data.size
                                        mem[_501 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_501 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_501 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _501 + ceil32(return_data.size) + 233] = mem[idx + _501 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_501 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_501 + 196] == bool(mem[_501 + 196])
                                            if not mem[_501 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
            else:
                require lenders.length - 1 < lenders.length
                require idx < lenders.length
                lenders[idx] = lenders[lenders.length]
                require lenders.length
                mem[0] = 12
                lenders[lenders.length] = 0
                lenders.length--
                mem[(2 * ceil32(return_data.size)) + 100] = this.address
                require ext_code.size(wantAddress)
                staticcall wantAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] > 0:
                    if not emergencyExit:
                        if lenders.length:
                            mem[(4 * ceil32(return_data.size)) + 100] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 96
                            require return_data.size >= 32
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _314 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_314] == bool(mem[_314])
                                if not mem[_314]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _354 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _362 = mem[_354]
                                if mem[_354] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _378 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_378]
                                t = _362
                                continue 
                            if ext_call.return_data[0] + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 12
                                mem[mem[64] + 4] = ext_call.return_data[0]
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _414 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_414] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_414]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 12
                            mem[mem[64] + 4] = ext_call.return_data[0] + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args (ext_call.return_data[0] + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _413 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_413] <= t:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _450 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _458 = mem[_450]
                                if mem[_450]:
                                    require 0 < lenders.length
                                    mem[0] = 12
                                    _473 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _458
                                    _484 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_484 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_484 + 36 len 28]
                                    mem[64] = _473 + 164
                                    mem[_473 + 100] = 32
                                    mem[_473 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _524 = mem[_484]
                                    idx = 0
                                    while idx < _524:
                                        mem[idx + _473 + 164] = mem[idx + _484 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_524) > _524:
                                        mem[_524 + _473 + 164] = 0
                                    call wantAddress.mem[_473 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_473 + 168 len _524 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_473 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_473 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _473 + 232] = mem[idx + _473 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_473 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_473 + 164] = return_data.size
                                        mem[_473 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_473 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_473 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _473 + ceil32(return_data.size) + 233] = mem[idx + _473 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_473 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_473 + 196] == bool(mem[_473 + 196])
                                            if not mem[_473 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                            else:
                                require 0 < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders)
                                call lenders.withdrawAll() with:
                                     gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _446 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_446] == bool(mem[_446])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _486 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _494 = mem[_486]
                                if mem[_486]:
                                    require 0 < lenders.length
                                    mem[0] = 12
                                    _502 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _494
                                    _525 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_525 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_525 + 36 len 28]
                                    mem[64] = _502 + 164
                                    mem[_502 + 100] = 32
                                    mem[_502 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _574 = mem[_525]
                                    idx = 0
                                    while idx < _574:
                                        mem[idx + _502 + 164] = mem[idx + _525 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_574) > _574:
                                        mem[_574 + _502 + 164] = 0
                                    call wantAddress.mem[_502 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_502 + 168 len _574 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_502 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_502 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _502 + 232] = mem[idx + _502 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_502 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_502 + 164] = return_data.size
                                        mem[_502 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_502 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_502 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _502 + ceil32(return_data.size) + 233] = mem[idx + _502 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_502 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_502 + 196] == bool(mem[_502 + 196])
                                            if not mem[_502 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
    revert with 0, 'NOT LENDER'
}

function safeRemoveLender(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if msg.sender == strategistAddress:
        idx = 0
        while idx < lenders.length:
            mem[0] = 12
            if lenders[idx] != arg1:
                idx = idx + 1
                continue 
            require idx < lenders.length
            require ext_code.size(lenders[idx])
            call lenders[idx].withdrawAll() with:
                 gas gas_remaining wei
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if not ext_call.return_data[0]:
                revert with 0, 'WITHDRAW FAILED'
            if idx == lenders.length - 1:
                require lenders.length
                mem[0] = 12
                lenders[lenders.length] = 0
                lenders.length--
                mem[ceil32(return_data.size) + 100] = this.address
                require ext_code.size(wantAddress)
                staticcall wantAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] > 0:
                    if not emergencyExit:
                        if lenders.length:
                            mem[(2 * ceil32(return_data.size)) + 100] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = (4 * ceil32(return_data.size)) + 96
                            require return_data.size >= 32
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _319 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_319] == bool(mem[_319])
                                if not mem[_319]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _359 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _367 = mem[_359]
                                if mem[_359] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _383 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_383]
                                t = _367
                                continue 
                            if ext_call.return_data[0] + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 12
                                mem[mem[64] + 4] = ext_call.return_data[0]
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _416 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_416] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_416]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 12
                            mem[mem[64] + 4] = ext_call.return_data[0] + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args (ext_call.return_data[0] + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _415 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_415] <= t:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _455 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _463 = mem[_455]
                                if mem[_455]:
                                    require 0 < lenders.length
                                    mem[0] = 12
                                    _475 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _463
                                    _483 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_483 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_483 + 36 len 28]
                                    mem[64] = _475 + 164
                                    mem[_475 + 100] = 32
                                    mem[_475 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _523 = mem[_483]
                                    idx = 0
                                    while idx < _523:
                                        mem[idx + _475 + 164] = mem[idx + _483 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_523) > _523:
                                        mem[_523 + _475 + 164] = 0
                                    call wantAddress.mem[_475 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_475 + 168 len _523 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_475 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_475 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _475 + 232] = mem[idx + _475 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_475 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_475 + 164] = return_data.size
                                        mem[_475 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_475 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_475 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _475 + ceil32(return_data.size) + 233] = mem[idx + _475 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_475 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_475 + 196] == bool(mem[_475 + 196])
                                            if not mem[_475 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                            else:
                                require 0 < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders)
                                call lenders.withdrawAll() with:
                                     gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _451 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_451] == bool(mem[_451])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _485 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _499 = mem[_485]
                                if mem[_485]:
                                    require 0 < lenders.length
                                    mem[0] = 12
                                    _507 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _499
                                    _524 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_524 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_524 + 36 len 28]
                                    mem[64] = _507 + 164
                                    mem[_507 + 100] = 32
                                    mem[_507 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _579 = mem[_524]
                                    idx = 0
                                    while idx < _579:
                                        mem[idx + _507 + 164] = mem[idx + _524 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_579) > _579:
                                        mem[_579 + _507 + 164] = 0
                                    call wantAddress.mem[_507 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_507 + 168 len _579 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_507 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_507 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _507 + 232] = mem[idx + _507 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_507 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_507 + 164] = return_data.size
                                        mem[_507 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_507 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_507 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _507 + ceil32(return_data.size) + 233] = mem[idx + _507 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_507 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_507 + 196] == bool(mem[_507 + 196])
                                            if not mem[_507 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
            else:
                require lenders.length - 1 < lenders.length
                require idx < lenders.length
                lenders[idx] = lenders[lenders.length]
                require lenders.length
                mem[0] = 12
                lenders[lenders.length] = 0
                lenders.length--
                mem[ceil32(return_data.size) + 100] = this.address
                require ext_code.size(wantAddress)
                staticcall wantAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] > 0:
                    if not emergencyExit:
                        if lenders.length:
                            mem[(2 * ceil32(return_data.size)) + 100] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = (4 * ceil32(return_data.size)) + 96
                            require return_data.size >= 32
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _320 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_320] == bool(mem[_320])
                                if not mem[_320]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _360 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _368 = mem[_360]
                                if mem[_360] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _384 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_384]
                                t = _368
                                continue 
                            if ext_call.return_data[0] + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 12
                                mem[mem[64] + 4] = ext_call.return_data[0]
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _418 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_418] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_418]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 12
                            mem[mem[64] + 4] = ext_call.return_data[0] + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args (ext_call.return_data[0] + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _417 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_417] <= t:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _456 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _464 = mem[_456]
                                if mem[_456]:
                                    require 0 < lenders.length
                                    mem[0] = 12
                                    _477 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _464
                                    _486 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_486 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_486 + 36 len 28]
                                    mem[64] = _477 + 164
                                    mem[_477 + 100] = 32
                                    mem[_477 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _526 = mem[_486]
                                    idx = 0
                                    while idx < _526:
                                        mem[idx + _477 + 164] = mem[idx + _486 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_526) > _526:
                                        mem[_526 + _477 + 164] = 0
                                    call wantAddress.mem[_477 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_477 + 168 len _526 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_477 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_477 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _477 + 232] = mem[idx + _477 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_477 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_477 + 164] = return_data.size
                                        mem[_477 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_477 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_477 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _477 + ceil32(return_data.size) + 233] = mem[idx + _477 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_477 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_477 + 196] == bool(mem[_477 + 196])
                                            if not mem[_477 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                            else:
                                require 0 < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders)
                                call lenders.withdrawAll() with:
                                     gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _452 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_452] == bool(mem[_452])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _488 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _500 = mem[_488]
                                if mem[_488]:
                                    require 0 < lenders.length
                                    mem[0] = 12
                                    _508 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _500
                                    _527 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_527 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_527 + 36 len 28]
                                    mem[64] = _508 + 164
                                    mem[_508 + 100] = 32
                                    mem[_508 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _580 = mem[_527]
                                    idx = 0
                                    while idx < _580:
                                        mem[idx + _508 + 164] = mem[idx + _527 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_580) > _580:
                                        mem[_580 + _508 + 164] = 0
                                    call wantAddress.mem[_508 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_508 + 168 len _580 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_508 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_508 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _508 + 232] = mem[idx + _508 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_508 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_508 + 164] = return_data.size
                                        mem[_508 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_508 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_508 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _508 + ceil32(return_data.size) + 233] = mem[idx + _508 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_508 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_508 + 196] == bool(mem[_508 + 196])
                                            if not mem[_508 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
    else:
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.governance() with:
                gas gas_remaining wei
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[64] = ceil32(return_data.size) + 96
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if ext_call.return_data[12 len 20] != msg.sender:
            revert with 0, '!authorized'
        idx = 0
        while idx < lenders.length:
            mem[0] = 12
            if lenders[idx] != arg1:
                idx = idx + 1
                continue 
            require idx < lenders.length
            require ext_code.size(lenders[idx])
            call lenders[idx].withdrawAll() with:
                 gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if not ext_call.return_data[0]:
                revert with 0, 'WITHDRAW FAILED'
            if idx == lenders.length - 1:
                require lenders.length
                mem[0] = 12
                lenders[lenders.length] = 0
                lenders.length--
                mem[(2 * ceil32(return_data.size)) + 100] = this.address
                require ext_code.size(wantAddress)
                staticcall wantAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] > 0:
                    if not emergencyExit:
                        if lenders.length:
                            mem[(4 * ceil32(return_data.size)) + 100] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 96
                            require return_data.size >= 32
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _321 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_321] == bool(mem[_321])
                                if not mem[_321]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _361 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _369 = mem[_361]
                                if mem[_361] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _385 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_385]
                                t = _369
                                continue 
                            if ext_call.return_data[0] + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 12
                                mem[mem[64] + 4] = ext_call.return_data[0]
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _420 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_420] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_420]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 12
                            mem[mem[64] + 4] = ext_call.return_data[0] + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args (ext_call.return_data[0] + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _419 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_419] <= t:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _457 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _465 = mem[_457]
                                if mem[_457]:
                                    require 0 < lenders.length
                                    mem[0] = 12
                                    _479 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _465
                                    _489 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_489 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_489 + 36 len 28]
                                    mem[64] = _479 + 164
                                    mem[_479 + 100] = 32
                                    mem[_479 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _529 = mem[_489]
                                    idx = 0
                                    while idx < _529:
                                        mem[idx + _479 + 164] = mem[idx + _489 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_529) > _529:
                                        mem[_529 + _479 + 164] = 0
                                    call wantAddress.mem[_479 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_479 + 168 len _529 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_479 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_479 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _479 + 232] = mem[idx + _479 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_479 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_479 + 164] = return_data.size
                                        mem[_479 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_479 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_479 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _479 + ceil32(return_data.size) + 233] = mem[idx + _479 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_479 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_479 + 196] == bool(mem[_479 + 196])
                                            if not mem[_479 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                            else:
                                require 0 < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders)
                                call lenders.withdrawAll() with:
                                     gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _453 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_453] == bool(mem[_453])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _491 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _501 = mem[_491]
                                if mem[_491]:
                                    require 0 < lenders.length
                                    mem[0] = 12
                                    _509 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _501
                                    _530 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_530 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_530 + 36 len 28]
                                    mem[64] = _509 + 164
                                    mem[_509 + 100] = 32
                                    mem[_509 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _581 = mem[_530]
                                    idx = 0
                                    while idx < _581:
                                        mem[idx + _509 + 164] = mem[idx + _530 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_581) > _581:
                                        mem[_581 + _509 + 164] = 0
                                    call wantAddress.mem[_509 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_509 + 168 len _581 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_509 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_509 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _509 + 232] = mem[idx + _509 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_509 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_509 + 164] = return_data.size
                                        mem[_509 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_509 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_509 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _509 + ceil32(return_data.size) + 233] = mem[idx + _509 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_509 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_509 + 196] == bool(mem[_509 + 196])
                                            if not mem[_509 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
            else:
                require lenders.length - 1 < lenders.length
                require idx < lenders.length
                lenders[idx] = lenders[lenders.length]
                require lenders.length
                mem[0] = 12
                lenders[lenders.length] = 0
                lenders.length--
                mem[(2 * ceil32(return_data.size)) + 100] = this.address
                require ext_code.size(wantAddress)
                staticcall wantAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] > 0:
                    if not emergencyExit:
                        if lenders.length:
                            mem[(4 * ceil32(return_data.size)) + 100] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 96
                            require return_data.size >= 32
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _322 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_322] == bool(mem[_322])
                                if not mem[_322]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _362 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _370 = mem[_362]
                                if mem[_362] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _386 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_386]
                                t = _370
                                continue 
                            if ext_call.return_data[0] + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 12
                                mem[mem[64] + 4] = ext_call.return_data[0]
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _422 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_422] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_422]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 12
                            mem[mem[64] + 4] = ext_call.return_data[0] + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args (ext_call.return_data[0] + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _421 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_421] <= t:
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _458 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _466 = mem[_458]
                                if mem[_458]:
                                    require 0 < lenders.length
                                    mem[0] = 12
                                    _481 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _466
                                    _492 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_492 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_492 + 36 len 28]
                                    mem[64] = _481 + 164
                                    mem[_481 + 100] = 32
                                    mem[_481 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _532 = mem[_492]
                                    idx = 0
                                    while idx < _532:
                                        mem[idx + _481 + 164] = mem[idx + _492 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_532) > _532:
                                        mem[_532 + _481 + 164] = 0
                                    call wantAddress.mem[_481 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_481 + 168 len _532 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_481 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_481 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _481 + 232] = mem[idx + _481 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_481 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_481 + 164] = return_data.size
                                        mem[_481 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_481 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_481 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _481 + ceil32(return_data.size) + 233] = mem[idx + _481 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_481 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_481 + 196] == bool(mem[_481 + 196])
                                            if not mem[_481 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                            else:
                                require 0 < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders)
                                call lenders.withdrawAll() with:
                                     gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _454 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_454] == bool(mem[_454])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(wantAddress)
                                staticcall wantAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _494 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _502 = mem[_494]
                                if mem[_494]:
                                    require 0 < lenders.length
                                    mem[0] = 12
                                    _510 = mem[64]
                                    mem[mem[64] + 36] = lenders
                                    mem[mem[64] + 68] = _502
                                    _533 = mem[64]
                                    mem[mem[64]] = 68
                                    mem[64] = mem[64] + 100
                                    mem[_533 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_533 + 36 len 28]
                                    mem[64] = _510 + 164
                                    mem[_510 + 100] = 32
                                    mem[_510 + 132] = 'SafeERC20: low-level call failed'
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(wantAddress):
                                        revert with 0, 'Address: call to non-contract'
                                    _582 = mem[_533]
                                    idx = 0
                                    while idx < _582:
                                        mem[idx + _510 + 164] = mem[idx + _533 + 32]
                                        idx = idx + 32
                                        continue 
                                    if ceil32(_582) > _582:
                                        mem[_582 + _510 + 164] = 0
                                    call wantAddress.mem[_510 + 164 len 4] with:
                                         gas gas_remaining wei
                                        args mem[_510 + 168 len _582 - 4]
                                    if not return_data.size:
                                        if not ext_call.success:
                                            if mem[96]:
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            mem[_510 + 164] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_510 + 168] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _510 + 232] = mem[idx + _510 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_510 + 232]
                                        if mem[96]:
                                            require mem[96] >= 32
                                            require mem[128] == bool(mem[128])
                                            if not mem[128]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    else:
                                        mem[_510 + 164] = return_data.size
                                        mem[_510 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_510 + ceil32(return_data.size) + 165] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_510 + ceil32(return_data.size) + 169] = 32
                                            idx = 0
                                            while idx < 32:
                                                mem[idx + _510 + ceil32(return_data.size) + 233] = mem[idx + _510 + 132]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 32, 32, mem[_510 + ceil32(return_data.size) + 233]
                                        if return_data.size:
                                            require return_data.size >= 32
                                            require mem[_510 + 196] == bool(mem[_510 + 196])
                                            if not mem[_510 + 196]:
                                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    require 0 < lenders.length
                                    require ext_code.size(lenders)
                                    call lenders.deposit() with:
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
    revert with 0, 'NOT LENDER'
}

function tendTrigger(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
        mem[96] = 0
        mem[128] = 0
        mem[160] = 0
        mem[192] = 0
        mem[224] = 0
        mem[256] = 0
        mem[288] = 0
        mem[320] = 0
        mem[352] = 0
        require ext_code.size(vaultAddress)
        staticcall vaultAddress.strategies(address rg1) with:
                gas gas_remaining wei
               args this.address
        mem[384 len 288] = ext_call.return_data[0 len 288]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 288
        require bool(ceil32(return_data.size) + 672 <= test266151307())
        mem[ceil32(return_data.size) + 384] = ext_call.return_data[0]
        mem[ceil32(return_data.size) + 416] = ext_call.return_data[32]
        mem[ceil32(return_data.size) + 448] = ext_call.return_data[64]
        mem[ceil32(return_data.size) + 480] = ext_call.return_data[96]
        mem[ceil32(return_data.size) + 512] = ext_call.return_data[128]
        mem[ceil32(return_data.size) + 544] = ext_call.return_data[160]
        mem[ceil32(return_data.size) + 576] = ext_call.return_data[192]
        mem[ceil32(return_data.size) + 608] = ext_call.return_data[224]
        mem[ceil32(return_data.size) + 640] = ext_call.return_data[256]
        if 0 == ext_call.return_data[32]:
            mem[ceil32(return_data.size) + 676] = this.address
            require ext_code.size(wantAddress)
            staticcall wantAddress.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(return_data.size) + 672] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[64] = (2 * ceil32(return_data.size)) + 672
            require return_data.size >= 32
            idx = 0
            s = 0
            t = -1
            while idx < lenders.length:
                mem[0] = 12
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].hasAssets() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _788 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_788] == bool(mem[_788])
                if not mem[_788]:
                    idx = idx + 1
                    s = s
                    t = t
                    continue 
                require idx < lenders.length
                mem[0] = 12
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].apr() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _851 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _863 = mem[_851]
                if mem[_851] >= t:
                    idx = idx + 1
                    s = s
                    t = t
                    continue 
                require idx < lenders.length
                mem[0] = 12
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].nav() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _897 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 1
                s = mem[_897]
                t = _863
                continue 
            if ext_call.return_data[0] + s < s:
                revert with 0, 'SafeMath: addition overflow'
            idx = 0
            u = 0
            while idx < lenders.length:
                mem[0] = 12
                mem[mem[64] + 4] = ext_call.return_data[0]
                require ext_code.size(lenders[idx])
                staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                        gas gas_remaining wei
                       args ext_call.return_data[0]
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1508 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_1508] <= u:
                    idx = idx + 1
                    u = u
                    continue 
                idx = idx + 1
                u = mem[_1508]
                continue 
            require 0 < lenders.length
            mem[0] = 12
            mem[mem[64] + 4] = ext_call.return_data[0] + s
            require ext_code.size(lenders)
            staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                    gas gas_remaining wei
                   args (ext_call.return_data[0] + s)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1507 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1532 = mem[_1507]
            if mem[_1507] <= t:
                return 0
            require 0 < lenders.length
            mem[0] = 12
            require ext_code.size(lenders)
            staticcall lenders.nav() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1624 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1629 = mem[_1624]
            if not mem[_1624]:
                _1701 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1701] = 26
                mem[_1701 + 32] = 'SafeMath: division by zero'
                _1742 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1742] = 26
                mem[_1742 + 32] = 'SafeMath: division by zero'
                if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                    if not arg1:
                        return 0
                    if profitFactor * arg1 / arg1 != profitFactor:
                        revert with 0, 'SafeMath: multiplication overflow'
                    return (profitFactor * arg1 < 0)
                if wantToEthOracleAddress:
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(wantToEthOracleAddress)
                    staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                            gas gas_remaining wei
                           args arg1
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1935 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if not mem[_1935]:
                        return 0
                    if profitFactor * mem[_1935] / mem[_1935] != profitFactor:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[mem[64]] = profitFactor * mem[_1935] < 0
                else:
                    _1818 = mem[64]
                    mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                    mem[mem[64] + 96] = 2
                    mem[64] = mem[64] + 192
                    require 0 < mem[_1818 + 96]
                    mem[_1818 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                    require 1 < mem[_1818 + 96]
                    mem[_1818 + 160] = wantAddress
                    mem[_1818 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[_1818 + 196] = arg1
                    mem[_1818 + 228] = 64
                    mem[_1818 + 260] = mem[_1818 + 96]
                    idx = 0
                    s = _1818 + 292
                    t = _1818 + 128
                    while idx < mem[_1818 + 96]:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                    staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4 len _1818 + (32 * mem[_1818 + 96]) + -mem[64] + 288]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2857 = mem[64]
                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2903 = mem[_2857]
                    require mem[_2857] <= test266151307()
                    require _2857 + return_data.size > _2857 + mem[_2857] + 31
                    _2944 = mem[_2857 + mem[_2857]]
                    require mem[_2857 + mem[_2857]] <= test266151307()
                    require (32 * mem[_2857 + mem[_2857]]) + 32 >= 0 and _2857 + ceil32(return_data.size) + (32 * mem[_2857 + mem[_2857]]) + 32 <= test266151307()
                    mem[64] = _2857 + ceil32(return_data.size) + (32 * mem[_2857 + mem[_2857]]) + 32
                    mem[_2857 + ceil32(return_data.size)] = _2944
                    require return_data.size >= _2903 + (32 * _2944) + 32
                    mem[_2857 + ceil32(return_data.size) + 32 len 32 * _2944] = mem[_2857 + _2903 + 32 len 32 * _2944]
                    require _2944 - 1 < _2944
                    if not mem[(32 * _2944 - 1) + _2857 + ceil32(return_data.size) + 32]:
                        return 0
                    if profitFactor * mem[(32 * _2944 - 1) + _2857 + ceil32(return_data.size) + 32] / mem[(32 * _2944 - 1) + _2857 + ceil32(return_data.size) + 32] != profitFactor:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[mem[64]] = profitFactor * mem[(32 * _2944 - 1) + _2857 + ceil32(return_data.size) + 32] < 0
            else:
                if t * mem[_1624] / mem[_1624] != t:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not mem[_1624]:
                    _1707 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1707] = 26
                    mem[_1707 + 32] = 'SafeMath: division by zero'
                    if not -1 * t * _1629 / 10^18:
                        _1752 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1752] = 26
                        mem[_1752 + 32] = 'SafeMath: division by zero'
                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                            if not arg1:
                                return 0
                            if profitFactor * arg1 / arg1 != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            return (profitFactor * arg1 < 0)
                        if wantToEthOracleAddress:
                            mem[mem[64] + 4] = arg1
                            require ext_code.size(wantToEthOracleAddress)
                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args arg1
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1966 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if not mem[_1966]:
                                return 0
                            if profitFactor * mem[_1966] / mem[_1966] != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[mem[64]] = profitFactor * mem[_1966] < 0
                        else:
                            _1848 = mem[64]
                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                            mem[mem[64] + 96] = 2
                            mem[64] = mem[64] + 192
                            require 0 < mem[_1848 + 96]
                            mem[_1848 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                            require 1 < mem[_1848 + 96]
                            mem[_1848 + 160] = wantAddress
                            mem[_1848 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_1848 + 196] = arg1
                            mem[_1848 + 228] = 64
                            mem[_1848 + 260] = mem[_1848 + 96]
                            idx = 0
                            s = _1848 + 292
                            t = _1848 + 128
                            while idx < mem[_1848 + 96]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _1848 + (32 * mem[_1848 + 96]) + -mem[64] + 288]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2856 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2902 = mem[_2856]
                            require mem[_2856] <= test266151307()
                            require _2856 + return_data.size > _2856 + mem[_2856] + 31
                            _2943 = mem[_2856 + mem[_2856]]
                            require mem[_2856 + mem[_2856]] <= test266151307()
                            require (32 * mem[_2856 + mem[_2856]]) + 32 >= 0 and _2856 + ceil32(return_data.size) + (32 * mem[_2856 + mem[_2856]]) + 32 <= test266151307()
                            mem[64] = _2856 + ceil32(return_data.size) + (32 * mem[_2856 + mem[_2856]]) + 32
                            mem[_2856 + ceil32(return_data.size)] = _2943
                            require return_data.size >= _2902 + (32 * _2943) + 32
                            mem[_2856 + ceil32(return_data.size) + 32 len 32 * _2943] = mem[_2856 + _2902 + 32 len 32 * _2943]
                            require _2943 - 1 < _2943
                            if not mem[(32 * _2943 - 1) + _2856 + ceil32(return_data.size) + 32]:
                                return 0
                            if profitFactor * mem[(32 * _2943 - 1) + _2856 + ceil32(return_data.size) + 32] / mem[(32 * _2943 - 1) + _2856 + ceil32(return_data.size) + 32] != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[mem[64]] = profitFactor * mem[(32 * _2943 - 1) + _2856 + ceil32(return_data.size) + 32] < 0
                    else:
                        if maxReportDelay * -1 * t * _1629 / 10^18 / -1 * t * _1629 / 10^18 != maxReportDelay:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _1767 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1767] = 26
                        mem[_1767 + 32] = 'SafeMath: division by zero'
                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                            if not arg1:
                                return (0 < maxReportDelay * -1 * t * _1629 / 10^18 / 31556952)
                            if profitFactor * arg1 / arg1 != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            return (profitFactor * arg1 < maxReportDelay * -1 * t * _1629 / 10^18 / 31556952)
                        if wantToEthOracleAddress:
                            mem[mem[64] + 4] = arg1
                            require ext_code.size(wantToEthOracleAddress)
                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args arg1
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2001 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if not mem[_2001]:
                                return (0 < maxReportDelay * -1 * t * _1629 / 10^18 / 31556952)
                            if profitFactor * mem[_2001] / mem[_2001] != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[mem[64]] = profitFactor * mem[_2001] < maxReportDelay * -1 * t * _1629 / 10^18 / 31556952
                        else:
                            _1890 = mem[64]
                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                            mem[mem[64] + 96] = 2
                            mem[64] = mem[64] + 192
                            require 0 < mem[_1890 + 96]
                            mem[_1890 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                            require 1 < mem[_1890 + 96]
                            mem[_1890 + 160] = wantAddress
                            mem[_1890 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_1890 + 196] = arg1
                            mem[_1890 + 228] = 64
                            mem[_1890 + 260] = mem[_1890 + 96]
                            idx = 0
                            s = _1890 + 292
                            u = _1890 + 128
                            while idx < mem[_1890 + 96]:
                                mem[s] = mem[u + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                u = u + 32
                                continue 
                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _1890 + (32 * mem[_1890 + 96]) + -mem[64] + 288]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2855 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2901 = mem[_2855]
                            require mem[_2855] <= test266151307()
                            require _2855 + return_data.size > _2855 + mem[_2855] + 31
                            _2942 = mem[_2855 + mem[_2855]]
                            require mem[_2855 + mem[_2855]] <= test266151307()
                            require (32 * mem[_2855 + mem[_2855]]) + 32 >= 0 and _2855 + ceil32(return_data.size) + (32 * mem[_2855 + mem[_2855]]) + 32 <= test266151307()
                            mem[64] = _2855 + ceil32(return_data.size) + (32 * mem[_2855 + mem[_2855]]) + 32
                            mem[_2855 + ceil32(return_data.size)] = _2942
                            require return_data.size >= _2901 + (32 * _2942) + 32
                            mem[_2855 + ceil32(return_data.size) + 32 len 32 * _2942] = mem[_2855 + _2901 + 32 len 32 * _2942]
                            require _2942 - 1 < _2942
                            if not mem[(32 * _2942 - 1) + _2855 + ceil32(return_data.size) + 32]:
                                return (0 < maxReportDelay * -1 * t * _1629 / 10^18 / 31556952)
                            if profitFactor * mem[(32 * _2942 - 1) + _2855 + ceil32(return_data.size) + 32] / mem[(32 * _2942 - 1) + _2855 + ceil32(return_data.size) + 32] != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[mem[64]] = profitFactor * mem[(32 * _2942 - 1) + _2855 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _1629 / 10^18 / 31556952
                else:
                    if _1532 * mem[_1624] / mem[_1624] != _1532:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _1715 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1715] = 26
                    mem[_1715 + 32] = 'SafeMath: division by zero'
                    if not (_1532 * _1629) - (t * _1629) / 10^18:
                        _1766 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1766] = 26
                        mem[_1766 + 32] = 'SafeMath: division by zero'
                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                            if not arg1:
                                return 0
                            if profitFactor * arg1 / arg1 != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            return (profitFactor * arg1 < 0)
                        if wantToEthOracleAddress:
                            mem[mem[64] + 4] = arg1
                            require ext_code.size(wantToEthOracleAddress)
                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args arg1
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1999 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if not mem[_1999]:
                                return 0
                            if profitFactor * mem[_1999] / mem[_1999] != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[mem[64]] = profitFactor * mem[_1999] < 0
                        else:
                            _1887 = mem[64]
                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                            mem[mem[64] + 96] = 2
                            mem[64] = mem[64] + 192
                            require 0 < mem[_1887 + 96]
                            mem[_1887 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                            require 1 < mem[_1887 + 96]
                            mem[_1887 + 160] = wantAddress
                            mem[_1887 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_1887 + 196] = arg1
                            mem[_1887 + 228] = 64
                            mem[_1887 + 260] = mem[_1887 + 96]
                            idx = 0
                            s = _1887 + 292
                            t = _1887 + 128
                            while idx < mem[_1887 + 96]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _1887 + (32 * mem[_1887 + 96]) + -mem[64] + 288]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2854 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2900 = mem[_2854]
                            require mem[_2854] <= test266151307()
                            require _2854 + return_data.size > _2854 + mem[_2854] + 31
                            _2941 = mem[_2854 + mem[_2854]]
                            require mem[_2854 + mem[_2854]] <= test266151307()
                            require (32 * mem[_2854 + mem[_2854]]) + 32 >= 0 and _2854 + ceil32(return_data.size) + (32 * mem[_2854 + mem[_2854]]) + 32 <= test266151307()
                            mem[64] = _2854 + ceil32(return_data.size) + (32 * mem[_2854 + mem[_2854]]) + 32
                            mem[_2854 + ceil32(return_data.size)] = _2941
                            require return_data.size >= _2900 + (32 * _2941) + 32
                            mem[_2854 + ceil32(return_data.size) + 32 len 32 * _2941] = mem[_2854 + _2900 + 32 len 32 * _2941]
                            require _2941 - 1 < _2941
                            if not mem[(32 * _2941 - 1) + _2854 + ceil32(return_data.size) + 32]:
                                return 0
                            if profitFactor * mem[(32 * _2941 - 1) + _2854 + ceil32(return_data.size) + 32] / mem[(32 * _2941 - 1) + _2854 + ceil32(return_data.size) + 32] != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[mem[64]] = profitFactor * mem[(32 * _2941 - 1) + _2854 + ceil32(return_data.size) + 32] < 0
                    else:
                        if maxReportDelay * (_1532 * _1629) - (t * _1629) / 10^18 / (_1532 * _1629) - (t * _1629) / 10^18 != maxReportDelay:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _1776 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1776] = 26
                        mem[_1776 + 32] = 'SafeMath: division by zero'
                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                            if not arg1:
                                return (0 < maxReportDelay * (_1532 * _1629) - (t * _1629) / 10^18 / 31556952)
                            if profitFactor * arg1 / arg1 != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            return (profitFactor * arg1 < maxReportDelay * (_1532 * _1629) - (t * _1629) / 10^18 / 31556952)
                        if wantToEthOracleAddress:
                            mem[mem[64] + 4] = arg1
                            require ext_code.size(wantToEthOracleAddress)
                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args arg1
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2034 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if not mem[_2034]:
                                return (0 < maxReportDelay * (_1532 * _1629) - (t * _1629) / 10^18 / 31556952)
                            if profitFactor * mem[_2034] / mem[_2034] != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[mem[64]] = profitFactor * mem[_2034] < maxReportDelay * (_1532 * _1629) - (t * _1629) / 10^18 / 31556952
                        else:
                            _1927 = mem[64]
                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                            mem[mem[64] + 96] = 2
                            mem[64] = mem[64] + 192
                            require 0 < mem[_1927 + 96]
                            mem[_1927 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                            require 1 < mem[_1927 + 96]
                            mem[_1927 + 160] = wantAddress
                            mem[_1927 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_1927 + 196] = arg1
                            mem[_1927 + 228] = 64
                            mem[_1927 + 260] = mem[_1927 + 96]
                            idx = 0
                            s = _1927 + 292
                            u = _1927 + 128
                            while idx < mem[_1927 + 96]:
                                mem[s] = mem[u + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                u = u + 32
                                continue 
                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _1927 + (32 * mem[_1927 + 96]) + -mem[64] + 288]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2853 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2899 = mem[_2853]
                            require mem[_2853] <= test266151307()
                            require _2853 + return_data.size > _2853 + mem[_2853] + 31
                            _2940 = mem[_2853 + mem[_2853]]
                            require mem[_2853 + mem[_2853]] <= test266151307()
                            require (32 * mem[_2853 + mem[_2853]]) + 32 >= 0 and _2853 + ceil32(return_data.size) + (32 * mem[_2853 + mem[_2853]]) + 32 <= test266151307()
                            mem[64] = _2853 + ceil32(return_data.size) + (32 * mem[_2853 + mem[_2853]]) + 32
                            mem[_2853 + ceil32(return_data.size)] = _2940
                            require return_data.size >= _2899 + (32 * _2940) + 32
                            mem[_2853 + ceil32(return_data.size) + 32 len 32 * _2940] = mem[_2853 + _2899 + 32 len 32 * _2940]
                            require _2940 - 1 < _2940
                            if not mem[(32 * _2940 - 1) + _2853 + ceil32(return_data.size) + 32]:
                                return (0 < maxReportDelay * (_1532 * _1629) - (t * _1629) / 10^18 / 31556952)
                            if profitFactor * mem[(32 * _2940 - 1) + _2853 + ceil32(return_data.size) + 32] / mem[(32 * _2940 - 1) + _2853 + ceil32(return_data.size) + 32] != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[mem[64]] = profitFactor * mem[(32 * _2940 - 1) + _2853 + ceil32(return_data.size) + 32] < maxReportDelay * (_1532 * _1629) - (t * _1629) / 10^18 / 31556952
        else:
            mem[ceil32(return_data.size) + 672] = 30
            mem[ceil32(return_data.size) + 704] = 'SafeMath: subtraction overflow'
            if ext_call.return_data[160] > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if block.timestamp - ext_call.return_data[160] < minReportDelay:
                mem[ceil32(return_data.size) + 740] = this.address
                require ext_code.size(wantAddress)
                staticcall wantAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + 736] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (2 * ceil32(return_data.size)) + 736
                require return_data.size >= 32
                idx = 0
                s = 0
                t = -1
                while idx < lenders.length:
                    mem[0] = 12
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].hasAssets() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _787 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_787] == bool(mem[_787])
                    if not mem[_787]:
                        idx = idx + 1
                        s = s
                        t = t
                        continue 
                    require idx < lenders.length
                    mem[0] = 12
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].apr() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _850 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _862 = mem[_850]
                    if mem[_850] >= t:
                        idx = idx + 1
                        s = s
                        t = t
                        continue 
                    require idx < lenders.length
                    mem[0] = 12
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].nav() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _896 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 1
                    s = mem[_896]
                    t = _862
                    continue 
                if ext_call.return_data[0] + s < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = 0
                u = 0
                while idx < lenders.length:
                    mem[0] = 12
                    mem[mem[64] + 4] = ext_call.return_data[0]
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                            gas gas_remaining wei
                           args ext_call.return_data[0]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1506 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_1506] <= u:
                        idx = idx + 1
                        u = u
                        continue 
                    idx = idx + 1
                    u = mem[_1506]
                    continue 
                require 0 < lenders.length
                mem[0] = 12
                mem[mem[64] + 4] = ext_call.return_data[0] + s
                require ext_code.size(lenders)
                staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                        gas gas_remaining wei
                       args (ext_call.return_data[0] + s)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1505 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1530 = mem[_1505]
                if mem[_1505] <= t:
                    return 0
                require 0 < lenders.length
                mem[0] = 12
                require ext_code.size(lenders)
                staticcall lenders.nav() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1622 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1628 = mem[_1622]
                if not mem[_1622]:
                    _1699 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1699] = 26
                    mem[_1699 + 32] = 'SafeMath: division by zero'
                    _1740 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1740] = 26
                    mem[_1740 + 32] = 'SafeMath: division by zero'
                    if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                        if not arg1:
                            return 0
                        if profitFactor * arg1 / arg1 != profitFactor:
                            revert with 0, 'SafeMath: multiplication overflow'
                        return (profitFactor * arg1 < 0)
                    if wantToEthOracleAddress:
                        mem[mem[64] + 4] = arg1
                        require ext_code.size(wantToEthOracleAddress)
                        staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                gas gas_remaining wei
                               args arg1
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1925 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if not mem[_1925]:
                            return 0
                        if profitFactor * mem[_1925] / mem[_1925] != profitFactor:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[mem[64]] = profitFactor * mem[_1925] < 0
                    else:
                        _1814 = mem[64]
                        mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                        mem[mem[64] + 96] = 2
                        mem[64] = mem[64] + 192
                        require 0 < mem[_1814 + 96]
                        mem[_1814 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                        require 1 < mem[_1814 + 96]
                        mem[_1814 + 160] = wantAddress
                        mem[_1814 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[_1814 + 196] = arg1
                        mem[_1814 + 228] = 64
                        mem[_1814 + 260] = mem[_1814 + 96]
                        idx = 0
                        s = _1814 + 292
                        t = _1814 + 128
                        while idx < mem[_1814 + 96]:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                        staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _1814 + (32 * mem[_1814 + 96]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2852 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2898 = mem[_2852]
                        require mem[_2852] <= test266151307()
                        require _2852 + return_data.size > _2852 + mem[_2852] + 31
                        _2939 = mem[_2852 + mem[_2852]]
                        require mem[_2852 + mem[_2852]] <= test266151307()
                        require (32 * mem[_2852 + mem[_2852]]) + 32 >= 0 and _2852 + ceil32(return_data.size) + (32 * mem[_2852 + mem[_2852]]) + 32 <= test266151307()
                        mem[64] = _2852 + ceil32(return_data.size) + (32 * mem[_2852 + mem[_2852]]) + 32
                        mem[_2852 + ceil32(return_data.size)] = _2939
                        require return_data.size >= _2898 + (32 * _2939) + 32
                        mem[_2852 + ceil32(return_data.size) + 32 len 32 * _2939] = mem[_2852 + _2898 + 32 len 32 * _2939]
                        require _2939 - 1 < _2939
                        if not mem[(32 * _2939 - 1) + _2852 + ceil32(return_data.size) + 32]:
                            return 0
                        if profitFactor * mem[(32 * _2939 - 1) + _2852 + ceil32(return_data.size) + 32] / mem[(32 * _2939 - 1) + _2852 + ceil32(return_data.size) + 32] != profitFactor:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[mem[64]] = profitFactor * mem[(32 * _2939 - 1) + _2852 + ceil32(return_data.size) + 32] < 0
                else:
                    if t * mem[_1622] / mem[_1622] != t:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not mem[_1622]:
                        _1706 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1706] = 26
                        mem[_1706 + 32] = 'SafeMath: division by zero'
                        if not -1 * t * _1628 / 10^18:
                            _1750 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1750] = 26
                            mem[_1750 + 32] = 'SafeMath: division by zero'
                            if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                if not arg1:
                                    return 0
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < 0)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1959 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_1959]:
                                    return 0
                                if profitFactor * mem[_1959] / mem[_1959] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_1959] < 0
                            else:
                                _1841 = mem[64]
                                mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                mem[mem[64] + 96] = 2
                                mem[64] = mem[64] + 192
                                require 0 < mem[_1841 + 96]
                                mem[_1841 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                require 1 < mem[_1841 + 96]
                                mem[_1841 + 160] = wantAddress
                                mem[_1841 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_1841 + 196] = arg1
                                mem[_1841 + 228] = 64
                                mem[_1841 + 260] = mem[_1841 + 96]
                                idx = 0
                                s = _1841 + 292
                                t = _1841 + 128
                                while idx < mem[_1841 + 96]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _1841 + (32 * mem[_1841 + 96]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2851 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _2897 = mem[_2851]
                                require mem[_2851] <= test266151307()
                                require _2851 + return_data.size > _2851 + mem[_2851] + 31
                                _2938 = mem[_2851 + mem[_2851]]
                                require mem[_2851 + mem[_2851]] <= test266151307()
                                require (32 * mem[_2851 + mem[_2851]]) + 32 >= 0 and _2851 + ceil32(return_data.size) + (32 * mem[_2851 + mem[_2851]]) + 32 <= test266151307()
                                mem[64] = _2851 + ceil32(return_data.size) + (32 * mem[_2851 + mem[_2851]]) + 32
                                mem[_2851 + ceil32(return_data.size)] = _2938
                                require return_data.size >= _2897 + (32 * _2938) + 32
                                mem[_2851 + ceil32(return_data.size) + 32 len 32 * _2938] = mem[_2851 + _2897 + 32 len 32 * _2938]
                                require _2938 - 1 < _2938
                                if not mem[(32 * _2938 - 1) + _2851 + ceil32(return_data.size) + 32]:
                                    return 0
                                if profitFactor * mem[(32 * _2938 - 1) + _2851 + ceil32(return_data.size) + 32] / mem[(32 * _2938 - 1) + _2851 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _2938 - 1) + _2851 + ceil32(return_data.size) + 32] < 0
                        else:
                            if maxReportDelay * -1 * t * _1628 / 10^18 / -1 * t * _1628 / 10^18 != maxReportDelay:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _1764 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1764] = 26
                            mem[_1764 + 32] = 'SafeMath: division by zero'
                            if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                if not arg1:
                                    return (0 < maxReportDelay * -1 * t * _1628 / 10^18 / 31556952)
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < maxReportDelay * -1 * t * _1628 / 10^18 / 31556952)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1993 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_1993]:
                                    return (0 < maxReportDelay * -1 * t * _1628 / 10^18 / 31556952)
                                if profitFactor * mem[_1993] / mem[_1993] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_1993] < maxReportDelay * -1 * t * _1628 / 10^18 / 31556952
                            else:
                                _1880 = mem[64]
                                mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                mem[mem[64] + 96] = 2
                                mem[64] = mem[64] + 192
                                require 0 < mem[_1880 + 96]
                                mem[_1880 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                require 1 < mem[_1880 + 96]
                                mem[_1880 + 160] = wantAddress
                                mem[_1880 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_1880 + 196] = arg1
                                mem[_1880 + 228] = 64
                                mem[_1880 + 260] = mem[_1880 + 96]
                                idx = 0
                                s = _1880 + 292
                                u = _1880 + 128
                                while idx < mem[_1880 + 96]:
                                    mem[s] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    u = u + 32
                                    continue 
                                require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _1880 + (32 * mem[_1880 + 96]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2850 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _2896 = mem[_2850]
                                require mem[_2850] <= test266151307()
                                require _2850 + return_data.size > _2850 + mem[_2850] + 31
                                _2937 = mem[_2850 + mem[_2850]]
                                require mem[_2850 + mem[_2850]] <= test266151307()
                                require (32 * mem[_2850 + mem[_2850]]) + 32 >= 0 and _2850 + ceil32(return_data.size) + (32 * mem[_2850 + mem[_2850]]) + 32 <= test266151307()
                                mem[64] = _2850 + ceil32(return_data.size) + (32 * mem[_2850 + mem[_2850]]) + 32
                                mem[_2850 + ceil32(return_data.size)] = _2937
                                require return_data.size >= _2896 + (32 * _2937) + 32
                                mem[_2850 + ceil32(return_data.size) + 32 len 32 * _2937] = mem[_2850 + _2896 + 32 len 32 * _2937]
                                require _2937 - 1 < _2937
                                if not mem[(32 * _2937 - 1) + _2850 + ceil32(return_data.size) + 32]:
                                    return (0 < maxReportDelay * -1 * t * _1628 / 10^18 / 31556952)
                                if profitFactor * mem[(32 * _2937 - 1) + _2850 + ceil32(return_data.size) + 32] / mem[(32 * _2937 - 1) + _2850 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _2937 - 1) + _2850 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _1628 / 10^18 / 31556952
                    else:
                        if _1530 * mem[_1622] / mem[_1622] != _1530:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _1713 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1713] = 26
                        mem[_1713 + 32] = 'SafeMath: division by zero'
                        if not (_1530 * _1628) - (t * _1628) / 10^18:
                            _1763 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1763] = 26
                            mem[_1763 + 32] = 'SafeMath: division by zero'
                            if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                if not arg1:
                                    return 0
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < 0)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1991 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_1991]:
                                    return 0
                                if profitFactor * mem[_1991] / mem[_1991] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_1991] < 0
                            else:
                                _1877 = mem[64]
                                mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                mem[mem[64] + 96] = 2
                                mem[64] = mem[64] + 192
                                require 0 < mem[_1877 + 96]
                                mem[_1877 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                require 1 < mem[_1877 + 96]
                                mem[_1877 + 160] = wantAddress
                                mem[_1877 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_1877 + 196] = arg1
                                mem[_1877 + 228] = 64
                                mem[_1877 + 260] = mem[_1877 + 96]
                                idx = 0
                                s = _1877 + 292
                                t = _1877 + 128
                                while idx < mem[_1877 + 96]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _1877 + (32 * mem[_1877 + 96]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2849 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _2895 = mem[_2849]
                                require mem[_2849] <= test266151307()
                                require _2849 + return_data.size > _2849 + mem[_2849] + 31
                                _2936 = mem[_2849 + mem[_2849]]
                                require mem[_2849 + mem[_2849]] <= test266151307()
                                require (32 * mem[_2849 + mem[_2849]]) + 32 >= 0 and _2849 + ceil32(return_data.size) + (32 * mem[_2849 + mem[_2849]]) + 32 <= test266151307()
                                mem[64] = _2849 + ceil32(return_data.size) + (32 * mem[_2849 + mem[_2849]]) + 32
                                mem[_2849 + ceil32(return_data.size)] = _2936
                                require return_data.size >= _2895 + (32 * _2936) + 32
                                mem[_2849 + ceil32(return_data.size) + 32 len 32 * _2936] = mem[_2849 + _2895 + 32 len 32 * _2936]
                                require _2936 - 1 < _2936
                                if not mem[(32 * _2936 - 1) + _2849 + ceil32(return_data.size) + 32]:
                                    return 0
                                if profitFactor * mem[(32 * _2936 - 1) + _2849 + ceil32(return_data.size) + 32] / mem[(32 * _2936 - 1) + _2849 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _2936 - 1) + _2849 + ceil32(return_data.size) + 32] < 0
                        else:
                            if maxReportDelay * (_1530 * _1628) - (t * _1628) / 10^18 / (_1530 * _1628) - (t * _1628) / 10^18 != maxReportDelay:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _1774 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1774] = 26
                            mem[_1774 + 32] = 'SafeMath: division by zero'
                            if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                if not arg1:
                                    return (0 < maxReportDelay * (_1530 * _1628) - (t * _1628) / 10^18 / 31556952)
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < maxReportDelay * (_1530 * _1628) - (t * _1628) / 10^18 / 31556952)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2025 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_2025]:
                                    return (0 < maxReportDelay * (_1530 * _1628) - (t * _1628) / 10^18 / 31556952)
                                if profitFactor * mem[_2025] / mem[_2025] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_2025] < maxReportDelay * (_1530 * _1628) - (t * _1628) / 10^18 / 31556952
                            else:
                                _1917 = mem[64]
                                mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                mem[mem[64] + 96] = 2
                                mem[64] = mem[64] + 192
                                require 0 < mem[_1917 + 96]
                                mem[_1917 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                require 1 < mem[_1917 + 96]
                                mem[_1917 + 160] = wantAddress
                                mem[_1917 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_1917 + 196] = arg1
                                mem[_1917 + 228] = 64
                                mem[_1917 + 260] = mem[_1917 + 96]
                                idx = 0
                                s = _1917 + 292
                                u = _1917 + 128
                                while idx < mem[_1917 + 96]:
                                    mem[s] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    u = u + 32
                                    continue 
                                require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _1917 + (32 * mem[_1917 + 96]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2848 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _2894 = mem[_2848]
                                require mem[_2848] <= test266151307()
                                require _2848 + return_data.size > _2848 + mem[_2848] + 31
                                _2935 = mem[_2848 + mem[_2848]]
                                require mem[_2848 + mem[_2848]] <= test266151307()
                                require (32 * mem[_2848 + mem[_2848]]) + 32 >= 0 and _2848 + ceil32(return_data.size) + (32 * mem[_2848 + mem[_2848]]) + 32 <= test266151307()
                                mem[64] = _2848 + ceil32(return_data.size) + (32 * mem[_2848 + mem[_2848]]) + 32
                                mem[_2848 + ceil32(return_data.size)] = _2935
                                require return_data.size >= _2894 + (32 * _2935) + 32
                                mem[_2848 + ceil32(return_data.size) + 32 len 32 * _2935] = mem[_2848 + _2894 + 32 len 32 * _2935]
                                require _2935 - 1 < _2935
                                if not mem[(32 * _2935 - 1) + _2848 + ceil32(return_data.size) + 32]:
                                    return (0 < maxReportDelay * (_1530 * _1628) - (t * _1628) / 10^18 / 31556952)
                                if profitFactor * mem[(32 * _2935 - 1) + _2848 + ceil32(return_data.size) + 32] / mem[(32 * _2935 - 1) + _2848 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _2935 - 1) + _2848 + ceil32(return_data.size) + 32] < maxReportDelay * (_1530 * _1628) - (t * _1628) / 10^18 / 31556952
            else:
                mem[ceil32(return_data.size) + 736] = 30
                mem[ceil32(return_data.size) + 768] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[160] > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if block.timestamp - ext_call.return_data[160] >= maxReportDelay:
                    return 0
                require ext_code.size(vaultAddress)
                staticcall vaultAddress.debtOutstanding() with:
                        gas gas_remaining wei
                mem[ceil32(return_data.size) + 800] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (2 * ceil32(return_data.size)) + 800
                require return_data.size >= 32
                if ext_call.return_data[0] > debtThreshold:
                    return 0
                idx = 0
                s = 0
                while idx < lenders.length:
                    mem[0] = 12
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].nav() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _786 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_786] + s < s:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = mem[_786] + s
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(wantAddress)
                staticcall wantAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _806 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _820 = mem[_806]
                if mem[_806] + (_807 * lenders.length) < _807 * lenders.length:
                    revert with 0, 'SafeMath: addition overflow'
                if debtThreshold < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if debtThreshold + mem[_806] + (_807 * lenders.length) < mem[ceil32(return_data.size) + 576]:
                    return 0
                if mem[_806] + (_807 * lenders.length) <= mem[ceil32(return_data.size) + 576]:
                    require ext_code.size(vaultAddress)
                    staticcall vaultAddress.creditAvailable() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _899 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_899] < mem[_899]:
                        revert with 0, 'SafeMath: addition overflow'
                    if not profitFactor:
                        if 0 < mem[_899]:
                            return 0
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _977 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _984 = mem[_977]
                        idx = 0
                        s = 0
                        t = -1
                        while idx < lenders.length:
                            mem[0] = 12
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].hasAssets() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1474 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1474] == bool(mem[_1474])
                            if not mem[_1474]:
                                idx = idx + 1
                                s = s
                                t = t
                                continue 
                            require idx < lenders.length
                            mem[0] = 12
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].apr() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1589 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _1618 = mem[_1589]
                            if mem[_1589] >= t:
                                idx = idx + 1
                                s = s
                                t = t
                                continue 
                            require idx < lenders.length
                            mem[0] = 12
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].nav() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1669 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            idx = idx + 1
                            s = mem[_1669]
                            t = _1618
                            continue 
                        if _984 + s < s:
                            revert with 0, 'SafeMath: addition overflow'
                        idx = 0
                        u = 0
                        while idx < lenders.length:
                            mem[0] = 12
                            mem[mem[64] + 4] = _984
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args _984
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2889 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_2889] <= u:
                                idx = idx + 1
                                u = u
                                continue 
                            idx = idx + 1
                            u = mem[_2889]
                            continue 
                        require 0 < lenders.length
                        mem[0] = 12
                        mem[mem[64] + 4] = _984 + s
                        require ext_code.size(lenders)
                        staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                                gas gas_remaining wei
                               args (_984 + s)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2888 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2929 = mem[_2888]
                        if mem[_2888] <= t:
                            return 0
                        require 0 < lenders.length
                        mem[0] = 12
                        require ext_code.size(lenders)
                        staticcall lenders.nav() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3029 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3040 = mem[_3029]
                        if not mem[_3029]:
                            _3187 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3187] = 26
                            mem[_3187 + 32] = 'SafeMath: division by zero'
                            _3351 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3351] = 26
                            mem[_3351 + 32] = 'SafeMath: division by zero'
                            if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                if not arg1:
                                    return 0
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < 0)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3679 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_3679]:
                                    return 0
                                if profitFactor * mem[_3679] / mem[_3679] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_3679] < 0
                            else:
                                _3466 = mem[64]
                                mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                mem[mem[64] + 96] = 2
                                mem[64] = mem[64] + 192
                                require 0 < mem[_3466 + 96]
                                mem[_3466 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                require 1 < mem[_3466 + 96]
                                mem[_3466 + 160] = wantAddress
                                mem[_3466 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3466 + 196] = arg1
                                mem[_3466 + 228] = 64
                                mem[_3466 + 260] = mem[_3466 + 96]
                                idx = 0
                                s = _3466 + 292
                                t = _3466 + 128
                                while idx < mem[_3466 + 96]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3466 + (32 * mem[_3466 + 96]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5262 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5316 = mem[_5262]
                                require mem[_5262] <= test266151307()
                                require _5262 + return_data.size > _5262 + mem[_5262] + 31
                                _5368 = mem[_5262 + mem[_5262]]
                                require mem[_5262 + mem[_5262]] <= test266151307()
                                require (32 * mem[_5262 + mem[_5262]]) + 32 >= 0 and _5262 + ceil32(return_data.size) + (32 * mem[_5262 + mem[_5262]]) + 32 <= test266151307()
                                mem[64] = _5262 + ceil32(return_data.size) + (32 * mem[_5262 + mem[_5262]]) + 32
                                mem[_5262 + ceil32(return_data.size)] = _5368
                                require return_data.size >= _5316 + (32 * _5368) + 32
                                mem[_5262 + ceil32(return_data.size) + 32 len 32 * _5368] = mem[_5262 + _5316 + 32 len 32 * _5368]
                                require _5368 - 1 < _5368
                                if not mem[(32 * _5368 - 1) + _5262 + ceil32(return_data.size) + 32]:
                                    return 0
                                if profitFactor * mem[(32 * _5368 - 1) + _5262 + ceil32(return_data.size) + 32] / mem[(32 * _5368 - 1) + _5262 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _5368 - 1) + _5262 + ceil32(return_data.size) + 32] < 0
                        else:
                            if t * mem[_3029] / mem[_3029] != t:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not mem[_3029]:
                                _3208 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3208] = 26
                                mem[_3208 + 32] = 'SafeMath: division by zero'
                                if not -1 * t * _3040 / 10^18:
                                    _3369 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3369] = 26
                                    mem[_3369 + 32] = 'SafeMath: division by zero'
                                    if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                        if not arg1:
                                            return 0
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < 0)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3743 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3743]:
                                            return 0
                                        if profitFactor * mem[_3743] / mem[_3743] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3743] < 0
                                    else:
                                        _3517 = mem[64]
                                        mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                        mem[mem[64] + 96] = 2
                                        mem[64] = mem[64] + 192
                                        require 0 < mem[_3517 + 96]
                                        mem[_3517 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                        require 1 < mem[_3517 + 96]
                                        mem[_3517 + 160] = wantAddress
                                        mem[_3517 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3517 + 196] = arg1
                                        mem[_3517 + 228] = 64
                                        mem[_3517 + 260] = mem[_3517 + 96]
                                        idx = 0
                                        s = _3517 + 292
                                        t = _3517 + 128
                                        while idx < mem[_3517 + 96]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                        staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3517 + (32 * mem[_3517 + 96]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5261 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5315 = mem[_5261]
                                        require mem[_5261] <= test266151307()
                                        require _5261 + return_data.size > _5261 + mem[_5261] + 31
                                        _5367 = mem[_5261 + mem[_5261]]
                                        require mem[_5261 + mem[_5261]] <= test266151307()
                                        require (32 * mem[_5261 + mem[_5261]]) + 32 >= 0 and _5261 + ceil32(return_data.size) + (32 * mem[_5261 + mem[_5261]]) + 32 <= test266151307()
                                        mem[64] = _5261 + ceil32(return_data.size) + (32 * mem[_5261 + mem[_5261]]) + 32
                                        mem[_5261 + ceil32(return_data.size)] = _5367
                                        require return_data.size >= _5315 + (32 * _5367) + 32
                                        mem[_5261 + ceil32(return_data.size) + 32 len 32 * _5367] = mem[_5261 + _5315 + 32 len 32 * _5367]
                                        require _5367 - 1 < _5367
                                        if not mem[(32 * _5367 - 1) + _5261 + ceil32(return_data.size) + 32]:
                                            return 0
                                        if profitFactor * mem[(32 * _5367 - 1) + _5261 + ceil32(return_data.size) + 32] / mem[(32 * _5367 - 1) + _5261 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5367 - 1) + _5261 + ceil32(return_data.size) + 32] < 0
                                else:
                                    if maxReportDelay * -1 * t * _3040 / 10^18 / -1 * t * _3040 / 10^18 != maxReportDelay:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3393 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3393] = 26
                                    mem[_3393 + 32] = 'SafeMath: division by zero'
                                    if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                        if not arg1:
                                            return (0 < maxReportDelay * -1 * t * _3040 / 10^18 / 31556952)
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < maxReportDelay * -1 * t * _3040 / 10^18 / 31556952)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3808 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3808]:
                                            return (0 < maxReportDelay * -1 * t * _3040 / 10^18 / 31556952)
                                        if profitFactor * mem[_3808] / mem[_3808] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3808] < maxReportDelay * -1 * t * _3040 / 10^18 / 31556952
                                    else:
                                        _3593 = mem[64]
                                        mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                        mem[mem[64] + 96] = 2
                                        mem[64] = mem[64] + 192
                                        require 0 < mem[_3593 + 96]
                                        mem[_3593 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                        require 1 < mem[_3593 + 96]
                                        mem[_3593 + 160] = wantAddress
                                        mem[_3593 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3593 + 196] = arg1
                                        mem[_3593 + 228] = 64
                                        mem[_3593 + 260] = mem[_3593 + 96]
                                        idx = 0
                                        s = _3593 + 292
                                        u = _3593 + 128
                                        while idx < mem[_3593 + 96]:
                                            mem[s] = mem[u + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            u = u + 32
                                            continue 
                                        require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                        staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3593 + (32 * mem[_3593 + 96]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5260 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5314 = mem[_5260]
                                        require mem[_5260] <= test266151307()
                                        require _5260 + return_data.size > _5260 + mem[_5260] + 31
                                        _5366 = mem[_5260 + mem[_5260]]
                                        require mem[_5260 + mem[_5260]] <= test266151307()
                                        require (32 * mem[_5260 + mem[_5260]]) + 32 >= 0 and _5260 + ceil32(return_data.size) + (32 * mem[_5260 + mem[_5260]]) + 32 <= test266151307()
                                        mem[64] = _5260 + ceil32(return_data.size) + (32 * mem[_5260 + mem[_5260]]) + 32
                                        mem[_5260 + ceil32(return_data.size)] = _5366
                                        require return_data.size >= _5314 + (32 * _5366) + 32
                                        mem[_5260 + ceil32(return_data.size) + 32 len 32 * _5366] = mem[_5260 + _5314 + 32 len 32 * _5366]
                                        require _5366 - 1 < _5366
                                        if not mem[(32 * _5366 - 1) + _5260 + ceil32(return_data.size) + 32]:
                                            return (0 < maxReportDelay * -1 * t * _3040 / 10^18 / 31556952)
                                        if profitFactor * mem[(32 * _5366 - 1) + _5260 + ceil32(return_data.size) + 32] / mem[(32 * _5366 - 1) + _5260 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5366 - 1) + _5260 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _3040 / 10^18 / 31556952
                            else:
                                if _2929 * mem[_3029] / mem[_3029] != _2929:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _3242 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3242] = 26
                                mem[_3242 + 32] = 'SafeMath: division by zero'
                                if not (_2929 * _3040) - (t * _3040) / 10^18:
                                    _3392 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3392] = 26
                                    mem[_3392 + 32] = 'SafeMath: division by zero'
                                    if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                        if not arg1:
                                            return 0
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < 0)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3806 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3806]:
                                            return 0
                                        if profitFactor * mem[_3806] / mem[_3806] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3806] < 0
                                    else:
                                        _3590 = mem[64]
                                        mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                        mem[mem[64] + 96] = 2
                                        mem[64] = mem[64] + 192
                                        require 0 < mem[_3590 + 96]
                                        mem[_3590 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                        require 1 < mem[_3590 + 96]
                                        mem[_3590 + 160] = wantAddress
                                        mem[_3590 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3590 + 196] = arg1
                                        mem[_3590 + 228] = 64
                                        mem[_3590 + 260] = mem[_3590 + 96]
                                        idx = 0
                                        s = _3590 + 292
                                        t = _3590 + 128
                                        while idx < mem[_3590 + 96]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                        staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3590 + (32 * mem[_3590 + 96]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5259 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5313 = mem[_5259]
                                        require mem[_5259] <= test266151307()
                                        require _5259 + return_data.size > _5259 + mem[_5259] + 31
                                        _5365 = mem[_5259 + mem[_5259]]
                                        require mem[_5259 + mem[_5259]] <= test266151307()
                                        require (32 * mem[_5259 + mem[_5259]]) + 32 >= 0 and _5259 + ceil32(return_data.size) + (32 * mem[_5259 + mem[_5259]]) + 32 <= test266151307()
                                        mem[64] = _5259 + ceil32(return_data.size) + (32 * mem[_5259 + mem[_5259]]) + 32
                                        mem[_5259 + ceil32(return_data.size)] = _5365
                                        require return_data.size >= _5313 + (32 * _5365) + 32
                                        mem[_5259 + ceil32(return_data.size) + 32 len 32 * _5365] = mem[_5259 + _5313 + 32 len 32 * _5365]
                                        require _5365 - 1 < _5365
                                        if not mem[(32 * _5365 - 1) + _5259 + ceil32(return_data.size) + 32]:
                                            return 0
                                        if profitFactor * mem[(32 * _5365 - 1) + _5259 + ceil32(return_data.size) + 32] / mem[(32 * _5365 - 1) + _5259 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5365 - 1) + _5259 + ceil32(return_data.size) + 32] < 0
                                else:
                                    if maxReportDelay * (_2929 * _3040) - (t * _3040) / 10^18 / (_2929 * _3040) - (t * _3040) / 10^18 != maxReportDelay:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3412 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3412] = 26
                                    mem[_3412 + 32] = 'SafeMath: division by zero'
                                    if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                        if not arg1:
                                            return (0 < maxReportDelay * (_2929 * _3040) - (t * _3040) / 10^18 / 31556952)
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < maxReportDelay * (_2929 * _3040) - (t * _3040) / 10^18 / 31556952)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3879 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3879]:
                                            return (0 < maxReportDelay * (_2929 * _3040) - (t * _3040) / 10^18 / 31556952)
                                        if profitFactor * mem[_3879] / mem[_3879] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3879] < maxReportDelay * (_2929 * _3040) - (t * _3040) / 10^18 / 31556952
                                    else:
                                        _3671 = mem[64]
                                        mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                        mem[mem[64] + 96] = 2
                                        mem[64] = mem[64] + 192
                                        require 0 < mem[_3671 + 96]
                                        mem[_3671 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                        require 1 < mem[_3671 + 96]
                                        mem[_3671 + 160] = wantAddress
                                        mem[_3671 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3671 + 196] = arg1
                                        mem[_3671 + 228] = 64
                                        mem[_3671 + 260] = mem[_3671 + 96]
                                        idx = 0
                                        s = _3671 + 292
                                        u = _3671 + 128
                                        while idx < mem[_3671 + 96]:
                                            mem[s] = mem[u + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            u = u + 32
                                            continue 
                                        require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                        staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3671 + (32 * mem[_3671 + 96]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5258 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5312 = mem[_5258]
                                        require mem[_5258] <= test266151307()
                                        require _5258 + return_data.size > _5258 + mem[_5258] + 31
                                        _5364 = mem[_5258 + mem[_5258]]
                                        require mem[_5258 + mem[_5258]] <= test266151307()
                                        require (32 * mem[_5258 + mem[_5258]]) + 32 >= 0 and _5258 + ceil32(return_data.size) + (32 * mem[_5258 + mem[_5258]]) + 32 <= test266151307()
                                        mem[64] = _5258 + ceil32(return_data.size) + (32 * mem[_5258 + mem[_5258]]) + 32
                                        mem[_5258 + ceil32(return_data.size)] = _5364
                                        require return_data.size >= _5312 + (32 * _5364) + 32
                                        mem[_5258 + ceil32(return_data.size) + 32 len 32 * _5364] = mem[_5258 + _5312 + 32 len 32 * _5364]
                                        require _5364 - 1 < _5364
                                        if not mem[(32 * _5364 - 1) + _5258 + ceil32(return_data.size) + 32]:
                                            return (0 < maxReportDelay * (_2929 * _3040) - (t * _3040) / 10^18 / 31556952)
                                        if profitFactor * mem[(32 * _5364 - 1) + _5258 + ceil32(return_data.size) + 32] / mem[(32 * _5364 - 1) + _5258 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5364 - 1) + _5258 + ceil32(return_data.size) + 32] < maxReportDelay * (_2929 * _3040) - (t * _3040) / 10^18 / 31556952
                    else:
                        if arg1 * profitFactor / profitFactor != arg1:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * profitFactor < mem[_899]:
                            return 0
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _981 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _991 = mem[_981]
                        idx = 0
                        s = 0
                        t = -1
                        while idx < lenders.length:
                            mem[0] = 12
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].hasAssets() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1473 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1473] == bool(mem[_1473])
                            if not mem[_1473]:
                                idx = idx + 1
                                s = s
                                t = t
                                continue 
                            require idx < lenders.length
                            mem[0] = 12
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].apr() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1588 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _1617 = mem[_1588]
                            if mem[_1588] >= t:
                                idx = idx + 1
                                s = s
                                t = t
                                continue 
                            require idx < lenders.length
                            mem[0] = 12
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].nav() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1668 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            idx = idx + 1
                            s = mem[_1668]
                            t = _1617
                            continue 
                        if _991 + s < s:
                            revert with 0, 'SafeMath: addition overflow'
                        idx = 0
                        u = 0
                        while idx < lenders.length:
                            mem[0] = 12
                            mem[mem[64] + 4] = _991
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args _991
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2887 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_2887] <= u:
                                idx = idx + 1
                                u = u
                                continue 
                            idx = idx + 1
                            u = mem[_2887]
                            continue 
                        require 0 < lenders.length
                        mem[0] = 12
                        mem[mem[64] + 4] = _991 + s
                        require ext_code.size(lenders)
                        staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                                gas gas_remaining wei
                               args (_991 + s)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2886 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2927 = mem[_2886]
                        if mem[_2886] <= t:
                            return 0
                        require 0 < lenders.length
                        mem[0] = 12
                        require ext_code.size(lenders)
                        staticcall lenders.nav() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3027 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3039 = mem[_3027]
                        if not mem[_3027]:
                            _3185 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3185] = 26
                            mem[_3185 + 32] = 'SafeMath: division by zero'
                            _3349 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3349] = 26
                            mem[_3349 + 32] = 'SafeMath: division by zero'
                            if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                if not arg1:
                                    return 0
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < 0)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3669 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_3669]:
                                    return 0
                                if profitFactor * mem[_3669] / mem[_3669] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_3669] < 0
                            else:
                                _3462 = mem[64]
                                mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                mem[mem[64] + 96] = 2
                                mem[64] = mem[64] + 192
                                require 0 < mem[_3462 + 96]
                                mem[_3462 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                require 1 < mem[_3462 + 96]
                                mem[_3462 + 160] = wantAddress
                                mem[_3462 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3462 + 196] = arg1
                                mem[_3462 + 228] = 64
                                mem[_3462 + 260] = mem[_3462 + 96]
                                idx = 0
                                s = _3462 + 292
                                t = _3462 + 128
                                while idx < mem[_3462 + 96]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3462 + (32 * mem[_3462 + 96]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5257 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5311 = mem[_5257]
                                require mem[_5257] <= test266151307()
                                require _5257 + return_data.size > _5257 + mem[_5257] + 31
                                _5363 = mem[_5257 + mem[_5257]]
                                require mem[_5257 + mem[_5257]] <= test266151307()
                                require (32 * mem[_5257 + mem[_5257]]) + 32 >= 0 and _5257 + ceil32(return_data.size) + (32 * mem[_5257 + mem[_5257]]) + 32 <= test266151307()
                                mem[64] = _5257 + ceil32(return_data.size) + (32 * mem[_5257 + mem[_5257]]) + 32
                                mem[_5257 + ceil32(return_data.size)] = _5363
                                require return_data.size >= _5311 + (32 * _5363) + 32
                                mem[_5257 + ceil32(return_data.size) + 32 len 32 * _5363] = mem[_5257 + _5311 + 32 len 32 * _5363]
                                require _5363 - 1 < _5363
                                if not mem[(32 * _5363 - 1) + _5257 + ceil32(return_data.size) + 32]:
                                    return 0
                                if profitFactor * mem[(32 * _5363 - 1) + _5257 + ceil32(return_data.size) + 32] / mem[(32 * _5363 - 1) + _5257 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _5363 - 1) + _5257 + ceil32(return_data.size) + 32] < 0
                        else:
                            if t * mem[_3027] / mem[_3027] != t:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not mem[_3027]:
                                _3207 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3207] = 26
                                mem[_3207 + 32] = 'SafeMath: division by zero'
                                if not -1 * t * _3039 / 10^18:
                                    _3367 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3367] = 26
                                    mem[_3367 + 32] = 'SafeMath: division by zero'
                                    if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                        if not arg1:
                                            return 0
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < 0)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3736 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3736]:
                                            return 0
                                        if profitFactor * mem[_3736] / mem[_3736] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3736] < 0
                                    else:
                                        _3510 = mem[64]
                                        mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                        mem[mem[64] + 96] = 2
                                        mem[64] = mem[64] + 192
                                        require 0 < mem[_3510 + 96]
                                        mem[_3510 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                        require 1 < mem[_3510 + 96]
                                        mem[_3510 + 160] = wantAddress
                                        mem[_3510 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3510 + 196] = arg1
                                        mem[_3510 + 228] = 64
                                        mem[_3510 + 260] = mem[_3510 + 96]
                                        idx = 0
                                        s = _3510 + 292
                                        t = _3510 + 128
                                        while idx < mem[_3510 + 96]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                        staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3510 + (32 * mem[_3510 + 96]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5256 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5310 = mem[_5256]
                                        require mem[_5256] <= test266151307()
                                        require _5256 + return_data.size > _5256 + mem[_5256] + 31
                                        _5362 = mem[_5256 + mem[_5256]]
                                        require mem[_5256 + mem[_5256]] <= test266151307()
                                        require (32 * mem[_5256 + mem[_5256]]) + 32 >= 0 and _5256 + ceil32(return_data.size) + (32 * mem[_5256 + mem[_5256]]) + 32 <= test266151307()
                                        mem[64] = _5256 + ceil32(return_data.size) + (32 * mem[_5256 + mem[_5256]]) + 32
                                        mem[_5256 + ceil32(return_data.size)] = _5362
                                        require return_data.size >= _5310 + (32 * _5362) + 32
                                        mem[_5256 + ceil32(return_data.size) + 32 len 32 * _5362] = mem[_5256 + _5310 + 32 len 32 * _5362]
                                        require _5362 - 1 < _5362
                                        if not mem[(32 * _5362 - 1) + _5256 + ceil32(return_data.size) + 32]:
                                            return 0
                                        if profitFactor * mem[(32 * _5362 - 1) + _5256 + ceil32(return_data.size) + 32] / mem[(32 * _5362 - 1) + _5256 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5362 - 1) + _5256 + ceil32(return_data.size) + 32] < 0
                                else:
                                    if maxReportDelay * -1 * t * _3039 / 10^18 / -1 * t * _3039 / 10^18 != maxReportDelay:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3390 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3390] = 26
                                    mem[_3390 + 32] = 'SafeMath: division by zero'
                                    if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                        if not arg1:
                                            return (0 < maxReportDelay * -1 * t * _3039 / 10^18 / 31556952)
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < maxReportDelay * -1 * t * _3039 / 10^18 / 31556952)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3800 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3800]:
                                            return (0 < maxReportDelay * -1 * t * _3039 / 10^18 / 31556952)
                                        if profitFactor * mem[_3800] / mem[_3800] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3800] < maxReportDelay * -1 * t * _3039 / 10^18 / 31556952
                                    else:
                                        _3583 = mem[64]
                                        mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                        mem[mem[64] + 96] = 2
                                        mem[64] = mem[64] + 192
                                        require 0 < mem[_3583 + 96]
                                        mem[_3583 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                        require 1 < mem[_3583 + 96]
                                        mem[_3583 + 160] = wantAddress
                                        mem[_3583 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3583 + 196] = arg1
                                        mem[_3583 + 228] = 64
                                        mem[_3583 + 260] = mem[_3583 + 96]
                                        idx = 0
                                        s = _3583 + 292
                                        u = _3583 + 128
                                        while idx < mem[_3583 + 96]:
                                            mem[s] = mem[u + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            u = u + 32
                                            continue 
                                        require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                        staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3583 + (32 * mem[_3583 + 96]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5255 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5309 = mem[_5255]
                                        require mem[_5255] <= test266151307()
                                        require _5255 + return_data.size > _5255 + mem[_5255] + 31
                                        _5361 = mem[_5255 + mem[_5255]]
                                        require mem[_5255 + mem[_5255]] <= test266151307()
                                        require (32 * mem[_5255 + mem[_5255]]) + 32 >= 0 and _5255 + ceil32(return_data.size) + (32 * mem[_5255 + mem[_5255]]) + 32 <= test266151307()
                                        mem[64] = _5255 + ceil32(return_data.size) + (32 * mem[_5255 + mem[_5255]]) + 32
                                        mem[_5255 + ceil32(return_data.size)] = _5361
                                        require return_data.size >= _5309 + (32 * _5361) + 32
                                        mem[_5255 + ceil32(return_data.size) + 32 len 32 * _5361] = mem[_5255 + _5309 + 32 len 32 * _5361]
                                        require _5361 - 1 < _5361
                                        if not mem[(32 * _5361 - 1) + _5255 + ceil32(return_data.size) + 32]:
                                            return (0 < maxReportDelay * -1 * t * _3039 / 10^18 / 31556952)
                                        if profitFactor * mem[(32 * _5361 - 1) + _5255 + ceil32(return_data.size) + 32] / mem[(32 * _5361 - 1) + _5255 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5361 - 1) + _5255 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _3039 / 10^18 / 31556952
                            else:
                                if _2927 * mem[_3027] / mem[_3027] != _2927:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _3240 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3240] = 26
                                mem[_3240 + 32] = 'SafeMath: division by zero'
                                if not (_2927 * _3039) - (t * _3039) / 10^18:
                                    _3389 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3389] = 26
                                    mem[_3389 + 32] = 'SafeMath: division by zero'
                                    if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                        if not arg1:
                                            return 0
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < 0)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3798 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3798]:
                                            return 0
                                        if profitFactor * mem[_3798] / mem[_3798] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3798] < 0
                                    else:
                                        _3580 = mem[64]
                                        mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                        mem[mem[64] + 96] = 2
                                        mem[64] = mem[64] + 192
                                        require 0 < mem[_3580 + 96]
                                        mem[_3580 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                        require 1 < mem[_3580 + 96]
                                        mem[_3580 + 160] = wantAddress
                                        mem[_3580 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3580 + 196] = arg1
                                        mem[_3580 + 228] = 64
                                        mem[_3580 + 260] = mem[_3580 + 96]
                                        idx = 0
                                        s = _3580 + 292
                                        t = _3580 + 128
                                        while idx < mem[_3580 + 96]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                        staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3580 + (32 * mem[_3580 + 96]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5254 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5308 = mem[_5254]
                                        require mem[_5254] <= test266151307()
                                        require _5254 + return_data.size > _5254 + mem[_5254] + 31
                                        _5360 = mem[_5254 + mem[_5254]]
                                        require mem[_5254 + mem[_5254]] <= test266151307()
                                        require (32 * mem[_5254 + mem[_5254]]) + 32 >= 0 and _5254 + ceil32(return_data.size) + (32 * mem[_5254 + mem[_5254]]) + 32 <= test266151307()
                                        mem[64] = _5254 + ceil32(return_data.size) + (32 * mem[_5254 + mem[_5254]]) + 32
                                        mem[_5254 + ceil32(return_data.size)] = _5360
                                        require return_data.size >= _5308 + (32 * _5360) + 32
                                        mem[_5254 + ceil32(return_data.size) + 32 len 32 * _5360] = mem[_5254 + _5308 + 32 len 32 * _5360]
                                        require _5360 - 1 < _5360
                                        if not mem[(32 * _5360 - 1) + _5254 + ceil32(return_data.size) + 32]:
                                            return 0
                                        if profitFactor * mem[(32 * _5360 - 1) + _5254 + ceil32(return_data.size) + 32] / mem[(32 * _5360 - 1) + _5254 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5360 - 1) + _5254 + ceil32(return_data.size) + 32] < 0
                                else:
                                    if maxReportDelay * (_2927 * _3039) - (t * _3039) / 10^18 / (_2927 * _3039) - (t * _3039) / 10^18 != maxReportDelay:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3410 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3410] = 26
                                    mem[_3410 + 32] = 'SafeMath: division by zero'
                                    if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                        if not arg1:
                                            return (0 < maxReportDelay * (_2927 * _3039) - (t * _3039) / 10^18 / 31556952)
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < maxReportDelay * (_2927 * _3039) - (t * _3039) / 10^18 / 31556952)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3870 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3870]:
                                            return (0 < maxReportDelay * (_2927 * _3039) - (t * _3039) / 10^18 / 31556952)
                                        if profitFactor * mem[_3870] / mem[_3870] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3870] < maxReportDelay * (_2927 * _3039) - (t * _3039) / 10^18 / 31556952
                                    else:
                                        _3661 = mem[64]
                                        mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                        mem[mem[64] + 96] = 2
                                        mem[64] = mem[64] + 192
                                        require 0 < mem[_3661 + 96]
                                        mem[_3661 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                        require 1 < mem[_3661 + 96]
                                        mem[_3661 + 160] = wantAddress
                                        mem[_3661 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3661 + 196] = arg1
                                        mem[_3661 + 228] = 64
                                        mem[_3661 + 260] = mem[_3661 + 96]
                                        idx = 0
                                        s = _3661 + 292
                                        u = _3661 + 128
                                        while idx < mem[_3661 + 96]:
                                            mem[s] = mem[u + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            u = u + 32
                                            continue 
                                        require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                        staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3661 + (32 * mem[_3661 + 96]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5253 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5307 = mem[_5253]
                                        require mem[_5253] <= test266151307()
                                        require _5253 + return_data.size > _5253 + mem[_5253] + 31
                                        _5359 = mem[_5253 + mem[_5253]]
                                        require mem[_5253 + mem[_5253]] <= test266151307()
                                        require (32 * mem[_5253 + mem[_5253]]) + 32 >= 0 and _5253 + ceil32(return_data.size) + (32 * mem[_5253 + mem[_5253]]) + 32 <= test266151307()
                                        mem[64] = _5253 + ceil32(return_data.size) + (32 * mem[_5253 + mem[_5253]]) + 32
                                        mem[_5253 + ceil32(return_data.size)] = _5359
                                        require return_data.size >= _5307 + (32 * _5359) + 32
                                        mem[_5253 + ceil32(return_data.size) + 32 len 32 * _5359] = mem[_5253 + _5307 + 32 len 32 * _5359]
                                        require _5359 - 1 < _5359
                                        if not mem[(32 * _5359 - 1) + _5253 + ceil32(return_data.size) + 32]:
                                            return (0 < maxReportDelay * (_2927 * _3039) - (t * _3039) / 10^18 / 31556952)
                                        if profitFactor * mem[(32 * _5359 - 1) + _5253 + ceil32(return_data.size) + 32] / mem[(32 * _5359 - 1) + _5253 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5359 - 1) + _5253 + ceil32(return_data.size) + 32] < maxReportDelay * (_2927 * _3039) - (t * _3039) / 10^18 / 31556952
                else:
                    _890 = mem[ceil32(return_data.size) + 576]
                    _895 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_895] = 30
                    mem[_895 + 32] = 'SafeMath: subtraction overflow'
                    if _890 > _820 + (_807 * lenders.length):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    require ext_code.size(vaultAddress)
                    staticcall vaultAddress.creditAvailable() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _924 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if _820 + (_807 * lenders.length) - _890 + mem[_924] < mem[_924]:
                        revert with 0, 'SafeMath: addition overflow'
                    if not profitFactor:
                        if 0 < _820 + (_807 * lenders.length) - _890 + mem[_924]:
                            return 0
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1015 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1033 = mem[_1015]
                        idx = 0
                        s = 0
                        t = -1
                        while idx < lenders.length:
                            mem[0] = 12
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].hasAssets() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1476 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1476] == bool(mem[_1476])
                            if not mem[_1476]:
                                idx = idx + 1
                                s = s
                                t = t
                                continue 
                            require idx < lenders.length
                            mem[0] = 12
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].apr() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1591 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _1620 = mem[_1591]
                            if mem[_1591] >= t:
                                idx = idx + 1
                                s = s
                                t = t
                                continue 
                            require idx < lenders.length
                            mem[0] = 12
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].nav() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1671 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            idx = idx + 1
                            s = mem[_1671]
                            t = _1620
                            continue 
                        if _1033 + s < s:
                            revert with 0, 'SafeMath: addition overflow'
                        idx = 0
                        u = 0
                        while idx < lenders.length:
                            mem[0] = 12
                            mem[mem[64] + 4] = _1033
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args _1033
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2893 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_2893] <= u:
                                idx = idx + 1
                                u = u
                                continue 
                            idx = idx + 1
                            u = mem[_2893]
                            continue 
                        require 0 < lenders.length
                        mem[0] = 12
                        mem[mem[64] + 4] = _1033 + s
                        require ext_code.size(lenders)
                        staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                                gas gas_remaining wei
                               args (_1033 + s)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2892 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2933 = mem[_2892]
                        if mem[_2892] <= t:
                            return 0
                        require 0 < lenders.length
                        mem[0] = 12
                        require ext_code.size(lenders)
                        staticcall lenders.nav() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3033 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3042 = mem[_3033]
                        if not mem[_3033]:
                            _3191 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3191] = 26
                            mem[_3191 + 32] = 'SafeMath: division by zero'
                            _3355 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3355] = 26
                            mem[_3355 + 32] = 'SafeMath: division by zero'
                            if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                if not arg1:
                                    return 0
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < 0)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3699 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_3699]:
                                    return 0
                                if profitFactor * mem[_3699] / mem[_3699] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_3699] < 0
                            else:
                                _3474 = mem[64]
                                mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                mem[mem[64] + 96] = 2
                                mem[64] = mem[64] + 192
                                require 0 < mem[_3474 + 96]
                                mem[_3474 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                require 1 < mem[_3474 + 96]
                                mem[_3474 + 160] = wantAddress
                                mem[_3474 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3474 + 196] = arg1
                                mem[_3474 + 228] = 64
                                mem[_3474 + 260] = mem[_3474 + 96]
                                idx = 0
                                s = _3474 + 292
                                t = _3474 + 128
                                while idx < mem[_3474 + 96]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3474 + (32 * mem[_3474 + 96]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5272 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5326 = mem[_5272]
                                require mem[_5272] <= test266151307()
                                require _5272 + return_data.size > _5272 + mem[_5272] + 31
                                _5378 = mem[_5272 + mem[_5272]]
                                require mem[_5272 + mem[_5272]] <= test266151307()
                                require (32 * mem[_5272 + mem[_5272]]) + 32 >= 0 and _5272 + ceil32(return_data.size) + (32 * mem[_5272 + mem[_5272]]) + 32 <= test266151307()
                                mem[64] = _5272 + ceil32(return_data.size) + (32 * mem[_5272 + mem[_5272]]) + 32
                                mem[_5272 + ceil32(return_data.size)] = _5378
                                require return_data.size >= _5326 + (32 * _5378) + 32
                                mem[_5272 + ceil32(return_data.size) + 32 len 32 * _5378] = mem[_5272 + _5326 + 32 len 32 * _5378]
                                require _5378 - 1 < _5378
                                if not mem[(32 * _5378 - 1) + _5272 + ceil32(return_data.size) + 32]:
                                    return 0
                                if profitFactor * mem[(32 * _5378 - 1) + _5272 + ceil32(return_data.size) + 32] / mem[(32 * _5378 - 1) + _5272 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _5378 - 1) + _5272 + ceil32(return_data.size) + 32] < 0
                        else:
                            if t * mem[_3033] / mem[_3033] != t:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not mem[_3033]:
                                _3210 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3210] = 26
                                mem[_3210 + 32] = 'SafeMath: division by zero'
                                if not -1 * t * _3042 / 10^18:
                                    _3373 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3373] = 26
                                    mem[_3373 + 32] = 'SafeMath: division by zero'
                                    if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                        if not arg1:
                                            return 0
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < 0)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3757 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3757]:
                                            return 0
                                        if profitFactor * mem[_3757] / mem[_3757] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3757] < 0
                                    else:
                                        _3531 = mem[64]
                                        mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                        mem[mem[64] + 96] = 2
                                        mem[64] = mem[64] + 192
                                        require 0 < mem[_3531 + 96]
                                        mem[_3531 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                        require 1 < mem[_3531 + 96]
                                        mem[_3531 + 160] = wantAddress
                                        mem[_3531 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3531 + 196] = arg1
                                        mem[_3531 + 228] = 64
                                        mem[_3531 + 260] = mem[_3531 + 96]
                                        idx = 0
                                        s = _3531 + 292
                                        t = _3531 + 128
                                        while idx < mem[_3531 + 96]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                        staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3531 + (32 * mem[_3531 + 96]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5271 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5325 = mem[_5271]
                                        require mem[_5271] <= test266151307()
                                        require _5271 + return_data.size > _5271 + mem[_5271] + 31
                                        _5377 = mem[_5271 + mem[_5271]]
                                        require mem[_5271 + mem[_5271]] <= test266151307()
                                        require (32 * mem[_5271 + mem[_5271]]) + 32 >= 0 and _5271 + ceil32(return_data.size) + (32 * mem[_5271 + mem[_5271]]) + 32 <= test266151307()
                                        mem[64] = _5271 + ceil32(return_data.size) + (32 * mem[_5271 + mem[_5271]]) + 32
                                        mem[_5271 + ceil32(return_data.size)] = _5377
                                        require return_data.size >= _5325 + (32 * _5377) + 32
                                        mem[_5271 + ceil32(return_data.size) + 32 len 32 * _5377] = mem[_5271 + _5325 + 32 len 32 * _5377]
                                        require _5377 - 1 < _5377
                                        if not mem[(32 * _5377 - 1) + _5271 + ceil32(return_data.size) + 32]:
                                            return 0
                                        if profitFactor * mem[(32 * _5377 - 1) + _5271 + ceil32(return_data.size) + 32] / mem[(32 * _5377 - 1) + _5271 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5377 - 1) + _5271 + ceil32(return_data.size) + 32] < 0
                                else:
                                    if maxReportDelay * -1 * t * _3042 / 10^18 / -1 * t * _3042 / 10^18 != maxReportDelay:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3399 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3399] = 26
                                    mem[_3399 + 32] = 'SafeMath: division by zero'
                                    if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                        if not arg1:
                                            return (0 < maxReportDelay * -1 * t * _3042 / 10^18 / 31556952)
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < maxReportDelay * -1 * t * _3042 / 10^18 / 31556952)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3824 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3824]:
                                            return (0 < maxReportDelay * -1 * t * _3042 / 10^18 / 31556952)
                                        if profitFactor * mem[_3824] / mem[_3824] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3824] < maxReportDelay * -1 * t * _3042 / 10^18 / 31556952
                                    else:
                                        _3613 = mem[64]
                                        mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                        mem[mem[64] + 96] = 2
                                        mem[64] = mem[64] + 192
                                        require 0 < mem[_3613 + 96]
                                        mem[_3613 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                        require 1 < mem[_3613 + 96]
                                        mem[_3613 + 160] = wantAddress
                                        mem[_3613 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3613 + 196] = arg1
                                        mem[_3613 + 228] = 64
                                        mem[_3613 + 260] = mem[_3613 + 96]
                                        idx = 0
                                        s = _3613 + 292
                                        u = _3613 + 128
                                        while idx < mem[_3613 + 96]:
                                            mem[s] = mem[u + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            u = u + 32
                                            continue 
                                        require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                        staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3613 + (32 * mem[_3613 + 96]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5270 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5324 = mem[_5270]
                                        require mem[_5270] <= test266151307()
                                        require _5270 + return_data.size > _5270 + mem[_5270] + 31
                                        _5376 = mem[_5270 + mem[_5270]]
                                        require mem[_5270 + mem[_5270]] <= test266151307()
                                        require (32 * mem[_5270 + mem[_5270]]) + 32 >= 0 and _5270 + ceil32(return_data.size) + (32 * mem[_5270 + mem[_5270]]) + 32 <= test266151307()
                                        mem[64] = _5270 + ceil32(return_data.size) + (32 * mem[_5270 + mem[_5270]]) + 32
                                        mem[_5270 + ceil32(return_data.size)] = _5376
                                        require return_data.size >= _5324 + (32 * _5376) + 32
                                        mem[_5270 + ceil32(return_data.size) + 32 len 32 * _5376] = mem[_5270 + _5324 + 32 len 32 * _5376]
                                        require _5376 - 1 < _5376
                                        if not mem[(32 * _5376 - 1) + _5270 + ceil32(return_data.size) + 32]:
                                            return (0 < maxReportDelay * -1 * t * _3042 / 10^18 / 31556952)
                                        if profitFactor * mem[(32 * _5376 - 1) + _5270 + ceil32(return_data.size) + 32] / mem[(32 * _5376 - 1) + _5270 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5376 - 1) + _5270 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _3042 / 10^18 / 31556952
                            else:
                                if _2933 * mem[_3033] / mem[_3033] != _2933:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _3246 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3246] = 26
                                mem[_3246 + 32] = 'SafeMath: division by zero'
                                if not (_2933 * _3042) - (t * _3042) / 10^18:
                                    _3398 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3398] = 26
                                    mem[_3398 + 32] = 'SafeMath: division by zero'
                                    if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                        if not arg1:
                                            return 0
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < 0)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3822 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3822]:
                                            return 0
                                        if profitFactor * mem[_3822] / mem[_3822] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3822] < 0
                                    else:
                                        _3610 = mem[64]
                                        mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                        mem[mem[64] + 96] = 2
                                        mem[64] = mem[64] + 192
                                        require 0 < mem[_3610 + 96]
                                        mem[_3610 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                        require 1 < mem[_3610 + 96]
                                        mem[_3610 + 160] = wantAddress
                                        mem[_3610 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3610 + 196] = arg1
                                        mem[_3610 + 228] = 64
                                        mem[_3610 + 260] = mem[_3610 + 96]
                                        idx = 0
                                        s = _3610 + 292
                                        t = _3610 + 128
                                        while idx < mem[_3610 + 96]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                        staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3610 + (32 * mem[_3610 + 96]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5269 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5323 = mem[_5269]
                                        require mem[_5269] <= test266151307()
                                        require _5269 + return_data.size > _5269 + mem[_5269] + 31
                                        _5375 = mem[_5269 + mem[_5269]]
                                        require mem[_5269 + mem[_5269]] <= test266151307()
                                        require (32 * mem[_5269 + mem[_5269]]) + 32 >= 0 and _5269 + ceil32(return_data.size) + (32 * mem[_5269 + mem[_5269]]) + 32 <= test266151307()
                                        mem[64] = _5269 + ceil32(return_data.size) + (32 * mem[_5269 + mem[_5269]]) + 32
                                        mem[_5269 + ceil32(return_data.size)] = _5375
                                        require return_data.size >= _5323 + (32 * _5375) + 32
                                        mem[_5269 + ceil32(return_data.size) + 32 len 32 * _5375] = mem[_5269 + _5323 + 32 len 32 * _5375]
                                        require _5375 - 1 < _5375
                                        if not mem[(32 * _5375 - 1) + _5269 + ceil32(return_data.size) + 32]:
                                            return 0
                                        if profitFactor * mem[(32 * _5375 - 1) + _5269 + ceil32(return_data.size) + 32] / mem[(32 * _5375 - 1) + _5269 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5375 - 1) + _5269 + ceil32(return_data.size) + 32] < 0
                                else:
                                    if maxReportDelay * (_2933 * _3042) - (t * _3042) / 10^18 / (_2933 * _3042) - (t * _3042) / 10^18 != maxReportDelay:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3416 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3416] = 26
                                    mem[_3416 + 32] = 'SafeMath: division by zero'
                                    if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                        if not arg1:
                                            return (0 < maxReportDelay * (_2933 * _3042) - (t * _3042) / 10^18 / 31556952)
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < maxReportDelay * (_2933 * _3042) - (t * _3042) / 10^18 / 31556952)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3897 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3897]:
                                            return (0 < maxReportDelay * (_2933 * _3042) - (t * _3042) / 10^18 / 31556952)
                                        if profitFactor * mem[_3897] / mem[_3897] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3897] < maxReportDelay * (_2933 * _3042) - (t * _3042) / 10^18 / 31556952
                                    else:
                                        _3691 = mem[64]
                                        mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                        mem[mem[64] + 96] = 2
                                        mem[64] = mem[64] + 192
                                        require 0 < mem[_3691 + 96]
                                        mem[_3691 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                        require 1 < mem[_3691 + 96]
                                        mem[_3691 + 160] = wantAddress
                                        mem[_3691 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3691 + 196] = arg1
                                        mem[_3691 + 228] = 64
                                        mem[_3691 + 260] = mem[_3691 + 96]
                                        idx = 0
                                        s = _3691 + 292
                                        u = _3691 + 128
                                        while idx < mem[_3691 + 96]:
                                            mem[s] = mem[u + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            u = u + 32
                                            continue 
                                        require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                        staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3691 + (32 * mem[_3691 + 96]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5268 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5322 = mem[_5268]
                                        require mem[_5268] <= test266151307()
                                        require _5268 + return_data.size > _5268 + mem[_5268] + 31
                                        _5374 = mem[_5268 + mem[_5268]]
                                        require mem[_5268 + mem[_5268]] <= test266151307()
                                        require (32 * mem[_5268 + mem[_5268]]) + 32 >= 0 and _5268 + ceil32(return_data.size) + (32 * mem[_5268 + mem[_5268]]) + 32 <= test266151307()
                                        mem[64] = _5268 + ceil32(return_data.size) + (32 * mem[_5268 + mem[_5268]]) + 32
                                        mem[_5268 + ceil32(return_data.size)] = _5374
                                        require return_data.size >= _5322 + (32 * _5374) + 32
                                        mem[_5268 + ceil32(return_data.size) + 32 len 32 * _5374] = mem[_5268 + _5322 + 32 len 32 * _5374]
                                        require _5374 - 1 < _5374
                                        if not mem[(32 * _5374 - 1) + _5268 + ceil32(return_data.size) + 32]:
                                            return (0 < maxReportDelay * (_2933 * _3042) - (t * _3042) / 10^18 / 31556952)
                                        if profitFactor * mem[(32 * _5374 - 1) + _5268 + ceil32(return_data.size) + 32] / mem[(32 * _5374 - 1) + _5268 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5374 - 1) + _5268 + ceil32(return_data.size) + 32] < maxReportDelay * (_2933 * _3042) - (t * _3042) / 10^18 / 31556952
                    else:
                        if arg1 * profitFactor / profitFactor != arg1:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * profitFactor < _820 + (_807 * lenders.length) - _890 + mem[_924]:
                            return 0
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(wantAddress)
                        staticcall wantAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1027 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1042 = mem[_1027]
                        idx = 0
                        s = 0
                        t = -1
                        while idx < lenders.length:
                            mem[0] = 12
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].hasAssets() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1475 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1475] == bool(mem[_1475])
                            if not mem[_1475]:
                                idx = idx + 1
                                s = s
                                t = t
                                continue 
                            require idx < lenders.length
                            mem[0] = 12
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].apr() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1590 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _1619 = mem[_1590]
                            if mem[_1590] >= t:
                                idx = idx + 1
                                s = s
                                t = t
                                continue 
                            require idx < lenders.length
                            mem[0] = 12
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].nav() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1670 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            idx = idx + 1
                            s = mem[_1670]
                            t = _1619
                            continue 
                        if _1042 + s < s:
                            revert with 0, 'SafeMath: addition overflow'
                        idx = 0
                        u = 0
                        while idx < lenders.length:
                            mem[0] = 12
                            mem[mem[64] + 4] = _1042
                            require ext_code.size(lenders[idx])
                            staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args _1042
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2891 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_2891] <= u:
                                idx = idx + 1
                                u = u
                                continue 
                            idx = idx + 1
                            u = mem[_2891]
                            continue 
                        require 0 < lenders.length
                        mem[0] = 12
                        mem[mem[64] + 4] = _1042 + s
                        require ext_code.size(lenders)
                        staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                                gas gas_remaining wei
                               args (_1042 + s)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2890 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2931 = mem[_2890]
                        if mem[_2890] <= t:
                            return 0
                        require 0 < lenders.length
                        mem[0] = 12
                        require ext_code.size(lenders)
                        staticcall lenders.nav() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3031 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3041 = mem[_3031]
                        if not mem[_3031]:
                            _3189 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3189] = 26
                            mem[_3189 + 32] = 'SafeMath: division by zero'
                            _3353 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3353] = 26
                            mem[_3353 + 32] = 'SafeMath: division by zero'
                            if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                if not arg1:
                                    return 0
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < 0)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _3689 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_3689]:
                                    return 0
                                if profitFactor * mem[_3689] / mem[_3689] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_3689] < 0
                            else:
                                _3470 = mem[64]
                                mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                mem[mem[64] + 96] = 2
                                mem[64] = mem[64] + 192
                                require 0 < mem[_3470 + 96]
                                mem[_3470 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                require 1 < mem[_3470 + 96]
                                mem[_3470 + 160] = wantAddress
                                mem[_3470 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_3470 + 196] = arg1
                                mem[_3470 + 228] = 64
                                mem[_3470 + 260] = mem[_3470 + 96]
                                idx = 0
                                s = _3470 + 292
                                t = _3470 + 128
                                while idx < mem[_3470 + 96]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _3470 + (32 * mem[_3470 + 96]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5267 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5321 = mem[_5267]
                                require mem[_5267] <= test266151307()
                                require _5267 + return_data.size > _5267 + mem[_5267] + 31
                                _5373 = mem[_5267 + mem[_5267]]
                                require mem[_5267 + mem[_5267]] <= test266151307()
                                require (32 * mem[_5267 + mem[_5267]]) + 32 >= 0 and _5267 + ceil32(return_data.size) + (32 * mem[_5267 + mem[_5267]]) + 32 <= test266151307()
                                mem[64] = _5267 + ceil32(return_data.size) + (32 * mem[_5267 + mem[_5267]]) + 32
                                mem[_5267 + ceil32(return_data.size)] = _5373
                                require return_data.size >= _5321 + (32 * _5373) + 32
                                mem[_5267 + ceil32(return_data.size) + 32 len 32 * _5373] = mem[_5267 + _5321 + 32 len 32 * _5373]
                                require _5373 - 1 < _5373
                                if not mem[(32 * _5373 - 1) + _5267 + ceil32(return_data.size) + 32]:
                                    return 0
                                if profitFactor * mem[(32 * _5373 - 1) + _5267 + ceil32(return_data.size) + 32] / mem[(32 * _5373 - 1) + _5267 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _5373 - 1) + _5267 + ceil32(return_data.size) + 32] < 0
                        else:
                            if t * mem[_3031] / mem[_3031] != t:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not mem[_3031]:
                                _3209 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3209] = 26
                                mem[_3209 + 32] = 'SafeMath: division by zero'
                                if not -1 * t * _3041 / 10^18:
                                    _3371 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3371] = 26
                                    mem[_3371 + 32] = 'SafeMath: division by zero'
                                    if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                        if not arg1:
                                            return 0
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < 0)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3750 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3750]:
                                            return 0
                                        if profitFactor * mem[_3750] / mem[_3750] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3750] < 0
                                    else:
                                        _3524 = mem[64]
                                        mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                        mem[mem[64] + 96] = 2
                                        mem[64] = mem[64] + 192
                                        require 0 < mem[_3524 + 96]
                                        mem[_3524 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                        require 1 < mem[_3524 + 96]
                                        mem[_3524 + 160] = wantAddress
                                        mem[_3524 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3524 + 196] = arg1
                                        mem[_3524 + 228] = 64
                                        mem[_3524 + 260] = mem[_3524 + 96]
                                        idx = 0
                                        s = _3524 + 292
                                        t = _3524 + 128
                                        while idx < mem[_3524 + 96]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                        staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3524 + (32 * mem[_3524 + 96]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5266 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5320 = mem[_5266]
                                        require mem[_5266] <= test266151307()
                                        require _5266 + return_data.size > _5266 + mem[_5266] + 31
                                        _5372 = mem[_5266 + mem[_5266]]
                                        require mem[_5266 + mem[_5266]] <= test266151307()
                                        require (32 * mem[_5266 + mem[_5266]]) + 32 >= 0 and _5266 + ceil32(return_data.size) + (32 * mem[_5266 + mem[_5266]]) + 32 <= test266151307()
                                        mem[64] = _5266 + ceil32(return_data.size) + (32 * mem[_5266 + mem[_5266]]) + 32
                                        mem[_5266 + ceil32(return_data.size)] = _5372
                                        require return_data.size >= _5320 + (32 * _5372) + 32
                                        mem[_5266 + ceil32(return_data.size) + 32 len 32 * _5372] = mem[_5266 + _5320 + 32 len 32 * _5372]
                                        require _5372 - 1 < _5372
                                        if not mem[(32 * _5372 - 1) + _5266 + ceil32(return_data.size) + 32]:
                                            return 0
                                        if profitFactor * mem[(32 * _5372 - 1) + _5266 + ceil32(return_data.size) + 32] / mem[(32 * _5372 - 1) + _5266 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5372 - 1) + _5266 + ceil32(return_data.size) + 32] < 0
                                else:
                                    if maxReportDelay * -1 * t * _3041 / 10^18 / -1 * t * _3041 / 10^18 != maxReportDelay:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3396 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3396] = 26
                                    mem[_3396 + 32] = 'SafeMath: division by zero'
                                    if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                        if not arg1:
                                            return (0 < maxReportDelay * -1 * t * _3041 / 10^18 / 31556952)
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < maxReportDelay * -1 * t * _3041 / 10^18 / 31556952)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3816 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3816]:
                                            return (0 < maxReportDelay * -1 * t * _3041 / 10^18 / 31556952)
                                        if profitFactor * mem[_3816] / mem[_3816] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3816] < maxReportDelay * -1 * t * _3041 / 10^18 / 31556952
                                    else:
                                        _3603 = mem[64]
                                        mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                        mem[mem[64] + 96] = 2
                                        mem[64] = mem[64] + 192
                                        require 0 < mem[_3603 + 96]
                                        mem[_3603 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                        require 1 < mem[_3603 + 96]
                                        mem[_3603 + 160] = wantAddress
                                        mem[_3603 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3603 + 196] = arg1
                                        mem[_3603 + 228] = 64
                                        mem[_3603 + 260] = mem[_3603 + 96]
                                        idx = 0
                                        s = _3603 + 292
                                        u = _3603 + 128
                                        while idx < mem[_3603 + 96]:
                                            mem[s] = mem[u + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            u = u + 32
                                            continue 
                                        require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                        staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3603 + (32 * mem[_3603 + 96]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5265 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5319 = mem[_5265]
                                        require mem[_5265] <= test266151307()
                                        require _5265 + return_data.size > _5265 + mem[_5265] + 31
                                        _5371 = mem[_5265 + mem[_5265]]
                                        require mem[_5265 + mem[_5265]] <= test266151307()
                                        require (32 * mem[_5265 + mem[_5265]]) + 32 >= 0 and _5265 + ceil32(return_data.size) + (32 * mem[_5265 + mem[_5265]]) + 32 <= test266151307()
                                        mem[64] = _5265 + ceil32(return_data.size) + (32 * mem[_5265 + mem[_5265]]) + 32
                                        mem[_5265 + ceil32(return_data.size)] = _5371
                                        require return_data.size >= _5319 + (32 * _5371) + 32
                                        mem[_5265 + ceil32(return_data.size) + 32 len 32 * _5371] = mem[_5265 + _5319 + 32 len 32 * _5371]
                                        require _5371 - 1 < _5371
                                        if not mem[(32 * _5371 - 1) + _5265 + ceil32(return_data.size) + 32]:
                                            return (0 < maxReportDelay * -1 * t * _3041 / 10^18 / 31556952)
                                        if profitFactor * mem[(32 * _5371 - 1) + _5265 + ceil32(return_data.size) + 32] / mem[(32 * _5371 - 1) + _5265 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5371 - 1) + _5265 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _3041 / 10^18 / 31556952
                            else:
                                if _2931 * mem[_3031] / mem[_3031] != _2931:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _3244 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3244] = 26
                                mem[_3244 + 32] = 'SafeMath: division by zero'
                                if not (_2931 * _3041) - (t * _3041) / 10^18:
                                    _3395 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3395] = 26
                                    mem[_3395 + 32] = 'SafeMath: division by zero'
                                    if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                        if not arg1:
                                            return 0
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < 0)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3814 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3814]:
                                            return 0
                                        if profitFactor * mem[_3814] / mem[_3814] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3814] < 0
                                    else:
                                        _3600 = mem[64]
                                        mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                        mem[mem[64] + 96] = 2
                                        mem[64] = mem[64] + 192
                                        require 0 < mem[_3600 + 96]
                                        mem[_3600 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                        require 1 < mem[_3600 + 96]
                                        mem[_3600 + 160] = wantAddress
                                        mem[_3600 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3600 + 196] = arg1
                                        mem[_3600 + 228] = 64
                                        mem[_3600 + 260] = mem[_3600 + 96]
                                        idx = 0
                                        s = _3600 + 292
                                        t = _3600 + 128
                                        while idx < mem[_3600 + 96]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                        staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3600 + (32 * mem[_3600 + 96]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5264 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5318 = mem[_5264]
                                        require mem[_5264] <= test266151307()
                                        require _5264 + return_data.size > _5264 + mem[_5264] + 31
                                        _5370 = mem[_5264 + mem[_5264]]
                                        require mem[_5264 + mem[_5264]] <= test266151307()
                                        require (32 * mem[_5264 + mem[_5264]]) + 32 >= 0 and _5264 + ceil32(return_data.size) + (32 * mem[_5264 + mem[_5264]]) + 32 <= test266151307()
                                        mem[64] = _5264 + ceil32(return_data.size) + (32 * mem[_5264 + mem[_5264]]) + 32
                                        mem[_5264 + ceil32(return_data.size)] = _5370
                                        require return_data.size >= _5318 + (32 * _5370) + 32
                                        mem[_5264 + ceil32(return_data.size) + 32 len 32 * _5370] = mem[_5264 + _5318 + 32 len 32 * _5370]
                                        require _5370 - 1 < _5370
                                        if not mem[(32 * _5370 - 1) + _5264 + ceil32(return_data.size) + 32]:
                                            return 0
                                        if profitFactor * mem[(32 * _5370 - 1) + _5264 + ceil32(return_data.size) + 32] / mem[(32 * _5370 - 1) + _5264 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5370 - 1) + _5264 + ceil32(return_data.size) + 32] < 0
                                else:
                                    if maxReportDelay * (_2931 * _3041) - (t * _3041) / 10^18 / (_2931 * _3041) - (t * _3041) / 10^18 != maxReportDelay:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3414 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3414] = 26
                                    mem[_3414 + 32] = 'SafeMath: division by zero'
                                    if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                        if not arg1:
                                            return (0 < maxReportDelay * (_2931 * _3041) - (t * _3041) / 10^18 / 31556952)
                                        if profitFactor * arg1 / arg1 != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        return (profitFactor * arg1 < maxReportDelay * (_2931 * _3041) - (t * _3041) / 10^18 / 31556952)
                                    if wantToEthOracleAddress:
                                        mem[mem[64] + 4] = arg1
                                        require ext_code.size(wantToEthOracleAddress)
                                        staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                gas gas_remaining wei
                                               args arg1
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _3888 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if not mem[_3888]:
                                            return (0 < maxReportDelay * (_2931 * _3041) - (t * _3041) / 10^18 / 31556952)
                                        if profitFactor * mem[_3888] / mem[_3888] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[_3888] < maxReportDelay * (_2931 * _3041) - (t * _3041) / 10^18 / 31556952
                                    else:
                                        _3681 = mem[64]
                                        mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                        mem[mem[64] + 96] = 2
                                        mem[64] = mem[64] + 192
                                        require 0 < mem[_3681 + 96]
                                        mem[_3681 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                        require 1 < mem[_3681 + 96]
                                        mem[_3681 + 160] = wantAddress
                                        mem[_3681 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[_3681 + 196] = arg1
                                        mem[_3681 + 228] = 64
                                        mem[_3681 + 260] = mem[_3681 + 96]
                                        idx = 0
                                        s = _3681 + 292
                                        u = _3681 + 128
                                        while idx < mem[_3681 + 96]:
                                            mem[s] = mem[u + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            u = u + 32
                                            continue 
                                        require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                        staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                gas gas_remaining wei
                                               args mem[mem[64] + 4 len _3681 + (32 * mem[_3681 + 96]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _5263 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _5317 = mem[_5263]
                                        require mem[_5263] <= test266151307()
                                        require _5263 + return_data.size > _5263 + mem[_5263] + 31
                                        _5369 = mem[_5263 + mem[_5263]]
                                        require mem[_5263 + mem[_5263]] <= test266151307()
                                        require (32 * mem[_5263 + mem[_5263]]) + 32 >= 0 and _5263 + ceil32(return_data.size) + (32 * mem[_5263 + mem[_5263]]) + 32 <= test266151307()
                                        mem[64] = _5263 + ceil32(return_data.size) + (32 * mem[_5263 + mem[_5263]]) + 32
                                        mem[_5263 + ceil32(return_data.size)] = _5369
                                        require return_data.size >= _5317 + (32 * _5369) + 32
                                        mem[_5263 + ceil32(return_data.size) + 32 len 32 * _5369] = mem[_5263 + _5317 + 32 len 32 * _5369]
                                        require _5369 - 1 < _5369
                                        if not mem[(32 * _5369 - 1) + _5263 + ceil32(return_data.size) + 32]:
                                            return (0 < maxReportDelay * (_2931 * _3041) - (t * _3041) / 10^18 / 31556952)
                                        if profitFactor * mem[(32 * _5369 - 1) + _5263 + ceil32(return_data.size) + 32] / mem[(32 * _5369 - 1) + _5263 + ceil32(return_data.size) + 32] != profitFactor:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[mem[64]] = profitFactor * mem[(32 * _5369 - 1) + _5263 + ceil32(return_data.size) + 32] < maxReportDelay * (_2931 * _3041) - (t * _3041) / 10^18 / 31556952
    else:
        if wantToEthOracleAddress:
            mem[100] = arg1
            require ext_code.size(wantToEthOracleAddress)
            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                    gas gas_remaining wei
                   args arg1
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[ceil32(return_data.size) + 96] = 0
            mem[ceil32(return_data.size) + 128] = 0
            mem[ceil32(return_data.size) + 160] = 0
            mem[ceil32(return_data.size) + 192] = 0
            mem[ceil32(return_data.size) + 224] = 0
            mem[ceil32(return_data.size) + 256] = 0
            mem[ceil32(return_data.size) + 288] = 0
            mem[ceil32(return_data.size) + 320] = 0
            mem[ceil32(return_data.size) + 352] = 0
            require ext_code.size(vaultAddress)
            staticcall vaultAddress.strategies(address rg1) with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(return_data.size) + 384 len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 288
            require bool((2 * ceil32(return_data.size)) + 672 <= test266151307())
            mem[(2 * ceil32(return_data.size)) + 384] = ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 416] = ext_call.return_data[32]
            mem[(2 * ceil32(return_data.size)) + 448] = ext_call.return_data[64]
            mem[(2 * ceil32(return_data.size)) + 480] = ext_call.return_data[96]
            mem[(2 * ceil32(return_data.size)) + 512] = ext_call.return_data[128]
            mem[(2 * ceil32(return_data.size)) + 544] = ext_call.return_data[160]
            mem[(2 * ceil32(return_data.size)) + 576] = ext_call.return_data[192]
            mem[(2 * ceil32(return_data.size)) + 608] = ext_call.return_data[224]
            mem[(2 * ceil32(return_data.size)) + 640] = ext_call.return_data[256]
            if 0 == ext_call.return_data[32]:
                mem[(2 * ceil32(return_data.size)) + 676] = this.address
                require ext_code.size(wantAddress)
                staticcall wantAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[(2 * ceil32(return_data.size)) + 672] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 672
                require return_data.size >= 32
                idx = 0
                s = 0
                t = -1
                while idx < lenders.length:
                    mem[0] = 12
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].hasAssets() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _783 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_783] == bool(mem[_783])
                    if not mem[_783]:
                        idx = idx + 1
                        s = s
                        t = t
                        continue 
                    require idx < lenders.length
                    mem[0] = 12
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].apr() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _848 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _861 = mem[_848]
                    if mem[_848] >= t:
                        idx = idx + 1
                        s = s
                        t = t
                        continue 
                    require idx < lenders.length
                    mem[0] = 12
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].nav() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _893 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 1
                    s = mem[_893]
                    t = _861
                    continue 
                if ext_call.return_data[0] + s < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = 0
                u = 0
                while idx < lenders.length:
                    mem[0] = 12
                    mem[mem[64] + 4] = ext_call.return_data[0]
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                            gas gas_remaining wei
                           args ext_call.return_data[0]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1500 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_1500] <= u:
                        idx = idx + 1
                        u = u
                        continue 
                    idx = idx + 1
                    u = mem[_1500]
                    continue 
                require 0 < lenders.length
                mem[0] = 12
                mem[mem[64] + 4] = ext_call.return_data[0] + s
                require ext_code.size(lenders)
                staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                        gas gas_remaining wei
                       args (ext_call.return_data[0] + s)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1499 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1527 = mem[_1499]
                if mem[_1499] <= t:
                    return 0
                require 0 < lenders.length
                mem[0] = 12
                require ext_code.size(lenders)
                staticcall lenders.nav() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1616 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1626 = mem[_1616]
                if not mem[_1616]:
                    _1696 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1696] = 26
                    mem[_1696 + 32] = 'SafeMath: division by zero'
                    _1736 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1736] = 26
                    mem[_1736 + 32] = 'SafeMath: division by zero'
                    if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                        if not arg1:
                            return 0
                        if profitFactor * arg1 / arg1 != profitFactor:
                            revert with 0, 'SafeMath: multiplication overflow'
                        return (profitFactor * arg1 < 0)
                    if wantToEthOracleAddress:
                        mem[mem[64] + 4] = arg1
                        require ext_code.size(wantToEthOracleAddress)
                        staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                gas gas_remaining wei
                               args arg1
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1914 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if not mem[_1914]:
                            return 0
                        if profitFactor * mem[_1914] / mem[_1914] != profitFactor:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[mem[64]] = profitFactor * mem[_1914] < 0
                    else:
                        _1806 = mem[64]
                        mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                        mem[mem[64] + 96] = 2
                        mem[64] = mem[64] + 192
                        require 0 < mem[_1806 + 96]
                        mem[_1806 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                        require 1 < mem[_1806 + 96]
                        mem[_1806 + 160] = wantAddress
                        mem[_1806 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[_1806 + 196] = arg1
                        mem[_1806 + 228] = 64
                        mem[_1806 + 260] = mem[_1806 + 96]
                        idx = 0
                        s = _1806 + 292
                        t = _1806 + 128
                        while idx < mem[_1806 + 96]:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                        staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _1806 + (32 * mem[_1806 + 96]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2835 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2881 = mem[_2835]
                        require mem[_2835] <= test266151307()
                        require _2835 + return_data.size > _2835 + mem[_2835] + 31
                        _2925 = mem[_2835 + mem[_2835]]
                        require mem[_2835 + mem[_2835]] <= test266151307()
                        require (32 * mem[_2835 + mem[_2835]]) + 32 >= 0 and _2835 + ceil32(return_data.size) + (32 * mem[_2835 + mem[_2835]]) + 32 <= test266151307()
                        mem[64] = _2835 + ceil32(return_data.size) + (32 * mem[_2835 + mem[_2835]]) + 32
                        mem[_2835 + ceil32(return_data.size)] = _2925
                        require return_data.size >= _2881 + (32 * _2925) + 32
                        mem[_2835 + ceil32(return_data.size) + 32 len 32 * _2925] = mem[_2835 + _2881 + 32 len 32 * _2925]
                        require _2925 - 1 < _2925
                        if not mem[(32 * _2925 - 1) + _2835 + ceil32(return_data.size) + 32]:
                            return 0
                        if profitFactor * mem[(32 * _2925 - 1) + _2835 + ceil32(return_data.size) + 32] / mem[(32 * _2925 - 1) + _2835 + ceil32(return_data.size) + 32] != profitFactor:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[mem[64]] = profitFactor * mem[(32 * _2925 - 1) + _2835 + ceil32(return_data.size) + 32] < 0
                else:
                    if t * mem[_1616] / mem[_1616] != t:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not mem[_1616]:
                        _1703 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1703] = 26
                        mem[_1703 + 32] = 'SafeMath: division by zero'
                        if not -1 * t * _1626 / 10^18:
                            _1746 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1746] = 26
                            mem[_1746 + 32] = 'SafeMath: division by zero'
                            if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                if not arg1:
                                    return 0
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < 0)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1948 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_1948]:
                                    return 0
                                if profitFactor * mem[_1948] / mem[_1948] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_1948] < 0
                            else:
                                _1830 = mem[64]
                                mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                mem[mem[64] + 96] = 2
                                mem[64] = mem[64] + 192
                                require 0 < mem[_1830 + 96]
                                mem[_1830 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                require 1 < mem[_1830 + 96]
                                mem[_1830 + 160] = wantAddress
                                mem[_1830 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_1830 + 196] = arg1
                                mem[_1830 + 228] = 64
                                mem[_1830 + 260] = mem[_1830 + 96]
                                idx = 0
                                s = _1830 + 292
                                t = _1830 + 128
                                while idx < mem[_1830 + 96]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _1830 + (32 * mem[_1830 + 96]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2834 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _2880 = mem[_2834]
                                require mem[_2834] <= test266151307()
                                require _2834 + return_data.size > _2834 + mem[_2834] + 31
                                _2924 = mem[_2834 + mem[_2834]]
                                require mem[_2834 + mem[_2834]] <= test266151307()
                                require (32 * mem[_2834 + mem[_2834]]) + 32 >= 0 and _2834 + ceil32(return_data.size) + (32 * mem[_2834 + mem[_2834]]) + 32 <= test266151307()
                                mem[64] = _2834 + ceil32(return_data.size) + (32 * mem[_2834 + mem[_2834]]) + 32
                                mem[_2834 + ceil32(return_data.size)] = _2924
                                require return_data.size >= _2880 + (32 * _2924) + 32
                                mem[_2834 + ceil32(return_data.size) + 32 len 32 * _2924] = mem[_2834 + _2880 + 32 len 32 * _2924]
                                require _2924 - 1 < _2924
                                if not mem[(32 * _2924 - 1) + _2834 + ceil32(return_data.size) + 32]:
                                    return 0
                                if profitFactor * mem[(32 * _2924 - 1) + _2834 + ceil32(return_data.size) + 32] / mem[(32 * _2924 - 1) + _2834 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _2924 - 1) + _2834 + ceil32(return_data.size) + 32] < 0
                        else:
                            if maxReportDelay * -1 * t * _1626 / 10^18 / -1 * t * _1626 / 10^18 != maxReportDelay:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _1757 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1757] = 26
                            mem[_1757 + 32] = 'SafeMath: division by zero'
                            if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                if not arg1:
                                    return (0 < maxReportDelay * -1 * t * _1626 / 10^18 / 31556952)
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < maxReportDelay * -1 * t * _1626 / 10^18 / 31556952)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1980 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_1980]:
                                    return (0 < maxReportDelay * -1 * t * _1626 / 10^18 / 31556952)
                                if profitFactor * mem[_1980] / mem[_1980] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_1980] < maxReportDelay * -1 * t * _1626 / 10^18 / 31556952
                            else:
                                _1867 = mem[64]
                                mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                mem[mem[64] + 96] = 2
                                mem[64] = mem[64] + 192
                                require 0 < mem[_1867 + 96]
                                mem[_1867 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                require 1 < mem[_1867 + 96]
                                mem[_1867 + 160] = wantAddress
                                mem[_1867 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_1867 + 196] = arg1
                                mem[_1867 + 228] = 64
                                mem[_1867 + 260] = mem[_1867 + 96]
                                idx = 0
                                s = _1867 + 292
                                u = _1867 + 128
                                while idx < mem[_1867 + 96]:
                                    mem[s] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    u = u + 32
                                    continue 
                                require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _1867 + (32 * mem[_1867 + 96]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2833 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _2879 = mem[_2833]
                                require mem[_2833] <= test266151307()
                                require _2833 + return_data.size > _2833 + mem[_2833] + 31
                                _2923 = mem[_2833 + mem[_2833]]
                                require mem[_2833 + mem[_2833]] <= test266151307()
                                require (32 * mem[_2833 + mem[_2833]]) + 32 >= 0 and _2833 + ceil32(return_data.size) + (32 * mem[_2833 + mem[_2833]]) + 32 <= test266151307()
                                mem[64] = _2833 + ceil32(return_data.size) + (32 * mem[_2833 + mem[_2833]]) + 32
                                mem[_2833 + ceil32(return_data.size)] = _2923
                                require return_data.size >= _2879 + (32 * _2923) + 32
                                mem[_2833 + ceil32(return_data.size) + 32 len 32 * _2923] = mem[_2833 + _2879 + 32 len 32 * _2923]
                                require _2923 - 1 < _2923
                                if not mem[(32 * _2923 - 1) + _2833 + ceil32(return_data.size) + 32]:
                                    return (0 < maxReportDelay * -1 * t * _1626 / 10^18 / 31556952)
                                if profitFactor * mem[(32 * _2923 - 1) + _2833 + ceil32(return_data.size) + 32] / mem[(32 * _2923 - 1) + _2833 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _2923 - 1) + _2833 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _1626 / 10^18 / 31556952
                    else:
                        if _1527 * mem[_1616] / mem[_1616] != _1527:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _1710 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1710] = 26
                        mem[_1710 + 32] = 'SafeMath: division by zero'
                        if not (_1527 * _1626) - (t * _1626) / 10^18:
                            _1756 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1756] = 26
                            mem[_1756 + 32] = 'SafeMath: division by zero'
                            if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                if not arg1:
                                    return 0
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < 0)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1978 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_1978]:
                                    return 0
                                if profitFactor * mem[_1978] / mem[_1978] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_1978] < 0
                            else:
                                _1864 = mem[64]
                                mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                mem[mem[64] + 96] = 2
                                mem[64] = mem[64] + 192
                                require 0 < mem[_1864 + 96]
                                mem[_1864 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                require 1 < mem[_1864 + 96]
                                mem[_1864 + 160] = wantAddress
                                mem[_1864 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_1864 + 196] = arg1
                                mem[_1864 + 228] = 64
                                mem[_1864 + 260] = mem[_1864 + 96]
                                idx = 0
                                s = _1864 + 292
                                t = _1864 + 128
                                while idx < mem[_1864 + 96]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _1864 + (32 * mem[_1864 + 96]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2832 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _2878 = mem[_2832]
                                require mem[_2832] <= test266151307()
                                require _2832 + return_data.size > _2832 + mem[_2832] + 31
                                _2922 = mem[_2832 + mem[_2832]]
                                require mem[_2832 + mem[_2832]] <= test266151307()
                                require (32 * mem[_2832 + mem[_2832]]) + 32 >= 0 and _2832 + ceil32(return_data.size) + (32 * mem[_2832 + mem[_2832]]) + 32 <= test266151307()
                                mem[64] = _2832 + ceil32(return_data.size) + (32 * mem[_2832 + mem[_2832]]) + 32
                                mem[_2832 + ceil32(return_data.size)] = _2922
                                require return_data.size >= _2878 + (32 * _2922) + 32
                                mem[_2832 + ceil32(return_data.size) + 32 len 32 * _2922] = mem[_2832 + _2878 + 32 len 32 * _2922]
                                require _2922 - 1 < _2922
                                if not mem[(32 * _2922 - 1) + _2832 + ceil32(return_data.size) + 32]:
                                    return 0
                                if profitFactor * mem[(32 * _2922 - 1) + _2832 + ceil32(return_data.size) + 32] / mem[(32 * _2922 - 1) + _2832 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _2922 - 1) + _2832 + ceil32(return_data.size) + 32] < 0
                        else:
                            if maxReportDelay * (_1527 * _1626) - (t * _1626) / 10^18 / (_1527 * _1626) - (t * _1626) / 10^18 != maxReportDelay:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _1771 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1771] = 26
                            mem[_1771 + 32] = 'SafeMath: division by zero'
                            if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                if not arg1:
                                    return (0 < maxReportDelay * (_1527 * _1626) - (t * _1626) / 10^18 / 31556952)
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < maxReportDelay * (_1527 * _1626) - (t * _1626) / 10^18 / 31556952)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2015 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_2015]:
                                    return (0 < maxReportDelay * (_1527 * _1626) - (t * _1626) / 10^18 / 31556952)
                                if profitFactor * mem[_2015] / mem[_2015] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_2015] < maxReportDelay * (_1527 * _1626) - (t * _1626) / 10^18 / 31556952
                            else:
                                _1906 = mem[64]
                                mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                mem[mem[64] + 96] = 2
                                mem[64] = mem[64] + 192
                                require 0 < mem[_1906 + 96]
                                mem[_1906 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                require 1 < mem[_1906 + 96]
                                mem[_1906 + 160] = wantAddress
                                mem[_1906 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_1906 + 196] = arg1
                                mem[_1906 + 228] = 64
                                mem[_1906 + 260] = mem[_1906 + 96]
                                idx = 0
                                s = _1906 + 292
                                u = _1906 + 128
                                while idx < mem[_1906 + 96]:
                                    mem[s] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    u = u + 32
                                    continue 
                                require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _1906 + (32 * mem[_1906 + 96]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2831 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _2877 = mem[_2831]
                                require mem[_2831] <= test266151307()
                                require _2831 + return_data.size > _2831 + mem[_2831] + 31
                                _2921 = mem[_2831 + mem[_2831]]
                                require mem[_2831 + mem[_2831]] <= test266151307()
                                require (32 * mem[_2831 + mem[_2831]]) + 32 >= 0 and _2831 + ceil32(return_data.size) + (32 * mem[_2831 + mem[_2831]]) + 32 <= test266151307()
                                mem[64] = _2831 + ceil32(return_data.size) + (32 * mem[_2831 + mem[_2831]]) + 32
                                mem[_2831 + ceil32(return_data.size)] = _2921
                                require return_data.size >= _2877 + (32 * _2921) + 32
                                mem[_2831 + ceil32(return_data.size) + 32 len 32 * _2921] = mem[_2831 + _2877 + 32 len 32 * _2921]
                                require _2921 - 1 < _2921
                                if not mem[(32 * _2921 - 1) + _2831 + ceil32(return_data.size) + 32]:
                                    return (0 < maxReportDelay * (_1527 * _1626) - (t * _1626) / 10^18 / 31556952)
                                if profitFactor * mem[(32 * _2921 - 1) + _2831 + ceil32(return_data.size) + 32] / mem[(32 * _2921 - 1) + _2831 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _2921 - 1) + _2831 + ceil32(return_data.size) + 32] < maxReportDelay * (_1527 * _1626) - (t * _1626) / 10^18 / 31556952
            else:
                mem[(2 * ceil32(return_data.size)) + 672] = 30
                mem[(2 * ceil32(return_data.size)) + 704] = 'SafeMath: subtraction overflow'
                if ext_call.return_data[160] > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if block.timestamp - ext_call.return_data[160] < minReportDelay:
                    mem[(2 * ceil32(return_data.size)) + 740] = this.address
                    require ext_code.size(wantAddress)
                    staticcall wantAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[(2 * ceil32(return_data.size)) + 736] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = (4 * ceil32(return_data.size)) + 736
                    require return_data.size >= 32
                    idx = 0
                    s = 0
                    t = -1
                    while idx < lenders.length:
                        mem[0] = 12
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].hasAssets() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _782 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_782] == bool(mem[_782])
                        if not mem[_782]:
                            idx = idx + 1
                            s = s
                            t = t
                            continue 
                        require idx < lenders.length
                        mem[0] = 12
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].apr() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _847 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _860 = mem[_847]
                        if mem[_847] >= t:
                            idx = idx + 1
                            s = s
                            t = t
                            continue 
                        require idx < lenders.length
                        mem[0] = 12
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].nav() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _892 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 1
                        s = mem[_892]
                        t = _860
                        continue 
                    if ext_call.return_data[0] + s < s:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = 0
                    u = 0
                    while idx < lenders.length:
                        mem[0] = 12
                        mem[mem[64] + 4] = ext_call.return_data[0]
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                                gas gas_remaining wei
                               args ext_call.return_data[0]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1498 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_1498] <= u:
                            idx = idx + 1
                            u = u
                            continue 
                        idx = idx + 1
                        u = mem[_1498]
                        continue 
                    require 0 < lenders.length
                    mem[0] = 12
                    mem[mem[64] + 4] = ext_call.return_data[0] + s
                    require ext_code.size(lenders)
                    staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                            gas gas_remaining wei
                           args (ext_call.return_data[0] + s)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1497 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1525 = mem[_1497]
                    if mem[_1497] <= t:
                        return 0
                    require 0 < lenders.length
                    mem[0] = 12
                    require ext_code.size(lenders)
                    staticcall lenders.nav() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1614 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1625 = mem[_1614]
                    if not mem[_1614]:
                        _1694 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1694] = 26
                        mem[_1694 + 32] = 'SafeMath: division by zero'
                        _1734 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1734] = 26
                        mem[_1734 + 32] = 'SafeMath: division by zero'
                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                            if not arg1:
                                return 0
                            if profitFactor * arg1 / arg1 != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            return (profitFactor * arg1 < 0)
                        if wantToEthOracleAddress:
                            mem[mem[64] + 4] = arg1
                            require ext_code.size(wantToEthOracleAddress)
                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args arg1
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1904 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if not mem[_1904]:
                                return 0
                            if profitFactor * mem[_1904] / mem[_1904] != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[mem[64]] = profitFactor * mem[_1904] < 0
                        else:
                            _1802 = mem[64]
                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                            mem[mem[64] + 96] = 2
                            mem[64] = mem[64] + 192
                            require 0 < mem[_1802 + 96]
                            mem[_1802 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                            require 1 < mem[_1802 + 96]
                            mem[_1802 + 160] = wantAddress
                            mem[_1802 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_1802 + 196] = arg1
                            mem[_1802 + 228] = 64
                            mem[_1802 + 260] = mem[_1802 + 96]
                            idx = 0
                            s = _1802 + 292
                            t = _1802 + 128
                            while idx < mem[_1802 + 96]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _1802 + (32 * mem[_1802 + 96]) + -mem[64] + 288]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2830 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2876 = mem[_2830]
                            require mem[_2830] <= test266151307()
                            require _2830 + return_data.size > _2830 + mem[_2830] + 31
                            _2920 = mem[_2830 + mem[_2830]]
                            require mem[_2830 + mem[_2830]] <= test266151307()
                            require (32 * mem[_2830 + mem[_2830]]) + 32 >= 0 and _2830 + ceil32(return_data.size) + (32 * mem[_2830 + mem[_2830]]) + 32 <= test266151307()
                            mem[64] = _2830 + ceil32(return_data.size) + (32 * mem[_2830 + mem[_2830]]) + 32
                            mem[_2830 + ceil32(return_data.size)] = _2920
                            require return_data.size >= _2876 + (32 * _2920) + 32
                            mem[_2830 + ceil32(return_data.size) + 32 len 32 * _2920] = mem[_2830 + _2876 + 32 len 32 * _2920]
                            require _2920 - 1 < _2920
                            if not mem[(32 * _2920 - 1) + _2830 + ceil32(return_data.size) + 32]:
                                return 0
                            if profitFactor * mem[(32 * _2920 - 1) + _2830 + ceil32(return_data.size) + 32] / mem[(32 * _2920 - 1) + _2830 + ceil32(return_data.size) + 32] != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[mem[64]] = profitFactor * mem[(32 * _2920 - 1) + _2830 + ceil32(return_data.size) + 32] < 0
                    else:
                        if t * mem[_1614] / mem[_1614] != t:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not mem[_1614]:
                            _1702 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1702] = 26
                            mem[_1702 + 32] = 'SafeMath: division by zero'
                            if not -1 * t * _1625 / 10^18:
                                _1744 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1744] = 26
                                mem[_1744 + 32] = 'SafeMath: division by zero'
                                if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                    if not arg1:
                                        return 0
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < 0)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1941 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_1941]:
                                        return 0
                                    if profitFactor * mem[_1941] / mem[_1941] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_1941] < 0
                                else:
                                    _1823 = mem[64]
                                    mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                    mem[mem[64] + 96] = 2
                                    mem[64] = mem[64] + 192
                                    require 0 < mem[_1823 + 96]
                                    mem[_1823 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                    require 1 < mem[_1823 + 96]
                                    mem[_1823 + 160] = wantAddress
                                    mem[_1823 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_1823 + 196] = arg1
                                    mem[_1823 + 228] = 64
                                    mem[_1823 + 260] = mem[_1823 + 96]
                                    idx = 0
                                    s = _1823 + 292
                                    t = _1823 + 128
                                    while idx < mem[_1823 + 96]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                    staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _1823 + (32 * mem[_1823 + 96]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2829 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _2875 = mem[_2829]
                                    require mem[_2829] <= test266151307()
                                    require _2829 + return_data.size > _2829 + mem[_2829] + 31
                                    _2919 = mem[_2829 + mem[_2829]]
                                    require mem[_2829 + mem[_2829]] <= test266151307()
                                    require (32 * mem[_2829 + mem[_2829]]) + 32 >= 0 and _2829 + ceil32(return_data.size) + (32 * mem[_2829 + mem[_2829]]) + 32 <= test266151307()
                                    mem[64] = _2829 + ceil32(return_data.size) + (32 * mem[_2829 + mem[_2829]]) + 32
                                    mem[_2829 + ceil32(return_data.size)] = _2919
                                    require return_data.size >= _2875 + (32 * _2919) + 32
                                    mem[_2829 + ceil32(return_data.size) + 32 len 32 * _2919] = mem[_2829 + _2875 + 32 len 32 * _2919]
                                    require _2919 - 1 < _2919
                                    if not mem[(32 * _2919 - 1) + _2829 + ceil32(return_data.size) + 32]:
                                        return 0
                                    if profitFactor * mem[(32 * _2919 - 1) + _2829 + ceil32(return_data.size) + 32] / mem[(32 * _2919 - 1) + _2829 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _2919 - 1) + _2829 + ceil32(return_data.size) + 32] < 0
                            else:
                                if maxReportDelay * -1 * t * _1625 / 10^18 / -1 * t * _1625 / 10^18 != maxReportDelay:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _1754 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1754] = 26
                                mem[_1754 + 32] = 'SafeMath: division by zero'
                                if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                    if not arg1:
                                        return (0 < maxReportDelay * -1 * t * _1625 / 10^18 / 31556952)
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < maxReportDelay * -1 * t * _1625 / 10^18 / 31556952)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1972 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_1972]:
                                        return (0 < maxReportDelay * -1 * t * _1625 / 10^18 / 31556952)
                                    if profitFactor * mem[_1972] / mem[_1972] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_1972] < maxReportDelay * -1 * t * _1625 / 10^18 / 31556952
                                else:
                                    _1857 = mem[64]
                                    mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                    mem[mem[64] + 96] = 2
                                    mem[64] = mem[64] + 192
                                    require 0 < mem[_1857 + 96]
                                    mem[_1857 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                    require 1 < mem[_1857 + 96]
                                    mem[_1857 + 160] = wantAddress
                                    mem[_1857 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_1857 + 196] = arg1
                                    mem[_1857 + 228] = 64
                                    mem[_1857 + 260] = mem[_1857 + 96]
                                    idx = 0
                                    s = _1857 + 292
                                    u = _1857 + 128
                                    while idx < mem[_1857 + 96]:
                                        mem[s] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        u = u + 32
                                        continue 
                                    require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                    staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _1857 + (32 * mem[_1857 + 96]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2828 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _2874 = mem[_2828]
                                    require mem[_2828] <= test266151307()
                                    require _2828 + return_data.size > _2828 + mem[_2828] + 31
                                    _2918 = mem[_2828 + mem[_2828]]
                                    require mem[_2828 + mem[_2828]] <= test266151307()
                                    require (32 * mem[_2828 + mem[_2828]]) + 32 >= 0 and _2828 + ceil32(return_data.size) + (32 * mem[_2828 + mem[_2828]]) + 32 <= test266151307()
                                    mem[64] = _2828 + ceil32(return_data.size) + (32 * mem[_2828 + mem[_2828]]) + 32
                                    mem[_2828 + ceil32(return_data.size)] = _2918
                                    require return_data.size >= _2874 + (32 * _2918) + 32
                                    mem[_2828 + ceil32(return_data.size) + 32 len 32 * _2918] = mem[_2828 + _2874 + 32 len 32 * _2918]
                                    require _2918 - 1 < _2918
                                    if not mem[(32 * _2918 - 1) + _2828 + ceil32(return_data.size) + 32]:
                                        return (0 < maxReportDelay * -1 * t * _1625 / 10^18 / 31556952)
                                    if profitFactor * mem[(32 * _2918 - 1) + _2828 + ceil32(return_data.size) + 32] / mem[(32 * _2918 - 1) + _2828 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _2918 - 1) + _2828 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _1625 / 10^18 / 31556952
                        else:
                            if _1525 * mem[_1614] / mem[_1614] != _1525:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _1708 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1708] = 26
                            mem[_1708 + 32] = 'SafeMath: division by zero'
                            if not (_1525 * _1625) - (t * _1625) / 10^18:
                                _1753 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1753] = 26
                                mem[_1753 + 32] = 'SafeMath: division by zero'
                                if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                    if not arg1:
                                        return 0
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < 0)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1970 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_1970]:
                                        return 0
                                    if profitFactor * mem[_1970] / mem[_1970] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_1970] < 0
                                else:
                                    _1854 = mem[64]
                                    mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                    mem[mem[64] + 96] = 2
                                    mem[64] = mem[64] + 192
                                    require 0 < mem[_1854 + 96]
                                    mem[_1854 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                    require 1 < mem[_1854 + 96]
                                    mem[_1854 + 160] = wantAddress
                                    mem[_1854 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_1854 + 196] = arg1
                                    mem[_1854 + 228] = 64
                                    mem[_1854 + 260] = mem[_1854 + 96]
                                    idx = 0
                                    s = _1854 + 292
                                    t = _1854 + 128
                                    while idx < mem[_1854 + 96]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                    staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _1854 + (32 * mem[_1854 + 96]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2827 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _2873 = mem[_2827]
                                    require mem[_2827] <= test266151307()
                                    require _2827 + return_data.size > _2827 + mem[_2827] + 31
                                    _2917 = mem[_2827 + mem[_2827]]
                                    require mem[_2827 + mem[_2827]] <= test266151307()
                                    require (32 * mem[_2827 + mem[_2827]]) + 32 >= 0 and _2827 + ceil32(return_data.size) + (32 * mem[_2827 + mem[_2827]]) + 32 <= test266151307()
                                    mem[64] = _2827 + ceil32(return_data.size) + (32 * mem[_2827 + mem[_2827]]) + 32
                                    mem[_2827 + ceil32(return_data.size)] = _2917
                                    require return_data.size >= _2873 + (32 * _2917) + 32
                                    mem[_2827 + ceil32(return_data.size) + 32 len 32 * _2917] = mem[_2827 + _2873 + 32 len 32 * _2917]
                                    require _2917 - 1 < _2917
                                    if not mem[(32 * _2917 - 1) + _2827 + ceil32(return_data.size) + 32]:
                                        return 0
                                    if profitFactor * mem[(32 * _2917 - 1) + _2827 + ceil32(return_data.size) + 32] / mem[(32 * _2917 - 1) + _2827 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _2917 - 1) + _2827 + ceil32(return_data.size) + 32] < 0
                            else:
                                if maxReportDelay * (_1525 * _1625) - (t * _1625) / 10^18 / (_1525 * _1625) - (t * _1625) / 10^18 != maxReportDelay:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _1769 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1769] = 26
                                mem[_1769 + 32] = 'SafeMath: division by zero'
                                if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                    if not arg1:
                                        return (0 < maxReportDelay * (_1525 * _1625) - (t * _1625) / 10^18 / 31556952)
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < maxReportDelay * (_1525 * _1625) - (t * _1625) / 10^18 / 31556952)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2006 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_2006]:
                                        return (0 < maxReportDelay * (_1525 * _1625) - (t * _1625) / 10^18 / 31556952)
                                    if profitFactor * mem[_2006] / mem[_2006] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_2006] < maxReportDelay * (_1525 * _1625) - (t * _1625) / 10^18 / 31556952
                                else:
                                    _1896 = mem[64]
                                    mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                    mem[mem[64] + 96] = 2
                                    mem[64] = mem[64] + 192
                                    require 0 < mem[_1896 + 96]
                                    mem[_1896 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                    require 1 < mem[_1896 + 96]
                                    mem[_1896 + 160] = wantAddress
                                    mem[_1896 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_1896 + 196] = arg1
                                    mem[_1896 + 228] = 64
                                    mem[_1896 + 260] = mem[_1896 + 96]
                                    idx = 0
                                    s = _1896 + 292
                                    u = _1896 + 128
                                    while idx < mem[_1896 + 96]:
                                        mem[s] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        u = u + 32
                                        continue 
                                    require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                    staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _1896 + (32 * mem[_1896 + 96]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _2826 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _2872 = mem[_2826]
                                    require mem[_2826] <= test266151307()
                                    require _2826 + return_data.size > _2826 + mem[_2826] + 31
                                    _2916 = mem[_2826 + mem[_2826]]
                                    require mem[_2826 + mem[_2826]] <= test266151307()
                                    require (32 * mem[_2826 + mem[_2826]]) + 32 >= 0 and _2826 + ceil32(return_data.size) + (32 * mem[_2826 + mem[_2826]]) + 32 <= test266151307()
                                    mem[64] = _2826 + ceil32(return_data.size) + (32 * mem[_2826 + mem[_2826]]) + 32
                                    mem[_2826 + ceil32(return_data.size)] = _2916
                                    require return_data.size >= _2872 + (32 * _2916) + 32
                                    mem[_2826 + ceil32(return_data.size) + 32 len 32 * _2916] = mem[_2826 + _2872 + 32 len 32 * _2916]
                                    require _2916 - 1 < _2916
                                    if not mem[(32 * _2916 - 1) + _2826 + ceil32(return_data.size) + 32]:
                                        return (0 < maxReportDelay * (_1525 * _1625) - (t * _1625) / 10^18 / 31556952)
                                    if profitFactor * mem[(32 * _2916 - 1) + _2826 + ceil32(return_data.size) + 32] / mem[(32 * _2916 - 1) + _2826 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _2916 - 1) + _2826 + ceil32(return_data.size) + 32] < maxReportDelay * (_1525 * _1625) - (t * _1625) / 10^18 / 31556952
                else:
                    mem[(2 * ceil32(return_data.size)) + 736] = 30
                    mem[(2 * ceil32(return_data.size)) + 768] = 'SafeMath: subtraction overflow'
                    if ext_call.return_data[160] > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if block.timestamp - ext_call.return_data[160] >= maxReportDelay:
                        return 0
                    require ext_code.size(vaultAddress)
                    staticcall vaultAddress.debtOutstanding() with:
                            gas gas_remaining wei
                    mem[(2 * ceil32(return_data.size)) + 800] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = (4 * ceil32(return_data.size)) + 800
                    require return_data.size >= 32
                    if ext_call.return_data[0] > debtThreshold:
                        return 0
                    idx = 0
                    s = 0
                    while idx < lenders.length:
                        mem[0] = 12
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].nav() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _781 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_781] + s < s:
                            revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = mem[_781] + s
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(wantAddress)
                    staticcall wantAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _801 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _818 = mem[_801]
                    if mem[_801] + (_802 * lenders.length) < _802 * lenders.length:
                        revert with 0, 'SafeMath: addition overflow'
                    if debtThreshold < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if debtThreshold + mem[_801] + (_802 * lenders.length) < mem[(2 * ceil32(return_data.size)) + 576]:
                        return 0
                    if mem[_801] + (_802 * lenders.length) <= mem[(2 * ceil32(return_data.size)) + 576]:
                        require ext_code.size(vaultAddress)
                        staticcall vaultAddress.creditAvailable() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _898 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_898] < mem[_898]:
                            revert with 0, 'SafeMath: addition overflow'
                        if not profitFactor:
                            if 0 < mem[_898]:
                                return 0
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _974 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _982 = mem[_974]
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1466 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1466] == bool(mem[_1466])
                                if not mem[_1466]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1577 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _1610 = mem[_1577]
                                if mem[_1577] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1664 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_1664]
                                t = _1610
                                continue 
                            if _982 + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 12
                                mem[mem[64] + 4] = _982
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args _982
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2867 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_2867] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_2867]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 12
                            mem[mem[64] + 4] = _982 + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args (_982 + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2866 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2910 = mem[_2866]
                            if mem[_2866] <= t:
                                return 0
                            require 0 < lenders.length
                            mem[0] = 12
                            require ext_code.size(lenders)
                            staticcall lenders.nav() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3019 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3036 = mem[_3019]
                            if not mem[_3019]:
                                _3167 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3167] = 26
                                mem[_3167 + 32] = 'SafeMath: division by zero'
                                _3340 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3340] = 26
                                mem[_3340 + 32] = 'SafeMath: division by zero'
                                if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                    if not arg1:
                                        return 0
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < 0)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3637 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_3637]:
                                        return 0
                                    if profitFactor * mem[_3637] / mem[_3637] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_3637] < 0
                                else:
                                    _3445 = mem[64]
                                    mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                    mem[mem[64] + 96] = 2
                                    mem[64] = mem[64] + 192
                                    require 0 < mem[_3445 + 96]
                                    mem[_3445 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                    require 1 < mem[_3445 + 96]
                                    mem[_3445 + 160] = wantAddress
                                    mem[_3445 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_3445 + 196] = arg1
                                    mem[_3445 + 228] = 64
                                    mem[_3445 + 260] = mem[_3445 + 96]
                                    idx = 0
                                    s = _3445 + 292
                                    t = _3445 + 128
                                    while idx < mem[_3445 + 96]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                    staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _3445 + (32 * mem[_3445 + 96]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5234 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5288 = mem[_5234]
                                    require mem[_5234] <= test266151307()
                                    require _5234 + return_data.size > _5234 + mem[_5234] + 31
                                    _5344 = mem[_5234 + mem[_5234]]
                                    require mem[_5234 + mem[_5234]] <= test266151307()
                                    require (32 * mem[_5234 + mem[_5234]]) + 32 >= 0 and _5234 + ceil32(return_data.size) + (32 * mem[_5234 + mem[_5234]]) + 32 <= test266151307()
                                    mem[64] = _5234 + ceil32(return_data.size) + (32 * mem[_5234 + mem[_5234]]) + 32
                                    mem[_5234 + ceil32(return_data.size)] = _5344
                                    require return_data.size >= _5288 + (32 * _5344) + 32
                                    mem[_5234 + ceil32(return_data.size) + 32 len 32 * _5344] = mem[_5234 + _5288 + 32 len 32 * _5344]
                                    require _5344 - 1 < _5344
                                    if not mem[(32 * _5344 - 1) + _5234 + ceil32(return_data.size) + 32]:
                                        return 0
                                    if profitFactor * mem[(32 * _5344 - 1) + _5234 + ceil32(return_data.size) + 32] / mem[(32 * _5344 - 1) + _5234 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _5344 - 1) + _5234 + ceil32(return_data.size) + 32] < 0
                            else:
                                if t * mem[_3019] / mem[_3019] != t:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not mem[_3019]:
                                    _3203 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3203] = 26
                                    mem[_3203 + 32] = 'SafeMath: division by zero'
                                    if not -1 * t * _3036 / 10^18:
                                        _3359 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3359] = 26
                                        mem[_3359 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3712 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3712]:
                                                return 0
                                            if profitFactor * mem[_3712] / mem[_3712] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3712] < 0
                                        else:
                                            _3486 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_3486 + 96]
                                            mem[_3486 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_3486 + 96]
                                            mem[_3486 + 160] = wantAddress
                                            mem[_3486 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3486 + 196] = arg1
                                            mem[_3486 + 228] = 64
                                            mem[_3486 + 260] = mem[_3486 + 96]
                                            idx = 0
                                            s = _3486 + 292
                                            t = _3486 + 128
                                            while idx < mem[_3486 + 96]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3486 + (32 * mem[_3486 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5233 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5287 = mem[_5233]
                                            require mem[_5233] <= test266151307()
                                            require _5233 + return_data.size > _5233 + mem[_5233] + 31
                                            _5343 = mem[_5233 + mem[_5233]]
                                            require mem[_5233 + mem[_5233]] <= test266151307()
                                            require (32 * mem[_5233 + mem[_5233]]) + 32 >= 0 and _5233 + ceil32(return_data.size) + (32 * mem[_5233 + mem[_5233]]) + 32 <= test266151307()
                                            mem[64] = _5233 + ceil32(return_data.size) + (32 * mem[_5233 + mem[_5233]]) + 32
                                            mem[_5233 + ceil32(return_data.size)] = _5343
                                            require return_data.size >= _5287 + (32 * _5343) + 32
                                            mem[_5233 + ceil32(return_data.size) + 32 len 32 * _5343] = mem[_5233 + _5287 + 32 len 32 * _5343]
                                            require _5343 - 1 < _5343
                                            if not mem[(32 * _5343 - 1) + _5233 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _5343 - 1) + _5233 + ceil32(return_data.size) + 32] / mem[(32 * _5343 - 1) + _5233 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5343 - 1) + _5233 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * -1 * t * _3036 / 10^18 / -1 * t * _3036 / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _3378 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3378] = 26
                                        mem[_3378 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * -1 * t * _3036 / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * -1 * t * _3036 / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3771 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3771]:
                                                return (0 < maxReportDelay * -1 * t * _3036 / 10^18 / 31556952)
                                            if profitFactor * mem[_3771] / mem[_3771] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3771] < maxReportDelay * -1 * t * _3036 / 10^18 / 31556952
                                        else:
                                            _3550 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_3550 + 96]
                                            mem[_3550 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_3550 + 96]
                                            mem[_3550 + 160] = wantAddress
                                            mem[_3550 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3550 + 196] = arg1
                                            mem[_3550 + 228] = 64
                                            mem[_3550 + 260] = mem[_3550 + 96]
                                            idx = 0
                                            s = _3550 + 292
                                            u = _3550 + 128
                                            while idx < mem[_3550 + 96]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3550 + (32 * mem[_3550 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5232 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5286 = mem[_5232]
                                            require mem[_5232] <= test266151307()
                                            require _5232 + return_data.size > _5232 + mem[_5232] + 31
                                            _5342 = mem[_5232 + mem[_5232]]
                                            require mem[_5232 + mem[_5232]] <= test266151307()
                                            require (32 * mem[_5232 + mem[_5232]]) + 32 >= 0 and _5232 + ceil32(return_data.size) + (32 * mem[_5232 + mem[_5232]]) + 32 <= test266151307()
                                            mem[64] = _5232 + ceil32(return_data.size) + (32 * mem[_5232 + mem[_5232]]) + 32
                                            mem[_5232 + ceil32(return_data.size)] = _5342
                                            require return_data.size >= _5286 + (32 * _5342) + 32
                                            mem[_5232 + ceil32(return_data.size) + 32 len 32 * _5342] = mem[_5232 + _5286 + 32 len 32 * _5342]
                                            require _5342 - 1 < _5342
                                            if not mem[(32 * _5342 - 1) + _5232 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * -1 * t * _3036 / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _5342 - 1) + _5232 + ceil32(return_data.size) + 32] / mem[(32 * _5342 - 1) + _5232 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5342 - 1) + _5232 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _3036 / 10^18 / 31556952
                                else:
                                    if _2910 * mem[_3019] / mem[_3019] != _2910:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3213 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3213] = 26
                                    mem[_3213 + 32] = 'SafeMath: division by zero'
                                    if not (_2910 * _3036) - (t * _3036) / 10^18:
                                        _3377 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3377] = 26
                                        mem[_3377 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3769 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3769]:
                                                return 0
                                            if profitFactor * mem[_3769] / mem[_3769] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3769] < 0
                                        else:
                                            _3547 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_3547 + 96]
                                            mem[_3547 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_3547 + 96]
                                            mem[_3547 + 160] = wantAddress
                                            mem[_3547 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3547 + 196] = arg1
                                            mem[_3547 + 228] = 64
                                            mem[_3547 + 260] = mem[_3547 + 96]
                                            idx = 0
                                            s = _3547 + 292
                                            t = _3547 + 128
                                            while idx < mem[_3547 + 96]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3547 + (32 * mem[_3547 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5231 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5285 = mem[_5231]
                                            require mem[_5231] <= test266151307()
                                            require _5231 + return_data.size > _5231 + mem[_5231] + 31
                                            _5341 = mem[_5231 + mem[_5231]]
                                            require mem[_5231 + mem[_5231]] <= test266151307()
                                            require (32 * mem[_5231 + mem[_5231]]) + 32 >= 0 and _5231 + ceil32(return_data.size) + (32 * mem[_5231 + mem[_5231]]) + 32 <= test266151307()
                                            mem[64] = _5231 + ceil32(return_data.size) + (32 * mem[_5231 + mem[_5231]]) + 32
                                            mem[_5231 + ceil32(return_data.size)] = _5341
                                            require return_data.size >= _5285 + (32 * _5341) + 32
                                            mem[_5231 + ceil32(return_data.size) + 32 len 32 * _5341] = mem[_5231 + _5285 + 32 len 32 * _5341]
                                            require _5341 - 1 < _5341
                                            if not mem[(32 * _5341 - 1) + _5231 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _5341 - 1) + _5231 + ceil32(return_data.size) + 32] / mem[(32 * _5341 - 1) + _5231 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5341 - 1) + _5231 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * (_2910 * _3036) - (t * _3036) / 10^18 / (_2910 * _3036) - (t * _3036) / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _3403 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3403] = 26
                                        mem[_3403 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * (_2910 * _3036) - (t * _3036) / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * (_2910 * _3036) - (t * _3036) / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3838 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3838]:
                                                return (0 < maxReportDelay * (_2910 * _3036) - (t * _3036) / 10^18 / 31556952)
                                            if profitFactor * mem[_3838] / mem[_3838] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3838] < maxReportDelay * (_2910 * _3036) - (t * _3036) / 10^18 / 31556952
                                        else:
                                            _3629 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_3629 + 96]
                                            mem[_3629 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_3629 + 96]
                                            mem[_3629 + 160] = wantAddress
                                            mem[_3629 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3629 + 196] = arg1
                                            mem[_3629 + 228] = 64
                                            mem[_3629 + 260] = mem[_3629 + 96]
                                            idx = 0
                                            s = _3629 + 292
                                            u = _3629 + 128
                                            while idx < mem[_3629 + 96]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3629 + (32 * mem[_3629 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5230 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5284 = mem[_5230]
                                            require mem[_5230] <= test266151307()
                                            require _5230 + return_data.size > _5230 + mem[_5230] + 31
                                            _5340 = mem[_5230 + mem[_5230]]
                                            require mem[_5230 + mem[_5230]] <= test266151307()
                                            require (32 * mem[_5230 + mem[_5230]]) + 32 >= 0 and _5230 + ceil32(return_data.size) + (32 * mem[_5230 + mem[_5230]]) + 32 <= test266151307()
                                            mem[64] = _5230 + ceil32(return_data.size) + (32 * mem[_5230 + mem[_5230]]) + 32
                                            mem[_5230 + ceil32(return_data.size)] = _5340
                                            require return_data.size >= _5284 + (32 * _5340) + 32
                                            mem[_5230 + ceil32(return_data.size) + 32 len 32 * _5340] = mem[_5230 + _5284 + 32 len 32 * _5340]
                                            require _5340 - 1 < _5340
                                            if not mem[(32 * _5340 - 1) + _5230 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * (_2910 * _3036) - (t * _3036) / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _5340 - 1) + _5230 + ceil32(return_data.size) + 32] / mem[(32 * _5340 - 1) + _5230 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5340 - 1) + _5230 + ceil32(return_data.size) + 32] < maxReportDelay * (_2910 * _3036) - (t * _3036) / 10^18 / 31556952
                        else:
                            if ext_call.return_data[0] * profitFactor / profitFactor != ext_call.return_data[0]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if ext_call.return_data[0] * profitFactor < mem[_898]:
                                return 0
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _979 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _986 = mem[_979]
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1465 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1465] == bool(mem[_1465])
                                if not mem[_1465]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1576 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _1609 = mem[_1576]
                                if mem[_1576] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1663 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_1663]
                                t = _1609
                                continue 
                            if _986 + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 12
                                mem[mem[64] + 4] = _986
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args _986
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2865 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_2865] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_2865]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 12
                            mem[mem[64] + 4] = _986 + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args (_986 + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2864 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2908 = mem[_2864]
                            if mem[_2864] <= t:
                                return 0
                            require 0 < lenders.length
                            mem[0] = 12
                            require ext_code.size(lenders)
                            staticcall lenders.nav() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3017 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3035 = mem[_3017]
                            if not mem[_3017]:
                                _3165 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3165] = 26
                                mem[_3165 + 32] = 'SafeMath: division by zero'
                                _3338 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3338] = 26
                                mem[_3338 + 32] = 'SafeMath: division by zero'
                                if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                    if not arg1:
                                        return 0
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < 0)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3627 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_3627]:
                                        return 0
                                    if profitFactor * mem[_3627] / mem[_3627] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_3627] < 0
                                else:
                                    _3441 = mem[64]
                                    mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                    mem[mem[64] + 96] = 2
                                    mem[64] = mem[64] + 192
                                    require 0 < mem[_3441 + 96]
                                    mem[_3441 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                    require 1 < mem[_3441 + 96]
                                    mem[_3441 + 160] = wantAddress
                                    mem[_3441 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_3441 + 196] = arg1
                                    mem[_3441 + 228] = 64
                                    mem[_3441 + 260] = mem[_3441 + 96]
                                    idx = 0
                                    s = _3441 + 292
                                    t = _3441 + 128
                                    while idx < mem[_3441 + 96]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                    staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _3441 + (32 * mem[_3441 + 96]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5229 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5283 = mem[_5229]
                                    require mem[_5229] <= test266151307()
                                    require _5229 + return_data.size > _5229 + mem[_5229] + 31
                                    _5339 = mem[_5229 + mem[_5229]]
                                    require mem[_5229 + mem[_5229]] <= test266151307()
                                    require (32 * mem[_5229 + mem[_5229]]) + 32 >= 0 and _5229 + ceil32(return_data.size) + (32 * mem[_5229 + mem[_5229]]) + 32 <= test266151307()
                                    mem[64] = _5229 + ceil32(return_data.size) + (32 * mem[_5229 + mem[_5229]]) + 32
                                    mem[_5229 + ceil32(return_data.size)] = _5339
                                    require return_data.size >= _5283 + (32 * _5339) + 32
                                    mem[_5229 + ceil32(return_data.size) + 32 len 32 * _5339] = mem[_5229 + _5283 + 32 len 32 * _5339]
                                    require _5339 - 1 < _5339
                                    if not mem[(32 * _5339 - 1) + _5229 + ceil32(return_data.size) + 32]:
                                        return 0
                                    if profitFactor * mem[(32 * _5339 - 1) + _5229 + ceil32(return_data.size) + 32] / mem[(32 * _5339 - 1) + _5229 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _5339 - 1) + _5229 + ceil32(return_data.size) + 32] < 0
                            else:
                                if t * mem[_3017] / mem[_3017] != t:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not mem[_3017]:
                                    _3202 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3202] = 26
                                    mem[_3202 + 32] = 'SafeMath: division by zero'
                                    if not -1 * t * _3035 / 10^18:
                                        _3357 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3357] = 26
                                        mem[_3357 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3705 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3705]:
                                                return 0
                                            if profitFactor * mem[_3705] / mem[_3705] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3705] < 0
                                        else:
                                            _3479 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_3479 + 96]
                                            mem[_3479 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_3479 + 96]
                                            mem[_3479 + 160] = wantAddress
                                            mem[_3479 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3479 + 196] = arg1
                                            mem[_3479 + 228] = 64
                                            mem[_3479 + 260] = mem[_3479 + 96]
                                            idx = 0
                                            s = _3479 + 292
                                            t = _3479 + 128
                                            while idx < mem[_3479 + 96]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3479 + (32 * mem[_3479 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5228 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5282 = mem[_5228]
                                            require mem[_5228] <= test266151307()
                                            require _5228 + return_data.size > _5228 + mem[_5228] + 31
                                            _5338 = mem[_5228 + mem[_5228]]
                                            require mem[_5228 + mem[_5228]] <= test266151307()
                                            require (32 * mem[_5228 + mem[_5228]]) + 32 >= 0 and _5228 + ceil32(return_data.size) + (32 * mem[_5228 + mem[_5228]]) + 32 <= test266151307()
                                            mem[64] = _5228 + ceil32(return_data.size) + (32 * mem[_5228 + mem[_5228]]) + 32
                                            mem[_5228 + ceil32(return_data.size)] = _5338
                                            require return_data.size >= _5282 + (32 * _5338) + 32
                                            mem[_5228 + ceil32(return_data.size) + 32 len 32 * _5338] = mem[_5228 + _5282 + 32 len 32 * _5338]
                                            require _5338 - 1 < _5338
                                            if not mem[(32 * _5338 - 1) + _5228 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _5338 - 1) + _5228 + ceil32(return_data.size) + 32] / mem[(32 * _5338 - 1) + _5228 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5338 - 1) + _5228 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * -1 * t * _3035 / 10^18 / -1 * t * _3035 / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _3375 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3375] = 26
                                        mem[_3375 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * -1 * t * _3035 / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * -1 * t * _3035 / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3763 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3763]:
                                                return (0 < maxReportDelay * -1 * t * _3035 / 10^18 / 31556952)
                                            if profitFactor * mem[_3763] / mem[_3763] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3763] < maxReportDelay * -1 * t * _3035 / 10^18 / 31556952
                                        else:
                                            _3540 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_3540 + 96]
                                            mem[_3540 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_3540 + 96]
                                            mem[_3540 + 160] = wantAddress
                                            mem[_3540 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3540 + 196] = arg1
                                            mem[_3540 + 228] = 64
                                            mem[_3540 + 260] = mem[_3540 + 96]
                                            idx = 0
                                            s = _3540 + 292
                                            u = _3540 + 128
                                            while idx < mem[_3540 + 96]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3540 + (32 * mem[_3540 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5227 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5281 = mem[_5227]
                                            require mem[_5227] <= test266151307()
                                            require _5227 + return_data.size > _5227 + mem[_5227] + 31
                                            _5337 = mem[_5227 + mem[_5227]]
                                            require mem[_5227 + mem[_5227]] <= test266151307()
                                            require (32 * mem[_5227 + mem[_5227]]) + 32 >= 0 and _5227 + ceil32(return_data.size) + (32 * mem[_5227 + mem[_5227]]) + 32 <= test266151307()
                                            mem[64] = _5227 + ceil32(return_data.size) + (32 * mem[_5227 + mem[_5227]]) + 32
                                            mem[_5227 + ceil32(return_data.size)] = _5337
                                            require return_data.size >= _5281 + (32 * _5337) + 32
                                            mem[_5227 + ceil32(return_data.size) + 32 len 32 * _5337] = mem[_5227 + _5281 + 32 len 32 * _5337]
                                            require _5337 - 1 < _5337
                                            if not mem[(32 * _5337 - 1) + _5227 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * -1 * t * _3035 / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _5337 - 1) + _5227 + ceil32(return_data.size) + 32] / mem[(32 * _5337 - 1) + _5227 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5337 - 1) + _5227 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _3035 / 10^18 / 31556952
                                else:
                                    if _2908 * mem[_3017] / mem[_3017] != _2908:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3211 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3211] = 26
                                    mem[_3211 + 32] = 'SafeMath: division by zero'
                                    if not (_2908 * _3035) - (t * _3035) / 10^18:
                                        _3374 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3374] = 26
                                        mem[_3374 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3761 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3761]:
                                                return 0
                                            if profitFactor * mem[_3761] / mem[_3761] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3761] < 0
                                        else:
                                            _3537 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_3537 + 96]
                                            mem[_3537 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_3537 + 96]
                                            mem[_3537 + 160] = wantAddress
                                            mem[_3537 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3537 + 196] = arg1
                                            mem[_3537 + 228] = 64
                                            mem[_3537 + 260] = mem[_3537 + 96]
                                            idx = 0
                                            s = _3537 + 292
                                            t = _3537 + 128
                                            while idx < mem[_3537 + 96]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3537 + (32 * mem[_3537 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5226 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5280 = mem[_5226]
                                            require mem[_5226] <= test266151307()
                                            require _5226 + return_data.size > _5226 + mem[_5226] + 31
                                            _5336 = mem[_5226 + mem[_5226]]
                                            require mem[_5226 + mem[_5226]] <= test266151307()
                                            require (32 * mem[_5226 + mem[_5226]]) + 32 >= 0 and _5226 + ceil32(return_data.size) + (32 * mem[_5226 + mem[_5226]]) + 32 <= test266151307()
                                            mem[64] = _5226 + ceil32(return_data.size) + (32 * mem[_5226 + mem[_5226]]) + 32
                                            mem[_5226 + ceil32(return_data.size)] = _5336
                                            require return_data.size >= _5280 + (32 * _5336) + 32
                                            mem[_5226 + ceil32(return_data.size) + 32 len 32 * _5336] = mem[_5226 + _5280 + 32 len 32 * _5336]
                                            require _5336 - 1 < _5336
                                            if not mem[(32 * _5336 - 1) + _5226 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _5336 - 1) + _5226 + ceil32(return_data.size) + 32] / mem[(32 * _5336 - 1) + _5226 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5336 - 1) + _5226 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * (_2908 * _3035) - (t * _3035) / 10^18 / (_2908 * _3035) - (t * _3035) / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _3401 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3401] = 26
                                        mem[_3401 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * (_2908 * _3035) - (t * _3035) / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * (_2908 * _3035) - (t * _3035) / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3829 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3829]:
                                                return (0 < maxReportDelay * (_2908 * _3035) - (t * _3035) / 10^18 / 31556952)
                                            if profitFactor * mem[_3829] / mem[_3829] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3829] < maxReportDelay * (_2908 * _3035) - (t * _3035) / 10^18 / 31556952
                                        else:
                                            _3619 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_3619 + 96]
                                            mem[_3619 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_3619 + 96]
                                            mem[_3619 + 160] = wantAddress
                                            mem[_3619 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3619 + 196] = arg1
                                            mem[_3619 + 228] = 64
                                            mem[_3619 + 260] = mem[_3619 + 96]
                                            idx = 0
                                            s = _3619 + 292
                                            u = _3619 + 128
                                            while idx < mem[_3619 + 96]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3619 + (32 * mem[_3619 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5225 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5279 = mem[_5225]
                                            require mem[_5225] <= test266151307()
                                            require _5225 + return_data.size > _5225 + mem[_5225] + 31
                                            _5335 = mem[_5225 + mem[_5225]]
                                            require mem[_5225 + mem[_5225]] <= test266151307()
                                            require (32 * mem[_5225 + mem[_5225]]) + 32 >= 0 and _5225 + ceil32(return_data.size) + (32 * mem[_5225 + mem[_5225]]) + 32 <= test266151307()
                                            mem[64] = _5225 + ceil32(return_data.size) + (32 * mem[_5225 + mem[_5225]]) + 32
                                            mem[_5225 + ceil32(return_data.size)] = _5335
                                            require return_data.size >= _5279 + (32 * _5335) + 32
                                            mem[_5225 + ceil32(return_data.size) + 32 len 32 * _5335] = mem[_5225 + _5279 + 32 len 32 * _5335]
                                            require _5335 - 1 < _5335
                                            if not mem[(32 * _5335 - 1) + _5225 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * (_2908 * _3035) - (t * _3035) / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _5335 - 1) + _5225 + ceil32(return_data.size) + 32] / mem[(32 * _5335 - 1) + _5225 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5335 - 1) + _5225 + ceil32(return_data.size) + 32] < maxReportDelay * (_2908 * _3035) - (t * _3035) / 10^18 / 31556952
                    else:
                        _885 = mem[(2 * ceil32(return_data.size)) + 576]
                        _891 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_891] = 30
                        mem[_891 + 32] = 'SafeMath: subtraction overflow'
                        if _885 > _818 + (_802 * lenders.length):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        require ext_code.size(vaultAddress)
                        staticcall vaultAddress.creditAvailable() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _922 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _818 + (_802 * lenders.length) - _885 + mem[_922] < mem[_922]:
                            revert with 0, 'SafeMath: addition overflow'
                        if not profitFactor:
                            if 0 < _818 + (_802 * lenders.length) - _885 + mem[_922]:
                                return 0
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1009 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _1030 = mem[_1009]
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1468 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1468] == bool(mem[_1468])
                                if not mem[_1468]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1579 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _1612 = mem[_1579]
                                if mem[_1579] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1666 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_1666]
                                t = _1612
                                continue 
                            if _1030 + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 12
                                mem[mem[64] + 4] = _1030
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args _1030
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2871 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_2871] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_2871]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 12
                            mem[mem[64] + 4] = _1030 + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args (_1030 + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2870 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2914 = mem[_2870]
                            if mem[_2870] <= t:
                                return 0
                            require 0 < lenders.length
                            mem[0] = 12
                            require ext_code.size(lenders)
                            staticcall lenders.nav() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3023 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3038 = mem[_3023]
                            if not mem[_3023]:
                                _3171 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3171] = 26
                                mem[_3171 + 32] = 'SafeMath: division by zero'
                                _3344 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3344] = 26
                                mem[_3344 + 32] = 'SafeMath: division by zero'
                                if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                    if not arg1:
                                        return 0
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < 0)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3657 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_3657]:
                                        return 0
                                    if profitFactor * mem[_3657] / mem[_3657] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_3657] < 0
                                else:
                                    _3453 = mem[64]
                                    mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                    mem[mem[64] + 96] = 2
                                    mem[64] = mem[64] + 192
                                    require 0 < mem[_3453 + 96]
                                    mem[_3453 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                    require 1 < mem[_3453 + 96]
                                    mem[_3453 + 160] = wantAddress
                                    mem[_3453 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_3453 + 196] = arg1
                                    mem[_3453 + 228] = 64
                                    mem[_3453 + 260] = mem[_3453 + 96]
                                    idx = 0
                                    s = _3453 + 292
                                    t = _3453 + 128
                                    while idx < mem[_3453 + 96]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                    staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _3453 + (32 * mem[_3453 + 96]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5244 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5298 = mem[_5244]
                                    require mem[_5244] <= test266151307()
                                    require _5244 + return_data.size > _5244 + mem[_5244] + 31
                                    _5354 = mem[_5244 + mem[_5244]]
                                    require mem[_5244 + mem[_5244]] <= test266151307()
                                    require (32 * mem[_5244 + mem[_5244]]) + 32 >= 0 and _5244 + ceil32(return_data.size) + (32 * mem[_5244 + mem[_5244]]) + 32 <= test266151307()
                                    mem[64] = _5244 + ceil32(return_data.size) + (32 * mem[_5244 + mem[_5244]]) + 32
                                    mem[_5244 + ceil32(return_data.size)] = _5354
                                    require return_data.size >= _5298 + (32 * _5354) + 32
                                    mem[_5244 + ceil32(return_data.size) + 32 len 32 * _5354] = mem[_5244 + _5298 + 32 len 32 * _5354]
                                    require _5354 - 1 < _5354
                                    if not mem[(32 * _5354 - 1) + _5244 + ceil32(return_data.size) + 32]:
                                        return 0
                                    if profitFactor * mem[(32 * _5354 - 1) + _5244 + ceil32(return_data.size) + 32] / mem[(32 * _5354 - 1) + _5244 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _5354 - 1) + _5244 + ceil32(return_data.size) + 32] < 0
                            else:
                                if t * mem[_3023] / mem[_3023] != t:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not mem[_3023]:
                                    _3205 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3205] = 26
                                    mem[_3205 + 32] = 'SafeMath: division by zero'
                                    if not -1 * t * _3038 / 10^18:
                                        _3363 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3363] = 26
                                        mem[_3363 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3726 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3726]:
                                                return 0
                                            if profitFactor * mem[_3726] / mem[_3726] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3726] < 0
                                        else:
                                            _3500 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_3500 + 96]
                                            mem[_3500 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_3500 + 96]
                                            mem[_3500 + 160] = wantAddress
                                            mem[_3500 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3500 + 196] = arg1
                                            mem[_3500 + 228] = 64
                                            mem[_3500 + 260] = mem[_3500 + 96]
                                            idx = 0
                                            s = _3500 + 292
                                            t = _3500 + 128
                                            while idx < mem[_3500 + 96]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3500 + (32 * mem[_3500 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5243 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5297 = mem[_5243]
                                            require mem[_5243] <= test266151307()
                                            require _5243 + return_data.size > _5243 + mem[_5243] + 31
                                            _5353 = mem[_5243 + mem[_5243]]
                                            require mem[_5243 + mem[_5243]] <= test266151307()
                                            require (32 * mem[_5243 + mem[_5243]]) + 32 >= 0 and _5243 + ceil32(return_data.size) + (32 * mem[_5243 + mem[_5243]]) + 32 <= test266151307()
                                            mem[64] = _5243 + ceil32(return_data.size) + (32 * mem[_5243 + mem[_5243]]) + 32
                                            mem[_5243 + ceil32(return_data.size)] = _5353
                                            require return_data.size >= _5297 + (32 * _5353) + 32
                                            mem[_5243 + ceil32(return_data.size) + 32 len 32 * _5353] = mem[_5243 + _5297 + 32 len 32 * _5353]
                                            require _5353 - 1 < _5353
                                            if not mem[(32 * _5353 - 1) + _5243 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _5353 - 1) + _5243 + ceil32(return_data.size) + 32] / mem[(32 * _5353 - 1) + _5243 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5353 - 1) + _5243 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * -1 * t * _3038 / 10^18 / -1 * t * _3038 / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _3384 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3384] = 26
                                        mem[_3384 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * -1 * t * _3038 / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * -1 * t * _3038 / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3787 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3787]:
                                                return (0 < maxReportDelay * -1 * t * _3038 / 10^18 / 31556952)
                                            if profitFactor * mem[_3787] / mem[_3787] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3787] < maxReportDelay * -1 * t * _3038 / 10^18 / 31556952
                                        else:
                                            _3570 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_3570 + 96]
                                            mem[_3570 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_3570 + 96]
                                            mem[_3570 + 160] = wantAddress
                                            mem[_3570 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3570 + 196] = arg1
                                            mem[_3570 + 228] = 64
                                            mem[_3570 + 260] = mem[_3570 + 96]
                                            idx = 0
                                            s = _3570 + 292
                                            u = _3570 + 128
                                            while idx < mem[_3570 + 96]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3570 + (32 * mem[_3570 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5242 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5296 = mem[_5242]
                                            require mem[_5242] <= test266151307()
                                            require _5242 + return_data.size > _5242 + mem[_5242] + 31
                                            _5352 = mem[_5242 + mem[_5242]]
                                            require mem[_5242 + mem[_5242]] <= test266151307()
                                            require (32 * mem[_5242 + mem[_5242]]) + 32 >= 0 and _5242 + ceil32(return_data.size) + (32 * mem[_5242 + mem[_5242]]) + 32 <= test266151307()
                                            mem[64] = _5242 + ceil32(return_data.size) + (32 * mem[_5242 + mem[_5242]]) + 32
                                            mem[_5242 + ceil32(return_data.size)] = _5352
                                            require return_data.size >= _5296 + (32 * _5352) + 32
                                            mem[_5242 + ceil32(return_data.size) + 32 len 32 * _5352] = mem[_5242 + _5296 + 32 len 32 * _5352]
                                            require _5352 - 1 < _5352
                                            if not mem[(32 * _5352 - 1) + _5242 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * -1 * t * _3038 / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _5352 - 1) + _5242 + ceil32(return_data.size) + 32] / mem[(32 * _5352 - 1) + _5242 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5352 - 1) + _5242 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _3038 / 10^18 / 31556952
                                else:
                                    if _2914 * mem[_3023] / mem[_3023] != _2914:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3217 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3217] = 26
                                    mem[_3217 + 32] = 'SafeMath: division by zero'
                                    if not (_2914 * _3038) - (t * _3038) / 10^18:
                                        _3383 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3383] = 26
                                        mem[_3383 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3785 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3785]:
                                                return 0
                                            if profitFactor * mem[_3785] / mem[_3785] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3785] < 0
                                        else:
                                            _3567 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_3567 + 96]
                                            mem[_3567 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_3567 + 96]
                                            mem[_3567 + 160] = wantAddress
                                            mem[_3567 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3567 + 196] = arg1
                                            mem[_3567 + 228] = 64
                                            mem[_3567 + 260] = mem[_3567 + 96]
                                            idx = 0
                                            s = _3567 + 292
                                            t = _3567 + 128
                                            while idx < mem[_3567 + 96]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3567 + (32 * mem[_3567 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5241 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5295 = mem[_5241]
                                            require mem[_5241] <= test266151307()
                                            require _5241 + return_data.size > _5241 + mem[_5241] + 31
                                            _5351 = mem[_5241 + mem[_5241]]
                                            require mem[_5241 + mem[_5241]] <= test266151307()
                                            require (32 * mem[_5241 + mem[_5241]]) + 32 >= 0 and _5241 + ceil32(return_data.size) + (32 * mem[_5241 + mem[_5241]]) + 32 <= test266151307()
                                            mem[64] = _5241 + ceil32(return_data.size) + (32 * mem[_5241 + mem[_5241]]) + 32
                                            mem[_5241 + ceil32(return_data.size)] = _5351
                                            require return_data.size >= _5295 + (32 * _5351) + 32
                                            mem[_5241 + ceil32(return_data.size) + 32 len 32 * _5351] = mem[_5241 + _5295 + 32 len 32 * _5351]
                                            require _5351 - 1 < _5351
                                            if not mem[(32 * _5351 - 1) + _5241 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _5351 - 1) + _5241 + ceil32(return_data.size) + 32] / mem[(32 * _5351 - 1) + _5241 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5351 - 1) + _5241 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * (_2914 * _3038) - (t * _3038) / 10^18 / (_2914 * _3038) - (t * _3038) / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _3407 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3407] = 26
                                        mem[_3407 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * (_2914 * _3038) - (t * _3038) / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * (_2914 * _3038) - (t * _3038) / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3856 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3856]:
                                                return (0 < maxReportDelay * (_2914 * _3038) - (t * _3038) / 10^18 / 31556952)
                                            if profitFactor * mem[_3856] / mem[_3856] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3856] < maxReportDelay * (_2914 * _3038) - (t * _3038) / 10^18 / 31556952
                                        else:
                                            _3649 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_3649 + 96]
                                            mem[_3649 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_3649 + 96]
                                            mem[_3649 + 160] = wantAddress
                                            mem[_3649 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3649 + 196] = arg1
                                            mem[_3649 + 228] = 64
                                            mem[_3649 + 260] = mem[_3649 + 96]
                                            idx = 0
                                            s = _3649 + 292
                                            u = _3649 + 128
                                            while idx < mem[_3649 + 96]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3649 + (32 * mem[_3649 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5240 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5294 = mem[_5240]
                                            require mem[_5240] <= test266151307()
                                            require _5240 + return_data.size > _5240 + mem[_5240] + 31
                                            _5350 = mem[_5240 + mem[_5240]]
                                            require mem[_5240 + mem[_5240]] <= test266151307()
                                            require (32 * mem[_5240 + mem[_5240]]) + 32 >= 0 and _5240 + ceil32(return_data.size) + (32 * mem[_5240 + mem[_5240]]) + 32 <= test266151307()
                                            mem[64] = _5240 + ceil32(return_data.size) + (32 * mem[_5240 + mem[_5240]]) + 32
                                            mem[_5240 + ceil32(return_data.size)] = _5350
                                            require return_data.size >= _5294 + (32 * _5350) + 32
                                            mem[_5240 + ceil32(return_data.size) + 32 len 32 * _5350] = mem[_5240 + _5294 + 32 len 32 * _5350]
                                            require _5350 - 1 < _5350
                                            if not mem[(32 * _5350 - 1) + _5240 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * (_2914 * _3038) - (t * _3038) / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _5350 - 1) + _5240 + ceil32(return_data.size) + 32] / mem[(32 * _5350 - 1) + _5240 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5350 - 1) + _5240 + ceil32(return_data.size) + 32] < maxReportDelay * (_2914 * _3038) - (t * _3038) / 10^18 / 31556952
                        else:
                            if ext_call.return_data[0] * profitFactor / profitFactor != ext_call.return_data[0]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if ext_call.return_data[0] * profitFactor < _818 + (_802 * lenders.length) - _885 + mem[_922]:
                                return 0
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1020 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _1036 = mem[_1020]
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1467 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1467] == bool(mem[_1467])
                                if not mem[_1467]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1578 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _1611 = mem[_1578]
                                if mem[_1578] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1665 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_1665]
                                t = _1611
                                continue 
                            if _1036 + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 12
                                mem[mem[64] + 4] = _1036
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args _1036
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2869 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_2869] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_2869]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 12
                            mem[mem[64] + 4] = _1036 + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args (_1036 + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2868 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2912 = mem[_2868]
                            if mem[_2868] <= t:
                                return 0
                            require 0 < lenders.length
                            mem[0] = 12
                            require ext_code.size(lenders)
                            staticcall lenders.nav() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3021 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3037 = mem[_3021]
                            if not mem[_3021]:
                                _3169 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3169] = 26
                                mem[_3169 + 32] = 'SafeMath: division by zero'
                                _3342 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3342] = 26
                                mem[_3342 + 32] = 'SafeMath: division by zero'
                                if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                    if not arg1:
                                        return 0
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < 0)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _3647 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_3647]:
                                        return 0
                                    if profitFactor * mem[_3647] / mem[_3647] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_3647] < 0
                                else:
                                    _3449 = mem[64]
                                    mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                    mem[mem[64] + 96] = 2
                                    mem[64] = mem[64] + 192
                                    require 0 < mem[_3449 + 96]
                                    mem[_3449 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                    require 1 < mem[_3449 + 96]
                                    mem[_3449 + 160] = wantAddress
                                    mem[_3449 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_3449 + 196] = arg1
                                    mem[_3449 + 228] = 64
                                    mem[_3449 + 260] = mem[_3449 + 96]
                                    idx = 0
                                    s = _3449 + 292
                                    t = _3449 + 128
                                    while idx < mem[_3449 + 96]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                    staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _3449 + (32 * mem[_3449 + 96]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _5239 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _5293 = mem[_5239]
                                    require mem[_5239] <= test266151307()
                                    require _5239 + return_data.size > _5239 + mem[_5239] + 31
                                    _5349 = mem[_5239 + mem[_5239]]
                                    require mem[_5239 + mem[_5239]] <= test266151307()
                                    require (32 * mem[_5239 + mem[_5239]]) + 32 >= 0 and _5239 + ceil32(return_data.size) + (32 * mem[_5239 + mem[_5239]]) + 32 <= test266151307()
                                    mem[64] = _5239 + ceil32(return_data.size) + (32 * mem[_5239 + mem[_5239]]) + 32
                                    mem[_5239 + ceil32(return_data.size)] = _5349
                                    require return_data.size >= _5293 + (32 * _5349) + 32
                                    mem[_5239 + ceil32(return_data.size) + 32 len 32 * _5349] = mem[_5239 + _5293 + 32 len 32 * _5349]
                                    require _5349 - 1 < _5349
                                    if not mem[(32 * _5349 - 1) + _5239 + ceil32(return_data.size) + 32]:
                                        return 0
                                    if profitFactor * mem[(32 * _5349 - 1) + _5239 + ceil32(return_data.size) + 32] / mem[(32 * _5349 - 1) + _5239 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _5349 - 1) + _5239 + ceil32(return_data.size) + 32] < 0
                            else:
                                if t * mem[_3021] / mem[_3021] != t:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not mem[_3021]:
                                    _3204 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3204] = 26
                                    mem[_3204 + 32] = 'SafeMath: division by zero'
                                    if not -1 * t * _3037 / 10^18:
                                        _3361 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3361] = 26
                                        mem[_3361 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3719 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3719]:
                                                return 0
                                            if profitFactor * mem[_3719] / mem[_3719] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3719] < 0
                                        else:
                                            _3493 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_3493 + 96]
                                            mem[_3493 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_3493 + 96]
                                            mem[_3493 + 160] = wantAddress
                                            mem[_3493 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3493 + 196] = arg1
                                            mem[_3493 + 228] = 64
                                            mem[_3493 + 260] = mem[_3493 + 96]
                                            idx = 0
                                            s = _3493 + 292
                                            t = _3493 + 128
                                            while idx < mem[_3493 + 96]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3493 + (32 * mem[_3493 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5238 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5292 = mem[_5238]
                                            require mem[_5238] <= test266151307()
                                            require _5238 + return_data.size > _5238 + mem[_5238] + 31
                                            _5348 = mem[_5238 + mem[_5238]]
                                            require mem[_5238 + mem[_5238]] <= test266151307()
                                            require (32 * mem[_5238 + mem[_5238]]) + 32 >= 0 and _5238 + ceil32(return_data.size) + (32 * mem[_5238 + mem[_5238]]) + 32 <= test266151307()
                                            mem[64] = _5238 + ceil32(return_data.size) + (32 * mem[_5238 + mem[_5238]]) + 32
                                            mem[_5238 + ceil32(return_data.size)] = _5348
                                            require return_data.size >= _5292 + (32 * _5348) + 32
                                            mem[_5238 + ceil32(return_data.size) + 32 len 32 * _5348] = mem[_5238 + _5292 + 32 len 32 * _5348]
                                            require _5348 - 1 < _5348
                                            if not mem[(32 * _5348 - 1) + _5238 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _5348 - 1) + _5238 + ceil32(return_data.size) + 32] / mem[(32 * _5348 - 1) + _5238 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5348 - 1) + _5238 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * -1 * t * _3037 / 10^18 / -1 * t * _3037 / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _3381 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3381] = 26
                                        mem[_3381 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * -1 * t * _3037 / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * -1 * t * _3037 / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3779 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3779]:
                                                return (0 < maxReportDelay * -1 * t * _3037 / 10^18 / 31556952)
                                            if profitFactor * mem[_3779] / mem[_3779] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3779] < maxReportDelay * -1 * t * _3037 / 10^18 / 31556952
                                        else:
                                            _3560 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_3560 + 96]
                                            mem[_3560 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_3560 + 96]
                                            mem[_3560 + 160] = wantAddress
                                            mem[_3560 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3560 + 196] = arg1
                                            mem[_3560 + 228] = 64
                                            mem[_3560 + 260] = mem[_3560 + 96]
                                            idx = 0
                                            s = _3560 + 292
                                            u = _3560 + 128
                                            while idx < mem[_3560 + 96]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3560 + (32 * mem[_3560 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5237 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5291 = mem[_5237]
                                            require mem[_5237] <= test266151307()
                                            require _5237 + return_data.size > _5237 + mem[_5237] + 31
                                            _5347 = mem[_5237 + mem[_5237]]
                                            require mem[_5237 + mem[_5237]] <= test266151307()
                                            require (32 * mem[_5237 + mem[_5237]]) + 32 >= 0 and _5237 + ceil32(return_data.size) + (32 * mem[_5237 + mem[_5237]]) + 32 <= test266151307()
                                            mem[64] = _5237 + ceil32(return_data.size) + (32 * mem[_5237 + mem[_5237]]) + 32
                                            mem[_5237 + ceil32(return_data.size)] = _5347
                                            require return_data.size >= _5291 + (32 * _5347) + 32
                                            mem[_5237 + ceil32(return_data.size) + 32 len 32 * _5347] = mem[_5237 + _5291 + 32 len 32 * _5347]
                                            require _5347 - 1 < _5347
                                            if not mem[(32 * _5347 - 1) + _5237 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * -1 * t * _3037 / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _5347 - 1) + _5237 + ceil32(return_data.size) + 32] / mem[(32 * _5347 - 1) + _5237 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5347 - 1) + _5237 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _3037 / 10^18 / 31556952
                                else:
                                    if _2912 * mem[_3021] / mem[_3021] != _2912:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _3215 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3215] = 26
                                    mem[_3215 + 32] = 'SafeMath: division by zero'
                                    if not (_2912 * _3037) - (t * _3037) / 10^18:
                                        _3380 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3380] = 26
                                        mem[_3380 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3777 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3777]:
                                                return 0
                                            if profitFactor * mem[_3777] / mem[_3777] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3777] < 0
                                        else:
                                            _3557 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_3557 + 96]
                                            mem[_3557 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_3557 + 96]
                                            mem[_3557 + 160] = wantAddress
                                            mem[_3557 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3557 + 196] = arg1
                                            mem[_3557 + 228] = 64
                                            mem[_3557 + 260] = mem[_3557 + 96]
                                            idx = 0
                                            s = _3557 + 292
                                            t = _3557 + 128
                                            while idx < mem[_3557 + 96]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3557 + (32 * mem[_3557 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5236 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5290 = mem[_5236]
                                            require mem[_5236] <= test266151307()
                                            require _5236 + return_data.size > _5236 + mem[_5236] + 31
                                            _5346 = mem[_5236 + mem[_5236]]
                                            require mem[_5236 + mem[_5236]] <= test266151307()
                                            require (32 * mem[_5236 + mem[_5236]]) + 32 >= 0 and _5236 + ceil32(return_data.size) + (32 * mem[_5236 + mem[_5236]]) + 32 <= test266151307()
                                            mem[64] = _5236 + ceil32(return_data.size) + (32 * mem[_5236 + mem[_5236]]) + 32
                                            mem[_5236 + ceil32(return_data.size)] = _5346
                                            require return_data.size >= _5290 + (32 * _5346) + 32
                                            mem[_5236 + ceil32(return_data.size) + 32 len 32 * _5346] = mem[_5236 + _5290 + 32 len 32 * _5346]
                                            require _5346 - 1 < _5346
                                            if not mem[(32 * _5346 - 1) + _5236 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _5346 - 1) + _5236 + ceil32(return_data.size) + 32] / mem[(32 * _5346 - 1) + _5236 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5346 - 1) + _5236 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * (_2912 * _3037) - (t * _3037) / 10^18 / (_2912 * _3037) - (t * _3037) / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _3405 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3405] = 26
                                        mem[_3405 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * (_2912 * _3037) - (t * _3037) / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * (_2912 * _3037) - (t * _3037) / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _3847 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_3847]:
                                                return (0 < maxReportDelay * (_2912 * _3037) - (t * _3037) / 10^18 / 31556952)
                                            if profitFactor * mem[_3847] / mem[_3847] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_3847] < maxReportDelay * (_2912 * _3037) - (t * _3037) / 10^18 / 31556952
                                        else:
                                            _3639 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_3639 + 96]
                                            mem[_3639 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_3639 + 96]
                                            mem[_3639 + 160] = wantAddress
                                            mem[_3639 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_3639 + 196] = arg1
                                            mem[_3639 + 228] = 64
                                            mem[_3639 + 260] = mem[_3639 + 96]
                                            idx = 0
                                            s = _3639 + 292
                                            u = _3639 + 128
                                            while idx < mem[_3639 + 96]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _3639 + (32 * mem[_3639 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _5235 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _5289 = mem[_5235]
                                            require mem[_5235] <= test266151307()
                                            require _5235 + return_data.size > _5235 + mem[_5235] + 31
                                            _5345 = mem[_5235 + mem[_5235]]
                                            require mem[_5235 + mem[_5235]] <= test266151307()
                                            require (32 * mem[_5235 + mem[_5235]]) + 32 >= 0 and _5235 + ceil32(return_data.size) + (32 * mem[_5235 + mem[_5235]]) + 32 <= test266151307()
                                            mem[64] = _5235 + ceil32(return_data.size) + (32 * mem[_5235 + mem[_5235]]) + 32
                                            mem[_5235 + ceil32(return_data.size)] = _5345
                                            require return_data.size >= _5289 + (32 * _5345) + 32
                                            mem[_5235 + ceil32(return_data.size) + 32 len 32 * _5345] = mem[_5235 + _5289 + 32 len 32 * _5345]
                                            require _5345 - 1 < _5345
                                            if not mem[(32 * _5345 - 1) + _5235 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * (_2912 * _3037) - (t * _3037) / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _5345 - 1) + _5235 + ceil32(return_data.size) + 32] / mem[(32 * _5345 - 1) + _5235 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _5345 - 1) + _5235 + ceil32(return_data.size) + 32] < maxReportDelay * (_2912 * _3037) - (t * _3037) / 10^18 / 31556952
        else:
            mem[96] = 2
            mem[128 len 64] = call.data[calldata.size len 64]
            mem[192] = 2
            mem[224] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
            mem[256] = wantAddress
            mem[288] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
            mem[292] = arg1
            mem[324] = 64
            mem[356] = 2
            idx = 0
            s = 388
            t = 224
            while idx < 2:
                mem[s] = mem[t + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.getAmountsOut(uint256 rg1, address[] rg2) with:
                    gas gas_remaining wei
                   args arg1, Array(len=2, data=mem[388 len 64])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[288 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(return_data.size) + 288
            require return_data.size >= 32
            _805 = mem[288 len 4], Mask(224, 32, arg1) >> 32
            require mem[288 len 4], Mask(224, 32, arg1) >> 32 <= test266151307()
            require return_data.size + 288 > mem[288 len 4], Mask(224, 32, arg1) >> 32 + 319
            _819 = mem[mem[288 len 4], Mask(224, 32, arg1) >> 32 + 288]
            require mem[mem[288 len 4], Mask(224, 32, arg1) >> 32 + 288] <= test266151307()
            require (32 * mem[mem[288 len 4], Mask(224, 32, arg1) >> 32 + 288]) + 32 >= 0 and ceil32(return_data.size) + (32 * mem[mem[288 len 4], Mask(224, 32, arg1) >> 32 + 288]) + 320 <= test266151307()
            mem[64] = ceil32(return_data.size) + (32 * mem[mem[288 len 4], Mask(224, 32, arg1) >> 32 + 288]) + 320
            mem[ceil32(return_data.size) + 288] = mem[mem[288 len 4], Mask(224, 32, arg1) >> 32 + 288]
            require return_data.size >= _805 + (32 * _819) + 32
            mem[ceil32(return_data.size) + 320 len 32 * _819] = mem[_805 + 320 len 32 * _819]
            require _819 - 1 < _819
            _1460 = mem[(32 * _819 - 1) + ceil32(return_data.size) + 320]
            _1529 = mem[64]
            mem[64] = mem[64] + 288
            mem[_1529] = 0
            mem[_1529 + 32] = 0
            mem[_1529 + 64] = 0
            mem[_1529 + 96] = 0
            mem[_1529 + 128] = 0
            mem[_1529 + 160] = 0
            mem[_1529 + 192] = 0
            mem[_1529 + 224] = 0
            mem[_1529 + 256] = 0
            require ext_code.size(vaultAddress)
            staticcall vaultAddress.strategies(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64] len 288] = ext_call.return_data[0 len 288]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1604 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 288
            _1627 = mem[64]
            require mem[64] + 288 >= mem[64] and mem[64] + 288 <= test266151307()
            mem[64] = mem[64] + 288
            mem[_1627] = mem[_1604]
            mem[_1627 + 32] = mem[_1604 + 32]
            mem[_1627 + 64] = mem[_1604 + 64]
            mem[_1627 + 96] = mem[_1604 + 96]
            mem[_1627 + 128] = mem[_1604 + 128]
            mem[_1627 + 160] = mem[_1604 + 160]
            mem[_1627 + 192] = mem[_1604 + 192]
            mem[_1627 + 224] = mem[_1604 + 224]
            mem[_1627 + 256] = mem[_1604 + 256]
            if 0 == mem[_1627 + 32]:
                mem[mem[64] + 4] = this.address
                require ext_code.size(wantAddress)
                staticcall wantAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1718 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1721 = mem[_1718]
                idx = 0
                s = 0
                t = -1
                while idx < lenders.length:
                    mem[0] = 12
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].hasAssets() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2839 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_2839] == bool(mem[_2839])
                    if not mem[_2839]:
                        idx = idx + 1
                        s = s
                        t = t
                        continue 
                    require idx < lenders.length
                    mem[0] = 12
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].apr() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2985 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3025 = mem[_2985]
                    if mem[_2985] >= t:
                        idx = idx + 1
                        s = s
                        t = t
                        continue 
                    require idx < lenders.length
                    mem[0] = 12
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].nav() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3126 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 1
                    s = mem[_3126]
                    t = _3025
                    continue 
                if _1721 + s < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = 0
                u = 0
                while idx < lenders.length:
                    mem[0] = 12
                    mem[mem[64] + 4] = _1721
                    require ext_code.size(lenders[idx])
                    staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                            gas gas_remaining wei
                           args _1721
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5306 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_5306] <= u:
                        idx = idx + 1
                        u = u
                        continue 
                    idx = idx + 1
                    u = mem[_5306]
                    continue 
                require 0 < lenders.length
                mem[0] = 12
                mem[mem[64] + 4] = _1721 + s
                require ext_code.size(lenders)
                staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                        gas gas_remaining wei
                       args (_1721 + s)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _5305 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _5357 = mem[_5305]
                if mem[_5305] <= t:
                    return 0
                require 0 < lenders.length
                mem[0] = 12
                require ext_code.size(lenders)
                staticcall lenders.nav() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _5552 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _5584 = mem[_5552]
                if not mem[_5552]:
                    _5792 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5792] = 26
                    mem[_5792 + 32] = 'SafeMath: division by zero'
                    _6022 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6022] = 26
                    mem[_6022 + 32] = 'SafeMath: division by zero'
                    if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                        if not arg1:
                            return 0
                        if profitFactor * arg1 / arg1 != profitFactor:
                            revert with 0, 'SafeMath: multiplication overflow'
                        return (profitFactor * arg1 < 0)
                    if wantToEthOracleAddress:
                        mem[mem[64] + 4] = arg1
                        require ext_code.size(wantToEthOracleAddress)
                        staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                gas gas_remaining wei
                               args arg1
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6099 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if not mem[_6099]:
                            return 0
                        if profitFactor * mem[_6099] / mem[_6099] != profitFactor:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[mem[64]] = profitFactor * mem[_6099] < 0
                    else:
                        _6044 = mem[64]
                        mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                        mem[mem[64] + 96] = 2
                        mem[64] = mem[64] + 192
                        require 0 < mem[_6044 + 96]
                        mem[_6044 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                        require 1 < mem[_6044 + 96]
                        mem[_6044 + 160] = wantAddress
                        mem[_6044 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[_6044 + 196] = arg1
                        mem[_6044 + 228] = 64
                        mem[_6044 + 260] = mem[_6044 + 96]
                        idx = 0
                        s = _6044 + 292
                        t = _6044 + 128
                        while idx < mem[_6044 + 96]:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                        staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4 len _6044 + (32 * mem[_6044 + 96]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6630 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _6648 = mem[_6630]
                        require mem[_6630] <= test266151307()
                        require _6630 + return_data.size > _6630 + mem[_6630] + 31
                        _6666 = mem[_6630 + mem[_6630]]
                        require mem[_6630 + mem[_6630]] <= test266151307()
                        require (32 * mem[_6630 + mem[_6630]]) + 32 >= 0 and _6630 + ceil32(return_data.size) + (32 * mem[_6630 + mem[_6630]]) + 32 <= test266151307()
                        mem[64] = _6630 + ceil32(return_data.size) + (32 * mem[_6630 + mem[_6630]]) + 32
                        mem[_6630 + ceil32(return_data.size)] = _6666
                        require return_data.size >= _6648 + (32 * _6666) + 32
                        mem[_6630 + ceil32(return_data.size) + 32 len 32 * _6666] = mem[_6630 + _6648 + 32 len 32 * _6666]
                        var140001 = _6630 + _6648 + (32 * _6666) + 32
                        require _6666 - 1 < _6666
                        if not mem[(32 * _6666 - 1) + _6630 + ceil32(return_data.size) + 32]:
                            return 0
                        if profitFactor * mem[(32 * _6666 - 1) + _6630 + ceil32(return_data.size) + 32] / mem[(32 * _6666 - 1) + _6630 + ceil32(return_data.size) + 32] != profitFactor:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[mem[64]] = profitFactor * mem[(32 * _6666 - 1) + _6630 + ceil32(return_data.size) + 32] < 0
                else:
                    if t * mem[_5552] / mem[_5552] != t:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if mem[_5552]:
                        if _5357 * mem[_5552] / mem[_5552] != _5357:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _5857 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5857] = 26
                        mem[_5857 + 32] = 'SafeMath: division by zero'
                        if (_5357 * _5584) - (t * _5584) / 10^18:
                            if maxReportDelay * (_5357 * _5584) - (t * _5584) / 10^18 / (_5357 * _5584) - (t * _5584) / 10^18 != maxReportDelay:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _6035 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6035] = 26
                            mem[_6035 + 32] = 'SafeMath: division by zero'
                            if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                if not arg1:
                                    return (0 < maxReportDelay * (_5357 * _5584) - (t * _5584) / 10^18 / 31556952)
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < maxReportDelay * (_5357 * _5584) - (t * _5584) / 10^18 / 31556952)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6140 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_6140]:
                                    return (0 < maxReportDelay * (_5357 * _5584) - (t * _5584) / 10^18 / 31556952)
                                if profitFactor * mem[_6140] / mem[_6140] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_6140] < maxReportDelay * (_5357 * _5584) - (t * _5584) / 10^18 / 31556952
                            else:
                                _6091 = mem[64]
                                mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                mem[mem[64] + 96] = 2
                                mem[64] = mem[64] + 192
                                require 0 < mem[_6091 + 96]
                                mem[_6091 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                require 1 < mem[_6091 + 96]
                                mem[_6091 + 160] = wantAddress
                                mem[_6091 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_6091 + 196] = arg1
                                mem[_6091 + 228] = 64
                                mem[_6091 + 260] = mem[_6091 + 96]
                                idx = 0
                                s = _6091 + 292
                                u = _6091 + 128
                                while idx < mem[_6091 + 96]:
                                    mem[s] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    u = u + 32
                                    continue 
                                require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _6091 + (32 * mem[_6091 + 96]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6626 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _6644 = mem[_6626]
                                require mem[_6626] <= test266151307()
                                require _6626 + return_data.size > _6626 + mem[_6626] + 31
                                _6662 = mem[_6626 + mem[_6626]]
                                require mem[_6626 + mem[_6626]] <= test266151307()
                                require (32 * mem[_6626 + mem[_6626]]) + 32 >= 0 and _6626 + ceil32(return_data.size) + (32 * mem[_6626 + mem[_6626]]) + 32 <= test266151307()
                                mem[64] = _6626 + ceil32(return_data.size) + (32 * mem[_6626 + mem[_6626]]) + 32
                                mem[_6626 + ceil32(return_data.size)] = _6662
                                require return_data.size >= _6644 + (32 * _6662) + 32
                                mem[_6626 + ceil32(return_data.size) + 32 len 32 * _6662] = mem[_6626 + _6644 + 32 len 32 * _6662]
                                require _6662 - 1 < _6662
                                if not mem[(32 * _6662 - 1) + _6626 + ceil32(return_data.size) + 32]:
                                    return (0 < maxReportDelay * (_5357 * _5584) - (t * _5584) / 10^18 / 31556952)
                                if profitFactor * mem[(32 * _6662 - 1) + _6626 + ceil32(return_data.size) + 32] / mem[(32 * _6662 - 1) + _6626 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _6662 - 1) + _6626 + ceil32(return_data.size) + 32] < maxReportDelay * (_5357 * _5584) - (t * _5584) / 10^18 / 31556952
                        else:
                            _6030 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6030] = 26
                            mem[_6030 + 32] = 'SafeMath: division by zero'
                            if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                if not arg1:
                                    return 0
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < 0)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6124 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_6124]:
                                    return 0
                                if profitFactor * mem[_6124] / mem[_6124] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_6124] < 0
                            else:
                                _6072 = mem[64]
                                mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                mem[mem[64] + 96] = 2
                                mem[64] = mem[64] + 192
                                require 0 < mem[_6072 + 96]
                                mem[_6072 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                require 1 < mem[_6072 + 96]
                                mem[_6072 + 160] = wantAddress
                                mem[_6072 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_6072 + 196] = arg1
                                mem[_6072 + 228] = 64
                                mem[_6072 + 260] = mem[_6072 + 96]
                                idx = 0
                                s = _6072 + 292
                                t = _6072 + 128
                                while idx < mem[_6072 + 96]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _6072 + (32 * mem[_6072 + 96]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6627 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _6645 = mem[_6627]
                                require mem[_6627] <= test266151307()
                                require _6627 + return_data.size > _6627 + mem[_6627] + 31
                                _6663 = mem[_6627 + mem[_6627]]
                                require mem[_6627 + mem[_6627]] <= test266151307()
                                require (32 * mem[_6627 + mem[_6627]]) + 32 >= 0 and _6627 + ceil32(return_data.size) + (32 * mem[_6627 + mem[_6627]]) + 32 <= test266151307()
                                mem[64] = _6627 + ceil32(return_data.size) + (32 * mem[_6627 + mem[_6627]]) + 32
                                mem[_6627 + ceil32(return_data.size)] = _6663
                                require return_data.size >= _6645 + (32 * _6663) + 32
                                mem[_6627 + ceil32(return_data.size) + 32 len 32 * _6663] = mem[_6627 + _6645 + 32 len 32 * _6663]
                                var142001 = _6627 + _6645 + (32 * _6663) + 32
                                require _6663 - 1 < _6663
                                if not mem[(32 * _6663 - 1) + _6627 + ceil32(return_data.size) + 32]:
                                    return 0
                                if profitFactor * mem[(32 * _6663 - 1) + _6627 + ceil32(return_data.size) + 32] / mem[(32 * _6663 - 1) + _6627 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _6663 - 1) + _6627 + ceil32(return_data.size) + 32] < 0
                    else:
                        _5814 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5814] = 26
                        mem[_5814 + 32] = 'SafeMath: division by zero'
                        if not -1 * t * _5584 / 10^18:
                            _6026 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6026] = 26
                            mem[_6026 + 32] = 'SafeMath: division by zero'
                            if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                if not arg1:
                                    return 0
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < 0)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6112 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_6112]:
                                    return 0
                                if profitFactor * mem[_6112] / mem[_6112] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_6112] < 0
                            else:
                                _6056 = mem[64]
                                mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                mem[mem[64] + 96] = 2
                                mem[64] = mem[64] + 192
                                require 0 < mem[_6056 + 96]
                                mem[_6056 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                require 1 < mem[_6056 + 96]
                                mem[_6056 + 160] = wantAddress
                                mem[_6056 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_6056 + 196] = arg1
                                mem[_6056 + 228] = 64
                                mem[_6056 + 260] = mem[_6056 + 96]
                                idx = 0
                                s = _6056 + 292
                                t = _6056 + 128
                                while idx < mem[_6056 + 96]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _6056 + (32 * mem[_6056 + 96]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6629 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _6647 = mem[_6629]
                                require mem[_6629] <= test266151307()
                                require _6629 + return_data.size > _6629 + mem[_6629] + 31
                                _6665 = mem[_6629 + mem[_6629]]
                                require mem[_6629 + mem[_6629]] <= test266151307()
                                require (32 * mem[_6629 + mem[_6629]]) + 32 >= 0 and _6629 + ceil32(return_data.size) + (32 * mem[_6629 + mem[_6629]]) + 32 <= test266151307()
                                mem[64] = _6629 + ceil32(return_data.size) + (32 * mem[_6629 + mem[_6629]]) + 32
                                mem[_6629 + ceil32(return_data.size)] = _6665
                                require return_data.size >= _6647 + (32 * _6665) + 32
                                mem[_6629 + ceil32(return_data.size) + 32 len 32 * _6665] = mem[_6629 + _6647 + 32 len 32 * _6665]
                                var141001 = _6629 + _6647 + (32 * _6665) + 32
                                require _6665 - 1 < _6665
                                if not mem[(32 * _6665 - 1) + _6629 + ceil32(return_data.size) + 32]:
                                    return 0
                                if profitFactor * mem[(32 * _6665 - 1) + _6629 + ceil32(return_data.size) + 32] / mem[(32 * _6665 - 1) + _6629 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _6665 - 1) + _6629 + ceil32(return_data.size) + 32] < 0
                        else:
                            if maxReportDelay * -1 * t * _5584 / 10^18 / -1 * t * _5584 / 10^18 != maxReportDelay:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _6031 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6031] = 26
                            mem[_6031 + 32] = 'SafeMath: division by zero'
                            if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                if not arg1:
                                    return (0 < maxReportDelay * -1 * t * _5584 / 10^18 / 31556952)
                                if profitFactor * arg1 / arg1 != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                return (profitFactor * arg1 < maxReportDelay * -1 * t * _5584 / 10^18 / 31556952)
                            if wantToEthOracleAddress:
                                mem[mem[64] + 4] = arg1
                                require ext_code.size(wantToEthOracleAddress)
                                staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args arg1
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6126 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if not mem[_6126]:
                                    return (0 < maxReportDelay * -1 * t * _5584 / 10^18 / 31556952)
                                if profitFactor * mem[_6126] / mem[_6126] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[_6126] < maxReportDelay * -1 * t * _5584 / 10^18 / 31556952
                            else:
                                _6075 = mem[64]
                                mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                mem[mem[64] + 96] = 2
                                mem[64] = mem[64] + 192
                                require 0 < mem[_6075 + 96]
                                mem[_6075 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                require 1 < mem[_6075 + 96]
                                mem[_6075 + 160] = wantAddress
                                mem[_6075 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[_6075 + 196] = arg1
                                mem[_6075 + 228] = 64
                                mem[_6075 + 260] = mem[_6075 + 96]
                                idx = 0
                                s = _6075 + 292
                                u = _6075 + 128
                                while idx < mem[_6075 + 96]:
                                    mem[s] = mem[u + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    u = u + 32
                                    continue 
                                require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                        gas gas_remaining wei
                                       args mem[mem[64] + 4 len _6075 + (32 * mem[_6075 + 96]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6628 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _6646 = mem[_6628]
                                require mem[_6628] <= test266151307()
                                require _6628 + return_data.size > _6628 + mem[_6628] + 31
                                _6664 = mem[_6628 + mem[_6628]]
                                require mem[_6628 + mem[_6628]] <= test266151307()
                                require (32 * mem[_6628 + mem[_6628]]) + 32 >= 0 and _6628 + ceil32(return_data.size) + (32 * mem[_6628 + mem[_6628]]) + 32 <= test266151307()
                                mem[64] = _6628 + ceil32(return_data.size) + (32 * mem[_6628 + mem[_6628]]) + 32
                                mem[_6628 + ceil32(return_data.size)] = _6664
                                require return_data.size >= _6646 + (32 * _6664) + 32
                                mem[_6628 + ceil32(return_data.size) + 32 len 32 * _6664] = mem[_6628 + _6646 + 32 len 32 * _6664]
                                var142001 = _6628 + _6646 + (32 * _6664) + 32
                                require _6664 - 1 < _6664
                                if not mem[(32 * _6664 - 1) + _6628 + ceil32(return_data.size) + 32]:
                                    return (0 < maxReportDelay * -1 * t * _5584 / 10^18 / 31556952)
                                if profitFactor * mem[(32 * _6664 - 1) + _6628 + ceil32(return_data.size) + 32] / mem[(32 * _6664 - 1) + _6628 + ceil32(return_data.size) + 32] != profitFactor:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[mem[64]] = profitFactor * mem[(32 * _6664 - 1) + _6628 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _5584 / 10^18 / 31556952
            else:
                _1672 = mem[_1627 + 160]
                _1679 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1679] = 30
                mem[_1679 + 32] = 'SafeMath: subtraction overflow'
                if _1672 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if block.timestamp - _1672 < minReportDelay:
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(wantAddress)
                    staticcall wantAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1729 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1747 = mem[_1729]
                    idx = 0
                    s = 0
                    t = -1
                    while idx < lenders.length:
                        mem[0] = 12
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].hasAssets() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2838 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_2838] == bool(mem[_2838])
                        if not mem[_2838]:
                            idx = idx + 1
                            s = s
                            t = t
                            continue 
                        require idx < lenders.length
                        mem[0] = 12
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].apr() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2984 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3024 = mem[_2984]
                        if mem[_2984] >= t:
                            idx = idx + 1
                            s = s
                            t = t
                            continue 
                        require idx < lenders.length
                        mem[0] = 12
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].nav() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3125 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 1
                        s = mem[_3125]
                        t = _3024
                        continue 
                    if _1747 + s < s:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = 0
                    u = 0
                    while idx < lenders.length:
                        mem[0] = 12
                        mem[mem[64] + 4] = _1747
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                                gas gas_remaining wei
                               args _1747
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _5304 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_5304] <= u:
                            idx = idx + 1
                            u = u
                            continue 
                        idx = idx + 1
                        u = mem[_5304]
                        continue 
                    require 0 < lenders.length
                    mem[0] = 12
                    mem[mem[64] + 4] = _1747 + s
                    require ext_code.size(lenders)
                    staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                            gas gas_remaining wei
                           args (_1747 + s)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5303 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _5355 = mem[_5303]
                    if mem[_5303] <= t:
                        return 0
                    require 0 < lenders.length
                    mem[0] = 12
                    require ext_code.size(lenders)
                    staticcall lenders.nav() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _5550 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _5583 = mem[_5550]
                    if not mem[_5550]:
                        _5790 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5790] = 26
                        mem[_5790 + 32] = 'SafeMath: division by zero'
                        _6020 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6020] = 26
                        mem[_6020 + 32] = 'SafeMath: division by zero'
                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                            if not arg1:
                                return 0
                            if profitFactor * arg1 / arg1 != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            return (profitFactor * arg1 < 0)
                        if wantToEthOracleAddress:
                            mem[mem[64] + 4] = arg1
                            require ext_code.size(wantToEthOracleAddress)
                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args arg1
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6089 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if not mem[_6089]:
                                return 0
                            if profitFactor * mem[_6089] / mem[_6089] != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[mem[64]] = profitFactor * mem[_6089] < 0
                        else:
                            _6040 = mem[64]
                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                            mem[mem[64] + 96] = 2
                            mem[64] = mem[64] + 192
                            require 0 < mem[_6040 + 96]
                            mem[_6040 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                            require 1 < mem[_6040 + 96]
                            mem[_6040 + 160] = wantAddress
                            mem[_6040 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[_6040 + 196] = arg1
                            mem[_6040 + 228] = 64
                            mem[_6040 + 260] = mem[_6040 + 96]
                            idx = 0
                            s = _6040 + 292
                            t = _6040 + 128
                            while idx < mem[_6040 + 96]:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4 len _6040 + (32 * mem[_6040 + 96]) + -mem[64] + 288]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6625 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _6643 = mem[_6625]
                            require mem[_6625] <= test266151307()
                            require _6625 + return_data.size > _6625 + mem[_6625] + 31
                            _6661 = mem[_6625 + mem[_6625]]
                            require mem[_6625 + mem[_6625]] <= test266151307()
                            require (32 * mem[_6625 + mem[_6625]]) + 32 >= 0 and _6625 + ceil32(return_data.size) + (32 * mem[_6625 + mem[_6625]]) + 32 <= test266151307()
                            mem[64] = _6625 + ceil32(return_data.size) + (32 * mem[_6625 + mem[_6625]]) + 32
                            mem[_6625 + ceil32(return_data.size)] = _6661
                            require return_data.size >= _6643 + (32 * _6661) + 32
                            mem[_6625 + ceil32(return_data.size) + 32 len 32 * _6661] = mem[_6625 + _6643 + 32 len 32 * _6661]
                            require _6661 - 1 < _6661
                            if not mem[(32 * _6661 - 1) + _6625 + ceil32(return_data.size) + 32]:
                                return 0
                            if profitFactor * mem[(32 * _6661 - 1) + _6625 + ceil32(return_data.size) + 32] / mem[(32 * _6661 - 1) + _6625 + ceil32(return_data.size) + 32] != profitFactor:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[mem[64]] = profitFactor * mem[(32 * _6661 - 1) + _6625 + ceil32(return_data.size) + 32] < 0
                    else:
                        if t * mem[_5550] / mem[_5550] != t:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if mem[_5550]:
                            if _5355 * mem[_5550] / mem[_5550] != _5355:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _5855 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5855] = 26
                            mem[_5855 + 32] = 'SafeMath: division by zero'
                            if (_5355 * _5583) - (t * _5583) / 10^18:
                                if maxReportDelay * (_5355 * _5583) - (t * _5583) / 10^18 / (_5355 * _5583) - (t * _5583) / 10^18 != maxReportDelay:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6033 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6033] = 26
                                mem[_6033 + 32] = 'SafeMath: division by zero'
                                if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                    if not arg1:
                                        return (0 < maxReportDelay * (_5355 * _5583) - (t * _5583) / 10^18 / 31556952)
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < maxReportDelay * (_5355 * _5583) - (t * _5583) / 10^18 / 31556952)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6131 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_6131]:
                                        return (0 < maxReportDelay * (_5355 * _5583) - (t * _5583) / 10^18 / 31556952)
                                    if profitFactor * mem[_6131] / mem[_6131] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_6131] < maxReportDelay * (_5355 * _5583) - (t * _5583) / 10^18 / 31556952
                                else:
                                    _6081 = mem[64]
                                    mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                    mem[mem[64] + 96] = 2
                                    mem[64] = mem[64] + 192
                                    require 0 < mem[_6081 + 96]
                                    mem[_6081 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                    require 1 < mem[_6081 + 96]
                                    mem[_6081 + 160] = wantAddress
                                    mem[_6081 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_6081 + 196] = arg1
                                    mem[_6081 + 228] = 64
                                    mem[_6081 + 260] = mem[_6081 + 96]
                                    idx = 0
                                    s = _6081 + 292
                                    u = _6081 + 128
                                    while idx < mem[_6081 + 96]:
                                        mem[s] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        u = u + 32
                                        continue 
                                    require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                    staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _6081 + (32 * mem[_6081 + 96]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6621 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _6639 = mem[_6621]
                                    require mem[_6621] <= test266151307()
                                    require _6621 + return_data.size > _6621 + mem[_6621] + 31
                                    _6657 = mem[_6621 + mem[_6621]]
                                    require mem[_6621 + mem[_6621]] <= test266151307()
                                    require (32 * mem[_6621 + mem[_6621]]) + 32 >= 0 and _6621 + ceil32(return_data.size) + (32 * mem[_6621 + mem[_6621]]) + 32 <= test266151307()
                                    mem[64] = _6621 + ceil32(return_data.size) + (32 * mem[_6621 + mem[_6621]]) + 32
                                    mem[_6621 + ceil32(return_data.size)] = _6657
                                    require return_data.size >= _6639 + (32 * _6657) + 32
                                    mem[_6621 + ceil32(return_data.size) + 32 len 32 * _6657] = mem[_6621 + _6639 + 32 len 32 * _6657]
                                    require _6657 - 1 < _6657
                                    if not mem[(32 * _6657 - 1) + _6621 + ceil32(return_data.size) + 32]:
                                        return (0 < maxReportDelay * (_5355 * _5583) - (t * _5583) / 10^18 / 31556952)
                                    if profitFactor * mem[(32 * _6657 - 1) + _6621 + ceil32(return_data.size) + 32] / mem[(32 * _6657 - 1) + _6621 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _6657 - 1) + _6621 + ceil32(return_data.size) + 32] < maxReportDelay * (_5355 * _5583) - (t * _5583) / 10^18 / 31556952
                            else:
                                _6027 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6027] = 26
                                mem[_6027 + 32] = 'SafeMath: division by zero'
                                if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                    if not arg1:
                                        return 0
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < 0)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6116 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_6116]:
                                        return 0
                                    if profitFactor * mem[_6116] / mem[_6116] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_6116] < 0
                                else:
                                    _6062 = mem[64]
                                    mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                    mem[mem[64] + 96] = 2
                                    mem[64] = mem[64] + 192
                                    require 0 < mem[_6062 + 96]
                                    mem[_6062 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                    require 1 < mem[_6062 + 96]
                                    mem[_6062 + 160] = wantAddress
                                    mem[_6062 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_6062 + 196] = arg1
                                    mem[_6062 + 228] = 64
                                    mem[_6062 + 260] = mem[_6062 + 96]
                                    idx = 0
                                    s = _6062 + 292
                                    t = _6062 + 128
                                    while idx < mem[_6062 + 96]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                    staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _6062 + (32 * mem[_6062 + 96]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6622 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _6640 = mem[_6622]
                                    require mem[_6622] <= test266151307()
                                    require _6622 + return_data.size > _6622 + mem[_6622] + 31
                                    _6658 = mem[_6622 + mem[_6622]]
                                    require mem[_6622 + mem[_6622]] <= test266151307()
                                    require (32 * mem[_6622 + mem[_6622]]) + 32 >= 0 and _6622 + ceil32(return_data.size) + (32 * mem[_6622 + mem[_6622]]) + 32 <= test266151307()
                                    mem[64] = _6622 + ceil32(return_data.size) + (32 * mem[_6622 + mem[_6622]]) + 32
                                    mem[_6622 + ceil32(return_data.size)] = _6658
                                    require return_data.size >= _6640 + (32 * _6658) + 32
                                    mem[_6622 + ceil32(return_data.size) + 32 len 32 * _6658] = mem[_6622 + _6640 + 32 len 32 * _6658]
                                    var148001 = _6622 + _6640 + (32 * _6658) + 32
                                    require _6658 - 1 < _6658
                                    if not mem[(32 * _6658 - 1) + _6622 + ceil32(return_data.size) + 32]:
                                        return 0
                                    if profitFactor * mem[(32 * _6658 - 1) + _6622 + ceil32(return_data.size) + 32] / mem[(32 * _6658 - 1) + _6622 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _6658 - 1) + _6622 + ceil32(return_data.size) + 32] < 0
                        else:
                            _5813 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5813] = 26
                            mem[_5813 + 32] = 'SafeMath: division by zero'
                            if not -1 * t * _5583 / 10^18:
                                _6024 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6024] = 26
                                mem[_6024 + 32] = 'SafeMath: division by zero'
                                if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                    if not arg1:
                                        return 0
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < 0)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6105 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_6105]:
                                        return 0
                                    if profitFactor * mem[_6105] / mem[_6105] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_6105] < 0
                                else:
                                    _6049 = mem[64]
                                    mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                    mem[mem[64] + 96] = 2
                                    mem[64] = mem[64] + 192
                                    require 0 < mem[_6049 + 96]
                                    mem[_6049 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                    require 1 < mem[_6049 + 96]
                                    mem[_6049 + 160] = wantAddress
                                    mem[_6049 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_6049 + 196] = arg1
                                    mem[_6049 + 228] = 64
                                    mem[_6049 + 260] = mem[_6049 + 96]
                                    idx = 0
                                    s = _6049 + 292
                                    t = _6049 + 128
                                    while idx < mem[_6049 + 96]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                    staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _6049 + (32 * mem[_6049 + 96]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6624 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _6642 = mem[_6624]
                                    require mem[_6624] <= test266151307()
                                    require _6624 + return_data.size > _6624 + mem[_6624] + 31
                                    _6660 = mem[_6624 + mem[_6624]]
                                    require mem[_6624 + mem[_6624]] <= test266151307()
                                    require (32 * mem[_6624 + mem[_6624]]) + 32 >= 0 and _6624 + ceil32(return_data.size) + (32 * mem[_6624 + mem[_6624]]) + 32 <= test266151307()
                                    mem[64] = _6624 + ceil32(return_data.size) + (32 * mem[_6624 + mem[_6624]]) + 32
                                    mem[_6624 + ceil32(return_data.size)] = _6660
                                    require return_data.size >= _6642 + (32 * _6660) + 32
                                    mem[_6624 + ceil32(return_data.size) + 32 len 32 * _6660] = mem[_6624 + _6642 + 32 len 32 * _6660]
                                    var147001 = _6624 + _6642 + (32 * _6660) + 32
                                    require _6660 - 1 < _6660
                                    if not mem[(32 * _6660 - 1) + _6624 + ceil32(return_data.size) + 32]:
                                        return 0
                                    if profitFactor * mem[(32 * _6660 - 1) + _6624 + ceil32(return_data.size) + 32] / mem[(32 * _6660 - 1) + _6624 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _6660 - 1) + _6624 + ceil32(return_data.size) + 32] < 0
                            else:
                                if maxReportDelay * -1 * t * _5583 / 10^18 / -1 * t * _5583 / 10^18 != maxReportDelay:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6028 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6028] = 26
                                mem[_6028 + 32] = 'SafeMath: division by zero'
                                if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                    if not arg1:
                                        return (0 < maxReportDelay * -1 * t * _5583 / 10^18 / 31556952)
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < maxReportDelay * -1 * t * _5583 / 10^18 / 31556952)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6118 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_6118]:
                                        return (0 < maxReportDelay * -1 * t * _5583 / 10^18 / 31556952)
                                    if profitFactor * mem[_6118] / mem[_6118] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_6118] < maxReportDelay * -1 * t * _5583 / 10^18 / 31556952
                                else:
                                    _6065 = mem[64]
                                    mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                    mem[mem[64] + 96] = 2
                                    mem[64] = mem[64] + 192
                                    require 0 < mem[_6065 + 96]
                                    mem[_6065 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                    require 1 < mem[_6065 + 96]
                                    mem[_6065 + 160] = wantAddress
                                    mem[_6065 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_6065 + 196] = arg1
                                    mem[_6065 + 228] = 64
                                    mem[_6065 + 260] = mem[_6065 + 96]
                                    idx = 0
                                    s = _6065 + 292
                                    u = _6065 + 128
                                    while idx < mem[_6065 + 96]:
                                        mem[s] = mem[u + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        u = u + 32
                                        continue 
                                    require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                    staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _6065 + (32 * mem[_6065 + 96]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _6623 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _6641 = mem[_6623]
                                    require mem[_6623] <= test266151307()
                                    require _6623 + return_data.size > _6623 + mem[_6623] + 31
                                    _6659 = mem[_6623 + mem[_6623]]
                                    require mem[_6623 + mem[_6623]] <= test266151307()
                                    require (32 * mem[_6623 + mem[_6623]]) + 32 >= 0 and _6623 + ceil32(return_data.size) + (32 * mem[_6623 + mem[_6623]]) + 32 <= test266151307()
                                    mem[64] = _6623 + ceil32(return_data.size) + (32 * mem[_6623 + mem[_6623]]) + 32
                                    mem[_6623 + ceil32(return_data.size)] = _6659
                                    require return_data.size >= _6641 + (32 * _6659) + 32
                                    mem[_6623 + ceil32(return_data.size) + 32 len 32 * _6659] = mem[_6623 + _6641 + 32 len 32 * _6659]
                                    var148001 = _6623 + _6641 + (32 * _6659) + 32
                                    require _6659 - 1 < _6659
                                    if not mem[(32 * _6659 - 1) + _6623 + ceil32(return_data.size) + 32]:
                                        return (0 < maxReportDelay * -1 * t * _5583 / 10^18 / 31556952)
                                    if profitFactor * mem[(32 * _6659 - 1) + _6623 + ceil32(return_data.size) + 32] / mem[(32 * _6659 - 1) + _6623 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _6659 - 1) + _6623 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _5583 / 10^18 / 31556952
                else:
                    _1697 = mem[_1627 + 160]
                    _1704 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1704] = 30
                    mem[_1704 + 32] = 'SafeMath: subtraction overflow'
                    if _1697 > block.timestamp:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if block.timestamp - _1697 >= maxReportDelay:
                        return 0
                    require ext_code.size(vaultAddress)
                    staticcall vaultAddress.debtOutstanding() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1727 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_1727] > debtThreshold:
                        return 0
                    idx = 0
                    s = 0
                    while idx < lenders.length:
                        mem[0] = 12
                        require ext_code.size(lenders[idx])
                        staticcall lenders[idx].nav() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2837 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2883 = mem[_2837]
                        if mem[_2837] + s < s:
                            revert with 0, 'SafeMath: addition overflow'
                        idx = idx + 1
                        s = mem[_2837] + s
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(wantAddress)
                    staticcall wantAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2882 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2926 = mem[_2882]
                    if mem[_2882] + (_2883 * lenders.length) < _2883 * lenders.length:
                        revert with 0, 'SafeMath: addition overflow'
                    if debtThreshold < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if debtThreshold + mem[_2882] + (_2883 * lenders.length) < mem[_1627 + 192]:
                        return 0
                    if mem[_2882] + (_2883 * lenders.length) <= mem[_1627 + 192]:
                        require ext_code.size(vaultAddress)
                        staticcall vaultAddress.creditAvailable() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3137 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_3137] < mem[_3137]:
                            revert with 0, 'SafeMath: addition overflow'
                        if not profitFactor:
                            if 0 < mem[_3137]:
                                return 0
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3387 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3418 = mem[_3387]
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5246 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_5246] == bool(mem[_5246])
                                if not mem[_5246]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5460 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5546 = mem[_5460]
                                if mem[_5460] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5738 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_5738]
                                t = _5546
                                continue 
                            if _3418 + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 12
                                mem[mem[64] + 4] = _3418
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args _3418
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6634 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_6634] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_6634]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 12
                            mem[mem[64] + 4] = _3418 + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args (_3418 + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6633 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _6651 = mem[_6633]
                            if mem[_6633] <= t:
                                return 0
                            require 0 < lenders.length
                            mem[0] = 12
                            require ext_code.size(lenders)
                            staticcall lenders.nav() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6876 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _6942 = mem[_6876]
                            if not mem[_6876]:
                                _6996 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6996] = 26
                                mem[_6996 + 32] = 'SafeMath: division by zero'
                                _7076 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7076] = 26
                                mem[_7076 + 32] = 'SafeMath: division by zero'
                                if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                    if not arg1:
                                        return 0
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < 0)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7215 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_7215]:
                                        return 0
                                    if profitFactor * mem[_7215] / mem[_7215] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_7215] < 0
                                else:
                                    _7118 = mem[64]
                                    mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                    mem[mem[64] + 96] = 2
                                    mem[64] = mem[64] + 192
                                    require 0 < mem[_7118 + 96]
                                    mem[_7118 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                    require 1 < mem[_7118 + 96]
                                    mem[_7118 + 160] = wantAddress
                                    mem[_7118 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_7118 + 196] = arg1
                                    mem[_7118 + 228] = 64
                                    mem[_7118 + 260] = mem[_7118 + 96]
                                    idx = 0
                                    s = _7118 + 292
                                    t = _7118 + 128
                                    while idx < mem[_7118 + 96]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                    staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _7118 + (32 * mem[_7118 + 96]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7958 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7978 = mem[_7958]
                                    require mem[_7958] <= test266151307()
                                    require _7958 + return_data.size > _7958 + mem[_7958] + 31
                                    _7998 = mem[_7958 + mem[_7958]]
                                    require mem[_7958 + mem[_7958]] <= test266151307()
                                    require (32 * mem[_7958 + mem[_7958]]) + 32 >= 0 and _7958 + ceil32(return_data.size) + (32 * mem[_7958 + mem[_7958]]) + 32 <= test266151307()
                                    mem[64] = _7958 + ceil32(return_data.size) + (32 * mem[_7958 + mem[_7958]]) + 32
                                    mem[_7958 + ceil32(return_data.size)] = _7998
                                    require return_data.size >= _7978 + (32 * _7998) + 32
                                    mem[_7958 + ceil32(return_data.size) + 32 len 32 * _7998] = mem[_7958 + _7978 + 32 len 32 * _7998]
                                    require _7998 - 1 < _7998
                                    if not mem[(32 * _7998 - 1) + _7958 + ceil32(return_data.size) + 32]:
                                        return 0
                                    if profitFactor * mem[(32 * _7998 - 1) + _7958 + ceil32(return_data.size) + 32] / mem[(32 * _7998 - 1) + _7958 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _7998 - 1) + _7958 + ceil32(return_data.size) + 32] < 0
                            else:
                                if t * mem[_6876] / mem[_6876] != t:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not mem[_6876]:
                                    _7012 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7012] = 26
                                    mem[_7012 + 32] = 'SafeMath: division by zero'
                                    if not -1 * t * _6942 / 10^18:
                                        _7084 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7084] = 26
                                        mem[_7084 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7248 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7248]:
                                                return 0
                                            if profitFactor * mem[_7248] / mem[_7248] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7248] < 0
                                        else:
                                            _7138 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_7138 + 96]
                                            mem[_7138 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_7138 + 96]
                                            mem[_7138 + 160] = wantAddress
                                            mem[_7138 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7138 + 196] = arg1
                                            mem[_7138 + 228] = 64
                                            mem[_7138 + 260] = mem[_7138 + 96]
                                            idx = 0
                                            s = _7138 + 292
                                            t = _7138 + 128
                                            while idx < mem[_7138 + 96]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7138 + (32 * mem[_7138 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7957 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7977 = mem[_7957]
                                            require mem[_7957] <= test266151307()
                                            require _7957 + return_data.size > _7957 + mem[_7957] + 31
                                            _7997 = mem[_7957 + mem[_7957]]
                                            require mem[_7957 + mem[_7957]] <= test266151307()
                                            require (32 * mem[_7957 + mem[_7957]]) + 32 >= 0 and _7957 + ceil32(return_data.size) + (32 * mem[_7957 + mem[_7957]]) + 32 <= test266151307()
                                            mem[64] = _7957 + ceil32(return_data.size) + (32 * mem[_7957 + mem[_7957]]) + 32
                                            mem[_7957 + ceil32(return_data.size)] = _7997
                                            require return_data.size >= _7977 + (32 * _7997) + 32
                                            mem[_7957 + ceil32(return_data.size) + 32 len 32 * _7997] = mem[_7957 + _7977 + 32 len 32 * _7997]
                                            require _7997 - 1 < _7997
                                            if not mem[(32 * _7997 - 1) + _7957 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _7997 - 1) + _7957 + ceil32(return_data.size) + 32] / mem[(32 * _7997 - 1) + _7957 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _7997 - 1) + _7957 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * -1 * t * _6942 / 10^18 / -1 * t * _6942 / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7093 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7093] = 26
                                        mem[_7093 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * -1 * t * _6942 / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * -1 * t * _6942 / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7276 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7276]:
                                                return (0 < maxReportDelay * -1 * t * _6942 / 10^18 / 31556952)
                                            if profitFactor * mem[_7276] / mem[_7276] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7276] < maxReportDelay * -1 * t * _6942 / 10^18 / 31556952
                                        else:
                                            _7171 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_7171 + 96]
                                            mem[_7171 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_7171 + 96]
                                            mem[_7171 + 160] = wantAddress
                                            mem[_7171 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7171 + 196] = arg1
                                            mem[_7171 + 228] = 64
                                            mem[_7171 + 260] = mem[_7171 + 96]
                                            idx = 0
                                            s = _7171 + 292
                                            u = _7171 + 128
                                            while idx < mem[_7171 + 96]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7171 + (32 * mem[_7171 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7956 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7976 = mem[_7956]
                                            require mem[_7956] <= test266151307()
                                            require _7956 + return_data.size > _7956 + mem[_7956] + 31
                                            _7996 = mem[_7956 + mem[_7956]]
                                            require mem[_7956 + mem[_7956]] <= test266151307()
                                            require (32 * mem[_7956 + mem[_7956]]) + 32 >= 0 and _7956 + ceil32(return_data.size) + (32 * mem[_7956 + mem[_7956]]) + 32 <= test266151307()
                                            mem[64] = _7956 + ceil32(return_data.size) + (32 * mem[_7956 + mem[_7956]]) + 32
                                            mem[_7956 + ceil32(return_data.size)] = _7996
                                            require return_data.size >= _7976 + (32 * _7996) + 32
                                            mem[_7956 + ceil32(return_data.size) + 32 len 32 * _7996] = mem[_7956 + _7976 + 32 len 32 * _7996]
                                            require _7996 - 1 < _7996
                                            if not mem[(32 * _7996 - 1) + _7956 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * -1 * t * _6942 / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _7996 - 1) + _7956 + ceil32(return_data.size) + 32] / mem[(32 * _7996 - 1) + _7956 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _7996 - 1) + _7956 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _6942 / 10^18 / 31556952
                                else:
                                    if _6651 * mem[_6876] / mem[_6876] != _6651:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _7017 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7017] = 26
                                    mem[_7017 + 32] = 'SafeMath: division by zero'
                                    if not (_6651 * _6942) - (t * _6942) / 10^18:
                                        _7092 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7092] = 26
                                        mem[_7092 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7274 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7274]:
                                                return 0
                                            if profitFactor * mem[_7274] / mem[_7274] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7274] < 0
                                        else:
                                            _7168 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_7168 + 96]
                                            mem[_7168 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_7168 + 96]
                                            mem[_7168 + 160] = wantAddress
                                            mem[_7168 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7168 + 196] = arg1
                                            mem[_7168 + 228] = 64
                                            mem[_7168 + 260] = mem[_7168 + 96]
                                            idx = 0
                                            s = _7168 + 292
                                            t = _7168 + 128
                                            while idx < mem[_7168 + 96]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7168 + (32 * mem[_7168 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7955 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7975 = mem[_7955]
                                            require mem[_7955] <= test266151307()
                                            require _7955 + return_data.size > _7955 + mem[_7955] + 31
                                            _7995 = mem[_7955 + mem[_7955]]
                                            require mem[_7955 + mem[_7955]] <= test266151307()
                                            require (32 * mem[_7955 + mem[_7955]]) + 32 >= 0 and _7955 + ceil32(return_data.size) + (32 * mem[_7955 + mem[_7955]]) + 32 <= test266151307()
                                            mem[64] = _7955 + ceil32(return_data.size) + (32 * mem[_7955 + mem[_7955]]) + 32
                                            mem[_7955 + ceil32(return_data.size)] = _7995
                                            require return_data.size >= _7975 + (32 * _7995) + 32
                                            mem[_7955 + ceil32(return_data.size) + 32 len 32 * _7995] = mem[_7955 + _7975 + 32 len 32 * _7995]
                                            require _7995 - 1 < _7995
                                            if not mem[(32 * _7995 - 1) + _7955 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _7995 - 1) + _7955 + ceil32(return_data.size) + 32] / mem[(32 * _7995 - 1) + _7955 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _7995 - 1) + _7955 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * (_6651 * _6942) - (t * _6942) / 10^18 / (_6651 * _6942) - (t * _6942) / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7103 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7103] = 26
                                        mem[_7103 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * (_6651 * _6942) - (t * _6942) / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * (_6651 * _6942) - (t * _6942) / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7306 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7306]:
                                                return (0 < maxReportDelay * (_6651 * _6942) - (t * _6942) / 10^18 / 31556952)
                                            if profitFactor * mem[_7306] / mem[_7306] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7306] < maxReportDelay * (_6651 * _6942) - (t * _6942) / 10^18 / 31556952
                                        else:
                                            _7207 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_7207 + 96]
                                            mem[_7207 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_7207 + 96]
                                            mem[_7207 + 160] = wantAddress
                                            mem[_7207 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7207 + 196] = arg1
                                            mem[_7207 + 228] = 64
                                            mem[_7207 + 260] = mem[_7207 + 96]
                                            idx = 0
                                            s = _7207 + 292
                                            u = _7207 + 128
                                            while idx < mem[_7207 + 96]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7207 + (32 * mem[_7207 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7954 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7974 = mem[_7954]
                                            require mem[_7954] <= test266151307()
                                            require _7954 + return_data.size > _7954 + mem[_7954] + 31
                                            _7994 = mem[_7954 + mem[_7954]]
                                            require mem[_7954 + mem[_7954]] <= test266151307()
                                            require (32 * mem[_7954 + mem[_7954]]) + 32 >= 0 and _7954 + ceil32(return_data.size) + (32 * mem[_7954 + mem[_7954]]) + 32 <= test266151307()
                                            mem[64] = _7954 + ceil32(return_data.size) + (32 * mem[_7954 + mem[_7954]]) + 32
                                            mem[_7954 + ceil32(return_data.size)] = _7994
                                            require return_data.size >= _7974 + (32 * _7994) + 32
                                            mem[_7954 + ceil32(return_data.size) + 32 len 32 * _7994] = mem[_7954 + _7974 + 32 len 32 * _7994]
                                            require _7994 - 1 < _7994
                                            if not mem[(32 * _7994 - 1) + _7954 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * (_6651 * _6942) - (t * _6942) / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _7994 - 1) + _7954 + ceil32(return_data.size) + 32] / mem[(32 * _7994 - 1) + _7954 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _7994 - 1) + _7954 + ceil32(return_data.size) + 32] < maxReportDelay * (_6651 * _6942) - (t * _6942) / 10^18 / 31556952
                        else:
                            if _1460 * profitFactor / profitFactor != _1460:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if _1460 * profitFactor < mem[_3137]:
                                return 0
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3409 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3420 = mem[_3409]
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5245 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_5245] == bool(mem[_5245])
                                if not mem[_5245]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5459 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5545 = mem[_5459]
                                if mem[_5459] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5737 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_5737]
                                t = _5545
                                continue 
                            if _3420 + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 12
                                mem[mem[64] + 4] = _3420
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args _3420
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6632 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_6632] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_6632]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 12
                            mem[mem[64] + 4] = _3420 + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args (_3420 + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6631 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _6649 = mem[_6631]
                            if mem[_6631] <= t:
                                return 0
                            require 0 < lenders.length
                            mem[0] = 12
                            require ext_code.size(lenders)
                            staticcall lenders.nav() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6874 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _6941 = mem[_6874]
                            if not mem[_6874]:
                                _6994 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6994] = 26
                                mem[_6994 + 32] = 'SafeMath: division by zero'
                                _7074 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7074] = 26
                                mem[_7074 + 32] = 'SafeMath: division by zero'
                                if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                    if not arg1:
                                        return 0
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < 0)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7205 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_7205]:
                                        return 0
                                    if profitFactor * mem[_7205] / mem[_7205] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_7205] < 0
                                else:
                                    _7114 = mem[64]
                                    mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                    mem[mem[64] + 96] = 2
                                    mem[64] = mem[64] + 192
                                    require 0 < mem[_7114 + 96]
                                    mem[_7114 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                    require 1 < mem[_7114 + 96]
                                    mem[_7114 + 160] = wantAddress
                                    mem[_7114 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_7114 + 196] = arg1
                                    mem[_7114 + 228] = 64
                                    mem[_7114 + 260] = mem[_7114 + 96]
                                    idx = 0
                                    s = _7114 + 292
                                    t = _7114 + 128
                                    while idx < mem[_7114 + 96]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                    staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _7114 + (32 * mem[_7114 + 96]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7953 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7973 = mem[_7953]
                                    require mem[_7953] <= test266151307()
                                    require _7953 + return_data.size > _7953 + mem[_7953] + 31
                                    _7993 = mem[_7953 + mem[_7953]]
                                    require mem[_7953 + mem[_7953]] <= test266151307()
                                    require (32 * mem[_7953 + mem[_7953]]) + 32 >= 0 and _7953 + ceil32(return_data.size) + (32 * mem[_7953 + mem[_7953]]) + 32 <= test266151307()
                                    mem[64] = _7953 + ceil32(return_data.size) + (32 * mem[_7953 + mem[_7953]]) + 32
                                    mem[_7953 + ceil32(return_data.size)] = _7993
                                    require return_data.size >= _7973 + (32 * _7993) + 32
                                    mem[_7953 + ceil32(return_data.size) + 32 len 32 * _7993] = mem[_7953 + _7973 + 32 len 32 * _7993]
                                    require _7993 - 1 < _7993
                                    if not mem[(32 * _7993 - 1) + _7953 + ceil32(return_data.size) + 32]:
                                        return 0
                                    if profitFactor * mem[(32 * _7993 - 1) + _7953 + ceil32(return_data.size) + 32] / mem[(32 * _7993 - 1) + _7953 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _7993 - 1) + _7953 + ceil32(return_data.size) + 32] < 0
                            else:
                                if t * mem[_6874] / mem[_6874] != t:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not mem[_6874]:
                                    _7011 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7011] = 26
                                    mem[_7011 + 32] = 'SafeMath: division by zero'
                                    if not -1 * t * _6941 / 10^18:
                                        _7082 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7082] = 26
                                        mem[_7082 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7241 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7241]:
                                                return 0
                                            if profitFactor * mem[_7241] / mem[_7241] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7241] < 0
                                        else:
                                            _7131 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_7131 + 96]
                                            mem[_7131 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_7131 + 96]
                                            mem[_7131 + 160] = wantAddress
                                            mem[_7131 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7131 + 196] = arg1
                                            mem[_7131 + 228] = 64
                                            mem[_7131 + 260] = mem[_7131 + 96]
                                            idx = 0
                                            s = _7131 + 292
                                            t = _7131 + 128
                                            while idx < mem[_7131 + 96]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7131 + (32 * mem[_7131 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7952 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7972 = mem[_7952]
                                            require mem[_7952] <= test266151307()
                                            require _7952 + return_data.size > _7952 + mem[_7952] + 31
                                            _7992 = mem[_7952 + mem[_7952]]
                                            require mem[_7952 + mem[_7952]] <= test266151307()
                                            require (32 * mem[_7952 + mem[_7952]]) + 32 >= 0 and _7952 + ceil32(return_data.size) + (32 * mem[_7952 + mem[_7952]]) + 32 <= test266151307()
                                            mem[64] = _7952 + ceil32(return_data.size) + (32 * mem[_7952 + mem[_7952]]) + 32
                                            mem[_7952 + ceil32(return_data.size)] = _7992
                                            require return_data.size >= _7972 + (32 * _7992) + 32
                                            mem[_7952 + ceil32(return_data.size) + 32 len 32 * _7992] = mem[_7952 + _7972 + 32 len 32 * _7992]
                                            require _7992 - 1 < _7992
                                            if not mem[(32 * _7992 - 1) + _7952 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _7992 - 1) + _7952 + ceil32(return_data.size) + 32] / mem[(32 * _7992 - 1) + _7952 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _7992 - 1) + _7952 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * -1 * t * _6941 / 10^18 / -1 * t * _6941 / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7090 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7090] = 26
                                        mem[_7090 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * -1 * t * _6941 / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * -1 * t * _6941 / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7268 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7268]:
                                                return (0 < maxReportDelay * -1 * t * _6941 / 10^18 / 31556952)
                                            if profitFactor * mem[_7268] / mem[_7268] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7268] < maxReportDelay * -1 * t * _6941 / 10^18 / 31556952
                                        else:
                                            _7161 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_7161 + 96]
                                            mem[_7161 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_7161 + 96]
                                            mem[_7161 + 160] = wantAddress
                                            mem[_7161 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7161 + 196] = arg1
                                            mem[_7161 + 228] = 64
                                            mem[_7161 + 260] = mem[_7161 + 96]
                                            idx = 0
                                            s = _7161 + 292
                                            u = _7161 + 128
                                            while idx < mem[_7161 + 96]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7161 + (32 * mem[_7161 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7951 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7971 = mem[_7951]
                                            require mem[_7951] <= test266151307()
                                            require _7951 + return_data.size > _7951 + mem[_7951] + 31
                                            _7991 = mem[_7951 + mem[_7951]]
                                            require mem[_7951 + mem[_7951]] <= test266151307()
                                            require (32 * mem[_7951 + mem[_7951]]) + 32 >= 0 and _7951 + ceil32(return_data.size) + (32 * mem[_7951 + mem[_7951]]) + 32 <= test266151307()
                                            mem[64] = _7951 + ceil32(return_data.size) + (32 * mem[_7951 + mem[_7951]]) + 32
                                            mem[_7951 + ceil32(return_data.size)] = _7991
                                            require return_data.size >= _7971 + (32 * _7991) + 32
                                            mem[_7951 + ceil32(return_data.size) + 32 len 32 * _7991] = mem[_7951 + _7971 + 32 len 32 * _7991]
                                            require _7991 - 1 < _7991
                                            if not mem[(32 * _7991 - 1) + _7951 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * -1 * t * _6941 / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _7991 - 1) + _7951 + ceil32(return_data.size) + 32] / mem[(32 * _7991 - 1) + _7951 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _7991 - 1) + _7951 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _6941 / 10^18 / 31556952
                                else:
                                    if _6649 * mem[_6874] / mem[_6874] != _6649:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _7015 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7015] = 26
                                    mem[_7015 + 32] = 'SafeMath: division by zero'
                                    if not (_6649 * _6941) - (t * _6941) / 10^18:
                                        _7089 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7089] = 26
                                        mem[_7089 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7266 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7266]:
                                                return 0
                                            if profitFactor * mem[_7266] / mem[_7266] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7266] < 0
                                        else:
                                            _7158 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_7158 + 96]
                                            mem[_7158 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_7158 + 96]
                                            mem[_7158 + 160] = wantAddress
                                            mem[_7158 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7158 + 196] = arg1
                                            mem[_7158 + 228] = 64
                                            mem[_7158 + 260] = mem[_7158 + 96]
                                            idx = 0
                                            s = _7158 + 292
                                            t = _7158 + 128
                                            while idx < mem[_7158 + 96]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7158 + (32 * mem[_7158 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7950 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7970 = mem[_7950]
                                            require mem[_7950] <= test266151307()
                                            require _7950 + return_data.size > _7950 + mem[_7950] + 31
                                            _7990 = mem[_7950 + mem[_7950]]
                                            require mem[_7950 + mem[_7950]] <= test266151307()
                                            require (32 * mem[_7950 + mem[_7950]]) + 32 >= 0 and _7950 + ceil32(return_data.size) + (32 * mem[_7950 + mem[_7950]]) + 32 <= test266151307()
                                            mem[64] = _7950 + ceil32(return_data.size) + (32 * mem[_7950 + mem[_7950]]) + 32
                                            mem[_7950 + ceil32(return_data.size)] = _7990
                                            require return_data.size >= _7970 + (32 * _7990) + 32
                                            mem[_7950 + ceil32(return_data.size) + 32 len 32 * _7990] = mem[_7950 + _7970 + 32 len 32 * _7990]
                                            require _7990 - 1 < _7990
                                            if not mem[(32 * _7990 - 1) + _7950 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _7990 - 1) + _7950 + ceil32(return_data.size) + 32] / mem[(32 * _7990 - 1) + _7950 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _7990 - 1) + _7950 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * (_6649 * _6941) - (t * _6941) / 10^18 / (_6649 * _6941) - (t * _6941) / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7101 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7101] = 26
                                        mem[_7101 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * (_6649 * _6941) - (t * _6941) / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * (_6649 * _6941) - (t * _6941) / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7297 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7297]:
                                                return (0 < maxReportDelay * (_6649 * _6941) - (t * _6941) / 10^18 / 31556952)
                                            if profitFactor * mem[_7297] / mem[_7297] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7297] < maxReportDelay * (_6649 * _6941) - (t * _6941) / 10^18 / 31556952
                                        else:
                                            _7197 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_7197 + 96]
                                            mem[_7197 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_7197 + 96]
                                            mem[_7197 + 160] = wantAddress
                                            mem[_7197 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7197 + 196] = arg1
                                            mem[_7197 + 228] = 64
                                            mem[_7197 + 260] = mem[_7197 + 96]
                                            idx = 0
                                            s = _7197 + 292
                                            u = _7197 + 128
                                            while idx < mem[_7197 + 96]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7197 + (32 * mem[_7197 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7949 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7969 = mem[_7949]
                                            require mem[_7949] <= test266151307()
                                            require _7949 + return_data.size > _7949 + mem[_7949] + 31
                                            _7989 = mem[_7949 + mem[_7949]]
                                            require mem[_7949 + mem[_7949]] <= test266151307()
                                            require (32 * mem[_7949 + mem[_7949]]) + 32 >= 0 and _7949 + ceil32(return_data.size) + (32 * mem[_7949 + mem[_7949]]) + 32 <= test266151307()
                                            mem[64] = _7949 + ceil32(return_data.size) + (32 * mem[_7949 + mem[_7949]]) + 32
                                            mem[_7949 + ceil32(return_data.size)] = _7989
                                            require return_data.size >= _7969 + (32 * _7989) + 32
                                            mem[_7949 + ceil32(return_data.size) + 32 len 32 * _7989] = mem[_7949 + _7969 + 32 len 32 * _7989]
                                            require _7989 - 1 < _7989
                                            if not mem[(32 * _7989 - 1) + _7949 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * (_6649 * _6941) - (t * _6941) / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _7989 - 1) + _7949 + ceil32(return_data.size) + 32] / mem[(32 * _7989 - 1) + _7949 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _7989 - 1) + _7949 + ceil32(return_data.size) + 32] < maxReportDelay * (_6649 * _6941) - (t * _6941) / 10^18 / 31556952
                    else:
                        _3093 = mem[_1627 + 192]
                        _3124 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3124] = 30
                        mem[_3124 + 32] = 'SafeMath: subtraction overflow'
                        if _3093 > _2926 + (_2883 * lenders.length):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        require ext_code.size(vaultAddress)
                        staticcall vaultAddress.creditAvailable() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3182 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if _2926 + (_2883 * lenders.length) - _3093 + mem[_3182] < mem[_3182]:
                            revert with 0, 'SafeMath: addition overflow'
                        if not profitFactor:
                            if 0 < _2926 + (_2883 * lenders.length) - _3093 + mem[_3182]:
                                return 0
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3435 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3507 = mem[_3435]
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5248 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_5248] == bool(mem[_5248])
                                if not mem[_5248]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5462 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5548 = mem[_5462]
                                if mem[_5462] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5740 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_5740]
                                t = _5548
                                continue 
                            if _3507 + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 12
                                mem[mem[64] + 4] = _3507
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args _3507
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6638 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_6638] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_6638]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 12
                            mem[mem[64] + 4] = _3507 + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args (_3507 + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6637 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _6655 = mem[_6637]
                            if mem[_6637] <= t:
                                return 0
                            require 0 < lenders.length
                            mem[0] = 12
                            require ext_code.size(lenders)
                            staticcall lenders.nav() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6880 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _6944 = mem[_6880]
                            if not mem[_6880]:
                                _7000 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7000] = 26
                                mem[_7000 + 32] = 'SafeMath: division by zero'
                                _7080 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7080] = 26
                                mem[_7080 + 32] = 'SafeMath: division by zero'
                                if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                    if not arg1:
                                        return 0
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < 0)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7235 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_7235]:
                                        return 0
                                    if profitFactor * mem[_7235] / mem[_7235] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_7235] < 0
                                else:
                                    _7126 = mem[64]
                                    mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                    mem[mem[64] + 96] = 2
                                    mem[64] = mem[64] + 192
                                    require 0 < mem[_7126 + 96]
                                    mem[_7126 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                    require 1 < mem[_7126 + 96]
                                    mem[_7126 + 160] = wantAddress
                                    mem[_7126 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_7126 + 196] = arg1
                                    mem[_7126 + 228] = 64
                                    mem[_7126 + 260] = mem[_7126 + 96]
                                    idx = 0
                                    s = _7126 + 292
                                    t = _7126 + 128
                                    while idx < mem[_7126 + 96]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                    staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _7126 + (32 * mem[_7126 + 96]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7968 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7988 = mem[_7968]
                                    require mem[_7968] <= test266151307()
                                    require _7968 + return_data.size > _7968 + mem[_7968] + 31
                                    _8008 = mem[_7968 + mem[_7968]]
                                    require mem[_7968 + mem[_7968]] <= test266151307()
                                    require (32 * mem[_7968 + mem[_7968]]) + 32 >= 0 and _7968 + ceil32(return_data.size) + (32 * mem[_7968 + mem[_7968]]) + 32 <= test266151307()
                                    mem[64] = _7968 + ceil32(return_data.size) + (32 * mem[_7968 + mem[_7968]]) + 32
                                    mem[_7968 + ceil32(return_data.size)] = _8008
                                    require return_data.size >= _7988 + (32 * _8008) + 32
                                    mem[_7968 + ceil32(return_data.size) + 32 len 32 * _8008] = mem[_7968 + _7988 + 32 len 32 * _8008]
                                    require _8008 - 1 < _8008
                                    if not mem[(32 * _8008 - 1) + _7968 + ceil32(return_data.size) + 32]:
                                        return 0
                                    if profitFactor * mem[(32 * _8008 - 1) + _7968 + ceil32(return_data.size) + 32] / mem[(32 * _8008 - 1) + _7968 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _8008 - 1) + _7968 + ceil32(return_data.size) + 32] < 0
                            else:
                                if t * mem[_6880] / mem[_6880] != t:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not mem[_6880]:
                                    _7014 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7014] = 26
                                    mem[_7014 + 32] = 'SafeMath: division by zero'
                                    if not -1 * t * _6944 / 10^18:
                                        _7088 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7088] = 26
                                        mem[_7088 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7262 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7262]:
                                                return 0
                                            if profitFactor * mem[_7262] / mem[_7262] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7262] < 0
                                        else:
                                            _7152 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_7152 + 96]
                                            mem[_7152 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_7152 + 96]
                                            mem[_7152 + 160] = wantAddress
                                            mem[_7152 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7152 + 196] = arg1
                                            mem[_7152 + 228] = 64
                                            mem[_7152 + 260] = mem[_7152 + 96]
                                            idx = 0
                                            s = _7152 + 292
                                            t = _7152 + 128
                                            while idx < mem[_7152 + 96]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7152 + (32 * mem[_7152 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7967 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7987 = mem[_7967]
                                            require mem[_7967] <= test266151307()
                                            require _7967 + return_data.size > _7967 + mem[_7967] + 31
                                            _8007 = mem[_7967 + mem[_7967]]
                                            require mem[_7967 + mem[_7967]] <= test266151307()
                                            require (32 * mem[_7967 + mem[_7967]]) + 32 >= 0 and _7967 + ceil32(return_data.size) + (32 * mem[_7967 + mem[_7967]]) + 32 <= test266151307()
                                            mem[64] = _7967 + ceil32(return_data.size) + (32 * mem[_7967 + mem[_7967]]) + 32
                                            mem[_7967 + ceil32(return_data.size)] = _8007
                                            require return_data.size >= _7987 + (32 * _8007) + 32
                                            mem[_7967 + ceil32(return_data.size) + 32 len 32 * _8007] = mem[_7967 + _7987 + 32 len 32 * _8007]
                                            require _8007 - 1 < _8007
                                            if not mem[(32 * _8007 - 1) + _7967 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _8007 - 1) + _7967 + ceil32(return_data.size) + 32] / mem[(32 * _8007 - 1) + _7967 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _8007 - 1) + _7967 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * -1 * t * _6944 / 10^18 / -1 * t * _6944 / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7099 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7099] = 26
                                        mem[_7099 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * -1 * t * _6944 / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * -1 * t * _6944 / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7292 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7292]:
                                                return (0 < maxReportDelay * -1 * t * _6944 / 10^18 / 31556952)
                                            if profitFactor * mem[_7292] / mem[_7292] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7292] < maxReportDelay * -1 * t * _6944 / 10^18 / 31556952
                                        else:
                                            _7191 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_7191 + 96]
                                            mem[_7191 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_7191 + 96]
                                            mem[_7191 + 160] = wantAddress
                                            mem[_7191 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7191 + 196] = arg1
                                            mem[_7191 + 228] = 64
                                            mem[_7191 + 260] = mem[_7191 + 96]
                                            idx = 0
                                            s = _7191 + 292
                                            u = _7191 + 128
                                            while idx < mem[_7191 + 96]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7191 + (32 * mem[_7191 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7966 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7986 = mem[_7966]
                                            require mem[_7966] <= test266151307()
                                            require _7966 + return_data.size > _7966 + mem[_7966] + 31
                                            _8006 = mem[_7966 + mem[_7966]]
                                            require mem[_7966 + mem[_7966]] <= test266151307()
                                            require (32 * mem[_7966 + mem[_7966]]) + 32 >= 0 and _7966 + ceil32(return_data.size) + (32 * mem[_7966 + mem[_7966]]) + 32 <= test266151307()
                                            mem[64] = _7966 + ceil32(return_data.size) + (32 * mem[_7966 + mem[_7966]]) + 32
                                            mem[_7966 + ceil32(return_data.size)] = _8006
                                            require return_data.size >= _7986 + (32 * _8006) + 32
                                            mem[_7966 + ceil32(return_data.size) + 32 len 32 * _8006] = mem[_7966 + _7986 + 32 len 32 * _8006]
                                            require _8006 - 1 < _8006
                                            if not mem[(32 * _8006 - 1) + _7966 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * -1 * t * _6944 / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _8006 - 1) + _7966 + ceil32(return_data.size) + 32] / mem[(32 * _8006 - 1) + _7966 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _8006 - 1) + _7966 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _6944 / 10^18 / 31556952
                                else:
                                    if _6655 * mem[_6880] / mem[_6880] != _6655:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _7021 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7021] = 26
                                    mem[_7021 + 32] = 'SafeMath: division by zero'
                                    if not (_6655 * _6944) - (t * _6944) / 10^18:
                                        _7098 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7098] = 26
                                        mem[_7098 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7290 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7290]:
                                                return 0
                                            if profitFactor * mem[_7290] / mem[_7290] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7290] < 0
                                        else:
                                            _7188 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_7188 + 96]
                                            mem[_7188 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_7188 + 96]
                                            mem[_7188 + 160] = wantAddress
                                            mem[_7188 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7188 + 196] = arg1
                                            mem[_7188 + 228] = 64
                                            mem[_7188 + 260] = mem[_7188 + 96]
                                            idx = 0
                                            s = _7188 + 292
                                            t = _7188 + 128
                                            while idx < mem[_7188 + 96]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7188 + (32 * mem[_7188 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7965 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7985 = mem[_7965]
                                            require mem[_7965] <= test266151307()
                                            require _7965 + return_data.size > _7965 + mem[_7965] + 31
                                            _8005 = mem[_7965 + mem[_7965]]
                                            require mem[_7965 + mem[_7965]] <= test266151307()
                                            require (32 * mem[_7965 + mem[_7965]]) + 32 >= 0 and _7965 + ceil32(return_data.size) + (32 * mem[_7965 + mem[_7965]]) + 32 <= test266151307()
                                            mem[64] = _7965 + ceil32(return_data.size) + (32 * mem[_7965 + mem[_7965]]) + 32
                                            mem[_7965 + ceil32(return_data.size)] = _8005
                                            require return_data.size >= _7985 + (32 * _8005) + 32
                                            mem[_7965 + ceil32(return_data.size) + 32 len 32 * _8005] = mem[_7965 + _7985 + 32 len 32 * _8005]
                                            require _8005 - 1 < _8005
                                            if not mem[(32 * _8005 - 1) + _7965 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _8005 - 1) + _7965 + ceil32(return_data.size) + 32] / mem[(32 * _8005 - 1) + _7965 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _8005 - 1) + _7965 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * (_6655 * _6944) - (t * _6944) / 10^18 / (_6655 * _6944) - (t * _6944) / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7107 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7107] = 26
                                        mem[_7107 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * (_6655 * _6944) - (t * _6944) / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * (_6655 * _6944) - (t * _6944) / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7324 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7324]:
                                                return (0 < maxReportDelay * (_6655 * _6944) - (t * _6944) / 10^18 / 31556952)
                                            if profitFactor * mem[_7324] / mem[_7324] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7324] < maxReportDelay * (_6655 * _6944) - (t * _6944) / 10^18 / 31556952
                                        else:
                                            _7227 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_7227 + 96]
                                            mem[_7227 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_7227 + 96]
                                            mem[_7227 + 160] = wantAddress
                                            mem[_7227 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7227 + 196] = arg1
                                            mem[_7227 + 228] = 64
                                            mem[_7227 + 260] = mem[_7227 + 96]
                                            idx = 0
                                            s = _7227 + 292
                                            u = _7227 + 128
                                            while idx < mem[_7227 + 96]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7227 + (32 * mem[_7227 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7964 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7984 = mem[_7964]
                                            require mem[_7964] <= test266151307()
                                            require _7964 + return_data.size > _7964 + mem[_7964] + 31
                                            _8004 = mem[_7964 + mem[_7964]]
                                            require mem[_7964 + mem[_7964]] <= test266151307()
                                            require (32 * mem[_7964 + mem[_7964]]) + 32 >= 0 and _7964 + ceil32(return_data.size) + (32 * mem[_7964 + mem[_7964]]) + 32 <= test266151307()
                                            mem[64] = _7964 + ceil32(return_data.size) + (32 * mem[_7964 + mem[_7964]]) + 32
                                            mem[_7964 + ceil32(return_data.size)] = _8004
                                            require return_data.size >= _7984 + (32 * _8004) + 32
                                            mem[_7964 + ceil32(return_data.size) + 32 len 32 * _8004] = mem[_7964 + _7984 + 32 len 32 * _8004]
                                            require _8004 - 1 < _8004
                                            if not mem[(32 * _8004 - 1) + _7964 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * (_6655 * _6944) - (t * _6944) / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _8004 - 1) + _7964 + ceil32(return_data.size) + 32] / mem[(32 * _8004 - 1) + _7964 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _8004 - 1) + _7964 + ceil32(return_data.size) + 32] < maxReportDelay * (_6655 * _6944) - (t * _6944) / 10^18 / 31556952
                        else:
                            if _1460 * profitFactor / profitFactor != _1460:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if _1460 * profitFactor < _2926 + (_2883 * lenders.length) - _3093 + mem[_3182]:
                                return 0
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(wantAddress)
                            staticcall wantAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3460 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _3578 = mem[_3460]
                            idx = 0
                            s = 0
                            t = -1
                            while idx < lenders.length:
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].hasAssets() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5247 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_5247] == bool(mem[_5247])
                                if not mem[_5247]:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].apr() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5461 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5547 = mem[_5461]
                                if mem[_5461] >= t:
                                    idx = idx + 1
                                    s = s
                                    t = t
                                    continue 
                                require idx < lenders.length
                                mem[0] = 12
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].nav() with:
                                        gas gas_remaining wei
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5739 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                idx = idx + 1
                                s = mem[_5739]
                                t = _5547
                                continue 
                            if _3578 + s < s:
                                revert with 0, 'SafeMath: addition overflow'
                            idx = 0
                            u = 0
                            while idx < lenders.length:
                                mem[0] = 12
                                mem[mem[64] + 4] = _3578
                                require ext_code.size(lenders[idx])
                                staticcall lenders[idx].aprAfterDeposit(uint256 rg1) with:
                                        gas gas_remaining wei
                                       args _3578
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6636 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_6636] <= u:
                                    idx = idx + 1
                                    u = u
                                    continue 
                                idx = idx + 1
                                u = mem[_6636]
                                continue 
                            require 0 < lenders.length
                            mem[0] = 12
                            mem[mem[64] + 4] = _3578 + s
                            require ext_code.size(lenders)
                            staticcall lenders.aprAfterDeposit(uint256 rg1) with:
                                    gas gas_remaining wei
                                   args (_3578 + s)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6635 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _6653 = mem[_6635]
                            if mem[_6635] <= t:
                                return 0
                            require 0 < lenders.length
                            mem[0] = 12
                            require ext_code.size(lenders)
                            staticcall lenders.nav() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _6878 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _6943 = mem[_6878]
                            if not mem[_6878]:
                                _6998 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6998] = 26
                                mem[_6998 + 32] = 'SafeMath: division by zero'
                                _7078 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7078] = 26
                                mem[_7078 + 32] = 'SafeMath: division by zero'
                                if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                    if not arg1:
                                        return 0
                                    if profitFactor * arg1 / arg1 != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    return (profitFactor * arg1 < 0)
                                if wantToEthOracleAddress:
                                    mem[mem[64] + 4] = arg1
                                    require ext_code.size(wantToEthOracleAddress)
                                    staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                            gas gas_remaining wei
                                           args arg1
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7225 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if not mem[_7225]:
                                        return 0
                                    if profitFactor * mem[_7225] / mem[_7225] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[_7225] < 0
                                else:
                                    _7122 = mem[64]
                                    mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                    mem[mem[64] + 96] = 2
                                    mem[64] = mem[64] + 192
                                    require 0 < mem[_7122 + 96]
                                    mem[_7122 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                    require 1 < mem[_7122 + 96]
                                    mem[_7122 + 160] = wantAddress
                                    mem[_7122 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[_7122 + 196] = arg1
                                    mem[_7122 + 228] = 64
                                    mem[_7122 + 260] = mem[_7122 + 96]
                                    idx = 0
                                    s = _7122 + 292
                                    t = _7122 + 128
                                    while idx < mem[_7122 + 96]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                    staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                            gas gas_remaining wei
                                           args mem[mem[64] + 4 len _7122 + (32 * mem[_7122 + 96]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7963 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7983 = mem[_7963]
                                    require mem[_7963] <= test266151307()
                                    require _7963 + return_data.size > _7963 + mem[_7963] + 31
                                    _8003 = mem[_7963 + mem[_7963]]
                                    require mem[_7963 + mem[_7963]] <= test266151307()
                                    require (32 * mem[_7963 + mem[_7963]]) + 32 >= 0 and _7963 + ceil32(return_data.size) + (32 * mem[_7963 + mem[_7963]]) + 32 <= test266151307()
                                    mem[64] = _7963 + ceil32(return_data.size) + (32 * mem[_7963 + mem[_7963]]) + 32
                                    mem[_7963 + ceil32(return_data.size)] = _8003
                                    require return_data.size >= _7983 + (32 * _8003) + 32
                                    mem[_7963 + ceil32(return_data.size) + 32 len 32 * _8003] = mem[_7963 + _7983 + 32 len 32 * _8003]
                                    require _8003 - 1 < _8003
                                    if not mem[(32 * _8003 - 1) + _7963 + ceil32(return_data.size) + 32]:
                                        return 0
                                    if profitFactor * mem[(32 * _8003 - 1) + _7963 + ceil32(return_data.size) + 32] / mem[(32 * _8003 - 1) + _7963 + ceil32(return_data.size) + 32] != profitFactor:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[mem[64]] = profitFactor * mem[(32 * _8003 - 1) + _7963 + ceil32(return_data.size) + 32] < 0
                            else:
                                if t * mem[_6878] / mem[_6878] != t:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not mem[_6878]:
                                    _7013 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7013] = 26
                                    mem[_7013 + 32] = 'SafeMath: division by zero'
                                    if not -1 * t * _6943 / 10^18:
                                        _7086 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7086] = 26
                                        mem[_7086 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7255 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7255]:
                                                return 0
                                            if profitFactor * mem[_7255] / mem[_7255] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7255] < 0
                                        else:
                                            _7145 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_7145 + 96]
                                            mem[_7145 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_7145 + 96]
                                            mem[_7145 + 160] = wantAddress
                                            mem[_7145 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7145 + 196] = arg1
                                            mem[_7145 + 228] = 64
                                            mem[_7145 + 260] = mem[_7145 + 96]
                                            idx = 0
                                            s = _7145 + 292
                                            t = _7145 + 128
                                            while idx < mem[_7145 + 96]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7145 + (32 * mem[_7145 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7962 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7982 = mem[_7962]
                                            require mem[_7962] <= test266151307()
                                            require _7962 + return_data.size > _7962 + mem[_7962] + 31
                                            _8002 = mem[_7962 + mem[_7962]]
                                            require mem[_7962 + mem[_7962]] <= test266151307()
                                            require (32 * mem[_7962 + mem[_7962]]) + 32 >= 0 and _7962 + ceil32(return_data.size) + (32 * mem[_7962 + mem[_7962]]) + 32 <= test266151307()
                                            mem[64] = _7962 + ceil32(return_data.size) + (32 * mem[_7962 + mem[_7962]]) + 32
                                            mem[_7962 + ceil32(return_data.size)] = _8002
                                            require return_data.size >= _7982 + (32 * _8002) + 32
                                            mem[_7962 + ceil32(return_data.size) + 32 len 32 * _8002] = mem[_7962 + _7982 + 32 len 32 * _8002]
                                            require _8002 - 1 < _8002
                                            if not mem[(32 * _8002 - 1) + _7962 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _8002 - 1) + _7962 + ceil32(return_data.size) + 32] / mem[(32 * _8002 - 1) + _7962 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _8002 - 1) + _7962 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * -1 * t * _6943 / 10^18 / -1 * t * _6943 / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7096 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7096] = 26
                                        mem[_7096 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * -1 * t * _6943 / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * -1 * t * _6943 / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7284 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7284]:
                                                return (0 < maxReportDelay * -1 * t * _6943 / 10^18 / 31556952)
                                            if profitFactor * mem[_7284] / mem[_7284] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7284] < maxReportDelay * -1 * t * _6943 / 10^18 / 31556952
                                        else:
                                            _7181 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_7181 + 96]
                                            mem[_7181 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_7181 + 96]
                                            mem[_7181 + 160] = wantAddress
                                            mem[_7181 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7181 + 196] = arg1
                                            mem[_7181 + 228] = 64
                                            mem[_7181 + 260] = mem[_7181 + 96]
                                            idx = 0
                                            s = _7181 + 292
                                            u = _7181 + 128
                                            while idx < mem[_7181 + 96]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7181 + (32 * mem[_7181 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7961 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7981 = mem[_7961]
                                            require mem[_7961] <= test266151307()
                                            require _7961 + return_data.size > _7961 + mem[_7961] + 31
                                            _8001 = mem[_7961 + mem[_7961]]
                                            require mem[_7961 + mem[_7961]] <= test266151307()
                                            require (32 * mem[_7961 + mem[_7961]]) + 32 >= 0 and _7961 + ceil32(return_data.size) + (32 * mem[_7961 + mem[_7961]]) + 32 <= test266151307()
                                            mem[64] = _7961 + ceil32(return_data.size) + (32 * mem[_7961 + mem[_7961]]) + 32
                                            mem[_7961 + ceil32(return_data.size)] = _8001
                                            require return_data.size >= _7981 + (32 * _8001) + 32
                                            mem[_7961 + ceil32(return_data.size) + 32 len 32 * _8001] = mem[_7961 + _7981 + 32 len 32 * _8001]
                                            require _8001 - 1 < _8001
                                            if not mem[(32 * _8001 - 1) + _7961 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * -1 * t * _6943 / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _8001 - 1) + _7961 + ceil32(return_data.size) + 32] / mem[(32 * _8001 - 1) + _7961 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _8001 - 1) + _7961 + ceil32(return_data.size) + 32] < maxReportDelay * -1 * t * _6943 / 10^18 / 31556952
                                else:
                                    if _6653 * mem[_6878] / mem[_6878] != _6653:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _7019 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7019] = 26
                                    mem[_7019 + 32] = 'SafeMath: division by zero'
                                    if not (_6653 * _6943) - (t * _6943) / 10^18:
                                        _7095 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7095] = 26
                                        mem[_7095 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return 0
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < 0)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7282 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7282]:
                                                return 0
                                            if profitFactor * mem[_7282] / mem[_7282] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7282] < 0
                                        else:
                                            _7178 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_7178 + 96]
                                            mem[_7178 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_7178 + 96]
                                            mem[_7178 + 160] = wantAddress
                                            mem[_7178 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7178 + 196] = arg1
                                            mem[_7178 + 228] = 64
                                            mem[_7178 + 260] = mem[_7178 + 96]
                                            idx = 0
                                            s = _7178 + 292
                                            t = _7178 + 128
                                            while idx < mem[_7178 + 96]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7178 + (32 * mem[_7178 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7960 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7980 = mem[_7960]
                                            require mem[_7960] <= test266151307()
                                            require _7960 + return_data.size > _7960 + mem[_7960] + 31
                                            _8000 = mem[_7960 + mem[_7960]]
                                            require mem[_7960 + mem[_7960]] <= test266151307()
                                            require (32 * mem[_7960 + mem[_7960]]) + 32 >= 0 and _7960 + ceil32(return_data.size) + (32 * mem[_7960 + mem[_7960]]) + 32 <= test266151307()
                                            mem[64] = _7960 + ceil32(return_data.size) + (32 * mem[_7960 + mem[_7960]]) + 32
                                            mem[_7960 + ceil32(return_data.size)] = _8000
                                            require return_data.size >= _7980 + (32 * _8000) + 32
                                            mem[_7960 + ceil32(return_data.size) + 32 len 32 * _8000] = mem[_7960 + _7980 + 32 len 32 * _8000]
                                            require _8000 - 1 < _8000
                                            if not mem[(32 * _8000 - 1) + _7960 + ceil32(return_data.size) + 32]:
                                                return 0
                                            if profitFactor * mem[(32 * _8000 - 1) + _7960 + ceil32(return_data.size) + 32] / mem[(32 * _8000 - 1) + _7960 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _8000 - 1) + _7960 + ceil32(return_data.size) + 32] < 0
                                    else:
                                        if maxReportDelay * (_6653 * _6943) - (t * _6943) / 10^18 / (_6653 * _6943) - (t * _6943) / 10^18 != maxReportDelay:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7105 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7105] = 26
                                        mem[_7105 + 32] = 'SafeMath: division by zero'
                                        if 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 == wantAddress:
                                            if not arg1:
                                                return (0 < maxReportDelay * (_6653 * _6943) - (t * _6943) / 10^18 / 31556952)
                                            if profitFactor * arg1 / arg1 != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            return (profitFactor * arg1 < maxReportDelay * (_6653 * _6943) - (t * _6943) / 10^18 / 31556952)
                                        if wantToEthOracleAddress:
                                            mem[mem[64] + 4] = arg1
                                            require ext_code.size(wantToEthOracleAddress)
                                            staticcall wantToEthOracleAddress.ethToWant(uint256 rg1) with:
                                                    gas gas_remaining wei
                                                   args arg1
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7315 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            if not mem[_7315]:
                                                return (0 < maxReportDelay * (_6653 * _6943) - (t * _6943) / 10^18 / 31556952)
                                            if profitFactor * mem[_7315] / mem[_7315] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[_7315] < maxReportDelay * (_6653 * _6943) - (t * _6943) / 10^18 / 31556952
                                        else:
                                            _7217 = mem[64]
                                            mem[mem[64] + 32 len 64] = call.data[calldata.size len 64]
                                            mem[mem[64] + 96] = 2
                                            mem[64] = mem[64] + 192
                                            require 0 < mem[_7217 + 96]
                                            mem[_7217 + 128] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2
                                            require 1 < mem[_7217 + 96]
                                            mem[_7217 + 160] = wantAddress
                                            mem[_7217 + 192] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[_7217 + 196] = arg1
                                            mem[_7217 + 228] = 64
                                            mem[_7217 + 260] = mem[_7217 + 96]
                                            idx = 0
                                            s = _7217 + 292
                                            u = _7217 + 128
                                            while idx < mem[_7217 + 96]:
                                                mem[s] = mem[u + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                u = u + 32
                                                continue 
                                            require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)
                                            staticcall 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.mem[mem[64] len 4] with:
                                                    gas gas_remaining wei
                                                   args mem[mem[64] + 4 len _7217 + (32 * mem[_7217 + 96]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7959 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7979 = mem[_7959]
                                            require mem[_7959] <= test266151307()
                                            require _7959 + return_data.size > _7959 + mem[_7959] + 31
                                            _7999 = mem[_7959 + mem[_7959]]
                                            require mem[_7959 + mem[_7959]] <= test266151307()
                                            require (32 * mem[_7959 + mem[_7959]]) + 32 >= 0 and _7959 + ceil32(return_data.size) + (32 * mem[_7959 + mem[_7959]]) + 32 <= test266151307()
                                            mem[64] = _7959 + ceil32(return_data.size) + (32 * mem[_7959 + mem[_7959]]) + 32
                                            mem[_7959 + ceil32(return_data.size)] = _7999
                                            require return_data.size >= _7979 + (32 * _7999) + 32
                                            mem[_7959 + ceil32(return_data.size) + 32 len 32 * _7999] = mem[_7959 + _7979 + 32 len 32 * _7999]
                                            require _7999 - 1 < _7999
                                            if not mem[(32 * _7999 - 1) + _7959 + ceil32(return_data.size) + 32]:
                                                return (0 < maxReportDelay * (_6653 * _6943) - (t * _6943) / 10^18 / 31556952)
                                            if profitFactor * mem[(32 * _7999 - 1) + _7959 + ceil32(return_data.size) + 32] / mem[(32 * _7999 - 1) + _7959 + ceil32(return_data.size) + 32] != profitFactor:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[mem[64]] = profitFactor * mem[(32 * _7999 - 1) + _7959 + ceil32(return_data.size) + 32] < maxReportDelay * (_6653 * _6943) - (t * _6943) / 10^18 / 31556952
    return memory
      from mem[64]
       len 32
}



}
