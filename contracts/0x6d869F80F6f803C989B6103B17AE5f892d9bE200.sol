contract main {




// =====================  Runtime code  =====================


#
#  - earn()
#
const sub_0316446f(?) = 100

const controllerFeeUL = 300

const sub_241c2b8c(?) = 10000

const sub_5f89eabc(?) = 800

const withdrawFeeFactorMax = 10000

const withdrawFeeFactorLL = 9950

const buyBackRateUL = 800

const slippageFactorUL = 995

const entranceFeeFactorLL = 9950

const entranceFeeFactorMax = 10000

const wftm = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83


address owner;
uint256 stor1;
uint8 stor2;
uint8 stor2; offset 8
uint32 stor2;
address stor2;
address farmContractAddress; offset 16
uint256 stor2;
uint256 pid;
address wantAddress;
address token0Address;
address token1Address;
address earnedAddress;
uint32 stor8;
address uniRouterAddress;
uint256 stor8;
uint32 stor9;
address sub_94d79b84Address;
uint256 stor9;
uint8 stor10; offset 160
uint128 stor10; offset 160
address govAddress;
uint256 lastEarnBlock;
uint256 stor12; offset 32
uint256 wantLockedTotal;
big480 stor12;
uint256 sharesTotal;
address buyBackAddress;
address rewardsAddress;
address devAddress;
uint256 buyBackRate;
uint256 sub_daecd258;
uint256 sub_3cc89a40;
uint256 controllerFee;
uint256 entranceFeeFactor;
uint256 withdrawFeeFactor;
uint256 slippageFactor;
array of address earnedToToken0Path;
array of address earnedToToken1Path;
array of address sub_58d6a125;
array of address sub_6ac29cd4;
array of struct token0ToEarnedPath;
array of struct token1ToEarnedPath;

function token1ToEarnedPath(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < token1ToEarnedPath.length
    return token1ToEarnedPath[arg1].field_0
}

function onlyGov() payable {
    return bool(uint8(stor10.field_160))
}

function lastEarnBlock() payable {
    return lastEarnBlock
}

function entranceFeeFactor() payable {
    return entranceFeeFactor
}

function buyBackRate() payable {
    return buyBackRate
}

function devAddress() payable {
    return devAddress
}

function sub_3cc89a40(?) payable {
    return sub_3cc89a40
}

function wantLockedTotal() payable {
    return wantLockedTotal
}

function sharesTotal() payable {
    return sharesTotal
}

function govAddress() payable {
    return govAddress
}

function sub_58d6a125(?) payable {
    require calldata.size - 4 >= 32
    require arg1 < sub_58d6a125.length
    return sub_58d6a125[arg1]
}

function paused() payable {
    return bool(uint8(stor2.field_0))
}

function withdrawFeeFactor() payable {
    return withdrawFeeFactor
}

function uniRouterAddress() payable {
    return address(uniRouterAddress)
}

function sub_6ac29cd4(?) payable {
    require calldata.size - 4 >= 32
    require arg1 < sub_6ac29cd4.length
    return sub_6ac29cd4[arg1]
}

function buyBackAddress() payable {
    return buyBackAddress
}

function token0Address() payable {
    return token0Address
}

function controllerFee() payable {
    return controllerFee
}

function owner() payable {
    return owner
}

function sub_94d79b84(?) payable {
    return address(sub_94d79b84Address)
}

function earnedToToken1Path(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < earnedToToken1Path.length
    return earnedToToken1Path[arg1]
}

function isSameAssetDeposit() payable {
    return bool(uint8(stor2.field_8))
}

function farmContractAddress() payable {
    return farmContractAddress
}

function token0ToEarnedPath(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < token0ToEarnedPath.length
    return token0ToEarnedPath[arg1].field_0
}

function rewardsAddress() payable {
    return rewardsAddress
}

function earnedToToken0Path(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < earnedToToken0Path.length
    return earnedToToken0Path[arg1]
}

function token1Address() payable {
    return token1Address
}

function sub_daecd258(?) payable {
    return sub_daecd258
}

function earnedAddress() payable {
    return earnedAddress
}

function wantAddress() payable {
    return wantAddress
}

function pid() payable {
    return pid
}

function slippageFactor() payable {
    return slippageFactor
}

function w1() payable {
  stop
}

function sub_603277c5(?) payable {
  stop
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function setGov(address arg1) payable {
    require calldata.size - 4 >= 32
    if govAddress != msg.sender:
        revert with 0, '!gov'
    govAddress = arg1
    emit SetGov(arg1);
}

function setDevAddress(address arg1) payable {
    require calldata.size - 4 >= 32
    if govAddress != msg.sender:
        revert with 0, '!gov'
    devAddress = arg1
    emit SetDevAddress(arg1);
}

function setRewardsAddress(address arg1) payable {
    require calldata.size - 4 >= 32
    if govAddress != msg.sender:
        revert with 0, '!gov'
    rewardsAddress = arg1
    emit SetRewardsAddress(arg1);
}

function setBuyBackAddress(address arg1) payable {
    require calldata.size - 4 >= 32
    if govAddress != msg.sender:
        revert with 0, '!gov'
    buyBackAddress = arg1
    emit SetBuyBackAddress(arg1);
}

function pause() payable {
    if govAddress != msg.sender:
        revert with 0, '!gov'
    if uint8(stor2.field_0):
        revert with 0, 'Pausable: paused'
    uint8(stor2.field_0) = 1
    emit Paused(msg.sender);
}

function setOnlyGov(bool arg1) payable {
    require calldata.size - 4 >= 32
    if govAddress != msg.sender:
        revert with 0, '!gov'
    Mask(96, 0, stor10.field_160) = Mask(96, 0, arg1)
    emit SetOnlyGov(arg1);
}

function setUniRouterAddress(address arg1) payable {
    require calldata.size - 4 >= 32
    if govAddress != msg.sender:
        revert with 0, '!gov'
    address(uniRouterAddress) = arg1
    emit SetUniRouterAddress(arg1);
}

function unpause() payable {
    if govAddress != msg.sender:
        revert with 0, '!gov'
    if not uint8(stor2.field_0):
        revert with 0, 'Pausable: not paused'
    uint8(stor2.field_0) = 0
    emit Unpaused(msg.sender);
}

function wrapBNB() payable {
    if govAddress != msg.sender:
        revert with 0, '!gov'
    if eth.balance(this.address):
        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
           value eth.balance(this.address) wei
             gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0x4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061646472657300,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function setSettings(uint256 arg1, uint256 arg2, uint256 arg3, uint256 arg4, uint256 arg5, uint256 arg6, uint256 arg7) payable {
    require calldata.size - 4 >= 224
    if govAddress != msg.sender:
        revert with 0, '!gov'
    if arg1 < 9950:
        revert with 0, '_entranceFeeFactor too low'
    if arg1 > 10000:
        revert with 0, '_entranceFeeFactor too high'
    entranceFeeFactor = arg1
    if arg2 < 9950:
        revert with 0, '_withdrawFeeFactor too low'
    if arg2 > 10000:
        revert with 0, '_withdrawFeeFactor too high'
    withdrawFeeFactor = arg2
    if arg3 > 300:
        revert with 0, '_controllerFee too high'
    controllerFee = arg3
    if arg4 > 800:
        revert with 0, '_buyBackRate too high'
    buyBackRate = arg4
    if arg5 > 800:
        revert with 0, '_estReward too high'
    sub_daecd258 = arg5
    if arg6 > sub_3cc89a40:
        revert with 0, '_callerReward too high'
    sub_3cc89a40 = arg6
    if arg7 > 995:
        revert with 0, '_slippageFactor too high'
    slippageFactor = arg7
    emit SetSettings(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
}

function inCaseTokensGetStuck(address arg1, uint256 arg2, address arg3) payable {
    require calldata.size - 4 >= 96
    if govAddress != msg.sender:
        revert with 0, '!gov'
    if earnedAddress == arg1:
        revert with 0, '!safe'
    if wantAddress == arg1:
        revert with 0, '!safe'
    if eth.balance(this.address) < 0:
        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[366 len 26]
    if not ext_code.size(arg1):
        revert with 0, 'Address: call to non-contract'
    mem[260 len 64] = unknown_0xa9059cbb(?????), address(arg3) << 64, 0, Mask(224, 32, arg2) >> 32
    call arg1 with:
         gas gas_remaining wei
        args Mask(224, 32, arg2) << 224, mem[324 len 4]
    if not return_data.size:
        if not ext_call.success:
            revert with unknown_0xa9059cbb(?????), address(arg3) << 64, 0, arg2
        if not unknown_0xa9059cbb(?????), address(arg3) << 64:
            revert with 0, 32, 42, 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
    else:
        mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            if not mem[292]:
                revert with 0, 
                            32,
                            42,
                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[ceil32(return_data.size) + 371 len 22]
}

function farm() payable {
    if stor1 == 2:
        revert with 0, 32, 31, 0xfe5265656e7472616e637947756172643a207265656e7472616e742063616c6c
    stor1 = 2
    require ext_code.size(wantAddress)
    staticcall wantAddress.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] + wantLockedTotal < wantLockedTotal:
        revert with 0, 'SafeMath: addition overflow'
    wantLockedTotal += ext_call.return_data[0]
    require ext_code.size(wantAddress)
    staticcall wantAddress.0xdd62ed3e with:
            gas gas_remaining wei
           args address(this.address), farmContractAddress
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
        revert with 0, 'SafeMath: addition overflow'
    if eth.balance(this.address) < 0:
        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[366 len 26]
    if not ext_code.size(wantAddress):
        revert with 0, 'Address: call to non-contract'
    mem[260 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor2.field_0), uint32(stor2.field_0), Mask(224, 31, ext_call.return_data[0]) >> 31
    call wantAddress with:
       funct uint32(stor2.field_0)
         gas gas_remaining wei
        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[324 len 4]
    if not return_data.size:
        if not ext_call.success:
            revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor2.field_0), uint32(stor2.field_0), 2 * ext_call.return_data[0]
        if not approve(address rg1, uint256 rg2), Mask(224, 0, stor2.field_0):
            revert with 0, 32, 42, 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
    else:
        mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            if not mem[292]:
                revert with 0, 
                            32,
                            42,
                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[ceil32(return_data.size) + 371 len 22]
    require ext_code.size(farmContractAddress)
    call farmContractAddress.0xe2bbb158 with:
         gas gas_remaining wei
        args pid, ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    stor1 = 1
}

function withdraw(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if stor1 == 2:
        revert with 0, 32, 31, 0xfe5265656e7472616e637947756172643a207265656e7472616e742063616c6c
    stor1 = 2
    if not arg2:
        revert with 0, '_wantAmt <= 0'
    if sharesTotal * arg2 / arg2 != sharesTotal:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    if not wantLockedTotal:
        revert with 0, 'SafeMath: division by zero'
    if sharesTotal * arg2 / wantLockedTotal <= sharesTotal:
        sharesTotal -= sharesTotal * arg2 / wantLockedTotal
        if 10000 <= withdrawFeeFactor:
            require ext_code.size(farmContractAddress)
            call farmContractAddress.0x441a3e70 with:
                 gas gas_remaining wei
                args pid, arg2
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(wantAddress)
            staticcall wantAddress.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if arg2 <= ext_call.return_data[0]:
                if wantLockedTotal >= arg2:
                    if arg2 > wantLockedTotal:
                        revert with 0, 'SafeMath: subtraction overflow'
                    wantLockedTotal -= arg2
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                    if not ext_code.size(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor9), uint32(stor9), Mask(224, 32, arg2) >> 32
                    mem[516 len 0] = 0
                    call wantAddress with:
                       funct uint32(stor9)
                         gas gas_remaining wei
                        args Mask(224, 32, arg2) << 224, mem[516 len 4]
                else:
                    if wantLockedTotal > wantLockedTotal:
                        revert with 0, 'SafeMath: subtraction overflow'
                    wantLockedTotal = 0
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                    if not ext_code.size(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor9), uint32(stor9), Mask(224, 0, stor12.field_32)
                    mem[516 len 0] = 0
                    call wantAddress with:
                       funct uint32(stor9)
                         gas gas_remaining wei
                        args Mask(480, 0, stor12.field_0), mem[516 len 4]
            else:
                if wantLockedTotal >= ext_call.return_data[0]:
                    if ext_call.return_data[0] > wantLockedTotal:
                        revert with 0, 'SafeMath: subtraction overflow'
                    wantLockedTotal -= ext_call.return_data[0]
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                    if not ext_code.size(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor9), uint32(stor9), ext_call.return_data[0 len 28]
                    call wantAddress with:
                       funct uint32(stor9)
                         gas gas_remaining wei
                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[516 len 4]
                else:
                    if wantLockedTotal > wantLockedTotal:
                        revert with 0, 'SafeMath: subtraction overflow'
                    wantLockedTotal = 0
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                    if not ext_code.size(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor9), uint32(stor9), Mask(224, 0, stor12.field_32)
                    mem[516 len 0] = 0
                    call wantAddress with:
                       funct uint32(stor9)
                         gas gas_remaining wei
                        args Mask(480, 0, stor12.field_0), mem[516 len 4]
            if not return_data.size:
                require not ext_call.success
                revert with 'SafeMath: division by zero'
            mem[484 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                if not mem[484]:
                    revert with 0, 
                                32,
                                42,
                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[ceil32(return_data.size) + 563 len 22]
        else:
            if not arg2:
                require ext_code.size(farmContractAddress)
                call farmContractAddress.0x441a3e70 with:
                     gas gas_remaining wei
                    args pid, 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(wantAddress)
                staticcall wantAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if 0 <= ext_call.return_data[0]:
                    if wantLockedTotal >= 0:
                        if 0 > wantLockedTotal:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                        if not ext_code.size(wantAddress):
                            revert with 0, 'Address: call to non-contract'
                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor9), uint32(stor9), 0
                        call wantAddress with:
                           funct uint32(stor9)
                             gas gas_remaining wei
                            args 0, mem[580 len 4]
                    else:
                        if wantLockedTotal > wantLockedTotal:
                            revert with 0, 'SafeMath: subtraction overflow'
                        wantLockedTotal = 0
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                        if not ext_code.size(wantAddress):
                            revert with 0, 'Address: call to non-contract'
                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor9), uint32(stor9), Mask(224, 0, stor12.field_32)
                        call wantAddress with:
                           funct uint32(stor9)
                             gas gas_remaining wei
                            args Mask(480, 0, stor12.field_0), mem[580 len 4]
                else:
                    if wantLockedTotal >= ext_call.return_data[0]:
                        if ext_call.return_data[0] > wantLockedTotal:
                            revert with 0, 'SafeMath: subtraction overflow'
                        wantLockedTotal -= ext_call.return_data[0]
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                        if not ext_code.size(wantAddress):
                            revert with 0, 'Address: call to non-contract'
                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor9), uint32(stor9), ext_call.return_data[0 len 28]
                        mem[580 len 0] = 0
                        call wantAddress with:
                           funct uint32(stor9)
                             gas gas_remaining wei
                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                    else:
                        if wantLockedTotal > wantLockedTotal:
                            revert with 0, 'SafeMath: subtraction overflow'
                        wantLockedTotal = 0
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                        if not ext_code.size(wantAddress):
                            revert with 0, 'Address: call to non-contract'
                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor9), uint32(stor9), Mask(224, 0, stor12.field_32)
                        mem[580 len 0] = 0
                        call wantAddress with:
                           funct uint32(stor9)
                             gas gas_remaining wei
                            args Mask(480, 0, stor12.field_0), mem[580 len 4]
            else:
                if withdrawFeeFactor * arg2 / arg2 != withdrawFeeFactor:
                    revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                require ext_code.size(farmContractAddress)
                call farmContractAddress.0x441a3e70 with:
                     gas gas_remaining wei
                    args pid, withdrawFeeFactor * arg2 / 10000
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(wantAddress)
                staticcall wantAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if withdrawFeeFactor * arg2 / 10000 <= ext_call.return_data[0]:
                    if wantLockedTotal >= withdrawFeeFactor * arg2 / 10000:
                        if withdrawFeeFactor * arg2 / 10000 > wantLockedTotal:
                            revert with 0, 'SafeMath: subtraction overflow'
                        wantLockedTotal -= withdrawFeeFactor * arg2 / 10000
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                        if not ext_code.size(wantAddress):
                            revert with 0, 'Address: call to non-contract'
                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor9), uint32(stor9), Mask(224, 32, withdrawFeeFactor * arg2 / 10000) >> 32
                        mem[580 len 0] = 0
                        call wantAddress with:
                           funct uint32(stor9)
                             gas gas_remaining wei
                            args Mask(224, 32, withdrawFeeFactor * arg2 / 10000) << 224, mem[580 len 4]
                    else:
                        if wantLockedTotal > wantLockedTotal:
                            revert with 0, 'SafeMath: subtraction overflow'
                        wantLockedTotal = 0
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                        if not ext_code.size(wantAddress):
                            revert with 0, 'Address: call to non-contract'
                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor9), uint32(stor9), Mask(224, 0, stor12.field_32)
                        mem[580 len 0] = 0
                        call wantAddress with:
                           funct uint32(stor9)
                             gas gas_remaining wei
                            args Mask(480, 0, stor12.field_0), mem[580 len 4]
                else:
                    if wantLockedTotal < ext_call.return_data[0]:
                        if wantLockedTotal > wantLockedTotal:
                            revert with 0, 'SafeMath: subtraction overflow'
                        wantLockedTotal = 0
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                        if not ext_code.size(wantAddress):
                            revert with 0, 'Address: call to non-contract'
                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor9), uint32(stor9), Mask(224, 0, stor12.field_32)
                        call wantAddress with:
                           funct uint32(stor9)
                             gas gas_remaining wei
                            args Mask(480, 0, stor12.field_0), mem[580 len 4]
                    else:
                        if ext_call.return_data[0] > wantLockedTotal:
                            revert with 0, 'SafeMath: subtraction overflow'
                        wantLockedTotal -= ext_call.return_data[0]
                        if eth.balance(this.address) < 0:
                            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                        if not ext_code.size(wantAddress):
                            revert with 0, 'Address: call to non-contract'
                        mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor9), uint32(stor9), ext_call.return_data[0 len 28]
                        mem[580 len 0] = 0
                        call wantAddress with:
                           funct uint32(stor9)
                             gas gas_remaining wei
                            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
            if not return_data.size:
                require not ext_call.success
                revert with 'SafeMath: division by zero'
            mem[548 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                if not mem[548]:
                    revert with 0, 
                                32,
                                42,
                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[ceil32(return_data.size) + 627 len 22]
        stor1 = 1
        return (sharesTotal * arg2 / wantLockedTotal)
    if sharesTotal > sharesTotal:
        revert with 0, 'SafeMath: subtraction overflow'
    sharesTotal = 0
    if 10000 <= withdrawFeeFactor:
        require ext_code.size(farmContractAddress)
        call farmContractAddress.0x441a3e70 with:
             gas gas_remaining wei
            args pid, arg2
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require ext_code.size(wantAddress)
        staticcall wantAddress.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if arg2 > ext_call.return_data[0]:
            if wantLockedTotal >= ext_call.return_data[0]:
                if ext_call.return_data[0] > wantLockedTotal:
                    revert with 0, 'SafeMath: subtraction overflow'
                wantLockedTotal -= ext_call.return_data[0]
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                if not ext_code.size(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor9), uint32(stor9), ext_call.return_data[0 len 28]
                call wantAddress with:
                   funct uint32(stor9)
                     gas gas_remaining wei
                    args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[516 len 4]
            else:
                if wantLockedTotal > wantLockedTotal:
                    revert with 0, 'SafeMath: subtraction overflow'
                wantLockedTotal = 0
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                if not ext_code.size(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor9), uint32(stor9), Mask(224, 0, stor12.field_32)
                call wantAddress with:
                   funct uint32(stor9)
                     gas gas_remaining wei
                    args Mask(480, 0, stor12.field_0), mem[516 len 4]
        else:
            if wantLockedTotal < arg2:
                if wantLockedTotal > wantLockedTotal:
                    revert with 0, 'SafeMath: subtraction overflow'
                wantLockedTotal = 0
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                if not ext_code.size(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor9), uint32(stor9), Mask(224, 0, stor12.field_32)
                call wantAddress with:
                   funct uint32(stor9)
                     gas gas_remaining wei
                    args Mask(480, 0, stor12.field_0), mem[516 len 4]
            else:
                if arg2 > wantLockedTotal:
                    revert with 0, 'SafeMath: subtraction overflow'
                wantLockedTotal -= arg2
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[558 len 26]
                if not ext_code.size(wantAddress):
                    revert with 0, 'Address: call to non-contract'
                mem[452 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor9), uint32(stor9), Mask(224, 32, arg2) >> 32
                mem[516 len 0] = 0
                call wantAddress with:
                   funct uint32(stor9)
                     gas gas_remaining wei
                    args Mask(224, 32, arg2) << 224, mem[516 len 4]
        if not return_data.size:
            require not ext_call.success
            revert with 'SafeMath: division by zero'
        mem[484 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            if not mem[484]:
                revert with 0, 
                            32,
                            42,
                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[ceil32(return_data.size) + 563 len 22]
    else:
        if not arg2:
            require ext_code.size(farmContractAddress)
            call farmContractAddress.0x441a3e70 with:
                 gas gas_remaining wei
                args pid, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(wantAddress)
            staticcall wantAddress.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if 0 <= ext_call.return_data[0]:
                if wantLockedTotal >= 0:
                    if 0 > wantLockedTotal:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                    if not ext_code.size(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor9), uint32(stor9), 0
                    mem[580 len 0] = 0
                    call wantAddress with:
                       funct uint32(stor9)
                         gas gas_remaining wei
                        args Mask(480, -256, unknown_0xa9059cbb(?????), Mask(224, 0, stor9), uint32(stor9), 0) << 256, mem[580 len 4]
                else:
                    if wantLockedTotal > wantLockedTotal:
                        revert with 0, 'SafeMath: subtraction overflow'
                    wantLockedTotal = 0
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                    if not ext_code.size(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor9), uint32(stor9), Mask(224, 0, stor12.field_32)
                    call wantAddress with:
                       funct uint32(stor9)
                         gas gas_remaining wei
                        args Mask(480, 0, stor12.field_0), mem[580 len 4]
            else:
                if wantLockedTotal >= ext_call.return_data[0]:
                    if ext_call.return_data[0] > wantLockedTotal:
                        revert with 0, 'SafeMath: subtraction overflow'
                    wantLockedTotal -= ext_call.return_data[0]
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                    if not ext_code.size(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor9), uint32(stor9), ext_call.return_data[0 len 28]
                    call wantAddress with:
                       funct uint32(stor9)
                         gas gas_remaining wei
                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                else:
                    if wantLockedTotal > wantLockedTotal:
                        revert with 0, 'SafeMath: subtraction overflow'
                    wantLockedTotal = 0
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                    if not ext_code.size(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor9), uint32(stor9), Mask(224, 0, stor12.field_32)
                    mem[580 len 0] = 0
                    call wantAddress with:
                       funct uint32(stor9)
                         gas gas_remaining wei
                        args Mask(480, 0, stor12.field_0), mem[580 len 4]
        else:
            if withdrawFeeFactor * arg2 / arg2 != withdrawFeeFactor:
                revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            require ext_code.size(farmContractAddress)
            call farmContractAddress.0x441a3e70 with:
                 gas gas_remaining wei
                args pid, withdrawFeeFactor * arg2 / 10000
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require ext_code.size(wantAddress)
            staticcall wantAddress.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if withdrawFeeFactor * arg2 / 10000 <= ext_call.return_data[0]:
                if wantLockedTotal >= withdrawFeeFactor * arg2 / 10000:
                    if withdrawFeeFactor * arg2 / 10000 > wantLockedTotal:
                        revert with 0, 'SafeMath: subtraction overflow'
                    wantLockedTotal -= withdrawFeeFactor * arg2 / 10000
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                    if not ext_code.size(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor9), uint32(stor9), Mask(224, 32, withdrawFeeFactor * arg2 / 10000) >> 32
                    mem[580 len 0] = 0
                    call wantAddress with:
                       funct uint32(stor9)
                         gas gas_remaining wei
                        args Mask(224, 32, withdrawFeeFactor * arg2 / 10000) << 224, mem[580 len 4]
                else:
                    if wantLockedTotal > wantLockedTotal:
                        revert with 0, 'SafeMath: subtraction overflow'
                    wantLockedTotal = 0
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                    if not ext_code.size(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor9), uint32(stor9), Mask(224, 0, stor12.field_32)
                    mem[580 len 0] = 0
                    call wantAddress with:
                       funct uint32(stor9)
                         gas gas_remaining wei
                        args Mask(480, 0, stor12.field_0), mem[580 len 4]
            else:
                if wantLockedTotal >= ext_call.return_data[0]:
                    if ext_call.return_data[0] > wantLockedTotal:
                        revert with 0, 'SafeMath: subtraction overflow'
                    wantLockedTotal -= ext_call.return_data[0]
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                    if not ext_code.size(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor9), uint32(stor9), ext_call.return_data[0 len 28]
                    mem[580 len 0] = 0
                    call wantAddress with:
                       funct uint32(stor9)
                         gas gas_remaining wei
                        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[580 len 4]
                else:
                    if wantLockedTotal > wantLockedTotal:
                        revert with 0, 'SafeMath: subtraction overflow'
                    wantLockedTotal = 0
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[622 len 26]
                    if not ext_code.size(wantAddress):
                        revert with 0, 'Address: call to non-contract'
                    mem[516 len 64] = unknown_0xa9059cbb(?????), Mask(224, 0, stor9), uint32(stor9), Mask(224, 0, stor12.field_32)
                    mem[580 len 0] = 0
                    call wantAddress with:
                       funct uint32(stor9)
                         gas gas_remaining wei
                        args Mask(480, 0, stor12.field_0), mem[580 len 4]
        if not return_data.size:
            require not ext_call.success
            revert with 'SafeMath: division by zero'
        mem[548 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            if not mem[548]:
                revert with 0, 
                            32,
                            42,
                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[ceil32(return_data.size) + 627 len 22]
    stor1 = 1
    return sharesTotal
}

function deposit(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if stor1 == 2:
        revert with 0, 32, 31, 0xfe5265656e7472616e637947756172643a207265656e7472616e742063616c6c
    stor1 = 2
    if uint8(stor2.field_0):
        revert with 0, 'Pausable: paused'
    if eth.balance(this.address) < 0:
        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[398 len 26]
    if not ext_code.size(wantAddress):
        revert with 0, 'Address: call to non-contract'
    mem[292 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
    mem[416 len 4] = 0
    mem[388 len 0] = 0
    call wantAddress with:
         gas gas_remaining wei
        args Mask(224, 32, arg2) << 480, mem[388 len 4]
    if not return_data.size:
        if not ext_call.success:
            revert with unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2
        if not unknown_0x23b872dd(?????), Mask(224, 32, msg.sender) >> 32:
            revert with 0, 
                        32,
                        42,
                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                        mem[402 len 14],
                        0,
                        mem[420 len 4]
        if not wantLockedTotal:
            if arg2 + sharesTotal < sharesTotal:
                revert with 0, 'SafeMath: addition overflow'
            sharesTotal += arg2
            require ext_code.size(wantAddress)
            staticcall wantAddress.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] + wantLockedTotal < wantLockedTotal:
                revert with 0, 'SafeMath: addition overflow'
            wantLockedTotal += ext_call.return_data[0]
            require ext_code.size(wantAddress)
            staticcall wantAddress.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), farmContractAddress
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if eth.balance(this.address) < 0:
                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[562 len 26]
            if not ext_code.size(wantAddress):
                revert with 0, 'Address: call to non-contract'
            mem[456 len 64] = 0, address(stor2.field_0), Mask(224, 31, ext_call.return_data[0]) >> 31
            call wantAddress with:
               funct uint32(stor2.field_0)
                 gas gas_remaining wei
                args 2 * ext_call.return_data[0], mem[392 len 24], 0, mem[520 len 4]
            if not return_data.size:
                if not ext_call.success:
                    revert with unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2
                if not unknown_0x23b872dd(?????), Mask(224, 32, msg.sender) >> 32:
                    revert with 0, 32, 42, 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[566 len 22]
            else:
                mem[488 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size:
                    require return_data.size >= 32
                    if not mem[488]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[ceil32(return_data.size) + 567 len 22]
            require ext_code.size(farmContractAddress)
            call farmContractAddress.0xe2bbb158 with:
                 gas gas_remaining wei
                args pid, ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            stor1 = 1
            return arg2
        if sharesTotal <= 0:
            if arg2 + sharesTotal < sharesTotal:
                revert with 0, 'SafeMath: addition overflow'
            sharesTotal += arg2
            require ext_code.size(wantAddress)
            staticcall wantAddress.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] + wantLockedTotal < wantLockedTotal:
                revert with 0, 'SafeMath: addition overflow'
            wantLockedTotal += ext_call.return_data[0]
            require ext_code.size(wantAddress)
            staticcall wantAddress.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), farmContractAddress
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if eth.balance(this.address) < 0:
                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[562 len 26]
            if not ext_code.size(wantAddress):
                revert with 0, 'Address: call to non-contract'
            mem[456 len 64] = 0, address(stor2.field_0), Mask(224, 31, ext_call.return_data[0]) >> 31
            call wantAddress with:
               funct uint32(stor2.field_0)
                 gas gas_remaining wei
                args 2 * ext_call.return_data[0], mem[392 len 24], 0, mem[520 len 4]
            if not return_data.size:
                if not ext_call.success:
                    revert with unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2
                if not unknown_0x23b872dd(?????), Mask(224, 32, msg.sender) >> 32:
                    revert with 0, 32, 42, 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[566 len 22]
            else:
                mem[488 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size:
                    require return_data.size >= 32
                    if not mem[488]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[ceil32(return_data.size) + 567 len 22]
            require ext_code.size(farmContractAddress)
            call farmContractAddress.0xe2bbb158 with:
                 gas gas_remaining wei
                args pid, ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            stor1 = 1
            return arg2
        if not arg2:
            if not wantLockedTotal:
                revert with 0, 'SafeMath: division by zero'
            if (0 / wantLockedTotal / 10000) + sharesTotal < sharesTotal:
                revert with 0, 'SafeMath: addition overflow'
            sharesTotal += 0 / wantLockedTotal / 10000
            require ext_code.size(wantAddress)
            staticcall wantAddress.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] + wantLockedTotal < wantLockedTotal:
                revert with 0, 'SafeMath: addition overflow'
            wantLockedTotal += ext_call.return_data[0]
            require ext_code.size(wantAddress)
            staticcall wantAddress.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), farmContractAddress
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if eth.balance(this.address) < 0:
                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[690 len 26]
            if not ext_code.size(wantAddress):
                revert with 0, 'Address: call to non-contract'
            mem[584 len 64] = 0, address(stor2.field_0), Mask(224, 31, ext_call.return_data[0]) >> 31
            call wantAddress with:
               funct uint32(stor2.field_0)
                 gas gas_remaining wei
                args 2 * ext_call.return_data[0], mem[520 len 28], mem[648 len 4]
            if not return_data.size:
                if not ext_call.success:
                    revert with unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2
                if not unknown_0x23b872dd(?????), Mask(224, 32, msg.sender) >> 32:
                    revert with 0, 32, 42, 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[694 len 22]
            else:
                mem[616 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size:
                    require return_data.size >= 32
                    if not mem[616]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[ceil32(return_data.size) + 695 len 22]
            require ext_code.size(farmContractAddress)
            call farmContractAddress.0xe2bbb158 with:
                 gas gas_remaining wei
                args pid, ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            stor1 = 1
            return (0 / wantLockedTotal / 10000)
        if sharesTotal * arg2 / arg2 != sharesTotal:
            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[393 len 23], 0, mem[420 len 4]
        if not sharesTotal * arg2:
            if not wantLockedTotal:
                revert with 0, 'SafeMath: division by zero'
            if (0 / wantLockedTotal / 10000) + sharesTotal < sharesTotal:
                revert with 0, 'SafeMath: addition overflow'
            sharesTotal += 0 / wantLockedTotal / 10000
            require ext_code.size(wantAddress)
            staticcall wantAddress.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] + wantLockedTotal < wantLockedTotal:
                revert with 0, 'SafeMath: addition overflow'
            wantLockedTotal += ext_call.return_data[0]
            require ext_code.size(wantAddress)
            staticcall wantAddress.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), farmContractAddress
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if eth.balance(this.address) < 0:
                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[690 len 26]
            if not ext_code.size(wantAddress):
                revert with 0, 'Address: call to non-contract'
            mem[584 len 64] = 0, address(stor2.field_0), Mask(224, 31, ext_call.return_data[0]) >> 31
            call wantAddress with:
               funct uint32(stor2.field_0)
                 gas gas_remaining wei
                args 2 * ext_call.return_data[0], mem[520 len 28], mem[648 len 4]
            if not return_data.size:
                if not ext_call.success:
                    revert with unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2
                if not unknown_0x23b872dd(?????), Mask(224, 32, msg.sender) >> 32:
                    revert with 0, 32, 42, 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[694 len 22]
            else:
                mem[616 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size:
                    require return_data.size >= 32
                    if not mem[616]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[ceil32(return_data.size) + 695 len 22]
            require ext_code.size(farmContractAddress)
            call farmContractAddress.0xe2bbb158 with:
                 gas gas_remaining wei
                args pid, ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            stor1 = 1
            return (0 / wantLockedTotal / 10000)
        if entranceFeeFactor * sharesTotal * arg2 / sharesTotal * arg2 != entranceFeeFactor:
            revert with 0, 32, 33, 0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[393 len 23], 0, mem[420 len 4]
        if not wantLockedTotal:
            revert with 0, 'SafeMath: division by zero'
        if (entranceFeeFactor * sharesTotal * arg2 / wantLockedTotal / 10000) + sharesTotal < sharesTotal:
            revert with 0, 'SafeMath: addition overflow'
        sharesTotal += entranceFeeFactor * sharesTotal * arg2 / wantLockedTotal / 10000
        require ext_code.size(wantAddress)
        staticcall wantAddress.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] + wantLockedTotal < wantLockedTotal:
            revert with 0, 'SafeMath: addition overflow'
        wantLockedTotal += ext_call.return_data[0]
        require ext_code.size(wantAddress)
        staticcall wantAddress.0xdd62ed3e with:
                gas gas_remaining wei
               args address(this.address), farmContractAddress
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
            revert with 0, 'SafeMath: addition overflow'
        if eth.balance(this.address) < 0:
            revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[690 len 26]
        if not ext_code.size(wantAddress):
            revert with 0, 'Address: call to non-contract'
        mem[584 len 64] = 0, address(stor2.field_0), Mask(224, 31, ext_call.return_data[0]) >> 31
        call wantAddress with:
           funct uint32(stor2.field_0)
             gas gas_remaining wei
            args 2 * ext_call.return_data[0], mem[520 len 28], mem[648 len 4]
        if not return_data.size:
            if not ext_call.success:
                revert with unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2
            if not unknown_0x23b872dd(?????), Mask(224, 32, msg.sender) >> 32:
                revert with 0, 32, 42, 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[694 len 22]
        else:
            mem[616 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                if not mem[616]:
                    revert with 0, 
                                32,
                                42,
                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[ceil32(return_data.size) + 695 len 22]
        require ext_code.size(farmContractAddress)
        call farmContractAddress.0xe2bbb158 with:
             gas gas_remaining wei
            args pid, ext_call.return_data[0]
    else:
        mem[324 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            if not mem[324]:
                revert with 0, 
                            32,
                            42,
                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[ceil32(return_data.size) + 403 len 22]
        if not wantLockedTotal:
            if arg2 + sharesTotal < sharesTotal:
                revert with 0, 'SafeMath: addition overflow'
            sharesTotal += arg2
            require ext_code.size(wantAddress)
            staticcall wantAddress.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] + wantLockedTotal < wantLockedTotal:
                revert with 0, 'SafeMath: addition overflow'
            wantLockedTotal += ext_call.return_data[0]
            require ext_code.size(wantAddress)
            staticcall wantAddress.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), farmContractAddress
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if eth.balance(this.address) < 0:
                revert with 0, 
                            32,
                            38,
                            0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                            mem[ceil32(return_data.size) + 563 len 26]
            if not ext_code.size(wantAddress):
                revert with 0, 'Address: call to non-contract'
            mem[ceil32(return_data.size) + 457 len 64] = 0, address(stor2.field_0), Mask(224, 31, ext_call.return_data[0]) >> 31
            mem[ceil32(return_data.size) + 549 len 4] = 0
            call wantAddress with:
               funct uint32(stor2.field_0)
                 gas gas_remaining wei
                args 2 * ext_call.return_data[0], mem[ceil32(return_data.size) + 393 len 28], mem[ceil32(return_data.size) + 521 len 4]
            if not return_data.size:
                if not ext_call.success:
                    revert with unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2
                if not unknown_0x23b872dd(?????), Mask(224, 32, msg.sender) >> 32:
                    revert with 0, 
                                32,
                                42,
                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[ceil32(return_data.size) + 567 len 22]
                require ext_code.size(farmContractAddress)
                call farmContractAddress.0xe2bbb158 with:
                     gas gas_remaining wei
                    args pid, ext_call.return_data[0]
            else:
                mem[ceil32(return_data.size) + 489 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 
                                'SafeERC20: low-level call failed',
                                mem[(2 * ceil32(return_data.size)) + 558 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))]
                if return_data.size:
                    require return_data.size >= 32
                    if not mem[ceil32(return_data.size) + 489]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[(2 * ceil32(return_data.size)) + 568 len (2 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 22]
                require ext_code.size(farmContractAddress)
                call farmContractAddress.0xe2bbb158 with:
                     gas gas_remaining wei
                    args pid, ext_call.return_data[0], mem[(2 * ceil32(return_data.size)) + 526 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            stor1 = 1
            return arg2
        if sharesTotal <= 0:
            if arg2 + sharesTotal < sharesTotal:
                revert with 0, 'SafeMath: addition overflow'
            sharesTotal += arg2
            require ext_code.size(wantAddress)
            staticcall wantAddress.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] + wantLockedTotal < wantLockedTotal:
                revert with 0, 'SafeMath: addition overflow'
            wantLockedTotal += ext_call.return_data[0]
            require ext_code.size(wantAddress)
            staticcall wantAddress.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), farmContractAddress
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if eth.balance(this.address) < 0:
                revert with 0, 
                            32,
                            38,
                            0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                            mem[ceil32(return_data.size) + 563 len 26]
            if not ext_code.size(wantAddress):
                revert with 0, 'Address: call to non-contract'
            mem[ceil32(return_data.size) + 457 len 64] = 0, address(stor2.field_0), Mask(224, 31, ext_call.return_data[0]) >> 31
            mem[ceil32(return_data.size) + 549 len 4] = 0
            call wantAddress with:
               funct uint32(stor2.field_0)
                 gas gas_remaining wei
                args 2 * ext_call.return_data[0], mem[ceil32(return_data.size) + 393 len 28], mem[ceil32(return_data.size) + 521 len 4]
            if not return_data.size:
                if not ext_call.success:
                    revert with unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2
                if not unknown_0x23b872dd(?????), Mask(224, 32, msg.sender) >> 32:
                    revert with 0, 
                                32,
                                42,
                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[ceil32(return_data.size) + 567 len 22]
                require ext_code.size(farmContractAddress)
                call farmContractAddress.0xe2bbb158 with:
                     gas gas_remaining wei
                    args pid, ext_call.return_data[0]
            else:
                mem[ceil32(return_data.size) + 489 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 
                                'SafeERC20: low-level call failed',
                                mem[(2 * ceil32(return_data.size)) + 558 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))]
                if return_data.size:
                    require return_data.size >= 32
                    if not mem[ceil32(return_data.size) + 489]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[(2 * ceil32(return_data.size)) + 568 len (2 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 22]
                require ext_code.size(farmContractAddress)
                call farmContractAddress.0xe2bbb158 with:
                     gas gas_remaining wei
                    args pid, ext_call.return_data[0], mem[(2 * ceil32(return_data.size)) + 526 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            stor1 = 1
            return arg2
        if not arg2:
            if not wantLockedTotal:
                revert with 0, 'SafeMath: division by zero'
            if (0 / wantLockedTotal / 10000) + sharesTotal < sharesTotal:
                revert with 0, 'SafeMath: addition overflow'
            sharesTotal += 0 / wantLockedTotal / 10000
            require ext_code.size(wantAddress)
            staticcall wantAddress.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] + wantLockedTotal < wantLockedTotal:
                revert with 0, 'SafeMath: addition overflow'
            wantLockedTotal += ext_call.return_data[0]
            require ext_code.size(wantAddress)
            staticcall wantAddress.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), farmContractAddress
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if eth.balance(this.address) < 0:
                revert with 0, 
                            32,
                            38,
                            0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                            mem[ceil32(return_data.size) + 691 len 26]
            if not ext_code.size(wantAddress):
                revert with 0, 'Address: call to non-contract'
            mem[ceil32(return_data.size) + 585 len 64] = 0, address(stor2.field_0), Mask(224, 31, ext_call.return_data[0]) >> 31
            call wantAddress with:
               funct uint32(stor2.field_0)
                 gas gas_remaining wei
                args 2 * ext_call.return_data[0], mem[ceil32(return_data.size) + 521 len 28], mem[ceil32(return_data.size) + 649 len 4]
            if not return_data.size:
                if not ext_call.success:
                    revert with unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2
                if not unknown_0x23b872dd(?????), Mask(224, 32, msg.sender) >> 32:
                    revert with 0, 
                                32,
                                42,
                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[ceil32(return_data.size) + 695 len 22]
            else:
                mem[ceil32(return_data.size) + 617 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size:
                    require return_data.size >= 32
                    if not mem[ceil32(return_data.size) + 617]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[(2 * ceil32(return_data.size)) + 696 len 22]
            require ext_code.size(farmContractAddress)
            call farmContractAddress.0xe2bbb158 with:
                 gas gas_remaining wei
                args pid, ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            stor1 = 1
            return (0 / wantLockedTotal / 10000)
        if sharesTotal * arg2 / arg2 != sharesTotal:
            revert with 0, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[ceil32(return_data.size) + 394 len 31]
        if not sharesTotal * arg2:
            if not wantLockedTotal:
                revert with 0, 'SafeMath: division by zero'
            if (0 / wantLockedTotal / 10000) + sharesTotal < sharesTotal:
                revert with 0, 'SafeMath: addition overflow'
            sharesTotal += 0 / wantLockedTotal / 10000
            require ext_code.size(wantAddress)
            staticcall wantAddress.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] + wantLockedTotal < wantLockedTotal:
                revert with 0, 'SafeMath: addition overflow'
            wantLockedTotal += ext_call.return_data[0]
            require ext_code.size(wantAddress)
            staticcall wantAddress.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), farmContractAddress
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            if eth.balance(this.address) < 0:
                revert with 0, 
                            32,
                            38,
                            0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                            mem[ceil32(return_data.size) + 691 len 26]
            if not ext_code.size(wantAddress):
                revert with 0, 'Address: call to non-contract'
            mem[ceil32(return_data.size) + 585 len 64] = 0, address(stor2.field_0), Mask(224, 31, ext_call.return_data[0]) >> 31
            call wantAddress with:
               funct uint32(stor2.field_0)
                 gas gas_remaining wei
                args 2 * ext_call.return_data[0], mem[ceil32(return_data.size) + 521 len 28], mem[ceil32(return_data.size) + 649 len 4]
            if not return_data.size:
                if not ext_call.success:
                    revert with unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2
                if not unknown_0x23b872dd(?????), Mask(224, 32, msg.sender) >> 32:
                    revert with 0, 
                                32,
                                42,
                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[ceil32(return_data.size) + 695 len 22]
            else:
                mem[ceil32(return_data.size) + 617 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size:
                    require return_data.size >= 32
                    if not mem[ceil32(return_data.size) + 617]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[(2 * ceil32(return_data.size)) + 696 len 22]
            require ext_code.size(farmContractAddress)
            call farmContractAddress.0xe2bbb158 with:
                 gas gas_remaining wei
                args pid, ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            stor1 = 1
            return (0 / wantLockedTotal / 10000)
        if entranceFeeFactor * sharesTotal * arg2 / sharesTotal * arg2 != entranceFeeFactor:
            revert with 0, 
                        32,
                        33,
                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[ceil32(return_data.size) + 394 len 31]
        if not wantLockedTotal:
            revert with 0, 'SafeMath: division by zero'
        if (entranceFeeFactor * sharesTotal * arg2 / wantLockedTotal / 10000) + sharesTotal < sharesTotal:
            revert with 0, 'SafeMath: addition overflow'
        sharesTotal += entranceFeeFactor * sharesTotal * arg2 / wantLockedTotal / 10000
        require ext_code.size(wantAddress)
        staticcall wantAddress.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] + wantLockedTotal < wantLockedTotal:
            revert with 0, 'SafeMath: addition overflow'
        wantLockedTotal += ext_call.return_data[0]
        require ext_code.size(wantAddress)
        staticcall wantAddress.0xdd62ed3e with:
                gas gas_remaining wei
               args address(this.address), farmContractAddress
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
            revert with 0, 'SafeMath: addition overflow'
        if eth.balance(this.address) < 0:
            revert with 0, 
                        32,
                        38,
                        0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                        mem[ceil32(return_data.size) + 691 len 26]
        if not ext_code.size(wantAddress):
            revert with 0, 'Address: call to non-contract'
        mem[ceil32(return_data.size) + 585 len 64] = 0, address(stor2.field_0), Mask(224, 31, ext_call.return_data[0]) >> 31
        mem[ceil32(return_data.size) + 677 len 4] = 0
        call wantAddress with:
           funct uint32(stor2.field_0)
             gas gas_remaining wei
            args 2 * ext_call.return_data[0], mem[ceil32(return_data.size) + 521 len 28], mem[ceil32(return_data.size) + 649 len 4]
        if not return_data.size:
            if not ext_call.success:
                revert with unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2
            if not unknown_0x23b872dd(?????), Mask(224, 32, msg.sender) >> 32:
                revert with 0, 
                            32,
                            42,
                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[ceil32(return_data.size) + 695 len 22]
            require ext_code.size(farmContractAddress)
            call farmContractAddress.0xe2bbb158 with:
                 gas gas_remaining wei
                args pid, ext_call.return_data[0]
        else:
            mem[ceil32(return_data.size) + 617 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 
                            'SafeERC20: low-level call failed',
                            mem[(2 * ceil32(return_data.size)) + 686 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))]
            if return_data.size:
                require return_data.size >= 32
                if not mem[ceil32(return_data.size) + 617]:
                    revert with 0, 
                                32,
                                42,
                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[(2 * ceil32(return_data.size)) + 696 len (2 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 22]
            require ext_code.size(farmContractAddress)
            call farmContractAddress.0xe2bbb158 with:
                 gas gas_remaining wei
                args pid, ext_call.return_data[0], mem[(2 * ceil32(return_data.size)) + 654 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    stor1 = 1
    return (entranceFeeFactor * sharesTotal * arg2 / wantLockedTotal / 10000)
}

function convertDustToEarned() payable {
    if uint8(stor2.field_0):
        revert with 0, 'Pausable: paused'
    require ext_code.size(token0Address)
    staticcall token0Address.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if earnedAddress == token0Address:
        require ext_code.size(token1Address)
        staticcall token1Address.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if earnedAddress != token1Address:
            if ext_call.return_data[0] > 0:
                require ext_code.size(token1Address)
                staticcall token1Address.0xdd62ed3e with:
                        gas gas_remaining wei
                       args address(this.address), address(uniRouterAddress)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                    revert with 0, 'SafeMath: addition overflow'
                mem[132] = address(uniRouterAddress)
                mem[164] = 2 * ext_call.return_data[0]
                mem[96] = 68
                mem[132 len 28] = Mask(224, 0, stor8)
                mem[128 len 4] = approve(address rg1, uint256 rg2)
                mem[196] = 32
                mem[228] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[366 len 26]
                if not ext_code.size(token1Address):
                    revert with 0, 'Address: call to non-contract'
                mem[260 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                mem[352 len 4] = 0
                mem[324 len 0] = 0
                call token1Address with:
                   funct uint32(stor8)
                     gas gas_remaining wei
                    args Mask(224, 31, ext_call.return_data[0]) << 225, mem[324 len 4]
                if not return_data.size:
                    if not ext_call.success:
                        revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                    if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                        revert with 0, 32, 42, 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
                    mem[260] = token1ToEarnedPath.length
                    if not token1ToEarnedPath.length:
                        if block.timestamp + 600 < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[(32 * token1ToEarnedPath.length) + 292] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[(32 * token1ToEarnedPath.length) + 296] = ext_call.return_data[0]
                        mem[(32 * token1ToEarnedPath.length) + 328] = 64
                        mem[(32 * token1ToEarnedPath.length) + 360] = token1ToEarnedPath.length
                        mem[(32 * token1ToEarnedPath.length) + 392 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                gas gas_remaining wei
                               args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 392 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * token1ToEarnedPath.length) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292
                        require return_data.size >= 32
                        _8605 = mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28]
                        require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] <= 4294967296
                        require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                        require mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292] <= 4294967296 and mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]) + 32 <= return_data.size
                        mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] = mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]
                        _8663 = mem[(32 * token1ToEarnedPath.length) + _8605 + 292]
                        mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324 len floor32(mem[(32 * token1ToEarnedPath.length) + _8605 + 292])] = mem[(32 * token1ToEarnedPath.length) + _8605 + 324 len floor32(mem[(32 * token1ToEarnedPath.length) + _8605 + 292])]
                        mem[(32 * _8663) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] = 30
                        mem[(32 * _8663) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 356] = 'SafeMath: subtraction overflow'
                        if 1 > mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1 < mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]
                        _12851 = mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]
                        if not mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]:
                            mem[(32 * _8663) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _8663) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                        else:
                            if slippageFactor * mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] / mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] != slippageFactor:
                                revert with 0, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * _8663) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 489 len 31]
                            mem[(32 * _8663) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], slippageFactor * _12851 / 1000, Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _8663) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                    else:
                        mem[0] = 29
                        mem[292] = address(token1ToEarnedPath.field_0)
                        if (32 * token1ToEarnedPath.length) + 32 <= 64:
                            if block.timestamp + 600 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[(32 * token1ToEarnedPath.length) + 292] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[(32 * token1ToEarnedPath.length) + 296] = ext_call.return_data[0]
                            mem[(32 * token1ToEarnedPath.length) + 328] = 64
                            mem[(32 * token1ToEarnedPath.length) + 360] = token1ToEarnedPath.length
                            mem[(32 * token1ToEarnedPath.length) + 392 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 392 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * token1ToEarnedPath.length) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292
                            require return_data.size >= 32
                            _8607 = mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28]
                            require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] <= 4294967296
                            require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                            require mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292] <= 4294967296 and mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]) + 32 <= return_data.size
                            mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] = mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]
                            _8664 = mem[(32 * token1ToEarnedPath.length) + _8607 + 292]
                            mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324 len floor32(mem[(32 * token1ToEarnedPath.length) + _8607 + 292])] = mem[(32 * token1ToEarnedPath.length) + _8607 + 324 len floor32(mem[(32 * token1ToEarnedPath.length) + _8607 + 292])]
                            mem[(32 * _8664) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] = 30
                            mem[(32 * _8664) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 356] = 'SafeMath: subtraction overflow'
                            if 1 > mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1 < mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]
                            _12854 = mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]
                            if not mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]:
                                mem[(32 * _8664) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _8664) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                            else:
                                if slippageFactor * mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] / mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] != slippageFactor:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _8664) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 489 len 31]
                                mem[(32 * _8664) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], slippageFactor * _12854 / 1000, Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _8664) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                        else:
                            mem[324] = address(token1ToEarnedPath.field_256)
                            idx = 324
                            s = 1
                            while (32 * token1ToEarnedPath.length) + 260 > idx:
                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            if block.timestamp + 600 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[(32 * token1ToEarnedPath.length) + 292] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[(32 * token1ToEarnedPath.length) + 296] = ext_call.return_data[0]
                            mem[(32 * token1ToEarnedPath.length) + 328] = 64
                            mem[(32 * token1ToEarnedPath.length) + 360] = token1ToEarnedPath.length
                            mem[(32 * token1ToEarnedPath.length) + 392 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 392 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * token1ToEarnedPath.length) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292
                            require return_data.size >= 32
                            _20303 = mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28]
                            require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] <= 4294967296
                            require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                            require mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292] <= 4294967296 and mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]) + 32 <= return_data.size
                            mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] = mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]
                            _20362 = mem[(32 * token1ToEarnedPath.length) + _20303 + 292]
                            mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324 len floor32(mem[(32 * token1ToEarnedPath.length) + _20303 + 292])] = mem[(32 * token1ToEarnedPath.length) + _20303 + 324 len floor32(mem[(32 * token1ToEarnedPath.length) + _20303 + 292])]
                            mem[(32 * _20362) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] = 30
                            mem[(32 * _20362) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 356] = 'SafeMath: subtraction overflow'
                            if 1 > mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1 < mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]
                            _27472 = mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]
                            if not mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]:
                                mem[(32 * _20362) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _20362) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                            else:
                                if slippageFactor * mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] / mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] != slippageFactor:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _20362) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 489 len 31]
                                mem[(32 * _20362) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], slippageFactor * _27472 / 1000, Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _20362) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                else:
                    mem[260] = return_data.size
                    mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if not return_data.size:
                        mem[ceil32(return_data.size) + 261] = token1ToEarnedPath.length
                        if not token1ToEarnedPath.length:
                            if block.timestamp + 600 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                            require return_data.size >= 32
                            _8609 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                            _8665 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8609 + 293]
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8609 + 293])] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8609 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8609 + 293])]
                            mem[(32 * _8665) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                            mem[(32 * _8665) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                            if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                            _12857 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                            if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                mem[(32 * _8665) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8665) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                            else:
                                if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _8665) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                mem[(32 * _8665) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], slippageFactor * _12857 / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8665) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                        else:
                            mem[0] = 29
                            mem[ceil32(return_data.size) + 293] = address(token1ToEarnedPath.field_0)
                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                if block.timestamp + 600 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                                require return_data.size >= 32
                                _8611 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                                _8666 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8611 + 293]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8611 + 293])] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8611 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8611 + 293])]
                                mem[(32 * _8666) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                                mem[(32 * _8666) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                                if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                                _12860 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                    mem[(32 * _8666) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8666) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                else:
                                    if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _8666) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                    mem[(32 * _8666) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], slippageFactor * _12860 / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8666) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                            else:
                                mem[ceil32(return_data.size) + 325] = address(token1ToEarnedPath.field_256)
                                idx = ceil32(return_data.size) + 325
                                s = 1
                                while ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 261 > idx:
                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if block.timestamp + 600 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                                require return_data.size >= 32
                                _20305 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                                _20363 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20305 + 293]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20305 + 293])] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20305 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20305 + 293])]
                                mem[(32 * _20363) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                                mem[(32 * _20363) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                                if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                                _27475 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                    mem[(32 * _20363) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _20363) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                else:
                                    if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _20363) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                    mem[(32 * _20363) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], slippageFactor * _27475 / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _20363) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                    else:
                        require return_data.size >= 32
                        if not mem[292]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[ceil32(return_data.size) + 371 len 22]
                        mem[ceil32(return_data.size) + 261] = token1ToEarnedPath.length
                        if not token1ToEarnedPath.length:
                            if block.timestamp + 600 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                            require return_data.size >= 32
                            _8613 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                            _8667 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8613 + 293]
                            mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8613 + 293])] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8613 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8613 + 293])]
                            mem[(32 * _8667) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                            mem[(32 * _8667) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                            if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                            _12863 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                            if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                mem[(32 * _8667) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8667) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                            else:
                                if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _8667) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                mem[(32 * _8667) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], slippageFactor * _12863 / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8667) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                        else:
                            mem[0] = 29
                            mem[ceil32(return_data.size) + 293] = address(token1ToEarnedPath.field_0)
                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                if block.timestamp + 600 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                                require return_data.size >= 32
                                _8615 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                                _8668 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8615 + 293]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8615 + 293])] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8615 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8615 + 293])]
                                mem[(32 * _8668) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                                mem[(32 * _8668) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                                if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                                _12866 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                    mem[(32 * _8668) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8668) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                else:
                                    if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _8668) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                    mem[(32 * _8668) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], slippageFactor * _12866 / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8668) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                            else:
                                mem[ceil32(return_data.size) + 325] = address(token1ToEarnedPath.field_256)
                                idx = ceil32(return_data.size) + 325
                                s = 1
                                while ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 261 > idx:
                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if block.timestamp + 600 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                                require return_data.size >= 32
                                _20307 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                                _20364 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20307 + 293]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20307 + 293])] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20307 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20307 + 293])]
                                mem[(32 * _20364) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                                mem[(32 * _20364) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                                if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                                _27478 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                    mem[(32 * _20364) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _20364) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                else:
                                    if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _20364) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                    mem[(32 * _20364) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], slippageFactor * _27478 / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _20364) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
    else:
        if ext_call.return_data[0] <= 0:
            require ext_code.size(token1Address)
            staticcall token1Address.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if earnedAddress != token1Address:
                if ext_call.return_data[0] > 0:
                    require ext_code.size(token1Address)
                    staticcall token1Address.0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(uniRouterAddress)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[132] = address(uniRouterAddress)
                    mem[164] = 2 * ext_call.return_data[0]
                    mem[96] = 68
                    mem[132 len 28] = Mask(224, 0, stor8)
                    mem[128 len 4] = approve(address rg1, uint256 rg2)
                    mem[196] = 32
                    mem[228] = 'SafeERC20: low-level call failed'
                    if eth.balance(this.address) < 0:
                        revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[366 len 26]
                    if not ext_code.size(token1Address):
                        revert with 0, 'Address: call to non-contract'
                    mem[260 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                    mem[352 len 4] = 0
                    mem[324 len 0] = 0
                    call token1Address with:
                       funct uint32(stor8)
                         gas gas_remaining wei
                        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[324 len 4]
                    if not return_data.size:
                        if not ext_call.success:
                            revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                        if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                            revert with 0, 32, 42, 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
                        mem[260] = token1ToEarnedPath.length
                        if not token1ToEarnedPath.length:
                            if block.timestamp + 600 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[(32 * token1ToEarnedPath.length) + 292] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[(32 * token1ToEarnedPath.length) + 296] = ext_call.return_data[0]
                            mem[(32 * token1ToEarnedPath.length) + 328] = 64
                            mem[(32 * token1ToEarnedPath.length) + 360] = token1ToEarnedPath.length
                            mem[(32 * token1ToEarnedPath.length) + 392 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 392 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * token1ToEarnedPath.length) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292
                            require return_data.size >= 32
                            _8621 = mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28]
                            require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] <= 4294967296
                            require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                            require mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292] <= 4294967296 and mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]) + 32 <= return_data.size
                            mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] = mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]
                            _8671 = mem[(32 * token1ToEarnedPath.length) + _8621 + 292]
                            mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324 len floor32(mem[(32 * token1ToEarnedPath.length) + _8621 + 292])] = mem[(32 * token1ToEarnedPath.length) + _8621 + 324 len floor32(mem[(32 * token1ToEarnedPath.length) + _8621 + 292])]
                            mem[(32 * _8671) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] = 30
                            mem[(32 * _8671) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 356] = 'SafeMath: subtraction overflow'
                            if 1 > mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1 < mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]
                            _12875 = mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]
                            if not mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]:
                                mem[(32 * _8671) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _8671) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                            else:
                                if slippageFactor * mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] / mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] != slippageFactor:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _8671) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 489 len 31]
                                mem[(32 * _8671) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], slippageFactor * _12875 / 1000, Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _8671) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                        else:
                            mem[0] = 29
                            mem[292] = address(token1ToEarnedPath.field_0)
                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                if block.timestamp + 600 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[(32 * token1ToEarnedPath.length) + 292] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[(32 * token1ToEarnedPath.length) + 296] = ext_call.return_data[0]
                                mem[(32 * token1ToEarnedPath.length) + 328] = 64
                                mem[(32 * token1ToEarnedPath.length) + 360] = token1ToEarnedPath.length
                                mem[(32 * token1ToEarnedPath.length) + 392 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 392 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * token1ToEarnedPath.length) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292
                                require return_data.size >= 32
                                _8623 = mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28]
                                require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                require mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292] <= 4294967296 and mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]) + 32 <= return_data.size
                                mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] = mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]
                                _8672 = mem[(32 * token1ToEarnedPath.length) + _8623 + 292]
                                mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324 len floor32(mem[(32 * token1ToEarnedPath.length) + _8623 + 292])] = mem[(32 * token1ToEarnedPath.length) + _8623 + 324 len floor32(mem[(32 * token1ToEarnedPath.length) + _8623 + 292])]
                                mem[(32 * _8672) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] = 30
                                mem[(32 * _8672) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 356] = 'SafeMath: subtraction overflow'
                                if 1 > mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1 < mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]
                                _12878 = mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]
                                if not mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]:
                                    mem[(32 * _8672) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _8672) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                else:
                                    if slippageFactor * mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] / mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] != slippageFactor:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _8672) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 489 len 31]
                                    mem[(32 * _8672) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], slippageFactor * _12878 / 1000, Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _8672) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                            else:
                                mem[324] = address(token1ToEarnedPath.field_256)
                                idx = 324
                                s = 1
                                while (32 * token1ToEarnedPath.length) + 260 > idx:
                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                    idx = idx + 32
                                    s = s + 1
                                    continue 
                                if block.timestamp + 600 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[(32 * token1ToEarnedPath.length) + 292] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[(32 * token1ToEarnedPath.length) + 296] = ext_call.return_data[0]
                                mem[(32 * token1ToEarnedPath.length) + 328] = 64
                                mem[(32 * token1ToEarnedPath.length) + 360] = token1ToEarnedPath.length
                                mem[(32 * token1ToEarnedPath.length) + 392 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 392 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * token1ToEarnedPath.length) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292
                                require return_data.size >= 32
                                _20311 = mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28]
                                require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                require mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                require mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292] <= 4294967296 and mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]) + 32 <= return_data.size
                                mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] = mem[(32 * token1ToEarnedPath.length) + mem[(32 * token1ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]
                                _20366 = mem[(32 * token1ToEarnedPath.length) + _20311 + 292]
                                mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324 len floor32(mem[(32 * token1ToEarnedPath.length) + _20311 + 292])] = mem[(32 * token1ToEarnedPath.length) + _20311 + 324 len floor32(mem[(32 * token1ToEarnedPath.length) + _20311 + 292])]
                                mem[(32 * _20366) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] = 30
                                mem[(32 * _20366) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 356] = 'SafeMath: subtraction overflow'
                                if 1 > mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1 < mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292]
                                _27484 = mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]
                                if not mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324]:
                                    mem[(32 * _20366) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _20366) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                else:
                                    if slippageFactor * mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] / mem[(32 * mem[(32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 324] != slippageFactor:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _20366) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 489 len 31]
                                    mem[(32 * _20366) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)] = mem[292 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], slippageFactor * _27484 / 1000, Array(len=token1ToEarnedPath.length, data=mem[292 len floor32(token1ToEarnedPath.length)], mem[(32 * _20366) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 648 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                    else:
                        mem[260] = return_data.size
                        mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if not return_data.size:
                            mem[ceil32(return_data.size) + 261] = token1ToEarnedPath.length
                            if not token1ToEarnedPath.length:
                                if block.timestamp + 600 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                                require return_data.size >= 32
                                _8625 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                                _8673 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8625 + 293]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8625 + 293])] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8625 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8625 + 293])]
                                mem[(32 * _8673) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                                mem[(32 * _8673) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                                if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                                _12881 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                    mem[(32 * _8673) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8673) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                else:
                                    if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _8673) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                    mem[(32 * _8673) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], slippageFactor * _12881 / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8673) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                            else:
                                mem[0] = 29
                                mem[ceil32(return_data.size) + 293] = address(token1ToEarnedPath.field_0)
                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                    if block.timestamp + 600 < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                            gas gas_remaining wei
                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                                    require return_data.size >= 32
                                    _8627 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                                    _8674 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8627 + 293]
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8627 + 293])] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8627 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8627 + 293])]
                                    mem[(32 * _8674) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                                    mem[(32 * _8674) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                                    if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                                    _12884 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                    if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                        mem[(32 * _8674) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8674) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                    else:
                                        if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _8674) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                        mem[(32 * _8674) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], slippageFactor * _12884 / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8674) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                else:
                                    mem[ceil32(return_data.size) + 325] = address(token1ToEarnedPath.field_256)
                                    idx = ceil32(return_data.size) + 325
                                    s = 1
                                    while ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 261 > idx:
                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    if block.timestamp + 600 < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                            gas gas_remaining wei
                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                                    require return_data.size >= 32
                                    _20313 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                                    _20367 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20313 + 293]
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20313 + 293])] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20313 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20313 + 293])]
                                    mem[(32 * _20367) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                                    mem[(32 * _20367) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                                    if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                                    _27487 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                    if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                        mem[(32 * _20367) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _20367) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                    else:
                                        if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _20367) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                        mem[(32 * _20367) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], slippageFactor * _27487 / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _20367) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                        else:
                            require return_data.size >= 32
                            if not mem[292]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[ceil32(return_data.size) + 371 len 22]
                            mem[ceil32(return_data.size) + 261] = token1ToEarnedPath.length
                            if not token1ToEarnedPath.length:
                                if block.timestamp + 600 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                require ext_code.size(address(uniRouterAddress))
                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                                require return_data.size >= 32
                                _8629 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                                _8675 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8629 + 293]
                                mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8629 + 293])] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8629 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8629 + 293])]
                                mem[(32 * _8675) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                                mem[(32 * _8675) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                                if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                                _12887 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                    mem[(32 * _8675) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8675) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                else:
                                    if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _8675) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                    mem[(32 * _8675) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], slippageFactor * _12887 / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8675) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                            else:
                                mem[0] = 29
                                mem[ceil32(return_data.size) + 293] = address(token1ToEarnedPath.field_0)
                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                    if block.timestamp + 600 < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                            gas gas_remaining wei
                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                                    require return_data.size >= 32
                                    _8631 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                                    _8676 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8631 + 293]
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8631 + 293])] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8631 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _8631 + 293])]
                                    mem[(32 * _8676) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                                    mem[(32 * _8676) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                                    if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                                    _12890 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                    if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                        mem[(32 * _8676) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8676) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                    else:
                                        if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _8676) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                        mem[(32 * _8676) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], slippageFactor * _12890 / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _8676) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                else:
                                    mem[ceil32(return_data.size) + 325] = address(token1ToEarnedPath.field_256)
                                    idx = ceil32(return_data.size) + 325
                                    s = 1
                                    while ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 261 > idx:
                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    if block.timestamp + 600 < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 297] = ext_call.return_data[0]
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 329] = 64
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 361] = token1ToEarnedPath.length
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 393 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                    require ext_code.size(address(uniRouterAddress))
                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                            gas gas_remaining wei
                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 393 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293
                                    require return_data.size >= 32
                                    _20315 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                                    _20368 = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20315 + 293]
                                    mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20315 + 293])] = mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20315 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _20315 + 293])]
                                    mem[(32 * _20368) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                                    mem[(32 * _20368) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                                    if 1 > mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293]
                                    _27490 = mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]
                                    if not mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                                        mem[(32 * _20368) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _20368) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                    else:
                                        if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _20368) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                                        mem[(32 * _20368) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], slippageFactor * _27490 / 1000, Array(len=token1ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token1ToEarnedPath.length)], mem[(32 * _20368) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + ceil32(return_data.size) + floor32(token1ToEarnedPath.length) + 649 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
        else:
            require ext_code.size(token0Address)
            staticcall token0Address.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(uniRouterAddress)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                revert with 0, 'SafeMath: addition overflow'
            mem[132] = address(uniRouterAddress)
            mem[164] = 2 * ext_call.return_data[0]
            mem[96] = 68
            mem[132 len 28] = Mask(224, 0, stor8)
            mem[128 len 4] = approve(address rg1, uint256 rg2)
            mem[196] = 32
            mem[228] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 32, 38, 0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[366 len 26]
            if not ext_code.size(token0Address):
                revert with 0, 'Address: call to non-contract'
            mem[260 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
            mem[352 len 4] = 0
            call token0Address with:
               funct uint32(stor8)
                 gas gas_remaining wei
                args Mask(224, 31, ext_call.return_data[0]) << 225, mem[324 len 4]
            if not return_data.size:
                if not ext_call.success:
                    revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                    revert with 0, 32, 42, 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
                mem[260] = token0ToEarnedPath.length
                if not token0ToEarnedPath.length:
                    if block.timestamp + 600 < block.timestamp:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[(32 * token0ToEarnedPath.length) + 292] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(32 * token0ToEarnedPath.length) + 296] = ext_call.return_data[0]
                    mem[(32 * token0ToEarnedPath.length) + 328] = 64
                    mem[(32 * token0ToEarnedPath.length) + 360] = token0ToEarnedPath.length
                    mem[(32 * token0ToEarnedPath.length) + 392 len floor32(token0ToEarnedPath.length)] = mem[292 len floor32(token0ToEarnedPath.length)]
                    require ext_code.size(address(uniRouterAddress))
                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                            gas gas_remaining wei
                           args ext_call.return_data[0], Array(len=token0ToEarnedPath.length, data=mem[292 len floor32(token0ToEarnedPath.length)], mem[(32 * token0ToEarnedPath.length) + floor32(token0ToEarnedPath.length) + 392 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(32 * token0ToEarnedPath.length) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292
                    require return_data.size >= 32
                    _8635 = mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28]
                    require mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] <= 4294967296
                    require mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                    require mem[(32 * token0ToEarnedPath.length) + mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292] <= 4294967296 and mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * token0ToEarnedPath.length) + mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]) + 32 <= return_data.size
                    mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] = mem[(32 * token0ToEarnedPath.length) + mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]
                    _8678 = mem[(32 * token0ToEarnedPath.length) + _8635 + 292]
                    mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324 len floor32(mem[(32 * token0ToEarnedPath.length) + _8635 + 292])] = mem[(32 * token0ToEarnedPath.length) + _8635 + 324 len floor32(mem[(32 * token0ToEarnedPath.length) + _8635 + 292])]
                    mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324] = 30
                    mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 356] = 'SafeMath: subtraction overflow'
                    if 1 > mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292]:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1 < mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292]
                    _12896 = mem[(32 * mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324]
                    if not mem[(32 * mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324]:
                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 388] = 26
                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 420] = 'SafeMath: division by zero'
                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token0ToEarnedPath.length)] = mem[292 len floor32(token0ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token0ToEarnedPath.length, mem[292 len floor32(token0ToEarnedPath.length)], mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 648 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(token1Address)
                        staticcall token1Address.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if earnedAddress != token1Address:
                            if ext_call.return_data[0] > 0:
                                require ext_code.size(token1Address)
                                staticcall token1Address.0xdd62ed3e with:
                                        gas gas_remaining wei
                                       args address(this.address), address(uniRouterAddress)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 488] = address(uniRouterAddress)
                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 520] = 2 * ext_call.return_data[0]
                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 452] = 68
                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 488 len 28] = Mask(224, 0, stor8)
                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 484 len 4] = approve(address rg1, uint256 rg2)
                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 552] = 32
                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 584] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 722 len 26]
                                if not ext_code.size(token1Address):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 708 len 4] = 0
                                call token1Address with:
                                   funct token0ToEarnedPath.length.field_224
                                     gas gas_remaining wei
                                    args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680 len 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                    if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 726 len 22]
                                    mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616] = token1ToEarnedPath.length
                                    if not token1ToEarnedPath.length:
                                        if block.timestamp + 600 < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                gas gas_remaining wei
                                               args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                        require return_data.size >= 32
                                        _34277 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                        require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                        require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                        require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648] <= 4294967296 and mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]) + 32 <= return_data.size
                                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]
                                        _34465 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34277 + 648]
                                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34277 + 648])] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34277 + 680 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34277 + 648])]
                                        mem[64] = (32 * _34465) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744
                                        mem[(32 * _34465) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                        mem[(32 * _34465) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                        if 1 > mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                        _40851 = mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                        if not mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                            mem[(32 * _34465) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _34465) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _34465) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _34465) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _34465) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                            mem[(32 * _34465) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _34465) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                            mem[(32 * _34465) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _34465) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _34465) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _34465) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                        else:
                                            if slippageFactor * mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] / mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _34465) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                            mem[(32 * _34465) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _34465) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _34465) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _34465) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _34465) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = slippageFactor * _40851 / 1000
                                            mem[(32 * _34465) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _34465) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                            mem[(32 * _34465) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _34465) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _34465) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], slippageFactor * _40851 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _34465) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        mem[0] = 29
                                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648] = address(token1ToEarnedPath.field_0)
                                        if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                            require return_data.size >= 32
                                            _34279 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648] <= 4294967296 and mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]) + 32 <= return_data.size
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]
                                            _34466 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34279 + 648]
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34279 + 648])] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34279 + 680 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34279 + 648])]
                                            mem[64] = (32 * _34466) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744
                                            mem[(32 * _34466) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                            mem[(32 * _34466) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                            _40854 = mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                            if not mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                                mem[(32 * _34466) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _34466) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _34466) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34466) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _34466) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                                mem[(32 * _34466) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _34466) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _34466) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _34466) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _34466) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _34466) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] / mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _34466) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                                mem[(32 * _34466) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _34466) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _34466) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34466) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _34466) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = slippageFactor * _40854 / 1000
                                                mem[(32 * _34466) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _34466) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _34466) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _34466) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _34466) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _40854 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _34466) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680] = address(token1ToEarnedPath.field_256)
                                            idx = (32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680
                                            s = 1
                                            while (32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 616 > idx:
                                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                            require return_data.size >= 32
                                            _46903 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648] <= 4294967296 and mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]) + 32 <= return_data.size
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]
                                            _47162 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46903 + 648]
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46903 + 648])] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46903 + 680 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46903 + 648])]
                                            mem[64] = (32 * _47162) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744
                                            mem[(32 * _47162) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                            mem[(32 * _47162) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                            _51572 = mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                            if not mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                                mem[(32 * _47162) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _47162) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _47162) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47162) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _47162) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                                mem[(32 * _47162) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _47162) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _47162) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _47162) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _47162) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _47162) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] / mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _47162) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                                mem[(32 * _47162) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _47162) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _47162) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47162) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _47162) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = slippageFactor * _51572 / 1000
                                                mem[(32 * _47162) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _47162) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _47162) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _47162) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _47162) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _51572 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _47162) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                else:
                                    mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616] = return_data.size
                                    mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not return_data.size:
                                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _34281 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _34467 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34281 + 649]
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34281 + 649])] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34281 + 681 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34281 + 649])]
                                            mem[64] = (32 * _34467) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _34467) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _34467) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _40857 = mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _34467) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34467) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34467) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34467) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34467) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _34467) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34467) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34467) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34467) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34467) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34467) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _34467) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _34467) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34467) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34467) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34467) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34467) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40857 / 1000
                                                mem[(32 * _34467) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34467) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34467) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34467) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34467) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _40857 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34467) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 29
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _34283 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _34468 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34283 + 649]
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34283 + 649])] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34283 + 681 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34283 + 649])]
                                                mem[64] = (32 * _34468) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _34468) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _34468) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _40860 = mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _34468) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34468) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34468) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34468) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34468) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _34468) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34468) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34468) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34468) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34468) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34468) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34468) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _34468) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34468) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34468) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34468) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34468) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40860 / 1000
                                                    mem[(32 * _34468) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34468) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34468) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34468) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34468) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40860 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34468) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _46905 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47163 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46905 + 649]
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46905 + 649])] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46905 + 681 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46905 + 649])]
                                                mem[64] = (32 * _47163) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47163) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47163) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _51575 = mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47163) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47163) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47163) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47163) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47163) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47163) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47163) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47163) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47163) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47163) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47163) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47163) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47163) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47163) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47163) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47163) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47163) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51575 / 1000
                                                    mem[(32 * _47163) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47163) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47163) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47163) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47163) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51575 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47163) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        require return_data.size >= 32
                                        if not mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _34285 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _34469 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34285 + 649]
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34285 + 649])] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34285 + 681 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34285 + 649])]
                                            mem[64] = (32 * _34469) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _34469) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _34469) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _40863 = mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _34469) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34469) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34469) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34469) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34469) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _34469) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34469) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34469) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34469) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34469) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34469) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _34469) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _34469) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34469) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34469) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34469) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34469) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40863 / 1000
                                                mem[(32 * _34469) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34469) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34469) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34469) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34469) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _40863 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34469) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 29
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _34287 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _34470 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34287 + 649]
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34287 + 649])] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34287 + 681 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34287 + 649])]
                                                mem[64] = (32 * _34470) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _34470) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _34470) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _40866 = mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _34470) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34470) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34470) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34470) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34470) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _34470) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34470) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34470) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34470) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34470) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34470) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34470) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _34470) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34470) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34470) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34470) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34470) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40866 / 1000
                                                    mem[(32 * _34470) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34470) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34470) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34470) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34470) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40866 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34470) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _46907 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47164 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46907 + 649]
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46907 + 649])] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46907 + 681 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46907 + 649])]
                                                mem[64] = (32 * _47164) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47164) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47164) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _51578 = mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47164) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47164) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47164) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47164) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47164) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47164) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47164) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47164) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47164) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47164) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47164) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47164) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47164) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47164) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47164) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47164) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47164) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51578 / 1000
                                                    mem[(32 * _47164) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47164) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47164) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47164) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47164) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51578 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47164) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                    else:
                        if slippageFactor * mem[(32 * mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324] / mem[(32 * mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324] != slippageFactor:
                            revert with 0, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 31]
                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 388] = 26
                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 420] = 'SafeMath: division by zero'
                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token0ToEarnedPath.length)] = mem[292 len floor32(token0ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], slippageFactor * _12896 / 1000, Array(len=token0ToEarnedPath.length, data=mem[292 len floor32(token0ToEarnedPath.length)], mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 648 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(token1Address)
                        staticcall token1Address.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if earnedAddress != token1Address:
                            if ext_call.return_data[0] > 0:
                                require ext_code.size(token1Address)
                                staticcall token1Address.0xdd62ed3e with:
                                        gas gas_remaining wei
                                       args address(this.address), address(uniRouterAddress)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 488] = address(uniRouterAddress)
                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 520] = 2 * ext_call.return_data[0]
                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 452] = 68
                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 488 len 28] = Mask(224, 0, stor8)
                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 484 len 4] = approve(address rg1, uint256 rg2)
                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 552] = 32
                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 584] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 722 len 26]
                                if not ext_code.size(token1Address):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 708 len 4] = 0
                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680 len 0] = 0
                                call token1Address with:
                                   funct uint32(stor8)
                                     gas gas_remaining wei
                                    args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680 len 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                    if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 726 len 22]
                                    mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616] = token1ToEarnedPath.length
                                    if not token1ToEarnedPath.length:
                                        if block.timestamp + 600 < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                gas gas_remaining wei
                                               args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                        require return_data.size >= 32
                                        _34261 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                        require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                        require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                        require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648] <= 4294967296 and mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]) + 32 <= return_data.size
                                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]
                                        _34457 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34261 + 648]
                                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34261 + 648])] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34261 + 680 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34261 + 648])]
                                        mem[64] = (32 * _34457) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744
                                        mem[(32 * _34457) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                        mem[(32 * _34457) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                        if 1 > mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                        _40827 = mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                        if not mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                            mem[(32 * _34457) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _34457) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _34457) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _34457) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _34457) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                            mem[(32 * _34457) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _34457) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                            mem[(32 * _34457) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _34457) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _34457) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _34457) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                        else:
                                            if slippageFactor * mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] / mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _34457) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                            mem[(32 * _34457) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _34457) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _34457) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _34457) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _34457) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = slippageFactor * _40827 / 1000
                                            mem[(32 * _34457) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _34457) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                            mem[(32 * _34457) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _34457) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _34457) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], slippageFactor * _40827 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _34457) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        mem[0] = 29
                                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648] = address(token1ToEarnedPath.field_0)
                                        if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                            require return_data.size >= 32
                                            _34263 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648] <= 4294967296 and mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]) + 32 <= return_data.size
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]
                                            _34458 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34263 + 648]
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34263 + 648])] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34263 + 680 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34263 + 648])]
                                            mem[64] = (32 * _34458) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744
                                            mem[(32 * _34458) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                            mem[(32 * _34458) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                            _40830 = mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                            if not mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                                mem[(32 * _34458) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _34458) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _34458) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34458) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _34458) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                                mem[(32 * _34458) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _34458) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _34458) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _34458) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _34458) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _34458) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] / mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _34458) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                                mem[(32 * _34458) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _34458) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _34458) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34458) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _34458) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = slippageFactor * _40830 / 1000
                                                mem[(32 * _34458) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _34458) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _34458) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _34458) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _34458) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _40830 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _34458) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680] = address(token1ToEarnedPath.field_256)
                                            idx = (32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680
                                            s = 1
                                            while (32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 616 > idx:
                                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                            require return_data.size >= 32
                                            _46895 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648] <= 4294967296 and mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]) + 32 <= return_data.size
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]
                                            _47158 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46895 + 648]
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46895 + 648])] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46895 + 680 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46895 + 648])]
                                            mem[64] = (32 * _47158) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744
                                            mem[(32 * _47158) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                            mem[(32 * _47158) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                            _51560 = mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                            if not mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                                mem[(32 * _47158) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _47158) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _47158) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47158) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _47158) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                                mem[(32 * _47158) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _47158) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _47158) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _47158) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _47158) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _47158) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] / mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _47158) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                                mem[(32 * _47158) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _47158) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _47158) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47158) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _47158) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = slippageFactor * _51560 / 1000
                                                mem[(32 * _47158) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _47158) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _47158) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _47158) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _47158) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _51560 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _47158) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                else:
                                    mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616] = return_data.size
                                    mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not return_data.size:
                                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _34265 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _34459 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34265 + 649]
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34265 + 649])] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34265 + 681 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34265 + 649])]
                                            mem[64] = (32 * _34459) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _34459) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _34459) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _40833 = mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _34459) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34459) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34459) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34459) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34459) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _34459) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34459) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34459) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34459) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34459) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34459) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _34459) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _34459) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34459) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34459) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34459) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34459) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40833 / 1000
                                                mem[(32 * _34459) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34459) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34459) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34459) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34459) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _40833 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34459) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 29
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _34267 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _34460 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34267 + 649]
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34267 + 649])] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34267 + 681 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34267 + 649])]
                                                mem[64] = (32 * _34460) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _34460) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _34460) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _40836 = mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _34460) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34460) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34460) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34460) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34460) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _34460) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34460) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34460) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34460) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34460) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34460) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34460) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _34460) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34460) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34460) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34460) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34460) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40836 / 1000
                                                    mem[(32 * _34460) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34460) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34460) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34460) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34460) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40836 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34460) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _46897 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47159 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46897 + 649]
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46897 + 649])] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46897 + 681 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46897 + 649])]
                                                mem[64] = (32 * _47159) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47159) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47159) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _51563 = mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47159) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47159) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47159) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47159) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47159) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47159) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47159) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47159) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47159) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47159) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47159) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47159) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47159) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47159) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47159) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47159) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47159) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51563 / 1000
                                                    mem[(32 * _47159) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47159) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47159) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47159) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47159) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51563 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47159) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        require return_data.size >= 32
                                        if not mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _34269 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _34461 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34269 + 649]
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34269 + 649])] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34269 + 681 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34269 + 649])]
                                            mem[64] = (32 * _34461) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _34461) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _34461) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _40839 = mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _34461) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34461) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34461) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34461) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34461) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _34461) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34461) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34461) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34461) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34461) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34461) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _34461) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _34461) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34461) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34461) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34461) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34461) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40839 / 1000
                                                mem[(32 * _34461) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34461) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34461) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34461) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34461) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _40839 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34461) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 29
                                            mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _34271 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _34462 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34271 + 649]
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34271 + 649])] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34271 + 681 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34271 + 649])]
                                                mem[64] = (32 * _34462) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _34462) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _34462) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _40842 = mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _34462) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34462) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34462) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34462) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34462) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _34462) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34462) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34462) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34462) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34462) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34462) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34462) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _34462) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34462) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34462) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34462) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34462) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40842 / 1000
                                                    mem[(32 * _34462) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34462) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34462) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34462) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34462) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40842 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34462) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _46899 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47160 = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46899 + 649]
                                                mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46899 + 649])] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46899 + 681 len floor32(mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46899 + 649])]
                                                mem[64] = (32 * _47160) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47160) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47160) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _51566 = mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47160) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47160) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47160) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47160) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47160) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47160) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47160) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47160) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47160) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47160) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47160) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47160) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47160) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47160) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47160) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47160) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47160) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51566 / 1000
                                                    mem[(32 * _47160) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47160) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47160) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47160) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47160) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51566 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8678) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47160) + (32 * _8678) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                else:
                    mem[0] = 28
                    mem[292] = address(token0ToEarnedPath.field_0)
                    idx = 292
                    s = 0
                    while (32 * token0ToEarnedPath.length) + 260 > idx:
                        mem[idx + 32] = token0ToEarnedPath[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    if block.timestamp + 600 < block.timestamp:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[(32 * token0ToEarnedPath.length) + 292] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(32 * token0ToEarnedPath.length) + 296] = ext_call.return_data[0]
                    mem[(32 * token0ToEarnedPath.length) + 328] = 64
                    mem[(32 * token0ToEarnedPath.length) + 360] = token0ToEarnedPath.length
                    mem[(32 * token0ToEarnedPath.length) + 392 len floor32(token0ToEarnedPath.length)] = mem[292 len floor32(token0ToEarnedPath.length)]
                    require ext_code.size(address(uniRouterAddress))
                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                            gas gas_remaining wei
                           args ext_call.return_data[0], Array(len=token0ToEarnedPath.length, data=mem[292 len floor32(token0ToEarnedPath.length)], mem[(32 * token0ToEarnedPath.length) + floor32(token0ToEarnedPath.length) + 392 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(32 * token0ToEarnedPath.length) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292
                    require return_data.size >= 32
                    _20327 = mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28]
                    require mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] <= 4294967296
                    require mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                    require mem[(32 * token0ToEarnedPath.length) + mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292] <= 4294967296 and mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * token0ToEarnedPath.length) + mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]) + 32 <= return_data.size
                    mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] = mem[(32 * token0ToEarnedPath.length) + mem[(32 * token0ToEarnedPath.length) + 292 len 4], ext_call.return_data[0 len 28] + 292]
                    _20374 = mem[(32 * token0ToEarnedPath.length) + _20327 + 292]
                    mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324 len floor32(mem[(32 * token0ToEarnedPath.length) + _20327 + 292])] = mem[(32 * token0ToEarnedPath.length) + _20327 + 324 len floor32(mem[(32 * token0ToEarnedPath.length) + _20327 + 292])]
                    mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324] = 30
                    mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 356] = 'SafeMath: subtraction overflow'
                    if 1 > mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292]:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1 < mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292]
                    _27512 = mem[(32 * mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324]
                    if not mem[(32 * mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324]:
                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 388] = 26
                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 420] = 'SafeMath: division by zero'
                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token0ToEarnedPath.length)] = mem[292 len floor32(token0ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token0ToEarnedPath.length, mem[292 len floor32(token0ToEarnedPath.length)], mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 648 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(token1Address)
                        staticcall token1Address.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if earnedAddress != token1Address:
                            if ext_call.return_data[0] > 0:
                                require ext_code.size(token1Address)
                                staticcall token1Address.0xdd62ed3e with:
                                        gas gas_remaining wei
                                       args address(this.address), address(uniRouterAddress)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 488] = address(uniRouterAddress)
                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 520] = 2 * ext_call.return_data[0]
                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 452] = 68
                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 488 len 28] = Mask(224, 0, stor8)
                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 484 len 4] = approve(address rg1, uint256 rg2)
                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 552] = 32
                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 584] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 722 len 26]
                                if not ext_code.size(token1Address):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 708 len 4] = 0
                                call token1Address with:
                                   funct token0ToEarnedPath.length.field_224
                                     gas gas_remaining wei
                                    args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680 len 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                    if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 726 len 22]
                                    if not token1ToEarnedPath.length:
                                        if block.timestamp + 600 < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                gas gas_remaining wei
                                               args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                        require return_data.size >= 32
                                        _46929 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                        require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                        require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                        require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648] <= 4294967296 and mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]) + 32 <= return_data.size
                                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]
                                        _47175 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46929 + 648]
                                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46929 + 648])] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46929 + 680 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46929 + 648])]
                                        mem[(32 * _47175) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                        mem[(32 * _47175) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                        if 1 > mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                        _51611 = mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                        if not mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                            mem[(32 * _47175) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _47175) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _47175) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _47175) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _47175) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                            mem[(32 * _47175) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _47175) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                            mem[(32 * _47175) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _47175) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _47175) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _47175) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                        else:
                                            if slippageFactor * mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] / mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _47175) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                            mem[(32 * _47175) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _47175) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _47175) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _47175) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _47175) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = slippageFactor * _51611 / 1000
                                            mem[(32 * _47175) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _47175) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                            mem[(32 * _47175) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _47175) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _47175) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], slippageFactor * _51611 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _47175) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        mem[0] = 29
                                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648] = address(token1ToEarnedPath.field_0)
                                        if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                            require return_data.size >= 32
                                            _46931 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648] <= 4294967296 and mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]) + 32 <= return_data.size
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]
                                            _47176 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46931 + 648]
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46931 + 648])] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46931 + 680 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46931 + 648])]
                                            mem[(32 * _47176) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                            mem[(32 * _47176) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                            _51614 = mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                            if not mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                                mem[(32 * _47176) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _47176) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _47176) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47176) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _47176) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                                mem[(32 * _47176) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _47176) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _47176) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _47176) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _47176) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _47176) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] / mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _47176) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                                mem[(32 * _47176) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _47176) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _47176) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47176) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _47176) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = slippageFactor * _51614 / 1000
                                                mem[(32 * _47176) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _47176) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _47176) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _47176) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _47176) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _51614 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _47176) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680] = address(token1ToEarnedPath.field_256)
                                            idx = (32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680
                                            s = 1
                                            while (32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 616 > idx:
                                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                            require return_data.size >= 32
                                            _55223 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648] <= 4294967296 and mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]) + 32 <= return_data.size
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]
                                            _55306 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55223 + 648]
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55223 + 648])] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55223 + 680 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55223 + 648])]
                                            mem[(32 * _55306) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                            mem[(32 * _55306) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                            _56708 = mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                            if not mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                                mem[(32 * _55306) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _55306) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _55306) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _55306) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _55306) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                                mem[(32 * _55306) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _55306) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _55306) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _55306) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _55306) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _55306) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] / mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _55306) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                                mem[(32 * _55306) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _55306) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _55306) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _55306) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _55306) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = slippageFactor * _56708 / 1000
                                                mem[(32 * _55306) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _55306) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _55306) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _55306) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _55306) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _56708 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _55306) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                else:
                                    mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616] = return_data.size
                                    mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not return_data.size:
                                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _46933 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _47177 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46933 + 649]
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46933 + 649])] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46933 + 681 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46933 + 649])]
                                            mem[64] = (32 * _47177) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _47177) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _47177) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _51617 = mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _47177) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47177) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47177) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47177) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47177) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _47177) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47177) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47177) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47177) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47177) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47177) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _47177) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _47177) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47177) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47177) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47177) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47177) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51617 / 1000
                                                mem[(32 * _47177) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47177) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47177) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47177) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47177) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _51617 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47177) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 29
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _46935 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47178 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46935 + 649]
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46935 + 649])] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46935 + 681 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46935 + 649])]
                                                mem[64] = (32 * _47178) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47178) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47178) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _51620 = mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47178) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47178) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47178) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47178) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47178) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47178) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47178) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47178) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47178) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47178) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47178) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47178) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47178) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47178) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47178) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47178) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47178) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51620 / 1000
                                                    mem[(32 * _47178) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47178) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47178) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47178) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47178) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51620 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47178) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _55225 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _55307 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55225 + 649]
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55225 + 649])] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55225 + 681 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55225 + 649])]
                                                mem[64] = (32 * _55307) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _55307) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _55307) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _56711 = mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _55307) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55307) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55307) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55307) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55307) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _55307) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55307) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55307) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55307) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55307) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55307) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _55307) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _55307) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55307) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55307) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55307) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55307) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _56711 / 1000
                                                    mem[(32 * _55307) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55307) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55307) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55307) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55307) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _56711 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55307) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        require return_data.size >= 32
                                        if not mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _46937 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _47179 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46937 + 649]
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46937 + 649])] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46937 + 681 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46937 + 649])]
                                            mem[64] = (32 * _47179) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _47179) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _47179) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _51623 = mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _47179) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47179) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47179) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47179) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47179) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _47179) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47179) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47179) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47179) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47179) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47179) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _47179) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _47179) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47179) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47179) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47179) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47179) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51623 / 1000
                                                mem[(32 * _47179) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47179) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47179) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47179) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47179) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _51623 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47179) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 29
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _46939 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47180 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46939 + 649]
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46939 + 649])] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46939 + 681 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46939 + 649])]
                                                mem[64] = (32 * _47180) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47180) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47180) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _51626 = mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47180) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47180) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47180) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47180) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47180) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47180) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47180) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47180) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47180) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47180) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47180) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47180) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47180) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47180) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47180) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47180) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47180) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51626 / 1000
                                                    mem[(32 * _47180) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47180) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47180) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47180) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47180) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51626 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47180) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _55227 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _55308 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55227 + 649]
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55227 + 649])] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55227 + 681 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55227 + 649])]
                                                mem[64] = (32 * _55308) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _55308) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _55308) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _56714 = mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _55308) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55308) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55308) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55308) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55308) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _55308) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55308) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55308) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55308) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55308) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55308) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _55308) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _55308) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55308) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55308) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55308) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55308) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _56714 / 1000
                                                    mem[(32 * _55308) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55308) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55308) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55308) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55308) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _56714 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55308) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                    else:
                        if slippageFactor * mem[(32 * mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324] / mem[(32 * mem[(32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 292] - 1) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 324] != slippageFactor:
                            revert with 0, 
                                        32,
                                        33,
                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 31]
                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 388] = 26
                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 420] = 'SafeMath: division by zero'
                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token0ToEarnedPath.length)] = mem[292 len floor32(token0ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], slippageFactor * _27512 / 1000, Array(len=token0ToEarnedPath.length, data=mem[292 len floor32(token0ToEarnedPath.length)], mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 648 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(token1Address)
                        staticcall token1Address.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if earnedAddress != token1Address:
                            if ext_call.return_data[0] > 0:
                                require ext_code.size(token1Address)
                                staticcall token1Address.0xdd62ed3e with:
                                        gas gas_remaining wei
                                       args address(this.address), address(uniRouterAddress)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 488] = address(uniRouterAddress)
                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 520] = 2 * ext_call.return_data[0]
                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 452] = 68
                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 488 len 28] = Mask(224, 0, stor8)
                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 484 len 4] = approve(address rg1, uint256 rg2)
                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 552] = 32
                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 584] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 722 len 26]
                                if not ext_code.size(token1Address):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 708 len 4] = 0
                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680 len 0] = 0
                                call token1Address with:
                                   funct uint32(stor8)
                                     gas gas_remaining wei
                                    args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680 len 4]
                                if not return_data.size:
                                    if not ext_call.success:
                                        revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                    if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 726 len 22]
                                    mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616] = token1ToEarnedPath.length
                                    if not token1ToEarnedPath.length:
                                        if block.timestamp + 600 < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                        require ext_code.size(address(uniRouterAddress))
                                        staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                gas gas_remaining wei
                                               args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                        require return_data.size >= 32
                                        _46913 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                        require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                        require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                        require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648] <= 4294967296 and mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]) + 32 <= return_data.size
                                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]
                                        _47167 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46913 + 648]
                                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46913 + 648])] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46913 + 680 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46913 + 648])]
                                        mem[(32 * _47167) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                        mem[(32 * _47167) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                        if 1 > mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                        _51587 = mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                        if not mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                            mem[(32 * _47167) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _47167) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _47167) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _47167) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _47167) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                            mem[(32 * _47167) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _47167) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                            mem[(32 * _47167) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _47167) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _47167) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _47167) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                        else:
                                            if slippageFactor * mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] / mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _47167) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                            mem[(32 * _47167) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                            mem[(32 * _47167) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                            mem[(32 * _47167) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _47167) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                            mem[(32 * _47167) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = slippageFactor * _51587 / 1000
                                            mem[(32 * _47167) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                            mem[(32 * _47167) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                            mem[(32 * _47167) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                            mem[(32 * _47167) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                            mem[(32 * _47167) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0], slippageFactor * _51587 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _47167) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        mem[0] = 29
                                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648] = address(token1ToEarnedPath.field_0)
                                        if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                            require return_data.size >= 32
                                            _46915 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648] <= 4294967296 and mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]) + 32 <= return_data.size
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]
                                            _47168 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46915 + 648]
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46915 + 648])] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46915 + 680 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46915 + 648])]
                                            mem[(32 * _47168) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                            mem[(32 * _47168) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                            _51590 = mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                            if not mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                                mem[(32 * _47168) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _47168) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _47168) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47168) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _47168) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                                mem[(32 * _47168) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _47168) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _47168) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _47168) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _47168) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _47168) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] / mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _47168) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                                mem[(32 * _47168) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _47168) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _47168) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47168) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _47168) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = slippageFactor * _51590 / 1000
                                                mem[(32 * _47168) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _47168) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _47168) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _47168) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _47168) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _51590 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _47168) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680] = address(token1ToEarnedPath.field_256)
                                            idx = (32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 680
                                            s = 1
                                            while (32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 616 > idx:
                                                mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                idx = idx + 32
                                                s = s + 1
                                                continue 
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 652] = ext_call.return_data[0]
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 684] = 64
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 716] = token1ToEarnedPath.length
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 748 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 748 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648
                                            require return_data.size >= 32
                                            _55215 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648] <= 4294967296 and mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]) + 32 <= return_data.size
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 648 len 4], ext_call.return_data[0 len 28] + 648]
                                            _55302 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55215 + 648]
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55215 + 648])] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55215 + 680 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55215 + 648])]
                                            mem[(32 * _55302) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] = 30
                                            mem[(32 * _55302) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 712] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1 < mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648]
                                            _56696 = mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]
                                            if not mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680]:
                                                mem[(32 * _55302) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _55302) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _55302) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _55302) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _55302) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = 0
                                                mem[(32 * _55302) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _55302) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _55302) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _55302) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _55302) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _55302) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] / mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 648] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 680] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _55302) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845 len 31]
                                                mem[(32 * _55302) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 744] = 26
                                                mem[(32 * _55302) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 776] = 'SafeMath: division by zero'
                                                mem[(32 * _55302) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 808] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _55302) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 812] = ext_call.return_data[0]
                                                mem[(32 * _55302) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 844] = slippageFactor * _56696 / 1000
                                                mem[(32 * _55302) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 908] = this.address
                                                mem[(32 * _55302) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 940] = block.timestamp + 600
                                                mem[(32 * _55302) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 876] = 160
                                                mem[(32 * _55302) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 972] = token1ToEarnedPath.length
                                                mem[(32 * _55302) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1004 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _56696 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len floor32(token1ToEarnedPath.length)], mem[(32 * _55302) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1004 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                else:
                                    mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 616] = return_data.size
                                    mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if not return_data.size:
                                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _46917 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _47169 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46917 + 649]
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46917 + 649])] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46917 + 681 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46917 + 649])]
                                            mem[64] = (32 * _47169) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _47169) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _47169) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _51593 = mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _47169) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47169) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47169) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47169) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47169) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _47169) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47169) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47169) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47169) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47169) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47169) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _47169) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _47169) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47169) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47169) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47169) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47169) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51593 / 1000
                                                mem[(32 * _47169) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47169) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47169) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47169) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47169) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _51593 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47169) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 29
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _46919 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47170 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46919 + 649]
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46919 + 649])] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46919 + 681 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46919 + 649])]
                                                mem[64] = (32 * _47170) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47170) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47170) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _51596 = mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47170) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47170) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47170) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47170) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47170) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47170) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47170) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47170) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47170) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47170) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47170) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47170) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47170) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47170) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47170) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47170) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47170) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51596 / 1000
                                                    mem[(32 * _47170) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47170) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47170) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47170) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47170) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51596 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47170) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _55217 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _55303 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55217 + 649]
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55217 + 649])] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55217 + 681 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55217 + 649])]
                                                mem[64] = (32 * _55303) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _55303) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _55303) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _56699 = mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _55303) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55303) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55303) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55303) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55303) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _55303) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55303) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55303) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55303) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55303) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55303) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _55303) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _55303) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55303) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55303) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55303) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55303) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _56699 / 1000
                                                    mem[(32 * _55303) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55303) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55303) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55303) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55303) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _56699 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55303) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        require return_data.size >= 32
                                        if not mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 648]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _46921 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _47171 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46921 + 649]
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46921 + 649])] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46921 + 681 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46921 + 649])]
                                            mem[64] = (32 * _47171) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _47171) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _47171) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                            _51599 = mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _47171) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47171) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47171) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47171) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47171) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _47171) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47171) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47171) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47171) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47171) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47171) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _47171) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _47171) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47171) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47171) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47171) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47171) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51599 / 1000
                                                mem[(32 * _47171) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47171) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47171) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47171) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47171) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _51599 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47171) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 29
                                            mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _46923 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47172 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46923 + 649]
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46923 + 649])] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46923 + 681 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46923 + 649])]
                                                mem[64] = (32 * _47172) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47172) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47172) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _51602 = mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47172) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47172) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47172) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47172) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47172) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47172) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47172) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47172) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47172) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47172) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47172) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47172) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47172) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47172) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47172) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47172) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47172) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51602 / 1000
                                                    mem[(32 * _47172) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47172) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47172) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47172) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47172) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51602 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47172) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _55219 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _55304 = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55219 + 649]
                                                mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55219 + 649])] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55219 + 681 len floor32(mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55219 + 649])]
                                                mem[64] = (32 * _55304) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _55304) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _55304) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649]
                                                _56702 = mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _55304) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55304) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55304) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55304) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55304) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _55304) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55304) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55304) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55304) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55304) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55304) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _55304) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _55304) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55304) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55304) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55304) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55304) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _56702 / 1000
                                                    mem[(32 * _55304) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55304) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55304) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55304) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55304) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _56702 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20374) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55304) + (32 * _20374) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
            else:
                mem[260] = return_data.size
                mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if not return_data.size:
                    mem[ceil32(return_data.size) + 261] = token0ToEarnedPath.length
                    if not token0ToEarnedPath.length:
                        if block.timestamp + 600 < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 297] = ext_call.return_data[0]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 329] = 64
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 361] = token0ToEarnedPath.length
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 393 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                gas gas_remaining wei
                               args ext_call.return_data[0], Array(len=token0ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + floor32(token0ToEarnedPath.length) + 393 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293
                        require return_data.size >= 32
                        _8637 = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                        _8679 = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _8637 + 293]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _8637 + 293])] = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _8637 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _8637 + 293])]
                        mem[64] = (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389
                        mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                        mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                        if 1 > mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293]
                        _12899 = mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]
                        if not mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                            mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389] = 26
                            mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 421] = 'SafeMath: division by zero'
                            mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token0ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 649 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(token1Address)
                            staticcall token1Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if earnedAddress != token1Address:
                                if ext_call.return_data[0] > 0:
                                    require ext_code.size(token1Address)
                                    staticcall token1Address.0xdd62ed3e with:
                                            gas gas_remaining wei
                                           args address(this.address), address(uniRouterAddress)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489] = address(uniRouterAddress)
                                    mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 521] = 2 * ext_call.return_data[0]
                                    mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 453] = 68
                                    mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 28] = Mask(224, 0, stor8)
                                    mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 485 len 4] = approve(address rg1, uint256 rg2)
                                    mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 553] = 32
                                    mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 585] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                    mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 723 len 26]
                                    if not ext_code.size(token1Address):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                    mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 709 len 4] = 0
                                    mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 0] = 0
                                    call token1Address with:
                                       funct uint32(stor8)
                                         gas gas_remaining wei
                                        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 4]
                                    if return_data.size:
                                        mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = return_data.size
                                        mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if not return_data.size:
                                            mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _34317 = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _34485 = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34317 + 650]
                                                mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34317 + 650])] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34317 + 682 len floor32(mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34317 + 650])]
                                                mem[(32 * _34485) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _34485) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _40913 = mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _34485) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34485) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34485) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _34485) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40913 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34485) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 29
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _34319 = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _34486 = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34319 + 650]
                                                    mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34319 + 650])] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34319 + 682 len floor32(mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34319 + 650])]
                                                    mem[(32 * _34486) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _34486) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _40916 = mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _34486) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34486) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _34486) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _34486) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _40916 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34486) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _46953 = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47187 = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46953 + 650]
                                                    mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46953 + 650])] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46953 + 682 len floor32(mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46953 + 650])]
                                                    mem[(32 * _47187) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47187) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51647 = mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47187) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47187) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47187) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47187) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51647 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47187) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            require return_data.size >= 32
                                            if not mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 728 len 22]
                                            mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _34321 = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _34487 = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34321 + 650]
                                                mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34321 + 650])] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34321 + 682 len floor32(mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34321 + 650])]
                                                mem[(32 * _34487) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _34487) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _40919 = mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _34487) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34487) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34487) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _34487) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40919 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34487) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 29
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _34323 = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _34488 = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34323 + 650]
                                                    mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34323 + 650])] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34323 + 682 len floor32(mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34323 + 650])]
                                                    mem[(32 * _34488) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _34488) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _40922 = mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _34488) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34488) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _34488) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _34488) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _40922 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34488) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _46955 = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47188 = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46955 + 650]
                                                    mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46955 + 650])] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46955 + 682 len floor32(mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46955 + 650])]
                                                    mem[(32 * _47188) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47188) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51650 = mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47188) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47188) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47188) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47188) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51650 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47188) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        if not ext_call.success:
                                            revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                        if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _34313 = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _34483 = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34313 + 649]
                                            mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34313 + 649])] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34313 + 681 len floor32(mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34313 + 649])]
                                            mem[64] = (32 * _34483) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _34483) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _34483) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _40907 = mem[(32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _34483) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34483) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34483) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34483) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34483) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _34483) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34483) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34483) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34483) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34483) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34483) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _34483) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _34483) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34483) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34483) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34483) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34483) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40907 / 1000
                                                mem[(32 * _34483) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34483) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34483) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34483) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34483) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _40907 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34483) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 29
                                            mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _34315 = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _34484 = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34315 + 649]
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34315 + 649])] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34315 + 681 len floor32(mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34315 + 649])]
                                                mem[64] = (32 * _34484) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _34484) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _34484) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _40910 = mem[(32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _34484) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34484) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34484) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34484) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34484) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _34484) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34484) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34484) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34484) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34484) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34484) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34484) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _34484) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34484) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34484) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34484) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34484) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40910 / 1000
                                                    mem[(32 * _34484) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34484) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34484) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34484) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34484) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40910 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34484) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _46951 = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47186 = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46951 + 649]
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46951 + 649])] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46951 + 681 len floor32(mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46951 + 649])]
                                                mem[64] = (32 * _47186) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47186) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47186) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _51644 = mem[(32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47186) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47186) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47186) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47186) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47186) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47186) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47186) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47186) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47186) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47186) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47186) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47186) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47186) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47186) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47186) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47186) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47186) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51644 / 1000
                                                    mem[(32 * _47186) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47186) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47186) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47186) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47186) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51644 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47186) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                        else:
                            if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                revert with 0, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                            mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389] = 26
                            mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 421] = 'SafeMath: division by zero'
                            mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], slippageFactor * _12899 / 1000, Array(len=token0ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 649 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(token1Address)
                            staticcall token1Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if earnedAddress != token1Address:
                                if ext_call.return_data[0] > 0:
                                    require ext_code.size(token1Address)
                                    staticcall token1Address.0xdd62ed3e with:
                                            gas gas_remaining wei
                                           args address(this.address), address(uniRouterAddress)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489] = address(uniRouterAddress)
                                    mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 521] = 2 * ext_call.return_data[0]
                                    mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 453] = 68
                                    mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 28] = Mask(224, 0, stor8)
                                    mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 485 len 4] = approve(address rg1, uint256 rg2)
                                    mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 553] = 32
                                    mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 585] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                    mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 723 len 26]
                                    if not ext_code.size(token1Address):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                    mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 709 len 4] = 0
                                    mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 0] = 0
                                    call token1Address with:
                                       funct uint32(stor8)
                                         gas gas_remaining wei
                                        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 4]
                                    if return_data.size:
                                        mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = return_data.size
                                        mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if not return_data.size:
                                            mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _34301 = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _34477 = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34301 + 650]
                                                mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34301 + 650])] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34301 + 682 len floor32(mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34301 + 650])]
                                                mem[(32 * _34477) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _34477) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _40889 = mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _34477) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34477) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34477) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _34477) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40889 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34477) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 29
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _34303 = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _34478 = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34303 + 650]
                                                    mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34303 + 650])] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34303 + 682 len floor32(mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34303 + 650])]
                                                    mem[(32 * _34478) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _34478) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _40892 = mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _34478) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34478) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _34478) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _34478) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _40892 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34478) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _46945 = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47183 = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46945 + 650]
                                                    mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46945 + 650])] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46945 + 682 len floor32(mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46945 + 650])]
                                                    mem[(32 * _47183) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47183) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51635 = mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47183) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47183) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47183) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47183) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51635 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47183) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            require return_data.size >= 32
                                            if not mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 728 len 22]
                                            mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _34305 = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _34479 = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34305 + 650]
                                                mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34305 + 650])] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34305 + 682 len floor32(mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34305 + 650])]
                                                mem[(32 * _34479) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _34479) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _40895 = mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _34479) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34479) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34479) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _34479) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40895 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34479) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 29
                                                mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _34307 = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _34480 = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34307 + 650]
                                                    mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34307 + 650])] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34307 + 682 len floor32(mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34307 + 650])]
                                                    mem[(32 * _34480) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _34480) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _40898 = mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _34480) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34480) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _34480) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _34480) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _40898 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34480) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _46947 = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47184 = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46947 + 650]
                                                    mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46947 + 650])] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46947 + 682 len floor32(mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46947 + 650])]
                                                    mem[(32 * _47184) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47184) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51638 = mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47184) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47184) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47184) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47184) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51638 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47184) + (32 * _8679) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        if not ext_call.success:
                                            revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                        if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _34297 = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _34475 = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34297 + 649]
                                            mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34297 + 649])] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34297 + 681 len floor32(mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34297 + 649])]
                                            mem[64] = (32 * _34475) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _34475) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _34475) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _40883 = mem[(32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _34475) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34475) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34475) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34475) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34475) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _34475) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34475) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34475) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34475) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34475) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34475) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _34475) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _34475) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34475) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34475) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34475) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34475) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40883 / 1000
                                                mem[(32 * _34475) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34475) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34475) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34475) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34475) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _40883 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34475) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 29
                                            mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _34299 = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _34476 = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34299 + 649]
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34299 + 649])] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34299 + 681 len floor32(mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34299 + 649])]
                                                mem[64] = (32 * _34476) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _34476) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _34476) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _40886 = mem[(32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _34476) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34476) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34476) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34476) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34476) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _34476) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34476) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34476) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34476) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34476) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34476) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34476) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _34476) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34476) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34476) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34476) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34476) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40886 / 1000
                                                    mem[(32 * _34476) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34476) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34476) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34476) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34476) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40886 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34476) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _46943 = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47182 = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46943 + 649]
                                                mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46943 + 649])] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46943 + 681 len floor32(mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46943 + 649])]
                                                mem[64] = (32 * _47182) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47182) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47182) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _51632 = mem[(32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47182) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47182) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47182) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47182) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47182) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47182) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47182) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47182) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47182) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47182) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47182) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47182) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47182) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47182) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47182) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47182) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47182) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51632 / 1000
                                                    mem[(32 * _47182) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47182) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47182) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47182) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47182) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51632 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47182) + (32 * _8679) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                    else:
                        mem[0] = 28
                        mem[ceil32(return_data.size) + 293] = address(token0ToEarnedPath.field_0)
                        idx = ceil32(return_data.size) + 293
                        s = 0
                        while ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 261 > idx:
                            mem[idx + 32] = token0ToEarnedPath[s].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        if block.timestamp + 600 < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 297] = ext_call.return_data[0]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 329] = 64
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 361] = token0ToEarnedPath.length
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 393 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                gas gas_remaining wei
                               args ext_call.return_data[0], Array(len=token0ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + floor32(token0ToEarnedPath.length) + 393 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293
                        require return_data.size >= 32
                        _20333 = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                        _20377 = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _20333 + 293]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _20333 + 293])] = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _20333 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _20333 + 293])]
                        mem[64] = (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389
                        mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                        mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                        if 1 > mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293]
                        _27523 = mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]
                        if not mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                            mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389] = 26
                            mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 421] = 'SafeMath: division by zero'
                            mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token0ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 649 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(token1Address)
                            staticcall token1Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if earnedAddress != token1Address:
                                if ext_call.return_data[0] > 0:
                                    require ext_code.size(token1Address)
                                    staticcall token1Address.0xdd62ed3e with:
                                            gas gas_remaining wei
                                           args address(this.address), address(uniRouterAddress)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489] = address(uniRouterAddress)
                                    mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 521] = 2 * ext_call.return_data[0]
                                    mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 453] = 68
                                    mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 28] = Mask(224, 0, stor8)
                                    mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 485 len 4] = approve(address rg1, uint256 rg2)
                                    mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 553] = 32
                                    mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 585] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                    mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 723 len 26]
                                    if not ext_code.size(token1Address):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                    mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 709 len 4] = 0
                                    mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 0] = 0
                                    call token1Address with:
                                       funct uint32(stor8)
                                         gas gas_remaining wei
                                        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 4]
                                    if return_data.size:
                                        mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = return_data.size
                                        mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 622] = 32
                                            mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 654] = 32
                                            mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 686] = 'SafeERC20: low-level call failed'
                                            revert with memory
                                              from (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618
                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                        if not return_data.size:
                                            mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _46981 = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _47201 = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46981 + 650]
                                                mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46981 + 650])] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46981 + 682 len floor32(mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46981 + 650])]
                                                mem[64] = (32 * _47201) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _47201) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _47201) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _51689 = mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _47201) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47201) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47201) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _47201) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51689 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47201) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 29
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _46983 = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47202 = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46983 + 650]
                                                    mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46983 + 650])] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46983 + 682 len floor32(mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46983 + 650])]
                                                    mem[64] = (32 * _47202) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47202) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47202) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51692 = mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47202) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47202) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47202) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47202) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51692 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47202) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _55241 = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _55315 = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55241 + 650]
                                                    mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55241 + 650])] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55241 + 682 len floor32(mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55241 + 650])]
                                                    mem[64] = (32 * _55315) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _55315) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _55315) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _56735 = mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _55315) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55315) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _55315) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _55315) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _56735 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55315) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            require return_data.size >= 32
                                            if not mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649]:
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 622] = 32
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 654] = 42
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 686 len 42] = 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                revert with memory
                                                  from (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                            mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _46985 = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _47203 = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46985 + 650]
                                                mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46985 + 650])] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46985 + 682 len floor32(mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46985 + 650])]
                                                mem[64] = (32 * _47203) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _47203) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _47203) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _51695 = mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _47203) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47203) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47203) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _47203) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51695 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47203) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 29
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _46987 = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47204 = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46987 + 650]
                                                    mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46987 + 650])] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46987 + 682 len floor32(mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46987 + 650])]
                                                    mem[64] = (32 * _47204) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47204) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47204) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51698 = mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47204) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47204) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47204) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47204) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51698 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47204) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _55243 = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _55316 = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55243 + 650]
                                                    mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55243 + 650])] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55243 + 682 len floor32(mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55243 + 650])]
                                                    mem[64] = (32 * _55316) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _55316) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _55316) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _56738 = mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _55316) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55316) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _55316) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _55316) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _56738 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55316) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        if not ext_call.success:
                                            revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                        if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _46977 = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _47199 = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46977 + 649]
                                            mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46977 + 649])] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46977 + 681 len floor32(mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46977 + 649])]
                                            mem[(32 * _47199) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _47199) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _51683 = mem[(32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _47199) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47199) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47199) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47199) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47199) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _47199) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47199) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47199) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47199) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47199) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47199) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _47199) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _47199) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47199) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47199) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47199) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47199) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51683 / 1000
                                                mem[(32 * _47199) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47199) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47199) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47199) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47199) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _51683 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47199) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 29
                                            mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _46979 = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47200 = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46979 + 649]
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46979 + 649])] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46979 + 681 len floor32(mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46979 + 649])]
                                                mem[(32 * _47200) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47200) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _51686 = mem[(32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47200) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47200) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47200) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47200) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47200) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47200) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47200) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47200) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47200) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47200) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47200) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47200) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47200) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47200) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47200) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47200) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47200) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51686 / 1000
                                                    mem[(32 * _47200) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47200) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47200) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47200) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47200) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51686 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47200) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _55239 = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _55314 = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55239 + 649]
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55239 + 649])] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55239 + 681 len floor32(mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55239 + 649])]
                                                mem[(32 * _55314) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _55314) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _56732 = mem[(32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _55314) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55314) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55314) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55314) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55314) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _55314) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55314) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55314) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55314) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55314) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55314) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _55314) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _55314) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55314) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55314) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55314) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55314) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _56732 / 1000
                                                    mem[(32 * _55314) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55314) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55314) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55314) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55314) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _56732 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55314) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                        else:
                            if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                revert with 0, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                            mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389] = 26
                            mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 421] = 'SafeMath: division by zero'
                            mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], slippageFactor * _27523 / 1000, Array(len=token0ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 649 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(token1Address)
                            staticcall token1Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if earnedAddress != token1Address:
                                if ext_call.return_data[0] > 0:
                                    require ext_code.size(token1Address)
                                    staticcall token1Address.0xdd62ed3e with:
                                            gas gas_remaining wei
                                           args address(this.address), address(uniRouterAddress)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489] = address(uniRouterAddress)
                                    mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 521] = 2 * ext_call.return_data[0]
                                    mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 453] = 68
                                    mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 28] = Mask(224, 0, stor8)
                                    mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 485 len 4] = approve(address rg1, uint256 rg2)
                                    mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 553] = 32
                                    mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 585] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                    mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 723 len 26]
                                    if not ext_code.size(token1Address):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                    mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 709 len 4] = 0
                                    mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 0] = 0
                                    call token1Address with:
                                       funct uint32(stor8)
                                         gas gas_remaining wei
                                        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 4]
                                    if return_data.size:
                                        mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = return_data.size
                                        mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 622] = 32
                                            mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 654] = 32
                                            mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 686] = 'SafeERC20: low-level call failed'
                                            revert with memory
                                              from (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618
                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                        if not return_data.size:
                                            mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _46965 = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _47193 = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46965 + 650]
                                                mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46965 + 650])] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46965 + 682 len floor32(mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46965 + 650])]
                                                mem[64] = (32 * _47193) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _47193) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _47193) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _51665 = mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _47193) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47193) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47193) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _47193) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51665 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47193) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 29
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _46967 = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47194 = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46967 + 650]
                                                    mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46967 + 650])] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46967 + 682 len floor32(mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46967 + 650])]
                                                    mem[64] = (32 * _47194) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47194) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47194) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51668 = mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47194) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47194) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47194) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47194) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51668 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47194) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _55233 = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _55311 = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55233 + 650]
                                                    mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55233 + 650])] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55233 + 682 len floor32(mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55233 + 650])]
                                                    mem[64] = (32 * _55311) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _55311) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _55311) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _56723 = mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _55311) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55311) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _55311) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _55311) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _56723 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55311) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            require return_data.size >= 32
                                            if not mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649]:
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 622] = 32
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 654] = 42
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 686 len 42] = 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                revert with memory
                                                  from (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                            mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _46969 = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _47195 = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46969 + 650]
                                                mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46969 + 650])] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46969 + 682 len floor32(mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46969 + 650])]
                                                mem[64] = (32 * _47195) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _47195) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _47195) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _51671 = mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _47195) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47195) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47195) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _47195) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51671 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47195) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 29
                                                mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _46971 = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47196 = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46971 + 650]
                                                    mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46971 + 650])] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46971 + 682 len floor32(mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46971 + 650])]
                                                    mem[64] = (32 * _47196) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47196) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47196) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51674 = mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47196) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47196) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47196) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47196) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51674 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47196) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _55235 = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _55312 = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55235 + 650]
                                                    mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55235 + 650])] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55235 + 682 len floor32(mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55235 + 650])]
                                                    mem[64] = (32 * _55312) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _55312) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _55312) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _56726 = mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _55312) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55312) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _55312) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _55312) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _56726 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20377) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55312) + (32 * _20377) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        if not ext_call.success:
                                            revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                        if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _46961 = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _47191 = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46961 + 649]
                                            mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46961 + 649])] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46961 + 681 len floor32(mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46961 + 649])]
                                            mem[(32 * _47191) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _47191) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _51659 = mem[(32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _47191) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47191) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47191) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47191) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47191) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _47191) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47191) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47191) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47191) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47191) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47191) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _47191) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _47191) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47191) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47191) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47191) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47191) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51659 / 1000
                                                mem[(32 * _47191) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47191) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47191) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47191) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47191) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _51659 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47191) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 29
                                            mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _46963 = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47192 = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46963 + 649]
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46963 + 649])] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46963 + 681 len floor32(mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46963 + 649])]
                                                mem[(32 * _47192) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47192) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _51662 = mem[(32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47192) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47192) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47192) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47192) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47192) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47192) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47192) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47192) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47192) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47192) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47192) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47192) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47192) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47192) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47192) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47192) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47192) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51662 / 1000
                                                    mem[(32 * _47192) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47192) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47192) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47192) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47192) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51662 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47192) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _55231 = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _55310 = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55231 + 649]
                                                mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55231 + 649])] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55231 + 681 len floor32(mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55231 + 649])]
                                                mem[(32 * _55310) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _55310) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _56720 = mem[(32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _55310) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55310) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55310) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55310) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55310) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _55310) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55310) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55310) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55310) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55310) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55310) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _55310) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _55310) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55310) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55310) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55310) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55310) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _56720 / 1000
                                                    mem[(32 * _55310) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55310) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55310) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55310) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55310) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _56720 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55310) + (32 * _20377) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                else:
                    require return_data.size >= 32
                    if not mem[292]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[ceil32(return_data.size) + 371 len 22]
                    mem[ceil32(return_data.size) + 261] = token0ToEarnedPath.length
                    if not token0ToEarnedPath.length:
                        if block.timestamp + 600 < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 297] = ext_call.return_data[0]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 329] = 64
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 361] = token0ToEarnedPath.length
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 393 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                gas gas_remaining wei
                               args ext_call.return_data[0], Array(len=token0ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + floor32(token0ToEarnedPath.length) + 393 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293
                        require return_data.size >= 32
                        _8639 = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                        _8680 = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _8639 + 293]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _8639 + 293])] = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _8639 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _8639 + 293])]
                        mem[64] = (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389
                        mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                        mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                        if 1 > mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293]
                        _12902 = mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]
                        if not mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                            mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389] = 26
                            mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 421] = 'SafeMath: division by zero'
                            mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token0ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 649 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(token1Address)
                            staticcall token1Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if earnedAddress != token1Address:
                                if ext_call.return_data[0] > 0:
                                    require ext_code.size(token1Address)
                                    staticcall token1Address.0xdd62ed3e with:
                                            gas gas_remaining wei
                                           args address(this.address), address(uniRouterAddress)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489] = address(uniRouterAddress)
                                    mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 521] = 2 * ext_call.return_data[0]
                                    mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 453] = 68
                                    mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 28] = Mask(224, 0, stor8)
                                    mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 485 len 4] = approve(address rg1, uint256 rg2)
                                    mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 553] = 32
                                    mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 585] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                    mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 723 len 26]
                                    if not ext_code.size(token1Address):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                    mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 709 len 4] = 0
                                    call token1Address with:
                                       funct token0ToEarnedPath.length.field_224
                                         gas gas_remaining wei
                                        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 4]
                                    if return_data.size:
                                        mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = return_data.size
                                        mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 622] = 32
                                            mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 654] = 32
                                            mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 686] = 'SafeERC20: low-level call failed'
                                            revert with memory
                                              from (32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618
                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                        if not return_data.size:
                                            mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from (32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (32 * token1ToEarnedPath.length) + (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _34353 = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _34503 = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34353 + 650]
                                                mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34353 + 650])] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34353 + 682 len floor32(mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34353 + 650])]
                                                mem[64] = (32 * _34503) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _34503) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _34503) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _40969 = mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _34503) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34503) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34503) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _34503) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40969 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34503) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 29
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (32 * token1ToEarnedPath.length) + (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _34355 = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _34504 = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34355 + 650]
                                                    mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34355 + 650])] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34355 + 682 len floor32(mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34355 + 650])]
                                                    mem[64] = (32 * _34504) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _34504) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _34504) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _40972 = mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _34504) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34504) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _34504) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _34504) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _40972 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34504) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (32 * token1ToEarnedPath.length) + (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _47001 = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47211 = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47001 + 650]
                                                    mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47001 + 650])] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47001 + 682 len floor32(mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47001 + 650])]
                                                    mem[64] = (32 * _47211) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47211) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47211) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51719 = mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47211) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47211) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47211) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47211) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51719 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47211) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            require return_data.size >= 32
                                            if not mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649]:
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 622] = 32
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 654] = 42
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 686 len 42] = 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                revert with memory
                                                  from (32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                            mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from (32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (32 * token1ToEarnedPath.length) + (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _34357 = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _34505 = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34357 + 650]
                                                mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34357 + 650])] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34357 + 682 len floor32(mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34357 + 650])]
                                                mem[64] = (32 * _34505) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _34505) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _34505) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _40975 = mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _34505) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34505) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34505) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _34505) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40975 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34505) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 29
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (32 * token1ToEarnedPath.length) + (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _34359 = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _34506 = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34359 + 650]
                                                    mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34359 + 650])] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34359 + 682 len floor32(mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34359 + 650])]
                                                    mem[64] = (32 * _34506) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _34506) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _34506) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _40978 = mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _34506) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34506) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _34506) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _34506) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _40978 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34506) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (32 * token1ToEarnedPath.length) + (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _47003 = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47212 = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47003 + 650]
                                                    mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47003 + 650])] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47003 + 682 len floor32(mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47003 + 650])]
                                                    mem[64] = (32 * _47212) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47212) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47212) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51722 = mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47212) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47212) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47212) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47212) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51722 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47212) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        if not ext_call.success:
                                            revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                        if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _34349 = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _34501 = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34349 + 649]
                                            mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34349 + 649])] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34349 + 681 len floor32(mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34349 + 649])]
                                            mem[64] = (32 * _34501) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _34501) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _34501) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _40963 = mem[(32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _34501) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34501) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34501) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34501) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34501) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _34501) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34501) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34501) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34501) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34501) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34501) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _34501) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _34501) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34501) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34501) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34501) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34501) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40963 / 1000
                                                mem[(32 * _34501) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34501) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34501) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34501) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34501) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _40963 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34501) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 29
                                            mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _34351 = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _34502 = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34351 + 649]
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34351 + 649])] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34351 + 681 len floor32(mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34351 + 649])]
                                                mem[64] = (32 * _34502) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _34502) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _34502) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _40966 = mem[(32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _34502) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34502) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34502) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34502) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34502) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _34502) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34502) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34502) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34502) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34502) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34502) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34502) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _34502) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34502) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34502) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34502) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34502) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40966 / 1000
                                                    mem[(32 * _34502) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34502) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34502) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34502) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34502) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40966 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34502) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _46999 = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47210 = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46999 + 649]
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46999 + 649])] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46999 + 681 len floor32(mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46999 + 649])]
                                                mem[64] = (32 * _47210) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47210) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47210) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _51716 = mem[(32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47210) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47210) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47210) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47210) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47210) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47210) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47210) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47210) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47210) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47210) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47210) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47210) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47210) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47210) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47210) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47210) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47210) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51716 / 1000
                                                    mem[(32 * _47210) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47210) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47210) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47210) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47210) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51716 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47210) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                        else:
                            if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                revert with 0, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                            mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389] = 26
                            mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 421] = 'SafeMath: division by zero'
                            mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], slippageFactor * _12902 / 1000, Array(len=token0ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 649 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(token1Address)
                            staticcall token1Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if earnedAddress != token1Address:
                                if ext_call.return_data[0] > 0:
                                    require ext_code.size(token1Address)
                                    staticcall token1Address.0xdd62ed3e with:
                                            gas gas_remaining wei
                                           args address(this.address), address(uniRouterAddress)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489] = address(uniRouterAddress)
                                    mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 521] = 2 * ext_call.return_data[0]
                                    mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 453] = 68
                                    mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 28] = Mask(224, 0, stor8)
                                    mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 485 len 4] = approve(address rg1, uint256 rg2)
                                    mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 553] = 32
                                    mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 585] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                    mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 723 len 26]
                                    if not ext_code.size(token1Address):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                    mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 709 len 4] = 0
                                    mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 0] = 0
                                    call token1Address with:
                                       funct uint32(stor8)
                                         gas gas_remaining wei
                                        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 4]
                                    if return_data.size:
                                        mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = return_data.size
                                        mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if not return_data.size:
                                            mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _34337 = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _34495 = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34337 + 650]
                                                mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34337 + 650])] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34337 + 682 len floor32(mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34337 + 650])]
                                                mem[64] = (32 * _34495) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _34495) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _34495) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _40945 = mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _34495) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34495) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34495) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _34495) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40945 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34495) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 29
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _34339 = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _34496 = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34339 + 650]
                                                    mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34339 + 650])] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34339 + 682 len floor32(mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34339 + 650])]
                                                    mem[64] = (32 * _34496) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _34496) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _34496) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _40948 = mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _34496) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34496) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _34496) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _34496) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _40948 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34496) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _46993 = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47207 = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46993 + 650]
                                                    mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46993 + 650])] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46993 + 682 len floor32(mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46993 + 650])]
                                                    mem[64] = (32 * _47207) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47207) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47207) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51707 = mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47207) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47207) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47207) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47207) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51707 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47207) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            require return_data.size >= 32
                                            if not mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 728 len 22]
                                            mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _34341 = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _34497 = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34341 + 650]
                                                mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34341 + 650])] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34341 + 682 len floor32(mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34341 + 650])]
                                                mem[64] = (32 * _34497) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _34497) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _34497) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _40951 = mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _34497) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34497) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34497) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _34497) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40951 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34497) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 29
                                                mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _34343 = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _34498 = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34343 + 650]
                                                    mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34343 + 650])] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34343 + 682 len floor32(mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _34343 + 650])]
                                                    mem[64] = (32 * _34498) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _34498) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _34498) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _40954 = mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _34498) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34498) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _34498) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _34498) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _40954 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _34498) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _46995 = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47208 = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46995 + 650]
                                                    mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46995 + 650])] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46995 + 682 len floor32(mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _46995 + 650])]
                                                    mem[64] = (32 * _47208) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47208) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47208) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51710 = mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47208) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47208) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47208) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47208) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51710 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47208) + (32 * _8680) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        if not ext_call.success:
                                            revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                        if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _34333 = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _34493 = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34333 + 649]
                                            mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34333 + 649])] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34333 + 681 len floor32(mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34333 + 649])]
                                            mem[64] = (32 * _34493) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _34493) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _34493) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _40939 = mem[(32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _34493) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34493) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34493) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34493) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34493) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _34493) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34493) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34493) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34493) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34493) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34493) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _34493) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _34493) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _34493) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _34493) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _34493) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _34493) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40939 / 1000
                                                mem[(32 * _34493) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _34493) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _34493) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _34493) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _34493) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _40939 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34493) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 29
                                            mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _34335 = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _34494 = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34335 + 649]
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34335 + 649])] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34335 + 681 len floor32(mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _34335 + 649])]
                                                mem[64] = (32 * _34494) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _34494) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _34494) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _40942 = mem[(32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _34494) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34494) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34494) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34494) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34494) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _34494) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34494) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34494) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34494) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34494) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34494) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _34494) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _34494) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _34494) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _34494) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _34494) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _34494) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _40942 / 1000
                                                    mem[(32 * _34494) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _34494) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _34494) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _34494) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _34494) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _40942 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _34494) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _46991 = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47206 = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46991 + 649]
                                                mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46991 + 649])] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46991 + 681 len floor32(mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _46991 + 649])]
                                                mem[64] = (32 * _47206) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47206) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47206) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _51704 = mem[(32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47206) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47206) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47206) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47206) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47206) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47206) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47206) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47206) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47206) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47206) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47206) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47206) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47206) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47206) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47206) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47206) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47206) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51704 / 1000
                                                    mem[(32 * _47206) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47206) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47206) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47206) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47206) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51704 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47206) + (32 * _8680) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                    else:
                        mem[0] = 28
                        mem[ceil32(return_data.size) + 293] = address(token0ToEarnedPath.field_0)
                        idx = ceil32(return_data.size) + 293
                        s = 0
                        while ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 261 > idx:
                            mem[idx + 32] = token0ToEarnedPath[s].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        if block.timestamp + 600 < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 297] = ext_call.return_data[0]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 329] = 64
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 361] = token0ToEarnedPath.length
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 393 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                        require ext_code.size(address(uniRouterAddress))
                        staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                gas gas_remaining wei
                               args ext_call.return_data[0], Array(len=token0ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + floor32(token0ToEarnedPath.length) + 393 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293
                        require return_data.size >= 32
                        _20339 = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28]
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] <= 4294967296
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293] <= 4294967296 and mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + (32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + 293 len 4], ext_call.return_data[0 len 28] + 293]
                        _20380 = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _20339 + 293]
                        mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325 len floor32(mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _20339 + 293])] = mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _20339 + 325 len floor32(mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + _20339 + 293])]
                        mem[64] = (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389
                        mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] = 30
                        mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 357] = 'SafeMath: subtraction overflow'
                        if 1 > mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        require mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1 < mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293]
                        _27534 = mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]
                        if not mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325]:
                            mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389] = 26
                            mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 421] = 'SafeMath: division by zero'
                            mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token0ToEarnedPath.length, mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 649 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(token1Address)
                            staticcall token1Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if earnedAddress != token1Address:
                                if ext_call.return_data[0] > 0:
                                    require ext_code.size(token1Address)
                                    staticcall token1Address.0xdd62ed3e with:
                                            gas gas_remaining wei
                                           args address(this.address), address(uniRouterAddress)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489] = address(uniRouterAddress)
                                    mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 521] = 2 * ext_call.return_data[0]
                                    mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 453] = 68
                                    mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 28] = Mask(224, 0, stor8)
                                    mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 485 len 4] = approve(address rg1, uint256 rg2)
                                    mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 553] = 32
                                    mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 585] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                    mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 723 len 26]
                                    if not ext_code.size(token1Address):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                    mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 709 len 4] = 0
                                    call token1Address with:
                                       funct token0ToEarnedPath.length.field_224
                                         gas gas_remaining wei
                                        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 4]
                                    if return_data.size:
                                        mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = return_data.size
                                        mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if not return_data.size:
                                            mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _47029 = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _47225 = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47029 + 650]
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47029 + 650])] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47029 + 682 len floor32(mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47029 + 650])]
                                                mem[64] = (32 * _47225) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _47225) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _47225) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _51761 = mem[(32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _47225) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47225) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47225) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _47225) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51761 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47225) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 29
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _47031 = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47226 = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47031 + 650]
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47031 + 650])] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47031 + 682 len floor32(mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47031 + 650])]
                                                    mem[64] = (32 * _47226) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47226) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47226) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51764 = mem[(32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47226) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47226) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47226) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47226) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51764 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47226) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _55257 = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _55323 = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55257 + 650]
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55257 + 650])] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55257 + 682 len floor32(mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55257 + 650])]
                                                    mem[64] = (32 * _55323) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _55323) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _55323) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _56759 = mem[(32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _55323) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55323) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _55323) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _55323) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _56759 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55323) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            require return_data.size >= 32
                                            if not mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 728 len 22]
                                            mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _47033 = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _47227 = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47033 + 650]
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47033 + 650])] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47033 + 682 len floor32(mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47033 + 650])]
                                                mem[64] = (32 * _47227) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _47227) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _47227) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _51767 = mem[(32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _47227) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47227) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47227) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _47227) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51767 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47227) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 29
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _47035 = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47228 = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47035 + 650]
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47035 + 650])] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47035 + 682 len floor32(mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47035 + 650])]
                                                    mem[64] = (32 * _47228) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47228) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47228) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51770 = mem[(32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47228) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47228) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47228) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47228) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51770 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47228) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 750 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _55259 = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _55324 = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55259 + 650]
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55259 + 650])] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55259 + 682 len floor32(mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55259 + 650])]
                                                    mem[64] = (32 * _55324) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _55324) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _55324) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _56762 = mem[(32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _55324) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55324) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _55324) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _55324) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _56762 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55324) + (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        if not ext_call.success:
                                            revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                        if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _47025 = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _47223 = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47025 + 649]
                                            mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47025 + 649])] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47025 + 681 len floor32(mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47025 + 649])]
                                            mem[64] = (32 * _47223) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _47223) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _47223) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _51755 = mem[(32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _47223) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47223) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47223) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47223) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47223) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _47223) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47223) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47223) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47223) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47223) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47223) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _47223) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _47223) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47223) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47223) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47223) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47223) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51755 / 1000
                                                mem[(32 * _47223) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47223) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47223) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47223) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47223) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _51755 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47223) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 29
                                            mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _47027 = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47224 = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47027 + 649]
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47027 + 649])] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47027 + 681 len floor32(mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47027 + 649])]
                                                mem[64] = (32 * _47224) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47224) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47224) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _51758 = mem[(32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47224) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47224) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47224) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47224) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47224) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47224) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47224) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47224) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47224) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47224) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47224) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47224) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47224) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47224) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47224) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47224) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47224) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51758 / 1000
                                                    mem[(32 * _47224) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47224) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47224) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47224) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47224) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51758 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47224) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _55255 = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _55322 = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55255 + 649]
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55255 + 649])] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55255 + 681 len floor32(mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55255 + 649])]
                                                mem[64] = (32 * _55322) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _55322) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _55322) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _56756 = mem[(32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _55322) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55322) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55322) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55322) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55322) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _55322) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55322) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55322) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55322) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55322) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55322) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _55322) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _55322) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55322) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55322) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55322) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55322) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _56756 / 1000
                                                    mem[(32 * _55322) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55322) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55322) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55322) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55322) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _56756 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55322) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                        else:
                            if slippageFactor * mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] / mem[(32 * mem[ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 293] - 1) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 325] != slippageFactor:
                                revert with 0, 
                                            32,
                                            33,
                                            0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 490 len 31]
                            mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 389] = 26
                            mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 421] = 'SafeMath: division by zero'
                            mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token0ToEarnedPath.length)] = mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)]
                            require ext_code.size(address(uniRouterAddress))
                            call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], slippageFactor * _27534 / 1000, Array(len=token0ToEarnedPath.length, data=mem[ceil32(return_data.size) + 293 len floor32(token0ToEarnedPath.length)], mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + floor32(token0ToEarnedPath.length) + 649 len (32 * token0ToEarnedPath.length) - floor32(token0ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(token1Address)
                            staticcall token1Address.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if earnedAddress != token1Address:
                                if ext_call.return_data[0] > 0:
                                    require ext_code.size(token1Address)
                                    staticcall token1Address.0xdd62ed3e with:
                                            gas gas_remaining wei
                                           args address(this.address), address(uniRouterAddress)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489] = address(uniRouterAddress)
                                    mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 521] = 2 * ext_call.return_data[0]
                                    mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 453] = 68
                                    mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 489 len 28] = Mask(224, 0, stor8)
                                    mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 485 len 4] = approve(address rg1, uint256 rg2)
                                    mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 553] = 32
                                    mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 585] = 'SafeERC20: low-level call failed'
                                    if eth.balance(this.address) < 0:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0x73416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                    mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 723 len 26]
                                    if not ext_code.size(token1Address):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617 len 64] = approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), Mask(224, 31, ext_call.return_data[0]) >> 31
                                    mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 709 len 4] = 0
                                    mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 0] = 0
                                    call token1Address with:
                                       funct uint32(stor8)
                                         gas gas_remaining wei
                                        args Mask(224, 31, ext_call.return_data[0]) << 225, mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681 len 4]
                                    if return_data.size:
                                        mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = return_data.size
                                        mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 622] = 32
                                            mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 654] = 32
                                            mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 686] = 'SafeERC20: low-level call failed'
                                            revert with memory
                                              from (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618
                                               len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                        if not return_data.size:
                                            mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _47013 = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _47217 = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47013 + 650]
                                                mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47013 + 650])] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47013 + 682 len floor32(mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47013 + 650])]
                                                mem[64] = (32 * _47217) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _47217) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _47217) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _51737 = mem[(32 * mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _47217) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47217) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47217) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _47217) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51737 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47217) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 29
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _47015 = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47218 = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47015 + 650]
                                                    mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47015 + 650])] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47015 + 682 len floor32(mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47015 + 650])]
                                                    mem[64] = (32 * _47218) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47218) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47218) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51740 = mem[(32 * mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47218) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47218) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47218) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47218) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51740 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47218) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _55249 = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _55319 = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55249 + 650]
                                                    mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55249 + 650])] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55249 + 682 len floor32(mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55249 + 650])]
                                                    mem[64] = (32 * _55319) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _55319) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _55319) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _56747 = mem[(32 * mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _55319) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55319) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _55319) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _55319) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _56747 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55319) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            require return_data.size >= 32
                                            if not mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649]:
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 622] = 32
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 654] = 42
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 686 len 42] = 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565
                                                revert with memory
                                                  from (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618
                                                   len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 132
                                            mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 618] = token1ToEarnedPath.length
                                            if not token1ToEarnedPath.length:
                                                if block.timestamp + 600 < block.timestamp:
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                       len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                require return_data.size >= 32
                                                _47017 = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                _47219 = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47017 + 650]
                                                mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47017 + 650])] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47017 + 682 len floor32(mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47017 + 650])]
                                                mem[64] = (32 * _47219) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                mem[(32 * _47219) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                mem[(32 * _47219) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                _51743 = mem[(32 * mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                if not mem[(32 * mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                    mem[(32 * _47219) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47219) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47219) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                    mem[(32 * _47219) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51743 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47219) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[0] = 29
                                                mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650] = address(token1ToEarnedPath.field_0)
                                                if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _47019 = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _47220 = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47019 + 650]
                                                    mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47019 + 650])] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47019 + 682 len floor32(mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _47019 + 650])]
                                                    mem[64] = (32 * _47220) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _47220) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _47220) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _51746 = mem[(32 * mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _47220) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47220) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _47220) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _47220) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _51746 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _47220) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                                else:
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682] = address(token1ToEarnedPath.field_256)
                                                    idx = (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 682
                                                    s = 1
                                                    while (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 618 > idx:
                                                        mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                        idx = idx + 32
                                                        s = s + 1
                                                        continue 
                                                    if block.timestamp + 600 < block.timestamp:
                                                        mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = 32
                                                        mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 27
                                                        mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                           len (4 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 100
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654] = ext_call.return_data[0]
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 686] = 64
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 718] = token1ToEarnedPath.length
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 750 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                            gas gas_remaining wei
                                                           args mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 654 len (4 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + (-2 * ceil32(return_data.size)) + 96]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = (32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650
                                                    require return_data.size >= 32
                                                    _55251 = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28]
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                    require mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650] <= 4294967296 and mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]) + 32 <= return_data.size
                                                    mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650 len 4], ext_call.return_data[0 len 28] + 650]
                                                    _55320 = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55251 + 650]
                                                    mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682 len floor32(mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55251 + 650])] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55251 + 682 len floor32(mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + _55251 + 650])]
                                                    mem[64] = (32 * _55320) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 746
                                                    mem[(32 * _55320) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] = 30
                                                    mem[(32 * _55320) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 714] = 'SafeMath: subtraction overflow'
                                                    if 1 > mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    require mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1 < mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650]
                                                    _56750 = mem[(32 * mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]
                                                    if not mem[(32 * mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682]:
                                                        mem[(32 * _55320) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55320) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                    else:
                                                        if slippageFactor * mem[(32 * mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] / mem[(32 * mem[(32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 650] - 1) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 682] != slippageFactor:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * _55320) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 847 len 31]
                                                        mem[(32 * _55320) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + 1006 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)]
                                                        require ext_code.size(address(uniRouterAddress))
                                                        call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                             gas gas_remaining wei
                                                            args ext_call.return_data[0], slippageFactor * _56750 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + (4 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + 650 len floor32(token1ToEarnedPath.length)], mem[(32 * _55320) + (32 * _20380) + (6 * ceil32(return_data.size)) + (32 * token0ToEarnedPath.length) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1006 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    else:
                                        if not ext_call.success:
                                            revert with approve(address rg1, uint256 rg2), Mask(224, 0, stor8), uint32(stor8), 2 * ext_call.return_data[0]
                                        if not approve(address rg1, uint256 rg2), Mask(224, 0, stor8):
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 727 len 22]
                                        mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 617] = token1ToEarnedPath.length
                                        if not token1ToEarnedPath.length:
                                            if block.timestamp + 600 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                            mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                            mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                            mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                            require ext_code.size(address(uniRouterAddress))
                                            staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                    gas gas_remaining wei
                                                   args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                            require return_data.size >= 32
                                            _47009 = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                            require mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                            require mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                            require mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                            mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                            _47215 = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47009 + 649]
                                            mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47009 + 649])] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47009 + 681 len floor32(mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47009 + 649])]
                                            mem[64] = (32 * _47215) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                            mem[(32 * _47215) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                            mem[(32 * _47215) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                            if 1 > mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                            _51731 = mem[(32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                            if not mem[(32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                mem[(32 * _47215) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47215) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47215) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47215) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47215) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                mem[(32 * _47215) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47215) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47215) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47215) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47215) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47215) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                            else:
                                                if slippageFactor * mem[(32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _47215) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                mem[(32 * _47215) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                mem[(32 * _47215) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                mem[(32 * _47215) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _47215) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                mem[(32 * _47215) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51731 / 1000
                                                mem[(32 * _47215) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                mem[(32 * _47215) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                mem[(32 * _47215) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                mem[(32 * _47215) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                mem[(32 * _47215) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0], slippageFactor * _51731 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47215) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                        else:
                                            mem[0] = 29
                                            mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649] = address(token1ToEarnedPath.field_0)
                                            if (32 * token1ToEarnedPath.length) + 32 <= 64:
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _47011 = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _47216 = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47011 + 649]
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47011 + 649])] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47011 + 681 len floor32(mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _47011 + 649])]
                                                mem[64] = (32 * _47216) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _47216) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _47216) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _51734 = mem[(32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _47216) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47216) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47216) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47216) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47216) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _47216) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47216) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47216) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47216) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47216) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47216) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _47216) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _47216) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _47216) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _47216) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _47216) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _47216) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _51734 / 1000
                                                    mem[(32 * _47216) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _47216) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _47216) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _47216) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _47216) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _51734 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _47216) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                            else:
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681] = address(token1ToEarnedPath.field_256)
                                                idx = (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 681
                                                s = 1
                                                while (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 617 > idx:
                                                    mem[idx + 32] = token1ToEarnedPath[s].field_256
                                                    idx = idx + 32
                                                    s = s + 1
                                                    continue 
                                                if block.timestamp + 600 < block.timestamp:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 653] = ext_call.return_data[0]
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 685] = 64
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 717] = token1ToEarnedPath.length
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 749 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                require ext_code.size(address(uniRouterAddress))
                                                staticcall address(uniRouterAddress).getAmountsOut(uint256 rg1, address[] rg2) with:
                                                        gas gas_remaining wei
                                                       args ext_call.return_data[0], Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 749 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)])
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649
                                                require return_data.size >= 32
                                                _55247 = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28]
                                                require mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] <= 4294967296
                                                require mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 32 <= return_data.size
                                                require mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649] <= 4294967296 and mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + (32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]) + 32 <= return_data.size
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + 649 len 4], ext_call.return_data[0 len 28] + 649]
                                                _55318 = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55247 + 649]
                                                mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681 len floor32(mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55247 + 649])] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55247 + 681 len floor32(mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + (32 * token1ToEarnedPath.length) + _55247 + 649])]
                                                mem[64] = (32 * _55318) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745
                                                mem[(32 * _55318) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] = 30
                                                mem[(32 * _55318) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 713] = 'SafeMath: subtraction overflow'
                                                if 1 > mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                require mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1 < mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649]
                                                _56744 = mem[(32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]
                                                if not mem[(32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681]:
                                                    mem[(32 * _55318) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55318) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55318) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55318) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55318) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = 0
                                                    mem[(32 * _55318) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55318) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55318) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55318) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55318) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 600, token1ToEarnedPath.length, mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55318) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]
                                                else:
                                                    if slippageFactor * mem[(32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] / mem[(32 * mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 649] - 1) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 681] != slippageFactor:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x6c536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * _55318) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 846 len 31]
                                                    mem[(32 * _55318) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 745] = 26
                                                    mem[(32 * _55318) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 777] = 'SafeMath: division by zero'
                                                    mem[(32 * _55318) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 809] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                                    mem[(32 * _55318) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 813] = ext_call.return_data[0]
                                                    mem[(32 * _55318) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 845] = slippageFactor * _56744 / 1000
                                                    mem[(32 * _55318) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 909] = this.address
                                                    mem[(32 * _55318) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 941] = block.timestamp + 600
                                                    mem[(32 * _55318) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 877] = 160
                                                    mem[(32 * _55318) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 973] = token1ToEarnedPath.length
                                                    mem[(32 * _55318) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + 1005 len floor32(token1ToEarnedPath.length)] = mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)]
                                                    require ext_code.size(address(uniRouterAddress))
                                                    call address(uniRouterAddress).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                         gas gas_remaining wei
                                                        args ext_call.return_data[0], slippageFactor * _56744 / 1000, Array(len=token1ToEarnedPath.length, data=mem[(32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + ceil32(return_data.size) + 649 len floor32(token1ToEarnedPath.length)], mem[(32 * _55318) + (32 * _20380) + ceil32(return_data.size) + (32 * token0ToEarnedPath.length) + (2 * ceil32(return_data.size)) + (32 * token1ToEarnedPath.length) + floor32(token1ToEarnedPath.length) + 1005 len (32 * token1ToEarnedPath.length) - floor32(token1ToEarnedPath.length)]), address(this.address), block.timestamp + 600
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
}



}
