contract main {




// =====================  Runtime code  =====================


#
#  - leaveStaking(uint256 arg1)
#  - add(uint256 arg1, address arg2, bool arg3)
#  - enterStaking(uint256 arg1)
#  - withdraw(uint256 arg1, uint256 arg2)
#  - emergencyWithdraw(uint256 arg1)
#  - deposit(uint256 arg1, uint256 arg2)
#
address owner;
address brushAddress;
address wftmAddress;
uint256 brushPerSecond;
address artGalleryAddress;
address routerAddress;
array of struct poolInfo;
mapping of struct userInfo;
uint256 totalAllocPoint;
uint256 startTime;
mapping of uint256 maxBurnAndBuyBackAmounts;
mapping of uint8 stor12;

function poolLength() payable {
    return poolInfo.length
}

function poolInfo(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < poolInfo.length
    return poolInfo[arg1].field_0, poolInfo[arg1].field_256, poolInfo[arg1].field_512, poolInfo[arg1].field_768
}

function totalAllocPoint() payable {
    return totalAllocPoint
}

function poolExists(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor12[address(arg1)])
}

function artGallery() payable {
    return artGalleryAddress
}

function brushPerSecond() payable {
    return brushPerSecond
}

function brush() payable {
    return brushAddress
}

function startTime() payable {
    return startTime
}

function owner() payable {
    return owner
}

function userInfo(uint256 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    return userInfo[arg1][arg2].field_0, userInfo[arg1][arg2].field_256
}

function wftm() payable {
    return wftmAddress
}

function router() payable {
    return routerAddress
}

function maxBurnAndBuyBackAmounts(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return maxBurnAndBuyBackAmounts[arg1]
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function sub_9f967f33(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(brushAddress)
    call brushAddress.0xf2fde38b with:
         gas gas_remaining wei
        args address(arg1)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_a80d17e2(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(brushAddress)
    call brushAddress.0xf2fde38b with:
         gas gas_remaining wei
        args address(arg1)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function updatePool(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if arg1 >= poolInfo.length:
        revert with 0, 50
    if block.timestamp > poolInfo[arg1].field_512:
        require ext_code.size(poolInfo[arg1].field_0)
        staticcall poolInfo[arg1].field_0.balanceOf(address rg1) with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0]:
            if poolInfo[arg1].field_256:
                if poolInfo[arg1].field_512 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if block.timestamp < poolInfo[arg1].field_512:
                    revert with 0, 17
                if not block.timestamp - poolInfo[arg1].field_512:
                    if not totalAllocPoint:
                        revert with 0, 'SafeMath: division by zero', 0
                    require ext_code.size(brushAddress)
                    call brushAddress.mint(address rg1, uint256 rg2) with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero', 0
                        if poolInfo[arg1].field_768 > !(0 / ext_call.return_data[0]):
                            revert with 0, 17
                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                    else:
                        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                            revert with 0, 17
                        if not 0 / totalAllocPoint:
                            revert with 0, 18
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero', 0
                        if poolInfo[arg1].field_768 > !(10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                            revert with 0, 17
                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                else:
                    if block.timestamp - poolInfo[arg1].field_512 and brushPerSecond > -1 / block.timestamp - poolInfo[arg1].field_512:
                        revert with 0, 17
                    if not block.timestamp - poolInfo[arg1].field_512:
                        revert with 0, 18
                    if (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond) / block.timestamp - poolInfo[arg1].field_512 != brushPerSecond:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond):
                        if not totalAllocPoint:
                            revert with 0, 'SafeMath: division by zero', 0
                        require ext_code.size(brushAddress)
                        call brushAddress.mint(address rg1, uint256 rg2) with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero', 0
                            if poolInfo[arg1].field_768 > !(0 / ext_call.return_data[0]):
                                revert with 0, 17
                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                        else:
                            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                                revert with 0, 17
                            if not 0 / totalAllocPoint:
                                revert with 0, 18
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero', 0
                            if poolInfo[arg1].field_768 > !(10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                                revert with 0, 17
                            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    else:
                        if (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond) and poolInfo[arg1].field_256 > -1 / (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond):
                            revert with 0, 17
                        if not (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond):
                            revert with 0, 18
                        if (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond) != poolInfo[arg1].field_256:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not totalAllocPoint:
                            revert with 0, 'SafeMath: division by zero', 0
                        require ext_code.size(brushAddress)
                        call brushAddress.mint(address rg1, uint256 rg2) with:
                             gas gas_remaining wei
                            args this.address, (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint:
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero', 0
                            if poolInfo[arg1].field_768 > !(0 / ext_call.return_data[0]):
                                revert with 0, 17
                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                        else:
                            if (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint and 10^12 > -1 / (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint:
                                revert with 0, 17
                            if not (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint:
                                revert with 0, 18
                            if 10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero', 0
                            if poolInfo[arg1].field_768 > !(10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]):
                                revert with 0, 17
                            if poolInfo[arg1].field_768 + (10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
        poolInfo[arg1].field_512 = block.timestamp
}

function massUpdatePools() payable {
    mem[64] = 96
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 6
        if block.timestamp <= poolInfo[idx].field_512:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(poolInfo[idx].field_0)
        staticcall poolInfo[idx].field_0.balanceOf(address rg1) with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _97 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _98 = mem[_97]
        if not mem[_97]:
            poolInfo[idx].field_512 = block.timestamp
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if not poolInfo[idx].field_256:
            poolInfo[idx].field_512 = block.timestamp
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _99 = mem[64]
        mem[64] = mem[64] + 64
        mem[_99] = 30
        mem[_99 + 32] = 'SafeMath: subtraction overflow'
        if poolInfo[idx].field_512 > block.timestamp:
            _100 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _100 + 68] = mem[idx + _99 + 32]
                idx = idx + 32
                continue 
            mem[_100 + 98] = 0
            revert with memory
              from mem[64]
               len _100 + -mem[64] + 100
        if block.timestamp < poolInfo[idx].field_512:
            revert with 0, 17
        if not block.timestamp - poolInfo[idx].field_512:
            _106 = mem[64]
            mem[64] = mem[64] + 64
            mem[_106] = 26
            mem[_106 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _108 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _108 + 68] = mem[idx + _106 + 32]
                    idx = idx + 32
                    continue 
                mem[_108 + 94] = 0
                revert with memory
                  from mem[64]
                   len _108 + -mem[64] + 100
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0 / totalAllocPoint
            require ext_code.size(brushAddress)
            call brushAddress.mint(address rg1, uint256 rg2) with:
                 gas gas_remaining wei
                args this.address, 0 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not 0 / totalAllocPoint:
                _125 = mem[64]
                mem[64] = mem[64] + 64
                mem[_125] = 26
                mem[_125 + 32] = 'SafeMath: division by zero'
                if _98:
                    if poolInfo[idx].field_768 > !(0 / _98):
                        revert with 0, 17
                    if poolInfo[idx].field_768 + (0 / _98) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / _98
                    poolInfo[idx].field_512 = block.timestamp
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _129 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _129 + 68] = mem[idx + _125 + 32]
                    idx = idx + 32
                    continue 
                mem[_129 + 94] = 0
                revert with memory
                  from mem[64]
                   len _129 + -mem[64] + 100
            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                revert with 0, 17
            if not 0 / totalAllocPoint:
                revert with 0, 18
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _137 = mem[64]
            mem[64] = mem[64] + 64
            mem[_137] = 26
            mem[_137 + 32] = 'SafeMath: division by zero'
            if _98:
                if poolInfo[idx].field_768 > !(10^12 * 0 / totalAllocPoint / _98):
                    revert with 0, 17
                if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / _98) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / _98
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _142 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _142 + 68] = mem[idx + _137 + 32]
                idx = idx + 32
                continue 
            mem[_142 + 94] = 0
            revert with memory
              from mem[64]
               len _142 + -mem[64] + 100
        if block.timestamp - poolInfo[idx].field_512 and brushPerSecond > -1 / block.timestamp - poolInfo[idx].field_512:
            revert with 0, 17
        if not block.timestamp - poolInfo[idx].field_512:
            revert with 0, 18
        if (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond) / block.timestamp - poolInfo[idx].field_512 != brushPerSecond:
            revert with 0, 'SafeMath: multiplication overflow'
        if not (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond):
            _110 = mem[64]
            mem[64] = mem[64] + 64
            mem[_110] = 26
            mem[_110 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _114 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _114 + 68] = mem[idx + _110 + 32]
                    idx = idx + 32
                    continue 
                mem[_114 + 94] = 0
                revert with memory
                  from mem[64]
                   len _114 + -mem[64] + 100
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0 / totalAllocPoint
            require ext_code.size(brushAddress)
            call brushAddress.mint(address rg1, uint256 rg2) with:
                 gas gas_remaining wei
                args this.address, 0 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not 0 / totalAllocPoint:
                _136 = mem[64]
                mem[64] = mem[64] + 64
                mem[_136] = 26
                mem[_136 + 32] = 'SafeMath: division by zero'
                if _98:
                    if poolInfo[idx].field_768 > !(0 / _98):
                        revert with 0, 17
                    if poolInfo[idx].field_768 + (0 / _98) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / _98
                    poolInfo[idx].field_512 = block.timestamp
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _141 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _141 + 68] = mem[idx + _136 + 32]
                    idx = idx + 32
                    continue 
                mem[_141 + 94] = 0
                revert with memory
                  from mem[64]
                   len _141 + -mem[64] + 100
            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                revert with 0, 17
            if not 0 / totalAllocPoint:
                revert with 0, 18
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _150 = mem[64]
            mem[64] = mem[64] + 64
            mem[_150] = 26
            mem[_150 + 32] = 'SafeMath: division by zero'
            if _98:
                if poolInfo[idx].field_768 > !(10^12 * 0 / totalAllocPoint / _98):
                    revert with 0, 17
                if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / _98) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / _98
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _156 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _156 + 68] = mem[idx + _150 + 32]
                idx = idx + 32
                continue 
            mem[_156 + 94] = 0
            revert with memory
              from mem[64]
               len _156 + -mem[64] + 100
        if (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond) and poolInfo[idx].field_256 > -1 / (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond):
            revert with 0, 17
        if not (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond):
            revert with 0, 18
        if (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond) != poolInfo[idx].field_256:
            revert with 0, 'SafeMath: multiplication overflow'
        _120 = mem[64]
        mem[64] = mem[64] + 64
        mem[_120] = 26
        mem[_120 + 32] = 'SafeMath: division by zero'
        if not totalAllocPoint:
            _124 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _124 + 68] = mem[idx + _120 + 32]
                idx = idx + 32
                continue 
            mem[_124 + 94] = 0
            revert with memory
              from mem[64]
               len _124 + -mem[64] + 100
        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = this.address
        mem[mem[64] + 36] = (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint
        require ext_code.size(brushAddress)
        call brushAddress.mint(address rg1, uint256 rg2) with:
             gas gas_remaining wei
            args this.address, (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if not (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint:
            _149 = mem[64]
            mem[64] = mem[64] + 64
            mem[_149] = 26
            mem[_149 + 32] = 'SafeMath: division by zero'
            if _98:
                if poolInfo[idx].field_768 > !(0 / _98):
                    revert with 0, 17
                if poolInfo[idx].field_768 + (0 / _98) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 0 / _98
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _155 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _155 + 68] = mem[idx + _149 + 32]
                idx = idx + 32
                continue 
            mem[_155 + 94] = 0
            revert with memory
              from mem[64]
               len _155 + -mem[64] + 100
        if (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint and 10^12 > -1 / (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint:
            revert with 0, 17
        if not (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint:
            revert with 0, 18
        if 10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        _165 = mem[64]
        mem[64] = mem[64] + 64
        mem[_165] = 26
        mem[_165 + 32] = 'SafeMath: division by zero'
        if _98:
            if poolInfo[idx].field_768 > !(10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / _98):
                revert with 0, 17
            if poolInfo[idx].field_768 + (10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / _98) < poolInfo[idx].field_768:
                revert with 0, 'SafeMath: addition overflow'
            poolInfo[idx].field_768 += 10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / _98
            poolInfo[idx].field_512 = block.timestamp
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _172 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 26
        idx = 0
        while idx < 26:
            mem[idx + _172 + 68] = mem[idx + _165 + 32]
            idx = idx + 32
            continue 
        mem[_172 + 94] = 0
        revert with memory
          from mem[64]
           len _172 + -mem[64] + 100
}

function setBrushPerSecondEmissionRate(uint256 arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 6
        if block.timestamp <= poolInfo[idx].field_512:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(poolInfo[idx].field_0)
        staticcall poolInfo[idx].field_0.balanceOf(address rg1) with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _99 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _100 = mem[_99]
        if not mem[_99]:
            poolInfo[idx].field_512 = block.timestamp
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if not poolInfo[idx].field_256:
            poolInfo[idx].field_512 = block.timestamp
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _101 = mem[64]
        mem[64] = mem[64] + 64
        mem[_101] = 30
        mem[_101 + 32] = 'SafeMath: subtraction overflow'
        if poolInfo[idx].field_512 > block.timestamp:
            _102 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _102 + 68] = mem[idx + _101 + 32]
                idx = idx + 32
                continue 
            mem[_102 + 98] = 0
            revert with memory
              from mem[64]
               len _102 + -mem[64] + 100
        if block.timestamp < poolInfo[idx].field_512:
            revert with 0, 17
        if not block.timestamp - poolInfo[idx].field_512:
            _108 = mem[64]
            mem[64] = mem[64] + 64
            mem[_108] = 26
            mem[_108 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _110 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _110 + 68] = mem[idx + _108 + 32]
                    idx = idx + 32
                    continue 
                mem[_110 + 94] = 0
                revert with memory
                  from mem[64]
                   len _110 + -mem[64] + 100
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0 / totalAllocPoint
            require ext_code.size(brushAddress)
            call brushAddress.mint(address rg1, uint256 rg2) with:
                 gas gas_remaining wei
                args this.address, 0 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not 0 / totalAllocPoint:
                _127 = mem[64]
                mem[64] = mem[64] + 64
                mem[_127] = 26
                mem[_127 + 32] = 'SafeMath: division by zero'
                if _100:
                    if poolInfo[idx].field_768 > !(0 / _100):
                        revert with 0, 17
                    if poolInfo[idx].field_768 + (0 / _100) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / _100
                    poolInfo[idx].field_512 = block.timestamp
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _131 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _131 + 68] = mem[idx + _127 + 32]
                    idx = idx + 32
                    continue 
                mem[_131 + 94] = 0
                revert with memory
                  from mem[64]
                   len _131 + -mem[64] + 100
            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                revert with 0, 17
            if not 0 / totalAllocPoint:
                revert with 0, 18
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _139 = mem[64]
            mem[64] = mem[64] + 64
            mem[_139] = 26
            mem[_139 + 32] = 'SafeMath: division by zero'
            if _100:
                if poolInfo[idx].field_768 > !(10^12 * 0 / totalAllocPoint / _100):
                    revert with 0, 17
                if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / _100) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / _100
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _144 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _144 + 68] = mem[idx + _139 + 32]
                idx = idx + 32
                continue 
            mem[_144 + 94] = 0
            revert with memory
              from mem[64]
               len _144 + -mem[64] + 100
        if block.timestamp - poolInfo[idx].field_512 and brushPerSecond > -1 / block.timestamp - poolInfo[idx].field_512:
            revert with 0, 17
        if not block.timestamp - poolInfo[idx].field_512:
            revert with 0, 18
        if (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond) / block.timestamp - poolInfo[idx].field_512 != brushPerSecond:
            revert with 0, 'SafeMath: multiplication overflow'
        if not (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond):
            _112 = mem[64]
            mem[64] = mem[64] + 64
            mem[_112] = 26
            mem[_112 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _116 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _116 + 68] = mem[idx + _112 + 32]
                    idx = idx + 32
                    continue 
                mem[_116 + 94] = 0
                revert with memory
                  from mem[64]
                   len _116 + -mem[64] + 100
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0 / totalAllocPoint
            require ext_code.size(brushAddress)
            call brushAddress.mint(address rg1, uint256 rg2) with:
                 gas gas_remaining wei
                args this.address, 0 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not 0 / totalAllocPoint:
                _138 = mem[64]
                mem[64] = mem[64] + 64
                mem[_138] = 26
                mem[_138 + 32] = 'SafeMath: division by zero'
                if _100:
                    if poolInfo[idx].field_768 > !(0 / _100):
                        revert with 0, 17
                    if poolInfo[idx].field_768 + (0 / _100) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / _100
                    poolInfo[idx].field_512 = block.timestamp
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _143 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _143 + 68] = mem[idx + _138 + 32]
                    idx = idx + 32
                    continue 
                mem[_143 + 94] = 0
                revert with memory
                  from mem[64]
                   len _143 + -mem[64] + 100
            if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                revert with 0, 17
            if not 0 / totalAllocPoint:
                revert with 0, 18
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _152 = mem[64]
            mem[64] = mem[64] + 64
            mem[_152] = 26
            mem[_152 + 32] = 'SafeMath: division by zero'
            if _100:
                if poolInfo[idx].field_768 > !(10^12 * 0 / totalAllocPoint / _100):
                    revert with 0, 17
                if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / _100) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / _100
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _158 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _158 + 68] = mem[idx + _152 + 32]
                idx = idx + 32
                continue 
            mem[_158 + 94] = 0
            revert with memory
              from mem[64]
               len _158 + -mem[64] + 100
        if (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond) and poolInfo[idx].field_256 > -1 / (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond):
            revert with 0, 17
        if not (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond):
            revert with 0, 18
        if (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond) != poolInfo[idx].field_256:
            revert with 0, 'SafeMath: multiplication overflow'
        _122 = mem[64]
        mem[64] = mem[64] + 64
        mem[_122] = 26
        mem[_122 + 32] = 'SafeMath: division by zero'
        if not totalAllocPoint:
            _126 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _126 + 68] = mem[idx + _122 + 32]
                idx = idx + 32
                continue 
            mem[_126 + 94] = 0
            revert with memory
              from mem[64]
               len _126 + -mem[64] + 100
        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = this.address
        mem[mem[64] + 36] = (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint
        require ext_code.size(brushAddress)
        call brushAddress.mint(address rg1, uint256 rg2) with:
             gas gas_remaining wei
            args this.address, (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if not (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint:
            _151 = mem[64]
            mem[64] = mem[64] + 64
            mem[_151] = 26
            mem[_151 + 32] = 'SafeMath: division by zero'
            if _100:
                if poolInfo[idx].field_768 > !(0 / _100):
                    revert with 0, 17
                if poolInfo[idx].field_768 + (0 / _100) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 0 / _100
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _157 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _157 + 68] = mem[idx + _151 + 32]
                idx = idx + 32
                continue 
            mem[_157 + 94] = 0
            revert with memory
              from mem[64]
               len _157 + -mem[64] + 100
        if (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint and 10^12 > -1 / (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint:
            revert with 0, 17
        if not (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint:
            revert with 0, 18
        if 10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        _167 = mem[64]
        mem[64] = mem[64] + 64
        mem[_167] = 26
        mem[_167 + 32] = 'SafeMath: division by zero'
        if _100:
            if poolInfo[idx].field_768 > !(10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / _100):
                revert with 0, 17
            if poolInfo[idx].field_768 + (10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / _100) < poolInfo[idx].field_768:
                revert with 0, 'SafeMath: addition overflow'
            poolInfo[idx].field_768 += 10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / _100
            poolInfo[idx].field_512 = block.timestamp
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _174 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 26
        idx = 0
        while idx < 26:
            mem[idx + _174 + 68] = mem[idx + _167 + 32]
            idx = idx + 32
            continue 
        mem[_174 + 94] = 0
        revert with memory
          from mem[64]
           len _174 + -mem[64] + 100
    brushPerSecond = arg1
}

function set(uint256 arg1, uint256 arg2, bool arg3) payable {
    mem[64] = 96
    require calldata.size - 4 >= 96
    require arg3 == arg3
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 >= poolInfo.length:
        revert with 0, 50
    mem[0] = poolInfo[arg1].field_0
    mem[32] = 12
    if not stor12[stor6[arg1].field_0]:
        revert with 0, 'pid does not yet exist'
    if arg3:
        idx = 0
        while idx < poolInfo.length:
            mem[0] = 6
            if block.timestamp <= poolInfo[idx].field_512:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(poolInfo[idx].field_0)
            staticcall poolInfo[idx].field_0.balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _129 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _131 = mem[_129]
            if not mem[_129]:
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if not poolInfo[idx].field_256:
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _135 = mem[64]
            mem[64] = mem[64] + 64
            mem[_135] = 30
            mem[_135 + 32] = 'SafeMath: subtraction overflow'
            if poolInfo[idx].field_512 > block.timestamp:
                _137 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _137 + 68] = mem[idx + _135 + 32]
                    idx = idx + 32
                    continue 
                mem[_137 + 98] = 0
                revert with memory
                  from mem[64]
                   len _137 + -mem[64] + 100
            if block.timestamp < poolInfo[idx].field_512:
                revert with 0, 17
            if not block.timestamp - poolInfo[idx].field_512:
                _145 = mem[64]
                mem[64] = mem[64] + 64
                mem[_145] = 26
                mem[_145 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _147 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _147 + 68] = mem[idx + _145 + 32]
                        idx = idx + 32
                        continue 
                    mem[_147 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _147 + -mem[64] + 100
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(brushAddress)
                call brushAddress.mint(address rg1, uint256 rg2) with:
                     gas gas_remaining wei
                    args this.address, 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _164 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_164] = 26
                    mem[_164 + 32] = 'SafeMath: division by zero'
                    if _131:
                        if poolInfo[idx].field_768 > !(0 / _131):
                            revert with 0, 17
                        if poolInfo[idx].field_768 + (0 / _131) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / _131
                        poolInfo[idx].field_512 = block.timestamp
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    _168 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _168 + 68] = mem[idx + _164 + 32]
                        idx = idx + 32
                        continue 
                    mem[_168 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _168 + -mem[64] + 100
                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                    revert with 0, 17
                if not 0 / totalAllocPoint:
                    revert with 0, 18
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _176 = mem[64]
                mem[64] = mem[64] + 64
                mem[_176] = 26
                mem[_176 + 32] = 'SafeMath: division by zero'
                if _131:
                    if poolInfo[idx].field_768 > !(10^12 * 0 / totalAllocPoint / _131):
                        revert with 0, 17
                    if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / _131) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / _131
                    poolInfo[idx].field_512 = block.timestamp
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _181 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _181 + 68] = mem[idx + _176 + 32]
                    idx = idx + 32
                    continue 
                mem[_181 + 94] = 0
                revert with memory
                  from mem[64]
                   len _181 + -mem[64] + 100
            if block.timestamp - poolInfo[idx].field_512 and brushPerSecond > -1 / block.timestamp - poolInfo[idx].field_512:
                revert with 0, 17
            if not block.timestamp - poolInfo[idx].field_512:
                revert with 0, 18
            if (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond) / block.timestamp - poolInfo[idx].field_512 != brushPerSecond:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond):
                _149 = mem[64]
                mem[64] = mem[64] + 64
                mem[_149] = 26
                mem[_149 + 32] = 'SafeMath: division by zero'
                if not totalAllocPoint:
                    _153 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _153 + 68] = mem[idx + _149 + 32]
                        idx = idx + 32
                        continue 
                    mem[_153 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _153 + -mem[64] + 100
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(brushAddress)
                call brushAddress.mint(address rg1, uint256 rg2) with:
                     gas gas_remaining wei
                    args this.address, 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _175 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_175] = 26
                    mem[_175 + 32] = 'SafeMath: division by zero'
                    if _131:
                        if poolInfo[idx].field_768 > !(0 / _131):
                            revert with 0, 17
                        if poolInfo[idx].field_768 + (0 / _131) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / _131
                        poolInfo[idx].field_512 = block.timestamp
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    _180 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _180 + 68] = mem[idx + _175 + 32]
                        idx = idx + 32
                        continue 
                    mem[_180 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _180 + -mem[64] + 100
                if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
                    revert with 0, 17
                if not 0 / totalAllocPoint:
                    revert with 0, 18
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _189 = mem[64]
                mem[64] = mem[64] + 64
                mem[_189] = 26
                mem[_189 + 32] = 'SafeMath: division by zero'
                if _131:
                    if poolInfo[idx].field_768 > !(10^12 * 0 / totalAllocPoint / _131):
                        revert with 0, 17
                    if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / _131) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / _131
                    poolInfo[idx].field_512 = block.timestamp
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _195 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _195 + 68] = mem[idx + _189 + 32]
                    idx = idx + 32
                    continue 
                mem[_195 + 94] = 0
                revert with memory
                  from mem[64]
                   len _195 + -mem[64] + 100
            if (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond) and poolInfo[idx].field_256 > -1 / (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond):
                revert with 0, 17
            if not (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond):
                revert with 0, 18
            if (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / (block.timestamp * brushPerSecond) - (poolInfo[idx].field_512 * brushPerSecond) != poolInfo[idx].field_256:
                revert with 0, 'SafeMath: multiplication overflow'
            _159 = mem[64]
            mem[64] = mem[64] + 64
            mem[_159] = 26
            mem[_159 + 32] = 'SafeMath: division by zero'
            if not totalAllocPoint:
                _163 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _163 + 68] = mem[idx + _159 + 32]
                    idx = idx + 32
                    continue 
                mem[_163 + 94] = 0
                revert with memory
                  from mem[64]
                   len _163 + -mem[64] + 100
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint
            require ext_code.size(brushAddress)
            call brushAddress.mint(address rg1, uint256 rg2) with:
                 gas gas_remaining wei
                args this.address, (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint:
                _188 = mem[64]
                mem[64] = mem[64] + 64
                mem[_188] = 26
                mem[_188 + 32] = 'SafeMath: division by zero'
                if _131:
                    if poolInfo[idx].field_768 > !(0 / _131):
                        revert with 0, 17
                    if poolInfo[idx].field_768 + (0 / _131) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / _131
                    poolInfo[idx].field_512 = block.timestamp
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _194 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _194 + 68] = mem[idx + _188 + 32]
                    idx = idx + 32
                    continue 
                mem[_194 + 94] = 0
                revert with memory
                  from mem[64]
                   len _194 + -mem[64] + 100
            if (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint and 10^12 > -1 / (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint:
                revert with 0, 17
            if not (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint:
                revert with 0, 18
            if 10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _204 = mem[64]
            mem[64] = mem[64] + 64
            mem[_204] = 26
            mem[_204 + 32] = 'SafeMath: division by zero'
            if _131:
                if poolInfo[idx].field_768 > !(10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / _131):
                    revert with 0, 17
                if poolInfo[idx].field_768 + (10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / _131) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * (block.timestamp * brushPerSecond * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * brushPerSecond * poolInfo[idx].field_256) / totalAllocPoint / _131
                poolInfo[idx].field_512 = block.timestamp
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _211 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _211 + 68] = mem[idx + _204 + 32]
                idx = idx + 32
                continue 
            mem[_211 + 94] = 0
            revert with memory
              from mem[64]
               len _211 + -mem[64] + 100
    if arg1 >= poolInfo.length:
        revert with 0, 50
    if poolInfo[arg1].field_256 > totalAllocPoint:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if totalAllocPoint < poolInfo[arg1].field_256:
        revert with 0, 17
    if totalAllocPoint - poolInfo[arg1].field_256 > !arg2:
        revert with 0, 17
    if arg2 < 0:
        revert with 0, 'SafeMath: addition overflow'
    totalAllocPoint = totalAllocPoint - poolInfo[arg1].field_256 + arg2
    if arg1 >= poolInfo.length:
        revert with 0, 50
    poolInfo[arg1].field_256 = arg2
}

function pendingBrush(uint256 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if arg1 >= poolInfo.length:
        revert with 0, 50
    require ext_code.size(poolInfo[arg1].field_0)
    staticcall poolInfo[arg1].field_0.balanceOf(address rg1) with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if block.timestamp <= poolInfo[arg1].field_512:
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < userInfo[arg1][address(arg2)].field_256:
                revert with 0, 17
            return (-userInfo[arg1][address(arg2)].field_256 / 2)
        if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][address(arg2)].field_0:
            revert with 0, 17
        if not userInfo[arg1][address(arg2)].field_0:
            revert with 0, 18
        if userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: multiplication overflow'
        if userInfo[arg1][address(arg2)].field_256 > userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12 < userInfo[arg1][address(arg2)].field_256:
            revert with 0, 17
        return ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2)
    if not ext_call.return_data[0]:
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < userInfo[arg1][address(arg2)].field_256:
                revert with 0, 17
            return (-userInfo[arg1][address(arg2)].field_256 / 2)
        if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 > -1 / userInfo[arg1][address(arg2)].field_0:
            revert with 0, 17
        if not userInfo[arg1][address(arg2)].field_0:
            revert with 0, 18
        if userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: multiplication overflow'
        if userInfo[arg1][address(arg2)].field_256 > userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12 < userInfo[arg1][address(arg2)].field_256:
            revert with 0, 17
        return ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2)
    if poolInfo[arg1].field_512 > block.timestamp:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if block.timestamp < poolInfo[arg1].field_512:
        revert with 0, 17
    if not block.timestamp - poolInfo[arg1].field_512:
        if not totalAllocPoint:
            revert with 0, 'SafeMath: division by zero', 0
        if not 0 / totalAllocPoint:
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero', 0
            if poolInfo[arg1].field_768 > !(0 / ext_call.return_data[0]):
                revert with 0, 17
            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < userInfo[arg1][address(arg2)].field_256:
                    revert with 0, 17
                return (-userInfo[arg1][address(arg2)].field_256 / 2)
            if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) > -1 / userInfo[arg1][address(arg2)].field_0:
                revert with 0, 17
            if not userInfo[arg1][address(arg2)].field_0:
                revert with 0, 18
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                revert with 0, 'SafeMath: multiplication overflow'
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12 < userInfo[arg1][address(arg2)].field_256:
                revert with 0, 17
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2)
        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
            revert with 0, 17
        if not 0 / totalAllocPoint:
            revert with 0, 18
        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero', 0
        if poolInfo[arg1].field_768 > !(10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
            revert with 0, 17
        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < userInfo[arg1][address(arg2)].field_256:
                revert with 0, 17
            return (-userInfo[arg1][address(arg2)].field_256 / 2)
        if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) > -1 / userInfo[arg1][address(arg2)].field_0:
            revert with 0, 17
        if not userInfo[arg1][address(arg2)].field_0:
            revert with 0, 18
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
            revert with 0, 'SafeMath: multiplication overflow'
        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12 < userInfo[arg1][address(arg2)].field_256:
            revert with 0, 17
        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2)
    if block.timestamp - poolInfo[arg1].field_512 and brushPerSecond > -1 / block.timestamp - poolInfo[arg1].field_512:
        revert with 0, 17
    if not block.timestamp - poolInfo[arg1].field_512:
        revert with 0, 18
    if (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond) / block.timestamp - poolInfo[arg1].field_512 != brushPerSecond:
        revert with 0, 'SafeMath: multiplication overflow'
    if not (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond):
        if not totalAllocPoint:
            revert with 0, 'SafeMath: division by zero', 0
        if not 0 / totalAllocPoint:
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero', 0
            if poolInfo[arg1].field_768 > !(0 / ext_call.return_data[0]):
                revert with 0, 17
            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < userInfo[arg1][address(arg2)].field_256:
                    revert with 0, 17
                return (-userInfo[arg1][address(arg2)].field_256 / 2)
            if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) > -1 / userInfo[arg1][address(arg2)].field_0:
                revert with 0, 17
            if not userInfo[arg1][address(arg2)].field_0:
                revert with 0, 18
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                revert with 0, 'SafeMath: multiplication overflow'
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12 < userInfo[arg1][address(arg2)].field_256:
                revert with 0, 17
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2)
        if 0 / totalAllocPoint and 10^12 > -1 / 0 / totalAllocPoint:
            revert with 0, 17
        if not 0 / totalAllocPoint:
            revert with 0, 18
        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero', 0
        if poolInfo[arg1].field_768 > !(10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
            revert with 0, 17
        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < userInfo[arg1][address(arg2)].field_256:
                revert with 0, 17
            return (-userInfo[arg1][address(arg2)].field_256 / 2)
        if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) > -1 / userInfo[arg1][address(arg2)].field_0:
            revert with 0, 17
        if not userInfo[arg1][address(arg2)].field_0:
            revert with 0, 18
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
            revert with 0, 'SafeMath: multiplication overflow'
        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12 < userInfo[arg1][address(arg2)].field_256:
            revert with 0, 17
        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2)
    if (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond) and poolInfo[arg1].field_256 > -1 / (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond):
        revert with 0, 17
    if not (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond):
        revert with 0, 18
    if (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / (block.timestamp * brushPerSecond) - (poolInfo[arg1].field_512 * brushPerSecond) != poolInfo[arg1].field_256:
        revert with 0, 'SafeMath: multiplication overflow'
    if not totalAllocPoint:
        revert with 0, 'SafeMath: division by zero', 0
    if not (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint:
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero', 0
        if poolInfo[arg1].field_768 > !(0 / ext_call.return_data[0]):
            revert with 0, 17
        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < userInfo[arg1][address(arg2)].field_256:
                revert with 0, 17
            return (-userInfo[arg1][address(arg2)].field_256 / 2)
        if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) > -1 / userInfo[arg1][address(arg2)].field_0:
            revert with 0, 17
        if not userInfo[arg1][address(arg2)].field_0:
            revert with 0, 18
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
            revert with 0, 'SafeMath: multiplication overflow'
        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12 < userInfo[arg1][address(arg2)].field_256:
            revert with 0, 17
        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2)
    if (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint and 10^12 > -1 / (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint:
        revert with 0, 17
    if not (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint:
        revert with 0, 18
    if 10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
        revert with 0, 'SafeMath: multiplication overflow'
    if not ext_call.return_data[0]:
        revert with 0, 'SafeMath: division by zero', 0
    if poolInfo[arg1].field_768 > !(10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]):
        revert with 0, 17
    if poolInfo[arg1].field_768 + (10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
        revert with 0, 'SafeMath: addition overflow'
    if not userInfo[arg1][address(arg2)].field_0:
        if userInfo[arg1][address(arg2)].field_256 > 0:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if 0 < userInfo[arg1][address(arg2)].field_256:
            revert with 0, 17
        return (-userInfo[arg1][address(arg2)].field_256 / 2)
    if userInfo[arg1][address(arg2)].field_0 and poolInfo[arg1].field_768 + (10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) > -1 / userInfo[arg1][address(arg2)].field_0:
        revert with 0, 17
    if not userInfo[arg1][address(arg2)].field_0:
        revert with 0, 18
    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]):
        revert with 0, 'SafeMath: multiplication overflow'
    if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12 < userInfo[arg1][address(arg2)].field_256:
        revert with 0, 17
    return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.timestamp * brushPerSecond * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * brushPerSecond * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256 / 2)
}

function buyBackAndBurn(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 > 0
    mem[0] = arg1
    mem[32] = 10
    require arg2 <= maxBurnAndBuyBackAmounts[address(arg1)]
    require ext_code.size(arg1)
    staticcall arg1.token0() with:
            gas gas_remaining wei
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(arg1)
    staticcall arg1.token1() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if 60 > !block.timestamp:
        revert with 0, 17
    mem[(2 * ceil32(return_data.size)) + 132] = address(ext_call.return_data[0])
    mem[(2 * ceil32(return_data.size)) + 164] = arg2
    mem[(2 * ceil32(return_data.size)) + 196] = 0
    mem[(2 * ceil32(return_data.size)) + 228] = 0
    mem[(2 * ceil32(return_data.size)) + 260] = this.address
    mem[(2 * ceil32(return_data.size)) + 292] = block.timestamp + 60
    require ext_code.size(routerAddress)
    call routerAddress.removeLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, address rg6, uint256 rg7) with:
         gas gas_remaining wei
        args address(ext_call.return_data[0]), address(ext_call.return_data[0]), arg2, 0, 0, address(this.address), block.timestamp + 60
    mem[(2 * ceil32(return_data.size)) + 96 len 64] = ext_call.return_data[0 len 64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 64
    if 10000 > !block.timestamp:
        revert with 0, 17
    if brushAddress == address(ext_call.return_data[0]):
        mem[(4 * ceil32(return_data.size)) + 128] = address(ext_call.return_data[0])
        mem[(4 * ceil32(return_data.size)) + 160] = brushAddress
        if brushAddress == address(ext_call.return_data[0]):
            if ext_call.return_data[32] > -1:
                revert with 0, 17
            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
            mem[(4 * ceil32(return_data.size)) + 228] = 0
            mem[(4 * ceil32(return_data.size)) + 260] = 160
            mem[(4 * ceil32(return_data.size)) + 356] = 2
            idx = 0
            s = (4 * ceil32(return_data.size)) + 388
            t = (4 * ceil32(return_data.size)) + 128
            while idx < 2:
                mem[s] = mem[t + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(4 * ceil32(return_data.size)) + 292] = this.address
            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
            require ext_code.size(routerAddress)
            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (6 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _2617 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
            _2648 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                revert with 0, 65
            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                revert with 0, 65
            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
            require return_data.size >= _2617 + (32 * _2648) + 32
            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2648] = mem[(4 * ceil32(return_data.size)) + _2617 + 224 len 32 * _2648]
            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                revert with 0, 17
            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
            if 1 >= _2648:
                revert with 0, 50
        else:
            if wftmAddress == address(ext_call.return_data[0]):
                if ext_call.return_data[32] > -1:
                    revert with 0, 17
                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                mem[(4 * ceil32(return_data.size)) + 228] = 0
                mem[(4 * ceil32(return_data.size)) + 260] = 160
                mem[(4 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 388
                t = (4 * ceil32(return_data.size)) + 128
                while idx < 2:
                    mem[s] = mem[t + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                require ext_code.size(routerAddress)
                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _2615 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _2646 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                require return_data.size >= _2615 + (32 * _2646) + 32
                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2646] = mem[(4 * ceil32(return_data.size)) + _2615 + 224 len 32 * _2646]
                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                    revert with 0, 17
                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                if 1 >= _2646:
                    revert with 0, 50
            else:
                if ext_call.return_data[0] > -1:
                    revert with 0, 17
                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                mem[(4 * ceil32(return_data.size)) + 228] = 0
                mem[(4 * ceil32(return_data.size)) + 260] = 160
                mem[(4 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 388
                t = (4 * ceil32(return_data.size)) + 128
                while idx < 2:
                    mem[s] = mem[t + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                require ext_code.size(routerAddress)
                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _2616 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _2647 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                require return_data.size >= _2616 + (32 * _2647) + 32
                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2647] = mem[(4 * ceil32(return_data.size)) + _2616 + 224 len 32 * _2647]
                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                    revert with 0, 17
                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                if 1 >= _2647:
                    revert with 0, 50
        require ext_code.size(brushAddress)
        call brushAddress.burn(uint256 rg1) with:
             gas gas_remaining wei
            args mem[(6 * ceil32(return_data.size)) + 256]
    else:
        if brushAddress == address(ext_call.return_data[0]):
            mem[(4 * ceil32(return_data.size)) + 128] = address(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 160] = brushAddress
            if brushAddress == address(ext_call.return_data[0]):
                if brushAddress != address(ext_call.return_data[0]):
                    if wftmAddress == address(ext_call.return_data[0]):
                        if ext_call.return_data[32] > -1:
                            revert with 0, 17
                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (4 * ceil32(return_data.size)) + 388
                        t = (4 * ceil32(return_data.size)) + 128
                        while idx < 2:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (6 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _2618 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                        _2649 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                            revert with 0, 65
                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                        require return_data.size >= _2618 + (32 * _2649) + 32
                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2649] = mem[(4 * ceil32(return_data.size)) + _2618 + 224 len 32 * _2649]
                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                            revert with 0, 17
                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                        if 1 >= _2649:
                            revert with 0, 50
                    else:
                        if ext_call.return_data[0] > -1:
                            revert with 0, 17
                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (4 * ceil32(return_data.size)) + 388
                        t = (4 * ceil32(return_data.size)) + 128
                        while idx < 2:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (6 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _2619 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                        _2650 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                            revert with 0, 65
                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                        require return_data.size >= _2619 + (32 * _2650) + 32
                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2650] = mem[(4 * ceil32(return_data.size)) + _2619 + 224 len 32 * _2650]
                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                            revert with 0, 17
                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                        if 1 >= _2650:
                            revert with 0, 50
                else:
                    if brushAddress == address(ext_call.return_data[0]):
                        if ext_call.return_data[32] > -1:
                            revert with 0, 17
                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (4 * ceil32(return_data.size)) + 388
                        t = (4 * ceil32(return_data.size)) + 128
                        while idx < 2:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (6 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _2620 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                        _2651 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                            revert with 0, 65
                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                        require return_data.size >= _2620 + (32 * _2651) + 32
                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2651] = mem[(4 * ceil32(return_data.size)) + _2620 + 224 len 32 * _2651]
                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                            revert with 0, 17
                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                        if 1 >= _2651:
                            revert with 0, 50
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if ext_call.return_data[0] > -1:
                                revert with 0, 17
                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 388
                            t = (4 * ceil32(return_data.size)) + 128
                            while idx < 2:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _2621 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                            _2652 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                revert with 0, 65
                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                revert with 0, 65
                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                            require return_data.size >= _2621 + (32 * _2652) + 32
                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2652] = mem[(4 * ceil32(return_data.size)) + _2621 + 224 len 32 * _2652]
                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                revert with 0, 17
                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                            if 1 >= _2652:
                                revert with 0, 50
                        else:
                            if wftmAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2622 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _2653 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _2622 + (32 * _2653) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2653] = mem[(4 * ceil32(return_data.size)) + _2622 + 224 len 32 * _2653]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                if 1 >= _2653:
                                    revert with 0, 50
                            else:
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2623 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _2654 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _2623 + (32 * _2654) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2654] = mem[(4 * ceil32(return_data.size)) + _2623 + 224 len 32 * _2654]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                if 1 >= _2654:
                                    revert with 0, 50
            else:
                if brushAddress == address(ext_call.return_data[0]):
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if ext_call.return_data[32] > -1:
                                revert with 0, 17
                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 388
                            t = (4 * ceil32(return_data.size)) + 128
                            while idx < 2:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _2624 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                            _2655 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                revert with 0, 65
                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                revert with 0, 65
                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                            require return_data.size >= _2624 + (32 * _2655) + 32
                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2655] = mem[(4 * ceil32(return_data.size)) + _2624 + 224 len 32 * _2655]
                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                revert with 0, 17
                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                            if 1 >= _2655:
                                revert with 0, 50
                        else:
                            if ext_call.return_data[0] > -1:
                                revert with 0, 17
                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 388
                            t = (4 * ceil32(return_data.size)) + 128
                            while idx < 2:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _2625 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                            _2656 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                revert with 0, 65
                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                revert with 0, 65
                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                            require return_data.size >= _2625 + (32 * _2656) + 32
                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2656] = mem[(4 * ceil32(return_data.size)) + _2625 + 224 len 32 * _2656]
                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                revert with 0, 17
                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                            if 1 >= _2656:
                                revert with 0, 50
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if ext_call.return_data[32] > -1:
                                revert with 0, 17
                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 388
                            t = (4 * ceil32(return_data.size)) + 128
                            while idx < 2:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _2626 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                            _2657 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                revert with 0, 65
                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                revert with 0, 65
                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                            require return_data.size >= _2626 + (32 * _2657) + 32
                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2657] = mem[(4 * ceil32(return_data.size)) + _2626 + 224 len 32 * _2657]
                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                revert with 0, 17
                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                            if 1 >= _2657:
                                revert with 0, 50
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2627 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _2658 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _2627 + (32 * _2658) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2658] = mem[(4 * ceil32(return_data.size)) + _2627 + 224 len 32 * _2658]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                if 1 >= _2658:
                                    revert with 0, 50
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _2628 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _2659 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                    require return_data.size >= _2628 + (32 * _2659) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2659] = mem[(4 * ceil32(return_data.size)) + _2628 + 224 len 32 * _2659]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _2659:
                                        revert with 0, 50
                                else:
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _2629 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _2660 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _2629 + (32 * _2660) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2660] = mem[(4 * ceil32(return_data.size)) + _2629 + 224 len 32 * _2660]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _2660:
                                        revert with 0, 50
                else:
                    if wftmAddress == address(ext_call.return_data[0]):
                        if brushAddress != address(ext_call.return_data[0]):
                            if wftmAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2630 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _2661 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _2630 + (32 * _2661) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2661] = mem[(4 * ceil32(return_data.size)) + _2630 + 224 len 32 * _2661]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                if 1 >= _2661:
                                    revert with 0, 50
                            else:
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2631 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _2662 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _2631 + (32 * _2662) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2662] = mem[(4 * ceil32(return_data.size)) + _2631 + 224 len 32 * _2662]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                if 1 >= _2662:
                                    revert with 0, 50
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2632 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _2663 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _2632 + (32 * _2663) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2663] = mem[(4 * ceil32(return_data.size)) + _2632 + 224 len 32 * _2663]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                if 1 >= _2663:
                                    revert with 0, 50
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _2633 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _2664 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _2633 + (32 * _2664) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2664] = mem[(4 * ceil32(return_data.size)) + _2633 + 224 len 32 * _2664]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _2664:
                                        revert with 0, 50
                                else:
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _2634 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _2665 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _2634 + (32 * _2665) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2665] = mem[(4 * ceil32(return_data.size)) + _2634 + 224 len 32 * _2665]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _2665:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _2635 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _2666 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _2635 + (32 * _2666) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2666] = mem[(4 * ceil32(return_data.size)) + _2635 + 224 len 32 * _2666]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _2666:
                                            revert with 0, 50
                    else:
                        if brushAddress != address(ext_call.return_data[0]):
                            if wftmAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2636 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _2667 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _2636 + (32 * _2667) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2667] = mem[(4 * ceil32(return_data.size)) + _2636 + 224 len 32 * _2667]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                if 1 >= _2667:
                                    revert with 0, 50
                            else:
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2637 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _2668 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _2637 + (32 * _2668) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2668] = mem[(4 * ceil32(return_data.size)) + _2637 + 224 len 32 * _2668]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                if 1 >= _2668:
                                    revert with 0, 50
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2638 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _2669 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _2638 + (32 * _2669) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2669] = mem[(4 * ceil32(return_data.size)) + _2638 + 224 len 32 * _2669]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                if 1 >= _2669:
                                    revert with 0, 50
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _2639 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _2670 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _2639 + (32 * _2670) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2670] = mem[(4 * ceil32(return_data.size)) + _2639 + 224 len 32 * _2670]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _2670:
                                        revert with 0, 50
                                else:
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _2640 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _2671 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _2640 + (32 * _2671) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2671] = mem[(4 * ceil32(return_data.size)) + _2640 + 224 len 32 * _2671]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _2671:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _2641 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _2672 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _2641 + (32 * _2672) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2672] = mem[(4 * ceil32(return_data.size)) + _2641 + 224 len 32 * _2672]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _2672:
                                            revert with 0, 50
            require ext_code.size(brushAddress)
            call brushAddress.burn(uint256 rg1) with:
                 gas gas_remaining wei
                args mem[(6 * ceil32(return_data.size)) + 256]
        else:
            mem[(4 * ceil32(return_data.size)) + 96] = 2
            mem[(4 * ceil32(return_data.size)) + 128] = address(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 160] = wftmAddress
            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            if wftmAddress == address(ext_call.return_data[0]):
                if wftmAddress == address(ext_call.return_data[0]):
                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 388
                    t = (4 * ceil32(return_data.size)) + 128
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2642 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _2673 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                        revert with 0, 65
                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                    require return_data.size >= _2642 + (32 * _2673) + 32
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2673] = mem[(4 * ceil32(return_data.size)) + _2642 + 224 len 32 * _2673]
                    if 1 >= _2673:
                        revert with 0, 50
                    _5012 = mem[(6 * ceil32(return_data.size)) + 256]
                    _5016 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_5016]:
                        revert with 0, 50
                    mem[_5016 + 32] = address(ext_call.return_data[0])
                    if 1 >= mem[_5016]:
                        revert with 0, 50
                    mem[_5016 + 64] = brushAddress
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5012:
                                        revert with 0, 17
                                    mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5016 + 100] = ext_call.return_data[32] + _5012
                                    mem[_5016 + 132] = 0
                                    mem[_5016 + 164] = 160
                                    mem[_5016 + 260] = mem[_5016]
                                    idx = 0
                                    s = _5016 + 292
                                    t = _5016 + 32
                                    while idx < mem[_5016]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5016 + 196] = this.address
                                    mem[_5016 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7480 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7624 = mem[_7480]
                                    require mem[_7480] <= test266151307()
                                    require _7480 + mem[_7480] + 31 < _7480 + return_data.size
                                    _7768 = mem[_7480 + mem[_7480]]
                                    if mem[_7480 + mem[_7480]] > test266151307():
                                        revert with 0, 65
                                    if _7480 + ceil32(return_data.size) + ceil32(32 * mem[_7480 + mem[_7480]]) + 1 > test266151307() or ceil32(32 * mem[_7480 + mem[_7480]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7480 + ceil32(return_data.size) + ceil32(32 * mem[_7480 + mem[_7480]]) + 1
                                    mem[_7480 + ceil32(return_data.size)] = _7768
                                    require return_data.size >= _7624 + (32 * _7768) + 32
                                    mem[_7480 + ceil32(return_data.size) + 32 len 32 * _7768] = mem[_7480 + _7624 + 32 len 32 * _7768]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7768:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7480 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5012:
                                        revert with 0, 17
                                    mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5016 + 100] = ext_call.return_data[0] + _5012
                                    mem[_5016 + 132] = 0
                                    mem[_5016 + 164] = 160
                                    mem[_5016 + 260] = mem[_5016]
                                    idx = 0
                                    s = _5016 + 292
                                    t = _5016 + 32
                                    while idx < mem[_5016]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5016 + 196] = this.address
                                    mem[_5016 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7481 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7625 = mem[_7481]
                                    require mem[_7481] <= test266151307()
                                    require _7481 + mem[_7481] + 31 < _7481 + return_data.size
                                    _7769 = mem[_7481 + mem[_7481]]
                                    if mem[_7481 + mem[_7481]] > test266151307():
                                        revert with 0, 65
                                    if _7481 + ceil32(return_data.size) + ceil32(32 * mem[_7481 + mem[_7481]]) + 1 > test266151307() or ceil32(32 * mem[_7481 + mem[_7481]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7481 + ceil32(return_data.size) + ceil32(32 * mem[_7481 + mem[_7481]]) + 1
                                    mem[_7481 + ceil32(return_data.size)] = _7769
                                    require return_data.size >= _7625 + (32 * _7769) + 32
                                    mem[_7481 + ceil32(return_data.size) + 32 len 32 * _7769] = mem[_7481 + _7625 + 32 len 32 * _7769]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7769:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7481 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5012:
                                        revert with 0, 17
                                    mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5016 + 100] = ext_call.return_data[32] + _5012
                                    mem[_5016 + 132] = 0
                                    mem[_5016 + 164] = 160
                                    mem[_5016 + 260] = mem[_5016]
                                    idx = 0
                                    s = _5016 + 292
                                    t = _5016 + 32
                                    while idx < mem[_5016]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5016 + 196] = this.address
                                    mem[_5016 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7482 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7626 = mem[_7482]
                                    require mem[_7482] <= test266151307()
                                    require _7482 + mem[_7482] + 31 < _7482 + return_data.size
                                    _7770 = mem[_7482 + mem[_7482]]
                                    if mem[_7482 + mem[_7482]] > test266151307():
                                        revert with 0, 65
                                    if _7482 + ceil32(return_data.size) + ceil32(32 * mem[_7482 + mem[_7482]]) + 1 > test266151307() or ceil32(32 * mem[_7482 + mem[_7482]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7482 + ceil32(return_data.size) + ceil32(32 * mem[_7482 + mem[_7482]]) + 1
                                    mem[_7482 + ceil32(return_data.size)] = _7770
                                    require return_data.size >= _7626 + (32 * _7770) + 32
                                    mem[_7482 + ceil32(return_data.size) + 32 len 32 * _7770] = mem[_7482 + _7626 + 32 len 32 * _7770]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7770:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7482 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5012:
                                            revert with 0, 17
                                        mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5016 + 100] = ext_call.return_data[0] + _5012
                                        mem[_5016 + 132] = 0
                                        mem[_5016 + 164] = 160
                                        mem[_5016 + 260] = mem[_5016]
                                        idx = 0
                                        s = _5016 + 292
                                        t = _5016 + 32
                                        while idx < mem[_5016]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5016 + 196] = this.address
                                        mem[_5016 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7483 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7627 = mem[_7483]
                                        require mem[_7483] <= test266151307()
                                        require _7483 + mem[_7483] + 31 < _7483 + return_data.size
                                        _7771 = mem[_7483 + mem[_7483]]
                                        if mem[_7483 + mem[_7483]] > test266151307():
                                            revert with 0, 65
                                        if _7483 + ceil32(return_data.size) + ceil32(32 * mem[_7483 + mem[_7483]]) + 1 > test266151307() or ceil32(32 * mem[_7483 + mem[_7483]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7483 + ceil32(return_data.size) + ceil32(32 * mem[_7483 + mem[_7483]]) + 1
                                        mem[_7483 + ceil32(return_data.size)] = _7771
                                        require return_data.size >= _7627 + (32 * _7771) + 32
                                        mem[_7483 + ceil32(return_data.size) + 32 len 32 * _7771] = mem[_7483 + _7627 + 32 len 32 * _7771]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _7771:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7483 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5012:
                                                revert with 0, 17
                                            mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5016 + 100] = ext_call.return_data[32] + _5012
                                            mem[_5016 + 132] = 0
                                            mem[_5016 + 164] = 160
                                            mem[_5016 + 260] = mem[_5016]
                                            idx = 0
                                            s = _5016 + 292
                                            t = _5016 + 32
                                            while idx < mem[_5016]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5016 + 196] = this.address
                                            mem[_5016 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7484 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7628 = mem[_7484]
                                            require mem[_7484] <= test266151307()
                                            require _7484 + mem[_7484] + 31 < _7484 + return_data.size
                                            _7772 = mem[_7484 + mem[_7484]]
                                            if mem[_7484 + mem[_7484]] > test266151307():
                                                revert with 0, 65
                                            if _7484 + ceil32(return_data.size) + ceil32(32 * mem[_7484 + mem[_7484]]) + 1 > test266151307() or ceil32(32 * mem[_7484 + mem[_7484]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7484 + ceil32(return_data.size) + ceil32(32 * mem[_7484 + mem[_7484]]) + 1
                                            mem[_7484 + ceil32(return_data.size)] = _7772
                                            require return_data.size >= _7628 + (32 * _7772) + 32
                                            mem[_7484 + ceil32(return_data.size) + 32 len 32 * _7772] = mem[_7484 + _7628 + 32 len 32 * _7772]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7772:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7484 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5012:
                                                revert with 0, 17
                                            mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5016 + 100] = ext_call.return_data[0] + _5012
                                            mem[_5016 + 132] = 0
                                            mem[_5016 + 164] = 160
                                            mem[_5016 + 260] = mem[_5016]
                                            idx = 0
                                            s = _5016 + 292
                                            t = _5016 + 32
                                            while idx < mem[_5016]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5016 + 196] = this.address
                                            mem[_5016 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7485 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7629 = mem[_7485]
                                            require mem[_7485] <= test266151307()
                                            require _7485 + mem[_7485] + 31 < _7485 + return_data.size
                                            _7773 = mem[_7485 + mem[_7485]]
                                            if mem[_7485 + mem[_7485]] > test266151307():
                                                revert with 0, 65
                                            if _7485 + ceil32(return_data.size) + ceil32(32 * mem[_7485 + mem[_7485]]) + 1 > test266151307() or ceil32(32 * mem[_7485 + mem[_7485]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7485 + ceil32(return_data.size) + ceil32(32 * mem[_7485 + mem[_7485]]) + 1
                                            mem[_7485 + ceil32(return_data.size)] = _7773
                                            require return_data.size >= _7629 + (32 * _7773) + 32
                                            mem[_7485 + ceil32(return_data.size) + 32 len 32 * _7773] = mem[_7485 + _7629 + 32 len 32 * _7773]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7773:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7485 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5012:
                                        revert with 0, 17
                                    mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5016 + 100] = ext_call.return_data[32] + _5012
                                    mem[_5016 + 132] = 0
                                    mem[_5016 + 164] = 160
                                    mem[_5016 + 260] = mem[_5016]
                                    idx = 0
                                    s = _5016 + 292
                                    t = _5016 + 32
                                    while idx < mem[_5016]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5016 + 196] = this.address
                                    mem[_5016 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7486 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7630 = mem[_7486]
                                    require mem[_7486] <= test266151307()
                                    require _7486 + mem[_7486] + 31 < _7486 + return_data.size
                                    _7774 = mem[_7486 + mem[_7486]]
                                    if mem[_7486 + mem[_7486]] > test266151307():
                                        revert with 0, 65
                                    if _7486 + ceil32(return_data.size) + ceil32(32 * mem[_7486 + mem[_7486]]) + 1 > test266151307() or ceil32(32 * mem[_7486 + mem[_7486]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7486 + ceil32(return_data.size) + ceil32(32 * mem[_7486 + mem[_7486]]) + 1
                                    mem[_7486 + ceil32(return_data.size)] = _7774
                                    require return_data.size >= _7630 + (32 * _7774) + 32
                                    mem[_7486 + ceil32(return_data.size) + 32 len 32 * _7774] = mem[_7486 + _7630 + 32 len 32 * _7774]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7774:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7486 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5012:
                                        revert with 0, 17
                                    mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5016 + 100] = ext_call.return_data[0] + _5012
                                    mem[_5016 + 132] = 0
                                    mem[_5016 + 164] = 160
                                    mem[_5016 + 260] = mem[_5016]
                                    idx = 0
                                    s = _5016 + 292
                                    t = _5016 + 32
                                    while idx < mem[_5016]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5016 + 196] = this.address
                                    mem[_5016 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7487 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7631 = mem[_7487]
                                    require mem[_7487] <= test266151307()
                                    require _7487 + mem[_7487] + 31 < _7487 + return_data.size
                                    _7775 = mem[_7487 + mem[_7487]]
                                    if mem[_7487 + mem[_7487]] > test266151307():
                                        revert with 0, 65
                                    if _7487 + ceil32(return_data.size) + ceil32(32 * mem[_7487 + mem[_7487]]) + 1 > test266151307() or ceil32(32 * mem[_7487 + mem[_7487]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7487 + ceil32(return_data.size) + ceil32(32 * mem[_7487 + mem[_7487]]) + 1
                                    mem[_7487 + ceil32(return_data.size)] = _7775
                                    require return_data.size >= _7631 + (32 * _7775) + 32
                                    mem[_7487 + ceil32(return_data.size) + 32 len 32 * _7775] = mem[_7487 + _7631 + 32 len 32 * _7775]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7775:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7487 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5012:
                                        revert with 0, 17
                                    mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5016 + 100] = ext_call.return_data[32] + _5012
                                    mem[_5016 + 132] = 0
                                    mem[_5016 + 164] = 160
                                    mem[_5016 + 260] = mem[_5016]
                                    idx = 0
                                    s = _5016 + 292
                                    t = _5016 + 32
                                    while idx < mem[_5016]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5016 + 196] = this.address
                                    mem[_5016 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7488 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7632 = mem[_7488]
                                    require mem[_7488] <= test266151307()
                                    require _7488 + mem[_7488] + 31 < _7488 + return_data.size
                                    _7776 = mem[_7488 + mem[_7488]]
                                    if mem[_7488 + mem[_7488]] > test266151307():
                                        revert with 0, 65
                                    if _7488 + ceil32(return_data.size) + ceil32(32 * mem[_7488 + mem[_7488]]) + 1 > test266151307() or ceil32(32 * mem[_7488 + mem[_7488]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7488 + ceil32(return_data.size) + ceil32(32 * mem[_7488 + mem[_7488]]) + 1
                                    mem[_7488 + ceil32(return_data.size)] = _7776
                                    require return_data.size >= _7632 + (32 * _7776) + 32
                                    mem[_7488 + ceil32(return_data.size) + 32 len 32 * _7776] = mem[_7488 + _7632 + 32 len 32 * _7776]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7776:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7488 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5012:
                                            revert with 0, 17
                                        mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5016 + 100] = ext_call.return_data[0] + _5012
                                        mem[_5016 + 132] = 0
                                        mem[_5016 + 164] = 160
                                        mem[_5016 + 260] = mem[_5016]
                                        idx = 0
                                        s = _5016 + 292
                                        t = _5016 + 32
                                        while idx < mem[_5016]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5016 + 196] = this.address
                                        mem[_5016 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7489 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7633 = mem[_7489]
                                        require mem[_7489] <= test266151307()
                                        require _7489 + mem[_7489] + 31 < _7489 + return_data.size
                                        _7777 = mem[_7489 + mem[_7489]]
                                        if mem[_7489 + mem[_7489]] > test266151307():
                                            revert with 0, 65
                                        if _7489 + ceil32(return_data.size) + ceil32(32 * mem[_7489 + mem[_7489]]) + 1 > test266151307() or ceil32(32 * mem[_7489 + mem[_7489]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7489 + ceil32(return_data.size) + ceil32(32 * mem[_7489 + mem[_7489]]) + 1
                                        mem[_7489 + ceil32(return_data.size)] = _7777
                                        require return_data.size >= _7633 + (32 * _7777) + 32
                                        mem[_7489 + ceil32(return_data.size) + 32 len 32 * _7777] = mem[_7489 + _7633 + 32 len 32 * _7777]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _7777:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7489 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5012:
                                                revert with 0, 17
                                            mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5016 + 100] = ext_call.return_data[32] + _5012
                                            mem[_5016 + 132] = 0
                                            mem[_5016 + 164] = 160
                                            mem[_5016 + 260] = mem[_5016]
                                            idx = 0
                                            s = _5016 + 292
                                            t = _5016 + 32
                                            while idx < mem[_5016]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5016 + 196] = this.address
                                            mem[_5016 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7490 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7634 = mem[_7490]
                                            require mem[_7490] <= test266151307()
                                            require _7490 + mem[_7490] + 31 < _7490 + return_data.size
                                            _7778 = mem[_7490 + mem[_7490]]
                                            if mem[_7490 + mem[_7490]] > test266151307():
                                                revert with 0, 65
                                            if _7490 + ceil32(return_data.size) + ceil32(32 * mem[_7490 + mem[_7490]]) + 1 > test266151307() or ceil32(32 * mem[_7490 + mem[_7490]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7490 + ceil32(return_data.size) + ceil32(32 * mem[_7490 + mem[_7490]]) + 1
                                            mem[_7490 + ceil32(return_data.size)] = _7778
                                            require return_data.size >= _7634 + (32 * _7778) + 32
                                            mem[_7490 + ceil32(return_data.size) + 32 len 32 * _7778] = mem[_7490 + _7634 + 32 len 32 * _7778]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7778:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7490 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5012:
                                                revert with 0, 17
                                            mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5016 + 100] = ext_call.return_data[0] + _5012
                                            mem[_5016 + 132] = 0
                                            mem[_5016 + 164] = 160
                                            mem[_5016 + 260] = mem[_5016]
                                            idx = 0
                                            s = _5016 + 292
                                            t = _5016 + 32
                                            while idx < mem[_5016]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5016 + 196] = this.address
                                            mem[_5016 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7491 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7635 = mem[_7491]
                                            require mem[_7491] <= test266151307()
                                            require _7491 + mem[_7491] + 31 < _7491 + return_data.size
                                            _7779 = mem[_7491 + mem[_7491]]
                                            if mem[_7491 + mem[_7491]] > test266151307():
                                                revert with 0, 65
                                            if _7491 + ceil32(return_data.size) + ceil32(32 * mem[_7491 + mem[_7491]]) + 1 > test266151307() or ceil32(32 * mem[_7491 + mem[_7491]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7491 + ceil32(return_data.size) + ceil32(32 * mem[_7491 + mem[_7491]]) + 1
                                            mem[_7491 + ceil32(return_data.size)] = _7779
                                            require return_data.size >= _7635 + (32 * _7779) + 32
                                            mem[_7491 + ceil32(return_data.size) + 32 len 32 * _7779] = mem[_7491 + _7635 + 32 len 32 * _7779]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7779:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7491 + ceil32(return_data.size) + 64]
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5012:
                                        revert with 0, 17
                                    mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5016 + 100] = ext_call.return_data[32] + _5012
                                    mem[_5016 + 132] = 0
                                    mem[_5016 + 164] = 160
                                    mem[_5016 + 260] = mem[_5016]
                                    idx = 0
                                    s = _5016 + 292
                                    t = _5016 + 32
                                    while idx < mem[_5016]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5016 + 196] = this.address
                                    mem[_5016 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7492 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7636 = mem[_7492]
                                    require mem[_7492] <= test266151307()
                                    require _7492 + mem[_7492] + 31 < _7492 + return_data.size
                                    _7780 = mem[_7492 + mem[_7492]]
                                    if mem[_7492 + mem[_7492]] > test266151307():
                                        revert with 0, 65
                                    if _7492 + ceil32(return_data.size) + ceil32(32 * mem[_7492 + mem[_7492]]) + 1 > test266151307() or ceil32(32 * mem[_7492 + mem[_7492]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7492 + ceil32(return_data.size) + ceil32(32 * mem[_7492 + mem[_7492]]) + 1
                                    mem[_7492 + ceil32(return_data.size)] = _7780
                                    require return_data.size >= _7636 + (32 * _7780) + 32
                                    mem[_7492 + ceil32(return_data.size) + 32 len 32 * _7780] = mem[_7492 + _7636 + 32 len 32 * _7780]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7780:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7492 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5012:
                                        revert with 0, 17
                                    mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5016 + 100] = ext_call.return_data[0] + _5012
                                    mem[_5016 + 132] = 0
                                    mem[_5016 + 164] = 160
                                    mem[_5016 + 260] = mem[_5016]
                                    idx = 0
                                    s = _5016 + 292
                                    t = _5016 + 32
                                    while idx < mem[_5016]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5016 + 196] = this.address
                                    mem[_5016 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7493 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7637 = mem[_7493]
                                    require mem[_7493] <= test266151307()
                                    require _7493 + mem[_7493] + 31 < _7493 + return_data.size
                                    _7781 = mem[_7493 + mem[_7493]]
                                    if mem[_7493 + mem[_7493]] > test266151307():
                                        revert with 0, 65
                                    if _7493 + ceil32(return_data.size) + ceil32(32 * mem[_7493 + mem[_7493]]) + 1 > test266151307() or ceil32(32 * mem[_7493 + mem[_7493]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7493 + ceil32(return_data.size) + ceil32(32 * mem[_7493 + mem[_7493]]) + 1
                                    mem[_7493 + ceil32(return_data.size)] = _7781
                                    require return_data.size >= _7637 + (32 * _7781) + 32
                                    mem[_7493 + ceil32(return_data.size) + 32 len 32 * _7781] = mem[_7493 + _7637 + 32 len 32 * _7781]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7781:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7493 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5012:
                                        revert with 0, 17
                                    mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5016 + 100] = ext_call.return_data[32] + _5012
                                    mem[_5016 + 132] = 0
                                    mem[_5016 + 164] = 160
                                    mem[_5016 + 260] = mem[_5016]
                                    idx = 0
                                    s = _5016 + 292
                                    t = _5016 + 32
                                    while idx < mem[_5016]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5016 + 196] = this.address
                                    mem[_5016 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7494 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7638 = mem[_7494]
                                    require mem[_7494] <= test266151307()
                                    require _7494 + mem[_7494] + 31 < _7494 + return_data.size
                                    _7782 = mem[_7494 + mem[_7494]]
                                    if mem[_7494 + mem[_7494]] > test266151307():
                                        revert with 0, 65
                                    if _7494 + ceil32(return_data.size) + ceil32(32 * mem[_7494 + mem[_7494]]) + 1 > test266151307() or ceil32(32 * mem[_7494 + mem[_7494]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7494 + ceil32(return_data.size) + ceil32(32 * mem[_7494 + mem[_7494]]) + 1
                                    mem[_7494 + ceil32(return_data.size)] = _7782
                                    require return_data.size >= _7638 + (32 * _7782) + 32
                                    mem[_7494 + ceil32(return_data.size) + 32 len 32 * _7782] = mem[_7494 + _7638 + 32 len 32 * _7782]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7782:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7494 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5012:
                                            revert with 0, 17
                                        mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5016 + 100] = ext_call.return_data[0] + _5012
                                        mem[_5016 + 132] = 0
                                        mem[_5016 + 164] = 160
                                        mem[_5016 + 260] = mem[_5016]
                                        idx = 0
                                        s = _5016 + 292
                                        t = _5016 + 32
                                        while idx < mem[_5016]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5016 + 196] = this.address
                                        mem[_5016 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7495 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7639 = mem[_7495]
                                        require mem[_7495] <= test266151307()
                                        require _7495 + mem[_7495] + 31 < _7495 + return_data.size
                                        _7783 = mem[_7495 + mem[_7495]]
                                        if mem[_7495 + mem[_7495]] > test266151307():
                                            revert with 0, 65
                                        if _7495 + ceil32(return_data.size) + ceil32(32 * mem[_7495 + mem[_7495]]) + 1 > test266151307() or ceil32(32 * mem[_7495 + mem[_7495]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7495 + ceil32(return_data.size) + ceil32(32 * mem[_7495 + mem[_7495]]) + 1
                                        mem[_7495 + ceil32(return_data.size)] = _7783
                                        require return_data.size >= _7639 + (32 * _7783) + 32
                                        mem[_7495 + ceil32(return_data.size) + 32 len 32 * _7783] = mem[_7495 + _7639 + 32 len 32 * _7783]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _7783:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7495 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5012:
                                                revert with 0, 17
                                            mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5016 + 100] = ext_call.return_data[32] + _5012
                                            mem[_5016 + 132] = 0
                                            mem[_5016 + 164] = 160
                                            mem[_5016 + 260] = mem[_5016]
                                            idx = 0
                                            s = _5016 + 292
                                            t = _5016 + 32
                                            while idx < mem[_5016]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5016 + 196] = this.address
                                            mem[_5016 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7496 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7640 = mem[_7496]
                                            require mem[_7496] <= test266151307()
                                            require _7496 + mem[_7496] + 31 < _7496 + return_data.size
                                            _7784 = mem[_7496 + mem[_7496]]
                                            if mem[_7496 + mem[_7496]] > test266151307():
                                                revert with 0, 65
                                            if _7496 + ceil32(return_data.size) + ceil32(32 * mem[_7496 + mem[_7496]]) + 1 > test266151307() or ceil32(32 * mem[_7496 + mem[_7496]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7496 + ceil32(return_data.size) + ceil32(32 * mem[_7496 + mem[_7496]]) + 1
                                            mem[_7496 + ceil32(return_data.size)] = _7784
                                            require return_data.size >= _7640 + (32 * _7784) + 32
                                            mem[_7496 + ceil32(return_data.size) + 32 len 32 * _7784] = mem[_7496 + _7640 + 32 len 32 * _7784]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7784:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7496 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5012:
                                                revert with 0, 17
                                            mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5016 + 100] = ext_call.return_data[0] + _5012
                                            mem[_5016 + 132] = 0
                                            mem[_5016 + 164] = 160
                                            mem[_5016 + 260] = mem[_5016]
                                            idx = 0
                                            s = _5016 + 292
                                            t = _5016 + 32
                                            while idx < mem[_5016]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5016 + 196] = this.address
                                            mem[_5016 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7497 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7641 = mem[_7497]
                                            require mem[_7497] <= test266151307()
                                            require _7497 + mem[_7497] + 31 < _7497 + return_data.size
                                            _7785 = mem[_7497 + mem[_7497]]
                                            if mem[_7497 + mem[_7497]] > test266151307():
                                                revert with 0, 65
                                            if _7497 + ceil32(return_data.size) + ceil32(32 * mem[_7497 + mem[_7497]]) + 1 > test266151307() or ceil32(32 * mem[_7497 + mem[_7497]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7497 + ceil32(return_data.size) + ceil32(32 * mem[_7497 + mem[_7497]]) + 1
                                            mem[_7497 + ceil32(return_data.size)] = _7785
                                            require return_data.size >= _7641 + (32 * _7785) + 32
                                            mem[_7497 + ceil32(return_data.size) + 32 len 32 * _7785] = mem[_7497 + _7641 + 32 len 32 * _7785]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7785:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7497 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5012:
                                            revert with 0, 17
                                        mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5016 + 100] = ext_call.return_data[32] + _5012
                                        mem[_5016 + 132] = 0
                                        mem[_5016 + 164] = 160
                                        mem[_5016 + 260] = mem[_5016]
                                        idx = 0
                                        s = _5016 + 292
                                        t = _5016 + 32
                                        while idx < mem[_5016]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5016 + 196] = this.address
                                        mem[_5016 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7498 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7642 = mem[_7498]
                                        require mem[_7498] <= test266151307()
                                        require _7498 + mem[_7498] + 31 < _7498 + return_data.size
                                        _7786 = mem[_7498 + mem[_7498]]
                                        if mem[_7498 + mem[_7498]] > test266151307():
                                            revert with 0, 65
                                        if _7498 + ceil32(return_data.size) + ceil32(32 * mem[_7498 + mem[_7498]]) + 1 > test266151307() or ceil32(32 * mem[_7498 + mem[_7498]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7498 + ceil32(return_data.size) + ceil32(32 * mem[_7498 + mem[_7498]]) + 1
                                        mem[_7498 + ceil32(return_data.size)] = _7786
                                        require return_data.size >= _7642 + (32 * _7786) + 32
                                        mem[_7498 + ceil32(return_data.size) + 32 len 32 * _7786] = mem[_7498 + _7642 + 32 len 32 * _7786]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _7786:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7498 + ceil32(return_data.size) + 64]
                                    else:
                                        if ext_call.return_data[0] > !_5012:
                                            revert with 0, 17
                                        mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5016 + 100] = ext_call.return_data[0] + _5012
                                        mem[_5016 + 132] = 0
                                        mem[_5016 + 164] = 160
                                        mem[_5016 + 260] = mem[_5016]
                                        idx = 0
                                        s = _5016 + 292
                                        t = _5016 + 32
                                        while idx < mem[_5016]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5016 + 196] = this.address
                                        mem[_5016 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7499 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7643 = mem[_7499]
                                        require mem[_7499] <= test266151307()
                                        require _7499 + mem[_7499] + 31 < _7499 + return_data.size
                                        _7787 = mem[_7499 + mem[_7499]]
                                        if mem[_7499 + mem[_7499]] > test266151307():
                                            revert with 0, 65
                                        if _7499 + ceil32(return_data.size) + ceil32(32 * mem[_7499 + mem[_7499]]) + 1 > test266151307() or ceil32(32 * mem[_7499 + mem[_7499]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7499 + ceil32(return_data.size) + ceil32(32 * mem[_7499 + mem[_7499]]) + 1
                                        mem[_7499 + ceil32(return_data.size)] = _7787
                                        require return_data.size >= _7643 + (32 * _7787) + 32
                                        mem[_7499 + ceil32(return_data.size) + 32 len 32 * _7787] = mem[_7499 + _7643 + 32 len 32 * _7787]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _7787:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7499 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5012:
                                            revert with 0, 17
                                        mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5016 + 100] = ext_call.return_data[32] + _5012
                                        mem[_5016 + 132] = 0
                                        mem[_5016 + 164] = 160
                                        mem[_5016 + 260] = mem[_5016]
                                        idx = 0
                                        s = _5016 + 292
                                        t = _5016 + 32
                                        while idx < mem[_5016]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5016 + 196] = this.address
                                        mem[_5016 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7500 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7644 = mem[_7500]
                                        require mem[_7500] <= test266151307()
                                        require _7500 + mem[_7500] + 31 < _7500 + return_data.size
                                        _7788 = mem[_7500 + mem[_7500]]
                                        if mem[_7500 + mem[_7500]] > test266151307():
                                            revert with 0, 65
                                        if _7500 + ceil32(return_data.size) + ceil32(32 * mem[_7500 + mem[_7500]]) + 1 > test266151307() or ceil32(32 * mem[_7500 + mem[_7500]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7500 + ceil32(return_data.size) + ceil32(32 * mem[_7500 + mem[_7500]]) + 1
                                        mem[_7500 + ceil32(return_data.size)] = _7788
                                        require return_data.size >= _7644 + (32 * _7788) + 32
                                        mem[_7500 + ceil32(return_data.size) + 32 len 32 * _7788] = mem[_7500 + _7644 + 32 len 32 * _7788]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _7788:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7500 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > !_5012:
                                                revert with 0, 17
                                            mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5016 + 100] = ext_call.return_data[0] + _5012
                                            mem[_5016 + 132] = 0
                                            mem[_5016 + 164] = 160
                                            mem[_5016 + 260] = mem[_5016]
                                            idx = 0
                                            s = _5016 + 292
                                            t = _5016 + 32
                                            while idx < mem[_5016]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5016 + 196] = this.address
                                            mem[_5016 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7501 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7645 = mem[_7501]
                                            require mem[_7501] <= test266151307()
                                            require _7501 + mem[_7501] + 31 < _7501 + return_data.size
                                            _7789 = mem[_7501 + mem[_7501]]
                                            if mem[_7501 + mem[_7501]] > test266151307():
                                                revert with 0, 65
                                            if _7501 + ceil32(return_data.size) + ceil32(32 * mem[_7501 + mem[_7501]]) + 1 > test266151307() or ceil32(32 * mem[_7501 + mem[_7501]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7501 + ceil32(return_data.size) + ceil32(32 * mem[_7501 + mem[_7501]]) + 1
                                            mem[_7501 + ceil32(return_data.size)] = _7789
                                            require return_data.size >= _7645 + (32 * _7789) + 32
                                            mem[_7501 + ceil32(return_data.size) + 32 len 32 * _7789] = mem[_7501 + _7645 + 32 len 32 * _7789]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7789:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7501 + ceil32(return_data.size) + 64]
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > !_5012:
                                                    revert with 0, 17
                                                mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5016 + 100] = ext_call.return_data[32] + _5012
                                                mem[_5016 + 132] = 0
                                                mem[_5016 + 164] = 160
                                                mem[_5016 + 260] = mem[_5016]
                                                idx = 0
                                                s = _5016 + 292
                                                t = _5016 + 32
                                                while idx < mem[_5016]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5016 + 196] = this.address
                                                mem[_5016 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7502 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7646 = mem[_7502]
                                                require mem[_7502] <= test266151307()
                                                require _7502 + mem[_7502] + 31 < _7502 + return_data.size
                                                _7790 = mem[_7502 + mem[_7502]]
                                                if mem[_7502 + mem[_7502]] > test266151307():
                                                    revert with 0, 65
                                                if _7502 + ceil32(return_data.size) + ceil32(32 * mem[_7502 + mem[_7502]]) + 1 > test266151307() or ceil32(32 * mem[_7502 + mem[_7502]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7502 + ceil32(return_data.size) + ceil32(32 * mem[_7502 + mem[_7502]]) + 1
                                                mem[_7502 + ceil32(return_data.size)] = _7790
                                                require return_data.size >= _7646 + (32 * _7790) + 32
                                                mem[_7502 + ceil32(return_data.size) + 32 len 32 * _7790] = mem[_7502 + _7646 + 32 len 32 * _7790]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _7790:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7502 + ceil32(return_data.size) + 64]
                                            else:
                                                if ext_call.return_data[0] > !_5012:
                                                    revert with 0, 17
                                                mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5016 + 100] = ext_call.return_data[0] + _5012
                                                mem[_5016 + 132] = 0
                                                mem[_5016 + 164] = 160
                                                mem[_5016 + 260] = mem[_5016]
                                                idx = 0
                                                s = _5016 + 292
                                                t = _5016 + 32
                                                while idx < mem[_5016]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5016 + 196] = this.address
                                                mem[_5016 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7503 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7647 = mem[_7503]
                                                require mem[_7503] <= test266151307()
                                                require _7503 + mem[_7503] + 31 < _7503 + return_data.size
                                                _7791 = mem[_7503 + mem[_7503]]
                                                if mem[_7503 + mem[_7503]] > test266151307():
                                                    revert with 0, 65
                                                if _7503 + ceil32(return_data.size) + ceil32(32 * mem[_7503 + mem[_7503]]) + 1 > test266151307() or ceil32(32 * mem[_7503 + mem[_7503]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7503 + ceil32(return_data.size) + ceil32(32 * mem[_7503 + mem[_7503]]) + 1
                                                mem[_7503 + ceil32(return_data.size)] = _7791
                                                require return_data.size >= _7647 + (32 * _7791) + 32
                                                mem[_7503 + ceil32(return_data.size) + 32 len 32 * _7791] = mem[_7503 + _7647 + 32 len 32 * _7791]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _7791:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7503 + ceil32(return_data.size) + 64]
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5012:
                                                revert with 0, 17
                                            mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5016 + 100] = ext_call.return_data[32] + _5012
                                            mem[_5016 + 132] = 0
                                            mem[_5016 + 164] = 160
                                            mem[_5016 + 260] = mem[_5016]
                                            idx = 0
                                            s = _5016 + 292
                                            t = _5016 + 32
                                            while idx < mem[_5016]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5016 + 196] = this.address
                                            mem[_5016 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7504 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7648 = mem[_7504]
                                            require mem[_7504] <= test266151307()
                                            require _7504 + mem[_7504] + 31 < _7504 + return_data.size
                                            _7792 = mem[_7504 + mem[_7504]]
                                            if mem[_7504 + mem[_7504]] > test266151307():
                                                revert with 0, 65
                                            if _7504 + ceil32(return_data.size) + ceil32(32 * mem[_7504 + mem[_7504]]) + 1 > test266151307() or ceil32(32 * mem[_7504 + mem[_7504]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7504 + ceil32(return_data.size) + ceil32(32 * mem[_7504 + mem[_7504]]) + 1
                                            mem[_7504 + ceil32(return_data.size)] = _7792
                                            require return_data.size >= _7648 + (32 * _7792) + 32
                                            mem[_7504 + ceil32(return_data.size) + 32 len 32 * _7792] = mem[_7504 + _7648 + 32 len 32 * _7792]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7792:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7504 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5012:
                                                revert with 0, 17
                                            mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5016 + 100] = ext_call.return_data[0] + _5012
                                            mem[_5016 + 132] = 0
                                            mem[_5016 + 164] = 160
                                            mem[_5016 + 260] = mem[_5016]
                                            idx = 0
                                            s = _5016 + 292
                                            t = _5016 + 32
                                            while idx < mem[_5016]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5016 + 196] = this.address
                                            mem[_5016 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7505 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7649 = mem[_7505]
                                            require mem[_7505] <= test266151307()
                                            require _7505 + mem[_7505] + 31 < _7505 + return_data.size
                                            _7793 = mem[_7505 + mem[_7505]]
                                            if mem[_7505 + mem[_7505]] > test266151307():
                                                revert with 0, 65
                                            if _7505 + ceil32(return_data.size) + ceil32(32 * mem[_7505 + mem[_7505]]) + 1 > test266151307() or ceil32(32 * mem[_7505 + mem[_7505]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7505 + ceil32(return_data.size) + ceil32(32 * mem[_7505 + mem[_7505]]) + 1
                                            mem[_7505 + ceil32(return_data.size)] = _7793
                                            require return_data.size >= _7649 + (32 * _7793) + 32
                                            mem[_7505 + ceil32(return_data.size) + 32 len 32 * _7793] = mem[_7505 + _7649 + 32 len 32 * _7793]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7793:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7505 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5012:
                                                revert with 0, 17
                                            mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5016 + 100] = ext_call.return_data[32] + _5012
                                            mem[_5016 + 132] = 0
                                            mem[_5016 + 164] = 160
                                            mem[_5016 + 260] = mem[_5016]
                                            idx = 0
                                            s = _5016 + 292
                                            t = _5016 + 32
                                            while idx < mem[_5016]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5016 + 196] = this.address
                                            mem[_5016 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7506 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7650 = mem[_7506]
                                            require mem[_7506] <= test266151307()
                                            require _7506 + mem[_7506] + 31 < _7506 + return_data.size
                                            _7794 = mem[_7506 + mem[_7506]]
                                            if mem[_7506 + mem[_7506]] > test266151307():
                                                revert with 0, 65
                                            if _7506 + ceil32(return_data.size) + ceil32(32 * mem[_7506 + mem[_7506]]) + 1 > test266151307() or ceil32(32 * mem[_7506 + mem[_7506]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7506 + ceil32(return_data.size) + ceil32(32 * mem[_7506 + mem[_7506]]) + 1
                                            mem[_7506 + ceil32(return_data.size)] = _7794
                                            require return_data.size >= _7650 + (32 * _7794) + 32
                                            mem[_7506 + ceil32(return_data.size) + 32 len 32 * _7794] = mem[_7506 + _7650 + 32 len 32 * _7794]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7794:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7506 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5012:
                                                    revert with 0, 17
                                                mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5016 + 100] = ext_call.return_data[0] + _5012
                                                mem[_5016 + 132] = 0
                                                mem[_5016 + 164] = 160
                                                mem[_5016 + 260] = mem[_5016]
                                                idx = 0
                                                s = _5016 + 292
                                                t = _5016 + 32
                                                while idx < mem[_5016]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5016 + 196] = this.address
                                                mem[_5016 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7507 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7651 = mem[_7507]
                                                require mem[_7507] <= test266151307()
                                                require _7507 + mem[_7507] + 31 < _7507 + return_data.size
                                                _7795 = mem[_7507 + mem[_7507]]
                                                if mem[_7507 + mem[_7507]] > test266151307():
                                                    revert with 0, 65
                                                if _7507 + ceil32(return_data.size) + ceil32(32 * mem[_7507 + mem[_7507]]) + 1 > test266151307() or ceil32(32 * mem[_7507 + mem[_7507]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7507 + ceil32(return_data.size) + ceil32(32 * mem[_7507 + mem[_7507]]) + 1
                                                mem[_7507 + ceil32(return_data.size)] = _7795
                                                require return_data.size >= _7651 + (32 * _7795) + 32
                                                mem[_7507 + ceil32(return_data.size) + 32 len 32 * _7795] = mem[_7507 + _7651 + 32 len 32 * _7795]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _7795:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7507 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5012:
                                                        revert with 0, 17
                                                    mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5016 + 100] = ext_call.return_data[32] + _5012
                                                    mem[_5016 + 132] = 0
                                                    mem[_5016 + 164] = 160
                                                    mem[_5016 + 260] = mem[_5016]
                                                    idx = 0
                                                    s = _5016 + 292
                                                    t = _5016 + 32
                                                    while idx < mem[_5016]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5016 + 196] = this.address
                                                    mem[_5016 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7508 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7652 = mem[_7508]
                                                    require mem[_7508] <= test266151307()
                                                    require _7508 + mem[_7508] + 31 < _7508 + return_data.size
                                                    _7796 = mem[_7508 + mem[_7508]]
                                                    if mem[_7508 + mem[_7508]] > test266151307():
                                                        revert with 0, 65
                                                    if _7508 + ceil32(return_data.size) + ceil32(32 * mem[_7508 + mem[_7508]]) + 1 > test266151307() or ceil32(32 * mem[_7508 + mem[_7508]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7508 + ceil32(return_data.size) + ceil32(32 * mem[_7508 + mem[_7508]]) + 1
                                                    mem[_7508 + ceil32(return_data.size)] = _7796
                                                    require return_data.size >= _7652 + (32 * _7796) + 32
                                                    mem[_7508 + ceil32(return_data.size) + 32 len 32 * _7796] = mem[_7508 + _7652 + 32 len 32 * _7796]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _7796:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7508 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5012:
                                                        revert with 0, 17
                                                    mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5016 + 100] = ext_call.return_data[0] + _5012
                                                    mem[_5016 + 132] = 0
                                                    mem[_5016 + 164] = 160
                                                    mem[_5016 + 260] = mem[_5016]
                                                    idx = 0
                                                    s = _5016 + 292
                                                    t = _5016 + 32
                                                    while idx < mem[_5016]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5016 + 196] = this.address
                                                    mem[_5016 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7509 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7653 = mem[_7509]
                                                    require mem[_7509] <= test266151307()
                                                    require _7509 + mem[_7509] + 31 < _7509 + return_data.size
                                                    _7797 = mem[_7509 + mem[_7509]]
                                                    if mem[_7509 + mem[_7509]] > test266151307():
                                                        revert with 0, 65
                                                    if _7509 + ceil32(return_data.size) + ceil32(32 * mem[_7509 + mem[_7509]]) + 1 > test266151307() or ceil32(32 * mem[_7509 + mem[_7509]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7509 + ceil32(return_data.size) + ceil32(32 * mem[_7509 + mem[_7509]]) + 1
                                                    mem[_7509 + ceil32(return_data.size)] = _7797
                                                    require return_data.size >= _7653 + (32 * _7797) + 32
                                                    mem[_7509 + ceil32(return_data.size) + 32 len 32 * _7797] = mem[_7509 + _7653 + 32 len 32 * _7797]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _7797:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7509 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5012:
                                                revert with 0, 17
                                            mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5016 + 100] = ext_call.return_data[32] + _5012
                                            mem[_5016 + 132] = 0
                                            mem[_5016 + 164] = 160
                                            mem[_5016 + 260] = mem[_5016]
                                            idx = 0
                                            s = _5016 + 292
                                            t = _5016 + 32
                                            while idx < mem[_5016]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5016 + 196] = this.address
                                            mem[_5016 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7510 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7654 = mem[_7510]
                                            require mem[_7510] <= test266151307()
                                            require _7510 + mem[_7510] + 31 < _7510 + return_data.size
                                            _7798 = mem[_7510 + mem[_7510]]
                                            if mem[_7510 + mem[_7510]] > test266151307():
                                                revert with 0, 65
                                            if _7510 + ceil32(return_data.size) + ceil32(32 * mem[_7510 + mem[_7510]]) + 1 > test266151307() or ceil32(32 * mem[_7510 + mem[_7510]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7510 + ceil32(return_data.size) + ceil32(32 * mem[_7510 + mem[_7510]]) + 1
                                            mem[_7510 + ceil32(return_data.size)] = _7798
                                            require return_data.size >= _7654 + (32 * _7798) + 32
                                            mem[_7510 + ceil32(return_data.size) + 32 len 32 * _7798] = mem[_7510 + _7654 + 32 len 32 * _7798]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7798:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7510 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5012:
                                                revert with 0, 17
                                            mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5016 + 100] = ext_call.return_data[0] + _5012
                                            mem[_5016 + 132] = 0
                                            mem[_5016 + 164] = 160
                                            mem[_5016 + 260] = mem[_5016]
                                            idx = 0
                                            s = _5016 + 292
                                            t = _5016 + 32
                                            while idx < mem[_5016]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5016 + 196] = this.address
                                            mem[_5016 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7511 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7655 = mem[_7511]
                                            require mem[_7511] <= test266151307()
                                            require _7511 + mem[_7511] + 31 < _7511 + return_data.size
                                            _7799 = mem[_7511 + mem[_7511]]
                                            if mem[_7511 + mem[_7511]] > test266151307():
                                                revert with 0, 65
                                            if _7511 + ceil32(return_data.size) + ceil32(32 * mem[_7511 + mem[_7511]]) + 1 > test266151307() or ceil32(32 * mem[_7511 + mem[_7511]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7511 + ceil32(return_data.size) + ceil32(32 * mem[_7511 + mem[_7511]]) + 1
                                            mem[_7511 + ceil32(return_data.size)] = _7799
                                            require return_data.size >= _7655 + (32 * _7799) + 32
                                            mem[_7511 + ceil32(return_data.size) + 32 len 32 * _7799] = mem[_7511 + _7655 + 32 len 32 * _7799]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7799:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7511 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5012:
                                                revert with 0, 17
                                            mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5016 + 100] = ext_call.return_data[32] + _5012
                                            mem[_5016 + 132] = 0
                                            mem[_5016 + 164] = 160
                                            mem[_5016 + 260] = mem[_5016]
                                            idx = 0
                                            s = _5016 + 292
                                            t = _5016 + 32
                                            while idx < mem[_5016]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5016 + 196] = this.address
                                            mem[_5016 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7512 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7656 = mem[_7512]
                                            require mem[_7512] <= test266151307()
                                            require _7512 + mem[_7512] + 31 < _7512 + return_data.size
                                            _7800 = mem[_7512 + mem[_7512]]
                                            if mem[_7512 + mem[_7512]] > test266151307():
                                                revert with 0, 65
                                            if _7512 + ceil32(return_data.size) + ceil32(32 * mem[_7512 + mem[_7512]]) + 1 > test266151307() or ceil32(32 * mem[_7512 + mem[_7512]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7512 + ceil32(return_data.size) + ceil32(32 * mem[_7512 + mem[_7512]]) + 1
                                            mem[_7512 + ceil32(return_data.size)] = _7800
                                            require return_data.size >= _7656 + (32 * _7800) + 32
                                            mem[_7512 + ceil32(return_data.size) + 32 len 32 * _7800] = mem[_7512 + _7656 + 32 len 32 * _7800]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7800:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7512 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5012:
                                                    revert with 0, 17
                                                mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5016 + 100] = ext_call.return_data[0] + _5012
                                                mem[_5016 + 132] = 0
                                                mem[_5016 + 164] = 160
                                                mem[_5016 + 260] = mem[_5016]
                                                idx = 0
                                                s = _5016 + 292
                                                t = _5016 + 32
                                                while idx < mem[_5016]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5016 + 196] = this.address
                                                mem[_5016 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7513 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7657 = mem[_7513]
                                                require mem[_7513] <= test266151307()
                                                require _7513 + mem[_7513] + 31 < _7513 + return_data.size
                                                _7801 = mem[_7513 + mem[_7513]]
                                                if mem[_7513 + mem[_7513]] > test266151307():
                                                    revert with 0, 65
                                                if _7513 + ceil32(return_data.size) + ceil32(32 * mem[_7513 + mem[_7513]]) + 1 > test266151307() or ceil32(32 * mem[_7513 + mem[_7513]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7513 + ceil32(return_data.size) + ceil32(32 * mem[_7513 + mem[_7513]]) + 1
                                                mem[_7513 + ceil32(return_data.size)] = _7801
                                                require return_data.size >= _7657 + (32 * _7801) + 32
                                                mem[_7513 + ceil32(return_data.size) + 32 len 32 * _7801] = mem[_7513 + _7657 + 32 len 32 * _7801]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _7801:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7513 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5012:
                                                        revert with 0, 17
                                                    mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5016 + 100] = ext_call.return_data[32] + _5012
                                                    mem[_5016 + 132] = 0
                                                    mem[_5016 + 164] = 160
                                                    mem[_5016 + 260] = mem[_5016]
                                                    idx = 0
                                                    s = _5016 + 292
                                                    t = _5016 + 32
                                                    while idx < mem[_5016]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5016 + 196] = this.address
                                                    mem[_5016 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7514 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7658 = mem[_7514]
                                                    require mem[_7514] <= test266151307()
                                                    require _7514 + mem[_7514] + 31 < _7514 + return_data.size
                                                    _7802 = mem[_7514 + mem[_7514]]
                                                    if mem[_7514 + mem[_7514]] > test266151307():
                                                        revert with 0, 65
                                                    if _7514 + ceil32(return_data.size) + ceil32(32 * mem[_7514 + mem[_7514]]) + 1 > test266151307() or ceil32(32 * mem[_7514 + mem[_7514]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7514 + ceil32(return_data.size) + ceil32(32 * mem[_7514 + mem[_7514]]) + 1
                                                    mem[_7514 + ceil32(return_data.size)] = _7802
                                                    require return_data.size >= _7658 + (32 * _7802) + 32
                                                    mem[_7514 + ceil32(return_data.size) + 32 len 32 * _7802] = mem[_7514 + _7658 + 32 len 32 * _7802]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _7802:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7514 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5012:
                                                        revert with 0, 17
                                                    mem[_5016 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5016 + 100] = ext_call.return_data[0] + _5012
                                                    mem[_5016 + 132] = 0
                                                    mem[_5016 + 164] = 160
                                                    mem[_5016 + 260] = mem[_5016]
                                                    idx = 0
                                                    s = _5016 + 292
                                                    t = _5016 + 32
                                                    while idx < mem[_5016]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5016 + 196] = this.address
                                                    mem[_5016 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5016 + (32 * mem[_5016]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7515 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7659 = mem[_7515]
                                                    require mem[_7515] <= test266151307()
                                                    require _7515 + mem[_7515] + 31 < _7515 + return_data.size
                                                    _7803 = mem[_7515 + mem[_7515]]
                                                    if mem[_7515 + mem[_7515]] > test266151307():
                                                        revert with 0, 65
                                                    if _7515 + ceil32(return_data.size) + ceil32(32 * mem[_7515 + mem[_7515]]) + 1 > test266151307() or ceil32(32 * mem[_7515 + mem[_7515]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7515 + ceil32(return_data.size) + ceil32(32 * mem[_7515 + mem[_7515]]) + 1
                                                    mem[_7515 + ceil32(return_data.size)] = _7803
                                                    require return_data.size >= _7659 + (32 * _7803) + 32
                                                    mem[_7515 + ceil32(return_data.size) + 32 len 32 * _7803] = mem[_7515 + _7659 + 32 len 32 * _7803]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _7803:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7515 + ceil32(return_data.size) + 64]
                else:
                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 388
                    t = (4 * ceil32(return_data.size)) + 128
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2643 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _2674 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                        revert with 0, 65
                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                    require return_data.size >= _2643 + (32 * _2674) + 32
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2674] = mem[(4 * ceil32(return_data.size)) + _2643 + 224 len 32 * _2674]
                    if 1 >= _2674:
                        revert with 0, 50
                    _5013 = mem[(6 * ceil32(return_data.size)) + 256]
                    _5017 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_5017]:
                        revert with 0, 50
                    mem[_5017 + 32] = address(ext_call.return_data[0])
                    if 1 >= mem[_5017]:
                        revert with 0, 50
                    mem[_5017 + 64] = brushAddress
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5013:
                                        revert with 0, 17
                                    mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                    mem[_5017 + 132] = 0
                                    mem[_5017 + 164] = 160
                                    mem[_5017 + 260] = mem[_5017]
                                    idx = 0
                                    s = _5017 + 292
                                    t = _5017 + 32
                                    while idx < mem[_5017]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5017 + 196] = this.address
                                    mem[_5017 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7516 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7660 = mem[_7516]
                                    require mem[_7516] <= test266151307()
                                    require _7516 + mem[_7516] + 31 < _7516 + return_data.size
                                    _7804 = mem[_7516 + mem[_7516]]
                                    if mem[_7516 + mem[_7516]] > test266151307():
                                        revert with 0, 65
                                    if _7516 + ceil32(return_data.size) + ceil32(32 * mem[_7516 + mem[_7516]]) + 1 > test266151307() or ceil32(32 * mem[_7516 + mem[_7516]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7516 + ceil32(return_data.size) + ceil32(32 * mem[_7516 + mem[_7516]]) + 1
                                    mem[_7516 + ceil32(return_data.size)] = _7804
                                    require return_data.size >= _7660 + (32 * _7804) + 32
                                    mem[_7516 + ceil32(return_data.size) + 32 len 32 * _7804] = mem[_7516 + _7660 + 32 len 32 * _7804]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7804:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7516 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5013:
                                        revert with 0, 17
                                    mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                    mem[_5017 + 132] = 0
                                    mem[_5017 + 164] = 160
                                    mem[_5017 + 260] = mem[_5017]
                                    idx = 0
                                    s = _5017 + 292
                                    t = _5017 + 32
                                    while idx < mem[_5017]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5017 + 196] = this.address
                                    mem[_5017 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7517 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7661 = mem[_7517]
                                    require mem[_7517] <= test266151307()
                                    require _7517 + mem[_7517] + 31 < _7517 + return_data.size
                                    _7805 = mem[_7517 + mem[_7517]]
                                    if mem[_7517 + mem[_7517]] > test266151307():
                                        revert with 0, 65
                                    if _7517 + ceil32(return_data.size) + ceil32(32 * mem[_7517 + mem[_7517]]) + 1 > test266151307() or ceil32(32 * mem[_7517 + mem[_7517]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7517 + ceil32(return_data.size) + ceil32(32 * mem[_7517 + mem[_7517]]) + 1
                                    mem[_7517 + ceil32(return_data.size)] = _7805
                                    require return_data.size >= _7661 + (32 * _7805) + 32
                                    mem[_7517 + ceil32(return_data.size) + 32 len 32 * _7805] = mem[_7517 + _7661 + 32 len 32 * _7805]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7805:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7517 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5013:
                                        revert with 0, 17
                                    mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                    mem[_5017 + 132] = 0
                                    mem[_5017 + 164] = 160
                                    mem[_5017 + 260] = mem[_5017]
                                    idx = 0
                                    s = _5017 + 292
                                    t = _5017 + 32
                                    while idx < mem[_5017]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5017 + 196] = this.address
                                    mem[_5017 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7518 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7662 = mem[_7518]
                                    require mem[_7518] <= test266151307()
                                    require _7518 + mem[_7518] + 31 < _7518 + return_data.size
                                    _7806 = mem[_7518 + mem[_7518]]
                                    if mem[_7518 + mem[_7518]] > test266151307():
                                        revert with 0, 65
                                    if _7518 + ceil32(return_data.size) + ceil32(32 * mem[_7518 + mem[_7518]]) + 1 > test266151307() or ceil32(32 * mem[_7518 + mem[_7518]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7518 + ceil32(return_data.size) + ceil32(32 * mem[_7518 + mem[_7518]]) + 1
                                    mem[_7518 + ceil32(return_data.size)] = _7806
                                    require return_data.size >= _7662 + (32 * _7806) + 32
                                    mem[_7518 + ceil32(return_data.size) + 32 len 32 * _7806] = mem[_7518 + _7662 + 32 len 32 * _7806]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7806:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7518 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5013:
                                            revert with 0, 17
                                        mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                        mem[_5017 + 132] = 0
                                        mem[_5017 + 164] = 160
                                        mem[_5017 + 260] = mem[_5017]
                                        idx = 0
                                        s = _5017 + 292
                                        t = _5017 + 32
                                        while idx < mem[_5017]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5017 + 196] = this.address
                                        mem[_5017 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7519 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7663 = mem[_7519]
                                        require mem[_7519] <= test266151307()
                                        require _7519 + mem[_7519] + 31 < _7519 + return_data.size
                                        _7807 = mem[_7519 + mem[_7519]]
                                        if mem[_7519 + mem[_7519]] > test266151307():
                                            revert with 0, 65
                                        if _7519 + ceil32(return_data.size) + ceil32(32 * mem[_7519 + mem[_7519]]) + 1 > test266151307() or ceil32(32 * mem[_7519 + mem[_7519]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7519 + ceil32(return_data.size) + ceil32(32 * mem[_7519 + mem[_7519]]) + 1
                                        mem[_7519 + ceil32(return_data.size)] = _7807
                                        require return_data.size >= _7663 + (32 * _7807) + 32
                                        mem[_7519 + ceil32(return_data.size) + 32 len 32 * _7807] = mem[_7519 + _7663 + 32 len 32 * _7807]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _7807:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7519 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5013:
                                                revert with 0, 17
                                            mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                            mem[_5017 + 132] = 0
                                            mem[_5017 + 164] = 160
                                            mem[_5017 + 260] = mem[_5017]
                                            idx = 0
                                            s = _5017 + 292
                                            t = _5017 + 32
                                            while idx < mem[_5017]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5017 + 196] = this.address
                                            mem[_5017 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7520 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7664 = mem[_7520]
                                            require mem[_7520] <= test266151307()
                                            require _7520 + mem[_7520] + 31 < _7520 + return_data.size
                                            _7808 = mem[_7520 + mem[_7520]]
                                            if mem[_7520 + mem[_7520]] > test266151307():
                                                revert with 0, 65
                                            if _7520 + ceil32(return_data.size) + ceil32(32 * mem[_7520 + mem[_7520]]) + 1 > test266151307() or ceil32(32 * mem[_7520 + mem[_7520]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7520 + ceil32(return_data.size) + ceil32(32 * mem[_7520 + mem[_7520]]) + 1
                                            mem[_7520 + ceil32(return_data.size)] = _7808
                                            require return_data.size >= _7664 + (32 * _7808) + 32
                                            mem[_7520 + ceil32(return_data.size) + 32 len 32 * _7808] = mem[_7520 + _7664 + 32 len 32 * _7808]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7808:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7520 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5013:
                                                revert with 0, 17
                                            mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                            mem[_5017 + 132] = 0
                                            mem[_5017 + 164] = 160
                                            mem[_5017 + 260] = mem[_5017]
                                            idx = 0
                                            s = _5017 + 292
                                            t = _5017 + 32
                                            while idx < mem[_5017]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5017 + 196] = this.address
                                            mem[_5017 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7521 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7665 = mem[_7521]
                                            require mem[_7521] <= test266151307()
                                            require _7521 + mem[_7521] + 31 < _7521 + return_data.size
                                            _7809 = mem[_7521 + mem[_7521]]
                                            if mem[_7521 + mem[_7521]] > test266151307():
                                                revert with 0, 65
                                            if _7521 + ceil32(return_data.size) + ceil32(32 * mem[_7521 + mem[_7521]]) + 1 > test266151307() or ceil32(32 * mem[_7521 + mem[_7521]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7521 + ceil32(return_data.size) + ceil32(32 * mem[_7521 + mem[_7521]]) + 1
                                            mem[_7521 + ceil32(return_data.size)] = _7809
                                            require return_data.size >= _7665 + (32 * _7809) + 32
                                            mem[_7521 + ceil32(return_data.size) + 32 len 32 * _7809] = mem[_7521 + _7665 + 32 len 32 * _7809]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7809:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7521 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5013:
                                        revert with 0, 17
                                    mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                    mem[_5017 + 132] = 0
                                    mem[_5017 + 164] = 160
                                    mem[_5017 + 260] = mem[_5017]
                                    idx = 0
                                    s = _5017 + 292
                                    t = _5017 + 32
                                    while idx < mem[_5017]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5017 + 196] = this.address
                                    mem[_5017 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7522 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7666 = mem[_7522]
                                    require mem[_7522] <= test266151307()
                                    require _7522 + mem[_7522] + 31 < _7522 + return_data.size
                                    _7810 = mem[_7522 + mem[_7522]]
                                    if mem[_7522 + mem[_7522]] > test266151307():
                                        revert with 0, 65
                                    if _7522 + ceil32(return_data.size) + ceil32(32 * mem[_7522 + mem[_7522]]) + 1 > test266151307() or ceil32(32 * mem[_7522 + mem[_7522]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7522 + ceil32(return_data.size) + ceil32(32 * mem[_7522 + mem[_7522]]) + 1
                                    mem[_7522 + ceil32(return_data.size)] = _7810
                                    require return_data.size >= _7666 + (32 * _7810) + 32
                                    mem[_7522 + ceil32(return_data.size) + 32 len 32 * _7810] = mem[_7522 + _7666 + 32 len 32 * _7810]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7810:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7522 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5013:
                                        revert with 0, 17
                                    mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                    mem[_5017 + 132] = 0
                                    mem[_5017 + 164] = 160
                                    mem[_5017 + 260] = mem[_5017]
                                    idx = 0
                                    s = _5017 + 292
                                    t = _5017 + 32
                                    while idx < mem[_5017]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5017 + 196] = this.address
                                    mem[_5017 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7523 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7667 = mem[_7523]
                                    require mem[_7523] <= test266151307()
                                    require _7523 + mem[_7523] + 31 < _7523 + return_data.size
                                    _7811 = mem[_7523 + mem[_7523]]
                                    if mem[_7523 + mem[_7523]] > test266151307():
                                        revert with 0, 65
                                    if _7523 + ceil32(return_data.size) + ceil32(32 * mem[_7523 + mem[_7523]]) + 1 > test266151307() or ceil32(32 * mem[_7523 + mem[_7523]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7523 + ceil32(return_data.size) + ceil32(32 * mem[_7523 + mem[_7523]]) + 1
                                    mem[_7523 + ceil32(return_data.size)] = _7811
                                    require return_data.size >= _7667 + (32 * _7811) + 32
                                    mem[_7523 + ceil32(return_data.size) + 32 len 32 * _7811] = mem[_7523 + _7667 + 32 len 32 * _7811]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7811:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7523 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5013:
                                        revert with 0, 17
                                    mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                    mem[_5017 + 132] = 0
                                    mem[_5017 + 164] = 160
                                    mem[_5017 + 260] = mem[_5017]
                                    idx = 0
                                    s = _5017 + 292
                                    t = _5017 + 32
                                    while idx < mem[_5017]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5017 + 196] = this.address
                                    mem[_5017 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7524 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7668 = mem[_7524]
                                    require mem[_7524] <= test266151307()
                                    require _7524 + mem[_7524] + 31 < _7524 + return_data.size
                                    _7812 = mem[_7524 + mem[_7524]]
                                    if mem[_7524 + mem[_7524]] > test266151307():
                                        revert with 0, 65
                                    if _7524 + ceil32(return_data.size) + ceil32(32 * mem[_7524 + mem[_7524]]) + 1 > test266151307() or ceil32(32 * mem[_7524 + mem[_7524]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7524 + ceil32(return_data.size) + ceil32(32 * mem[_7524 + mem[_7524]]) + 1
                                    mem[_7524 + ceil32(return_data.size)] = _7812
                                    require return_data.size >= _7668 + (32 * _7812) + 32
                                    mem[_7524 + ceil32(return_data.size) + 32 len 32 * _7812] = mem[_7524 + _7668 + 32 len 32 * _7812]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7812:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7524 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5013:
                                            revert with 0, 17
                                        mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                        mem[_5017 + 132] = 0
                                        mem[_5017 + 164] = 160
                                        mem[_5017 + 260] = mem[_5017]
                                        idx = 0
                                        s = _5017 + 292
                                        t = _5017 + 32
                                        while idx < mem[_5017]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5017 + 196] = this.address
                                        mem[_5017 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7525 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7669 = mem[_7525]
                                        require mem[_7525] <= test266151307()
                                        require _7525 + mem[_7525] + 31 < _7525 + return_data.size
                                        _7813 = mem[_7525 + mem[_7525]]
                                        if mem[_7525 + mem[_7525]] > test266151307():
                                            revert with 0, 65
                                        if _7525 + ceil32(return_data.size) + ceil32(32 * mem[_7525 + mem[_7525]]) + 1 > test266151307() or ceil32(32 * mem[_7525 + mem[_7525]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7525 + ceil32(return_data.size) + ceil32(32 * mem[_7525 + mem[_7525]]) + 1
                                        mem[_7525 + ceil32(return_data.size)] = _7813
                                        require return_data.size >= _7669 + (32 * _7813) + 32
                                        mem[_7525 + ceil32(return_data.size) + 32 len 32 * _7813] = mem[_7525 + _7669 + 32 len 32 * _7813]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _7813:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7525 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5013:
                                                revert with 0, 17
                                            mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                            mem[_5017 + 132] = 0
                                            mem[_5017 + 164] = 160
                                            mem[_5017 + 260] = mem[_5017]
                                            idx = 0
                                            s = _5017 + 292
                                            t = _5017 + 32
                                            while idx < mem[_5017]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5017 + 196] = this.address
                                            mem[_5017 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7526 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7670 = mem[_7526]
                                            require mem[_7526] <= test266151307()
                                            require _7526 + mem[_7526] + 31 < _7526 + return_data.size
                                            _7814 = mem[_7526 + mem[_7526]]
                                            if mem[_7526 + mem[_7526]] > test266151307():
                                                revert with 0, 65
                                            if _7526 + ceil32(return_data.size) + ceil32(32 * mem[_7526 + mem[_7526]]) + 1 > test266151307() or ceil32(32 * mem[_7526 + mem[_7526]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7526 + ceil32(return_data.size) + ceil32(32 * mem[_7526 + mem[_7526]]) + 1
                                            mem[_7526 + ceil32(return_data.size)] = _7814
                                            require return_data.size >= _7670 + (32 * _7814) + 32
                                            mem[_7526 + ceil32(return_data.size) + 32 len 32 * _7814] = mem[_7526 + _7670 + 32 len 32 * _7814]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7814:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7526 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5013:
                                                revert with 0, 17
                                            mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                            mem[_5017 + 132] = 0
                                            mem[_5017 + 164] = 160
                                            mem[_5017 + 260] = mem[_5017]
                                            idx = 0
                                            s = _5017 + 292
                                            t = _5017 + 32
                                            while idx < mem[_5017]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5017 + 196] = this.address
                                            mem[_5017 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7527 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7671 = mem[_7527]
                                            require mem[_7527] <= test266151307()
                                            require _7527 + mem[_7527] + 31 < _7527 + return_data.size
                                            _7815 = mem[_7527 + mem[_7527]]
                                            if mem[_7527 + mem[_7527]] > test266151307():
                                                revert with 0, 65
                                            if _7527 + ceil32(return_data.size) + ceil32(32 * mem[_7527 + mem[_7527]]) + 1 > test266151307() or ceil32(32 * mem[_7527 + mem[_7527]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7527 + ceil32(return_data.size) + ceil32(32 * mem[_7527 + mem[_7527]]) + 1
                                            mem[_7527 + ceil32(return_data.size)] = _7815
                                            require return_data.size >= _7671 + (32 * _7815) + 32
                                            mem[_7527 + ceil32(return_data.size) + 32 len 32 * _7815] = mem[_7527 + _7671 + 32 len 32 * _7815]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7815:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7527 + ceil32(return_data.size) + 64]
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5013:
                                        revert with 0, 17
                                    mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                    mem[_5017 + 132] = 0
                                    mem[_5017 + 164] = 160
                                    mem[_5017 + 260] = mem[_5017]
                                    idx = 0
                                    s = _5017 + 292
                                    t = _5017 + 32
                                    while idx < mem[_5017]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5017 + 196] = this.address
                                    mem[_5017 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7528 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7672 = mem[_7528]
                                    require mem[_7528] <= test266151307()
                                    require _7528 + mem[_7528] + 31 < _7528 + return_data.size
                                    _7816 = mem[_7528 + mem[_7528]]
                                    if mem[_7528 + mem[_7528]] > test266151307():
                                        revert with 0, 65
                                    if _7528 + ceil32(return_data.size) + ceil32(32 * mem[_7528 + mem[_7528]]) + 1 > test266151307() or ceil32(32 * mem[_7528 + mem[_7528]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7528 + ceil32(return_data.size) + ceil32(32 * mem[_7528 + mem[_7528]]) + 1
                                    mem[_7528 + ceil32(return_data.size)] = _7816
                                    require return_data.size >= _7672 + (32 * _7816) + 32
                                    mem[_7528 + ceil32(return_data.size) + 32 len 32 * _7816] = mem[_7528 + _7672 + 32 len 32 * _7816]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7816:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7528 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5013:
                                        revert with 0, 17
                                    mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                    mem[_5017 + 132] = 0
                                    mem[_5017 + 164] = 160
                                    mem[_5017 + 260] = mem[_5017]
                                    idx = 0
                                    s = _5017 + 292
                                    t = _5017 + 32
                                    while idx < mem[_5017]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5017 + 196] = this.address
                                    mem[_5017 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7529 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7673 = mem[_7529]
                                    require mem[_7529] <= test266151307()
                                    require _7529 + mem[_7529] + 31 < _7529 + return_data.size
                                    _7817 = mem[_7529 + mem[_7529]]
                                    if mem[_7529 + mem[_7529]] > test266151307():
                                        revert with 0, 65
                                    if _7529 + ceil32(return_data.size) + ceil32(32 * mem[_7529 + mem[_7529]]) + 1 > test266151307() or ceil32(32 * mem[_7529 + mem[_7529]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7529 + ceil32(return_data.size) + ceil32(32 * mem[_7529 + mem[_7529]]) + 1
                                    mem[_7529 + ceil32(return_data.size)] = _7817
                                    require return_data.size >= _7673 + (32 * _7817) + 32
                                    mem[_7529 + ceil32(return_data.size) + 32 len 32 * _7817] = mem[_7529 + _7673 + 32 len 32 * _7817]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7817:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7529 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5013:
                                        revert with 0, 17
                                    mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                    mem[_5017 + 132] = 0
                                    mem[_5017 + 164] = 160
                                    mem[_5017 + 260] = mem[_5017]
                                    idx = 0
                                    s = _5017 + 292
                                    t = _5017 + 32
                                    while idx < mem[_5017]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5017 + 196] = this.address
                                    mem[_5017 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7530 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7674 = mem[_7530]
                                    require mem[_7530] <= test266151307()
                                    require _7530 + mem[_7530] + 31 < _7530 + return_data.size
                                    _7818 = mem[_7530 + mem[_7530]]
                                    if mem[_7530 + mem[_7530]] > test266151307():
                                        revert with 0, 65
                                    if _7530 + ceil32(return_data.size) + ceil32(32 * mem[_7530 + mem[_7530]]) + 1 > test266151307() or ceil32(32 * mem[_7530 + mem[_7530]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7530 + ceil32(return_data.size) + ceil32(32 * mem[_7530 + mem[_7530]]) + 1
                                    mem[_7530 + ceil32(return_data.size)] = _7818
                                    require return_data.size >= _7674 + (32 * _7818) + 32
                                    mem[_7530 + ceil32(return_data.size) + 32 len 32 * _7818] = mem[_7530 + _7674 + 32 len 32 * _7818]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7818:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7530 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5013:
                                            revert with 0, 17
                                        mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                        mem[_5017 + 132] = 0
                                        mem[_5017 + 164] = 160
                                        mem[_5017 + 260] = mem[_5017]
                                        idx = 0
                                        s = _5017 + 292
                                        t = _5017 + 32
                                        while idx < mem[_5017]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5017 + 196] = this.address
                                        mem[_5017 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7531 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7675 = mem[_7531]
                                        require mem[_7531] <= test266151307()
                                        require _7531 + mem[_7531] + 31 < _7531 + return_data.size
                                        _7819 = mem[_7531 + mem[_7531]]
                                        if mem[_7531 + mem[_7531]] > test266151307():
                                            revert with 0, 65
                                        if _7531 + ceil32(return_data.size) + ceil32(32 * mem[_7531 + mem[_7531]]) + 1 > test266151307() or ceil32(32 * mem[_7531 + mem[_7531]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7531 + ceil32(return_data.size) + ceil32(32 * mem[_7531 + mem[_7531]]) + 1
                                        mem[_7531 + ceil32(return_data.size)] = _7819
                                        require return_data.size >= _7675 + (32 * _7819) + 32
                                        mem[_7531 + ceil32(return_data.size) + 32 len 32 * _7819] = mem[_7531 + _7675 + 32 len 32 * _7819]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _7819:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7531 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5013:
                                                revert with 0, 17
                                            mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                            mem[_5017 + 132] = 0
                                            mem[_5017 + 164] = 160
                                            mem[_5017 + 260] = mem[_5017]
                                            idx = 0
                                            s = _5017 + 292
                                            t = _5017 + 32
                                            while idx < mem[_5017]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5017 + 196] = this.address
                                            mem[_5017 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7532 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7676 = mem[_7532]
                                            require mem[_7532] <= test266151307()
                                            require _7532 + mem[_7532] + 31 < _7532 + return_data.size
                                            _7820 = mem[_7532 + mem[_7532]]
                                            if mem[_7532 + mem[_7532]] > test266151307():
                                                revert with 0, 65
                                            if _7532 + ceil32(return_data.size) + ceil32(32 * mem[_7532 + mem[_7532]]) + 1 > test266151307() or ceil32(32 * mem[_7532 + mem[_7532]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7532 + ceil32(return_data.size) + ceil32(32 * mem[_7532 + mem[_7532]]) + 1
                                            mem[_7532 + ceil32(return_data.size)] = _7820
                                            require return_data.size >= _7676 + (32 * _7820) + 32
                                            mem[_7532 + ceil32(return_data.size) + 32 len 32 * _7820] = mem[_7532 + _7676 + 32 len 32 * _7820]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7820:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7532 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5013:
                                                revert with 0, 17
                                            mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                            mem[_5017 + 132] = 0
                                            mem[_5017 + 164] = 160
                                            mem[_5017 + 260] = mem[_5017]
                                            idx = 0
                                            s = _5017 + 292
                                            t = _5017 + 32
                                            while idx < mem[_5017]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5017 + 196] = this.address
                                            mem[_5017 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7533 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7677 = mem[_7533]
                                            require mem[_7533] <= test266151307()
                                            require _7533 + mem[_7533] + 31 < _7533 + return_data.size
                                            _7821 = mem[_7533 + mem[_7533]]
                                            if mem[_7533 + mem[_7533]] > test266151307():
                                                revert with 0, 65
                                            if _7533 + ceil32(return_data.size) + ceil32(32 * mem[_7533 + mem[_7533]]) + 1 > test266151307() or ceil32(32 * mem[_7533 + mem[_7533]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7533 + ceil32(return_data.size) + ceil32(32 * mem[_7533 + mem[_7533]]) + 1
                                            mem[_7533 + ceil32(return_data.size)] = _7821
                                            require return_data.size >= _7677 + (32 * _7821) + 32
                                            mem[_7533 + ceil32(return_data.size) + 32 len 32 * _7821] = mem[_7533 + _7677 + 32 len 32 * _7821]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7821:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7533 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5013:
                                            revert with 0, 17
                                        mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                        mem[_5017 + 132] = 0
                                        mem[_5017 + 164] = 160
                                        mem[_5017 + 260] = mem[_5017]
                                        idx = 0
                                        s = _5017 + 292
                                        t = _5017 + 32
                                        while idx < mem[_5017]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5017 + 196] = this.address
                                        mem[_5017 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7534 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7678 = mem[_7534]
                                        require mem[_7534] <= test266151307()
                                        require _7534 + mem[_7534] + 31 < _7534 + return_data.size
                                        _7822 = mem[_7534 + mem[_7534]]
                                        if mem[_7534 + mem[_7534]] > test266151307():
                                            revert with 0, 65
                                        if _7534 + ceil32(return_data.size) + ceil32(32 * mem[_7534 + mem[_7534]]) + 1 > test266151307() or ceil32(32 * mem[_7534 + mem[_7534]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7534 + ceil32(return_data.size) + ceil32(32 * mem[_7534 + mem[_7534]]) + 1
                                        mem[_7534 + ceil32(return_data.size)] = _7822
                                        require return_data.size >= _7678 + (32 * _7822) + 32
                                        mem[_7534 + ceil32(return_data.size) + 32 len 32 * _7822] = mem[_7534 + _7678 + 32 len 32 * _7822]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _7822:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7534 + ceil32(return_data.size) + 64]
                                    else:
                                        if ext_call.return_data[0] > !_5013:
                                            revert with 0, 17
                                        mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                        mem[_5017 + 132] = 0
                                        mem[_5017 + 164] = 160
                                        mem[_5017 + 260] = mem[_5017]
                                        idx = 0
                                        s = _5017 + 292
                                        t = _5017 + 32
                                        while idx < mem[_5017]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5017 + 196] = this.address
                                        mem[_5017 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7535 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7679 = mem[_7535]
                                        require mem[_7535] <= test266151307()
                                        require _7535 + mem[_7535] + 31 < _7535 + return_data.size
                                        _7823 = mem[_7535 + mem[_7535]]
                                        if mem[_7535 + mem[_7535]] > test266151307():
                                            revert with 0, 65
                                        if _7535 + ceil32(return_data.size) + ceil32(32 * mem[_7535 + mem[_7535]]) + 1 > test266151307() or ceil32(32 * mem[_7535 + mem[_7535]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7535 + ceil32(return_data.size) + ceil32(32 * mem[_7535 + mem[_7535]]) + 1
                                        mem[_7535 + ceil32(return_data.size)] = _7823
                                        require return_data.size >= _7679 + (32 * _7823) + 32
                                        mem[_7535 + ceil32(return_data.size) + 32 len 32 * _7823] = mem[_7535 + _7679 + 32 len 32 * _7823]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _7823:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7535 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5013:
                                            revert with 0, 17
                                        mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                        mem[_5017 + 132] = 0
                                        mem[_5017 + 164] = 160
                                        mem[_5017 + 260] = mem[_5017]
                                        idx = 0
                                        s = _5017 + 292
                                        t = _5017 + 32
                                        while idx < mem[_5017]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5017 + 196] = this.address
                                        mem[_5017 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7536 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7680 = mem[_7536]
                                        require mem[_7536] <= test266151307()
                                        require _7536 + mem[_7536] + 31 < _7536 + return_data.size
                                        _7824 = mem[_7536 + mem[_7536]]
                                        if mem[_7536 + mem[_7536]] > test266151307():
                                            revert with 0, 65
                                        if _7536 + ceil32(return_data.size) + ceil32(32 * mem[_7536 + mem[_7536]]) + 1 > test266151307() or ceil32(32 * mem[_7536 + mem[_7536]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7536 + ceil32(return_data.size) + ceil32(32 * mem[_7536 + mem[_7536]]) + 1
                                        mem[_7536 + ceil32(return_data.size)] = _7824
                                        require return_data.size >= _7680 + (32 * _7824) + 32
                                        mem[_7536 + ceil32(return_data.size) + 32 len 32 * _7824] = mem[_7536 + _7680 + 32 len 32 * _7824]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _7824:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7536 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > !_5013:
                                                revert with 0, 17
                                            mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                            mem[_5017 + 132] = 0
                                            mem[_5017 + 164] = 160
                                            mem[_5017 + 260] = mem[_5017]
                                            idx = 0
                                            s = _5017 + 292
                                            t = _5017 + 32
                                            while idx < mem[_5017]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5017 + 196] = this.address
                                            mem[_5017 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7537 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7681 = mem[_7537]
                                            require mem[_7537] <= test266151307()
                                            require _7537 + mem[_7537] + 31 < _7537 + return_data.size
                                            _7825 = mem[_7537 + mem[_7537]]
                                            if mem[_7537 + mem[_7537]] > test266151307():
                                                revert with 0, 65
                                            if _7537 + ceil32(return_data.size) + ceil32(32 * mem[_7537 + mem[_7537]]) + 1 > test266151307() or ceil32(32 * mem[_7537 + mem[_7537]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7537 + ceil32(return_data.size) + ceil32(32 * mem[_7537 + mem[_7537]]) + 1
                                            mem[_7537 + ceil32(return_data.size)] = _7825
                                            require return_data.size >= _7681 + (32 * _7825) + 32
                                            mem[_7537 + ceil32(return_data.size) + 32 len 32 * _7825] = mem[_7537 + _7681 + 32 len 32 * _7825]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7825:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7537 + ceil32(return_data.size) + 64]
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > !_5013:
                                                    revert with 0, 17
                                                mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                                mem[_5017 + 132] = 0
                                                mem[_5017 + 164] = 160
                                                mem[_5017 + 260] = mem[_5017]
                                                idx = 0
                                                s = _5017 + 292
                                                t = _5017 + 32
                                                while idx < mem[_5017]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5017 + 196] = this.address
                                                mem[_5017 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7538 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7682 = mem[_7538]
                                                require mem[_7538] <= test266151307()
                                                require _7538 + mem[_7538] + 31 < _7538 + return_data.size
                                                _7826 = mem[_7538 + mem[_7538]]
                                                if mem[_7538 + mem[_7538]] > test266151307():
                                                    revert with 0, 65
                                                if _7538 + ceil32(return_data.size) + ceil32(32 * mem[_7538 + mem[_7538]]) + 1 > test266151307() or ceil32(32 * mem[_7538 + mem[_7538]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7538 + ceil32(return_data.size) + ceil32(32 * mem[_7538 + mem[_7538]]) + 1
                                                mem[_7538 + ceil32(return_data.size)] = _7826
                                                require return_data.size >= _7682 + (32 * _7826) + 32
                                                mem[_7538 + ceil32(return_data.size) + 32 len 32 * _7826] = mem[_7538 + _7682 + 32 len 32 * _7826]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _7826:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7538 + ceil32(return_data.size) + 64]
                                            else:
                                                if ext_call.return_data[0] > !_5013:
                                                    revert with 0, 17
                                                mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                                mem[_5017 + 132] = 0
                                                mem[_5017 + 164] = 160
                                                mem[_5017 + 260] = mem[_5017]
                                                idx = 0
                                                s = _5017 + 292
                                                t = _5017 + 32
                                                while idx < mem[_5017]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5017 + 196] = this.address
                                                mem[_5017 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7539 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7683 = mem[_7539]
                                                require mem[_7539] <= test266151307()
                                                require _7539 + mem[_7539] + 31 < _7539 + return_data.size
                                                _7827 = mem[_7539 + mem[_7539]]
                                                if mem[_7539 + mem[_7539]] > test266151307():
                                                    revert with 0, 65
                                                if _7539 + ceil32(return_data.size) + ceil32(32 * mem[_7539 + mem[_7539]]) + 1 > test266151307() or ceil32(32 * mem[_7539 + mem[_7539]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7539 + ceil32(return_data.size) + ceil32(32 * mem[_7539 + mem[_7539]]) + 1
                                                mem[_7539 + ceil32(return_data.size)] = _7827
                                                require return_data.size >= _7683 + (32 * _7827) + 32
                                                mem[_7539 + ceil32(return_data.size) + 32 len 32 * _7827] = mem[_7539 + _7683 + 32 len 32 * _7827]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _7827:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7539 + ceil32(return_data.size) + 64]
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5013:
                                                revert with 0, 17
                                            mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                            mem[_5017 + 132] = 0
                                            mem[_5017 + 164] = 160
                                            mem[_5017 + 260] = mem[_5017]
                                            idx = 0
                                            s = _5017 + 292
                                            t = _5017 + 32
                                            while idx < mem[_5017]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5017 + 196] = this.address
                                            mem[_5017 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7540 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7684 = mem[_7540]
                                            require mem[_7540] <= test266151307()
                                            require _7540 + mem[_7540] + 31 < _7540 + return_data.size
                                            _7828 = mem[_7540 + mem[_7540]]
                                            if mem[_7540 + mem[_7540]] > test266151307():
                                                revert with 0, 65
                                            if _7540 + ceil32(return_data.size) + ceil32(32 * mem[_7540 + mem[_7540]]) + 1 > test266151307() or ceil32(32 * mem[_7540 + mem[_7540]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7540 + ceil32(return_data.size) + ceil32(32 * mem[_7540 + mem[_7540]]) + 1
                                            mem[_7540 + ceil32(return_data.size)] = _7828
                                            require return_data.size >= _7684 + (32 * _7828) + 32
                                            mem[_7540 + ceil32(return_data.size) + 32 len 32 * _7828] = mem[_7540 + _7684 + 32 len 32 * _7828]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7828:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7540 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5013:
                                                revert with 0, 17
                                            mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                            mem[_5017 + 132] = 0
                                            mem[_5017 + 164] = 160
                                            mem[_5017 + 260] = mem[_5017]
                                            idx = 0
                                            s = _5017 + 292
                                            t = _5017 + 32
                                            while idx < mem[_5017]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5017 + 196] = this.address
                                            mem[_5017 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7541 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7685 = mem[_7541]
                                            require mem[_7541] <= test266151307()
                                            require _7541 + mem[_7541] + 31 < _7541 + return_data.size
                                            _7829 = mem[_7541 + mem[_7541]]
                                            if mem[_7541 + mem[_7541]] > test266151307():
                                                revert with 0, 65
                                            if _7541 + ceil32(return_data.size) + ceil32(32 * mem[_7541 + mem[_7541]]) + 1 > test266151307() or ceil32(32 * mem[_7541 + mem[_7541]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7541 + ceil32(return_data.size) + ceil32(32 * mem[_7541 + mem[_7541]]) + 1
                                            mem[_7541 + ceil32(return_data.size)] = _7829
                                            require return_data.size >= _7685 + (32 * _7829) + 32
                                            mem[_7541 + ceil32(return_data.size) + 32 len 32 * _7829] = mem[_7541 + _7685 + 32 len 32 * _7829]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7829:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7541 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5013:
                                                revert with 0, 17
                                            mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                            mem[_5017 + 132] = 0
                                            mem[_5017 + 164] = 160
                                            mem[_5017 + 260] = mem[_5017]
                                            idx = 0
                                            s = _5017 + 292
                                            t = _5017 + 32
                                            while idx < mem[_5017]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5017 + 196] = this.address
                                            mem[_5017 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7542 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7686 = mem[_7542]
                                            require mem[_7542] <= test266151307()
                                            require _7542 + mem[_7542] + 31 < _7542 + return_data.size
                                            _7830 = mem[_7542 + mem[_7542]]
                                            if mem[_7542 + mem[_7542]] > test266151307():
                                                revert with 0, 65
                                            if _7542 + ceil32(return_data.size) + ceil32(32 * mem[_7542 + mem[_7542]]) + 1 > test266151307() or ceil32(32 * mem[_7542 + mem[_7542]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7542 + ceil32(return_data.size) + ceil32(32 * mem[_7542 + mem[_7542]]) + 1
                                            mem[_7542 + ceil32(return_data.size)] = _7830
                                            require return_data.size >= _7686 + (32 * _7830) + 32
                                            mem[_7542 + ceil32(return_data.size) + 32 len 32 * _7830] = mem[_7542 + _7686 + 32 len 32 * _7830]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7830:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7542 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5013:
                                                    revert with 0, 17
                                                mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                                mem[_5017 + 132] = 0
                                                mem[_5017 + 164] = 160
                                                mem[_5017 + 260] = mem[_5017]
                                                idx = 0
                                                s = _5017 + 292
                                                t = _5017 + 32
                                                while idx < mem[_5017]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5017 + 196] = this.address
                                                mem[_5017 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7543 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7687 = mem[_7543]
                                                require mem[_7543] <= test266151307()
                                                require _7543 + mem[_7543] + 31 < _7543 + return_data.size
                                                _7831 = mem[_7543 + mem[_7543]]
                                                if mem[_7543 + mem[_7543]] > test266151307():
                                                    revert with 0, 65
                                                if _7543 + ceil32(return_data.size) + ceil32(32 * mem[_7543 + mem[_7543]]) + 1 > test266151307() or ceil32(32 * mem[_7543 + mem[_7543]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7543 + ceil32(return_data.size) + ceil32(32 * mem[_7543 + mem[_7543]]) + 1
                                                mem[_7543 + ceil32(return_data.size)] = _7831
                                                require return_data.size >= _7687 + (32 * _7831) + 32
                                                mem[_7543 + ceil32(return_data.size) + 32 len 32 * _7831] = mem[_7543 + _7687 + 32 len 32 * _7831]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _7831:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7543 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5013:
                                                        revert with 0, 17
                                                    mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                                    mem[_5017 + 132] = 0
                                                    mem[_5017 + 164] = 160
                                                    mem[_5017 + 260] = mem[_5017]
                                                    idx = 0
                                                    s = _5017 + 292
                                                    t = _5017 + 32
                                                    while idx < mem[_5017]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5017 + 196] = this.address
                                                    mem[_5017 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7544 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7688 = mem[_7544]
                                                    require mem[_7544] <= test266151307()
                                                    require _7544 + mem[_7544] + 31 < _7544 + return_data.size
                                                    _7832 = mem[_7544 + mem[_7544]]
                                                    if mem[_7544 + mem[_7544]] > test266151307():
                                                        revert with 0, 65
                                                    if _7544 + ceil32(return_data.size) + ceil32(32 * mem[_7544 + mem[_7544]]) + 1 > test266151307() or ceil32(32 * mem[_7544 + mem[_7544]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7544 + ceil32(return_data.size) + ceil32(32 * mem[_7544 + mem[_7544]]) + 1
                                                    mem[_7544 + ceil32(return_data.size)] = _7832
                                                    require return_data.size >= _7688 + (32 * _7832) + 32
                                                    mem[_7544 + ceil32(return_data.size) + 32 len 32 * _7832] = mem[_7544 + _7688 + 32 len 32 * _7832]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _7832:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7544 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5013:
                                                        revert with 0, 17
                                                    mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                                    mem[_5017 + 132] = 0
                                                    mem[_5017 + 164] = 160
                                                    mem[_5017 + 260] = mem[_5017]
                                                    idx = 0
                                                    s = _5017 + 292
                                                    t = _5017 + 32
                                                    while idx < mem[_5017]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5017 + 196] = this.address
                                                    mem[_5017 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7545 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7689 = mem[_7545]
                                                    require mem[_7545] <= test266151307()
                                                    require _7545 + mem[_7545] + 31 < _7545 + return_data.size
                                                    _7833 = mem[_7545 + mem[_7545]]
                                                    if mem[_7545 + mem[_7545]] > test266151307():
                                                        revert with 0, 65
                                                    if _7545 + ceil32(return_data.size) + ceil32(32 * mem[_7545 + mem[_7545]]) + 1 > test266151307() or ceil32(32 * mem[_7545 + mem[_7545]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7545 + ceil32(return_data.size) + ceil32(32 * mem[_7545 + mem[_7545]]) + 1
                                                    mem[_7545 + ceil32(return_data.size)] = _7833
                                                    require return_data.size >= _7689 + (32 * _7833) + 32
                                                    mem[_7545 + ceil32(return_data.size) + 32 len 32 * _7833] = mem[_7545 + _7689 + 32 len 32 * _7833]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _7833:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7545 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5013:
                                                revert with 0, 17
                                            mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                            mem[_5017 + 132] = 0
                                            mem[_5017 + 164] = 160
                                            mem[_5017 + 260] = mem[_5017]
                                            idx = 0
                                            s = _5017 + 292
                                            t = _5017 + 32
                                            while idx < mem[_5017]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5017 + 196] = this.address
                                            mem[_5017 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7546 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7690 = mem[_7546]
                                            require mem[_7546] <= test266151307()
                                            require _7546 + mem[_7546] + 31 < _7546 + return_data.size
                                            _7834 = mem[_7546 + mem[_7546]]
                                            if mem[_7546 + mem[_7546]] > test266151307():
                                                revert with 0, 65
                                            if _7546 + ceil32(return_data.size) + ceil32(32 * mem[_7546 + mem[_7546]]) + 1 > test266151307() or ceil32(32 * mem[_7546 + mem[_7546]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7546 + ceil32(return_data.size) + ceil32(32 * mem[_7546 + mem[_7546]]) + 1
                                            mem[_7546 + ceil32(return_data.size)] = _7834
                                            require return_data.size >= _7690 + (32 * _7834) + 32
                                            mem[_7546 + ceil32(return_data.size) + 32 len 32 * _7834] = mem[_7546 + _7690 + 32 len 32 * _7834]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7834:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7546 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5013:
                                                revert with 0, 17
                                            mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                            mem[_5017 + 132] = 0
                                            mem[_5017 + 164] = 160
                                            mem[_5017 + 260] = mem[_5017]
                                            idx = 0
                                            s = _5017 + 292
                                            t = _5017 + 32
                                            while idx < mem[_5017]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5017 + 196] = this.address
                                            mem[_5017 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7547 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7691 = mem[_7547]
                                            require mem[_7547] <= test266151307()
                                            require _7547 + mem[_7547] + 31 < _7547 + return_data.size
                                            _7835 = mem[_7547 + mem[_7547]]
                                            if mem[_7547 + mem[_7547]] > test266151307():
                                                revert with 0, 65
                                            if _7547 + ceil32(return_data.size) + ceil32(32 * mem[_7547 + mem[_7547]]) + 1 > test266151307() or ceil32(32 * mem[_7547 + mem[_7547]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7547 + ceil32(return_data.size) + ceil32(32 * mem[_7547 + mem[_7547]]) + 1
                                            mem[_7547 + ceil32(return_data.size)] = _7835
                                            require return_data.size >= _7691 + (32 * _7835) + 32
                                            mem[_7547 + ceil32(return_data.size) + 32 len 32 * _7835] = mem[_7547 + _7691 + 32 len 32 * _7835]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7835:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7547 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5013:
                                                revert with 0, 17
                                            mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                            mem[_5017 + 132] = 0
                                            mem[_5017 + 164] = 160
                                            mem[_5017 + 260] = mem[_5017]
                                            idx = 0
                                            s = _5017 + 292
                                            t = _5017 + 32
                                            while idx < mem[_5017]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5017 + 196] = this.address
                                            mem[_5017 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7548 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7692 = mem[_7548]
                                            require mem[_7548] <= test266151307()
                                            require _7548 + mem[_7548] + 31 < _7548 + return_data.size
                                            _7836 = mem[_7548 + mem[_7548]]
                                            if mem[_7548 + mem[_7548]] > test266151307():
                                                revert with 0, 65
                                            if _7548 + ceil32(return_data.size) + ceil32(32 * mem[_7548 + mem[_7548]]) + 1 > test266151307() or ceil32(32 * mem[_7548 + mem[_7548]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7548 + ceil32(return_data.size) + ceil32(32 * mem[_7548 + mem[_7548]]) + 1
                                            mem[_7548 + ceil32(return_data.size)] = _7836
                                            require return_data.size >= _7692 + (32 * _7836) + 32
                                            mem[_7548 + ceil32(return_data.size) + 32 len 32 * _7836] = mem[_7548 + _7692 + 32 len 32 * _7836]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7836:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7548 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5013:
                                                    revert with 0, 17
                                                mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                                mem[_5017 + 132] = 0
                                                mem[_5017 + 164] = 160
                                                mem[_5017 + 260] = mem[_5017]
                                                idx = 0
                                                s = _5017 + 292
                                                t = _5017 + 32
                                                while idx < mem[_5017]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5017 + 196] = this.address
                                                mem[_5017 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7549 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7693 = mem[_7549]
                                                require mem[_7549] <= test266151307()
                                                require _7549 + mem[_7549] + 31 < _7549 + return_data.size
                                                _7837 = mem[_7549 + mem[_7549]]
                                                if mem[_7549 + mem[_7549]] > test266151307():
                                                    revert with 0, 65
                                                if _7549 + ceil32(return_data.size) + ceil32(32 * mem[_7549 + mem[_7549]]) + 1 > test266151307() or ceil32(32 * mem[_7549 + mem[_7549]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7549 + ceil32(return_data.size) + ceil32(32 * mem[_7549 + mem[_7549]]) + 1
                                                mem[_7549 + ceil32(return_data.size)] = _7837
                                                require return_data.size >= _7693 + (32 * _7837) + 32
                                                mem[_7549 + ceil32(return_data.size) + 32 len 32 * _7837] = mem[_7549 + _7693 + 32 len 32 * _7837]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _7837:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7549 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5013:
                                                        revert with 0, 17
                                                    mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                                    mem[_5017 + 132] = 0
                                                    mem[_5017 + 164] = 160
                                                    mem[_5017 + 260] = mem[_5017]
                                                    idx = 0
                                                    s = _5017 + 292
                                                    t = _5017 + 32
                                                    while idx < mem[_5017]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5017 + 196] = this.address
                                                    mem[_5017 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7550 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7694 = mem[_7550]
                                                    require mem[_7550] <= test266151307()
                                                    require _7550 + mem[_7550] + 31 < _7550 + return_data.size
                                                    _7838 = mem[_7550 + mem[_7550]]
                                                    if mem[_7550 + mem[_7550]] > test266151307():
                                                        revert with 0, 65
                                                    if _7550 + ceil32(return_data.size) + ceil32(32 * mem[_7550 + mem[_7550]]) + 1 > test266151307() or ceil32(32 * mem[_7550 + mem[_7550]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7550 + ceil32(return_data.size) + ceil32(32 * mem[_7550 + mem[_7550]]) + 1
                                                    mem[_7550 + ceil32(return_data.size)] = _7838
                                                    require return_data.size >= _7694 + (32 * _7838) + 32
                                                    mem[_7550 + ceil32(return_data.size) + 32 len 32 * _7838] = mem[_7550 + _7694 + 32 len 32 * _7838]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _7838:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7550 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5013:
                                                        revert with 0, 17
                                                    mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                                    mem[_5017 + 132] = 0
                                                    mem[_5017 + 164] = 160
                                                    mem[_5017 + 260] = mem[_5017]
                                                    idx = 0
                                                    s = _5017 + 292
                                                    t = _5017 + 32
                                                    while idx < mem[_5017]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5017 + 196] = this.address
                                                    mem[_5017 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7551 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7695 = mem[_7551]
                                                    require mem[_7551] <= test266151307()
                                                    require _7551 + mem[_7551] + 31 < _7551 + return_data.size
                                                    _7839 = mem[_7551 + mem[_7551]]
                                                    if mem[_7551 + mem[_7551]] > test266151307():
                                                        revert with 0, 65
                                                    if _7551 + ceil32(return_data.size) + ceil32(32 * mem[_7551 + mem[_7551]]) + 1 > test266151307() or ceil32(32 * mem[_7551 + mem[_7551]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7551 + ceil32(return_data.size) + ceil32(32 * mem[_7551 + mem[_7551]]) + 1
                                                    mem[_7551 + ceil32(return_data.size)] = _7839
                                                    require return_data.size >= _7695 + (32 * _7839) + 32
                                                    mem[_7551 + ceil32(return_data.size) + 32 len 32 * _7839] = mem[_7551 + _7695 + 32 len 32 * _7839]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _7839:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7551 + ceil32(return_data.size) + 64]
            else:
                if wftmAddress == address(ext_call.return_data[0]):
                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 388
                    t = (4 * ceil32(return_data.size)) + 128
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2644 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _2675 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                        revert with 0, 65
                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                    require return_data.size >= _2644 + (32 * _2675) + 32
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2675] = mem[(4 * ceil32(return_data.size)) + _2644 + 224 len 32 * _2675]
                    if 1 >= _2675:
                        revert with 0, 50
                    _5014 = mem[(6 * ceil32(return_data.size)) + 256]
                    _5018 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_5018]:
                        revert with 0, 50
                    mem[_5018 + 32] = address(ext_call.return_data[0])
                    if 1 >= mem[_5018]:
                        revert with 0, 50
                    mem[_5018 + 64] = brushAddress
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5014:
                                        revert with 0, 17
                                    mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                    mem[_5018 + 132] = 0
                                    mem[_5018 + 164] = 160
                                    mem[_5018 + 260] = mem[_5018]
                                    idx = 0
                                    s = _5018 + 292
                                    t = _5018 + 32
                                    while idx < mem[_5018]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5018 + 196] = this.address
                                    mem[_5018 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7552 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7696 = mem[_7552]
                                    require mem[_7552] <= test266151307()
                                    require _7552 + mem[_7552] + 31 < _7552 + return_data.size
                                    _7840 = mem[_7552 + mem[_7552]]
                                    if mem[_7552 + mem[_7552]] > test266151307():
                                        revert with 0, 65
                                    if _7552 + ceil32(return_data.size) + ceil32(32 * mem[_7552 + mem[_7552]]) + 1 > test266151307() or ceil32(32 * mem[_7552 + mem[_7552]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7552 + ceil32(return_data.size) + ceil32(32 * mem[_7552 + mem[_7552]]) + 1
                                    mem[_7552 + ceil32(return_data.size)] = _7840
                                    require return_data.size >= _7696 + (32 * _7840) + 32
                                    mem[_7552 + ceil32(return_data.size) + 32 len 32 * _7840] = mem[_7552 + _7696 + 32 len 32 * _7840]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7840:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7552 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5014:
                                        revert with 0, 17
                                    mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                    mem[_5018 + 132] = 0
                                    mem[_5018 + 164] = 160
                                    mem[_5018 + 260] = mem[_5018]
                                    idx = 0
                                    s = _5018 + 292
                                    t = _5018 + 32
                                    while idx < mem[_5018]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5018 + 196] = this.address
                                    mem[_5018 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7553 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7697 = mem[_7553]
                                    require mem[_7553] <= test266151307()
                                    require _7553 + mem[_7553] + 31 < _7553 + return_data.size
                                    _7841 = mem[_7553 + mem[_7553]]
                                    if mem[_7553 + mem[_7553]] > test266151307():
                                        revert with 0, 65
                                    if _7553 + ceil32(return_data.size) + ceil32(32 * mem[_7553 + mem[_7553]]) + 1 > test266151307() or ceil32(32 * mem[_7553 + mem[_7553]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7553 + ceil32(return_data.size) + ceil32(32 * mem[_7553 + mem[_7553]]) + 1
                                    mem[_7553 + ceil32(return_data.size)] = _7841
                                    require return_data.size >= _7697 + (32 * _7841) + 32
                                    mem[_7553 + ceil32(return_data.size) + 32 len 32 * _7841] = mem[_7553 + _7697 + 32 len 32 * _7841]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7841:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7553 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5014:
                                        revert with 0, 17
                                    mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                    mem[_5018 + 132] = 0
                                    mem[_5018 + 164] = 160
                                    mem[_5018 + 260] = mem[_5018]
                                    idx = 0
                                    s = _5018 + 292
                                    t = _5018 + 32
                                    while idx < mem[_5018]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5018 + 196] = this.address
                                    mem[_5018 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7554 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7698 = mem[_7554]
                                    require mem[_7554] <= test266151307()
                                    require _7554 + mem[_7554] + 31 < _7554 + return_data.size
                                    _7842 = mem[_7554 + mem[_7554]]
                                    if mem[_7554 + mem[_7554]] > test266151307():
                                        revert with 0, 65
                                    if _7554 + ceil32(return_data.size) + ceil32(32 * mem[_7554 + mem[_7554]]) + 1 > test266151307() or ceil32(32 * mem[_7554 + mem[_7554]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7554 + ceil32(return_data.size) + ceil32(32 * mem[_7554 + mem[_7554]]) + 1
                                    mem[_7554 + ceil32(return_data.size)] = _7842
                                    require return_data.size >= _7698 + (32 * _7842) + 32
                                    mem[_7554 + ceil32(return_data.size) + 32 len 32 * _7842] = mem[_7554 + _7698 + 32 len 32 * _7842]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7842:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7554 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5014:
                                            revert with 0, 17
                                        mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                        mem[_5018 + 132] = 0
                                        mem[_5018 + 164] = 160
                                        mem[_5018 + 260] = mem[_5018]
                                        idx = 0
                                        s = _5018 + 292
                                        t = _5018 + 32
                                        while idx < mem[_5018]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5018 + 196] = this.address
                                        mem[_5018 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7555 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7699 = mem[_7555]
                                        require mem[_7555] <= test266151307()
                                        require _7555 + mem[_7555] + 31 < _7555 + return_data.size
                                        _7843 = mem[_7555 + mem[_7555]]
                                        if mem[_7555 + mem[_7555]] > test266151307():
                                            revert with 0, 65
                                        if _7555 + ceil32(return_data.size) + ceil32(32 * mem[_7555 + mem[_7555]]) + 1 > test266151307() or ceil32(32 * mem[_7555 + mem[_7555]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7555 + ceil32(return_data.size) + ceil32(32 * mem[_7555 + mem[_7555]]) + 1
                                        mem[_7555 + ceil32(return_data.size)] = _7843
                                        require return_data.size >= _7699 + (32 * _7843) + 32
                                        mem[_7555 + ceil32(return_data.size) + 32 len 32 * _7843] = mem[_7555 + _7699 + 32 len 32 * _7843]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _7843:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7555 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5014:
                                                revert with 0, 17
                                            mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                            mem[_5018 + 132] = 0
                                            mem[_5018 + 164] = 160
                                            mem[_5018 + 260] = mem[_5018]
                                            idx = 0
                                            s = _5018 + 292
                                            t = _5018 + 32
                                            while idx < mem[_5018]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5018 + 196] = this.address
                                            mem[_5018 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7556 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7700 = mem[_7556]
                                            require mem[_7556] <= test266151307()
                                            require _7556 + mem[_7556] + 31 < _7556 + return_data.size
                                            _7844 = mem[_7556 + mem[_7556]]
                                            if mem[_7556 + mem[_7556]] > test266151307():
                                                revert with 0, 65
                                            if _7556 + ceil32(return_data.size) + ceil32(32 * mem[_7556 + mem[_7556]]) + 1 > test266151307() or ceil32(32 * mem[_7556 + mem[_7556]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7556 + ceil32(return_data.size) + ceil32(32 * mem[_7556 + mem[_7556]]) + 1
                                            mem[_7556 + ceil32(return_data.size)] = _7844
                                            require return_data.size >= _7700 + (32 * _7844) + 32
                                            mem[_7556 + ceil32(return_data.size) + 32 len 32 * _7844] = mem[_7556 + _7700 + 32 len 32 * _7844]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7844:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7556 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5014:
                                                revert with 0, 17
                                            mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                            mem[_5018 + 132] = 0
                                            mem[_5018 + 164] = 160
                                            mem[_5018 + 260] = mem[_5018]
                                            idx = 0
                                            s = _5018 + 292
                                            t = _5018 + 32
                                            while idx < mem[_5018]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5018 + 196] = this.address
                                            mem[_5018 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7557 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7701 = mem[_7557]
                                            require mem[_7557] <= test266151307()
                                            require _7557 + mem[_7557] + 31 < _7557 + return_data.size
                                            _7845 = mem[_7557 + mem[_7557]]
                                            if mem[_7557 + mem[_7557]] > test266151307():
                                                revert with 0, 65
                                            if _7557 + ceil32(return_data.size) + ceil32(32 * mem[_7557 + mem[_7557]]) + 1 > test266151307() or ceil32(32 * mem[_7557 + mem[_7557]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7557 + ceil32(return_data.size) + ceil32(32 * mem[_7557 + mem[_7557]]) + 1
                                            mem[_7557 + ceil32(return_data.size)] = _7845
                                            require return_data.size >= _7701 + (32 * _7845) + 32
                                            mem[_7557 + ceil32(return_data.size) + 32 len 32 * _7845] = mem[_7557 + _7701 + 32 len 32 * _7845]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7845:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7557 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5014:
                                        revert with 0, 17
                                    mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                    mem[_5018 + 132] = 0
                                    mem[_5018 + 164] = 160
                                    mem[_5018 + 260] = mem[_5018]
                                    idx = 0
                                    s = _5018 + 292
                                    t = _5018 + 32
                                    while idx < mem[_5018]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5018 + 196] = this.address
                                    mem[_5018 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7558 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7702 = mem[_7558]
                                    require mem[_7558] <= test266151307()
                                    require _7558 + mem[_7558] + 31 < _7558 + return_data.size
                                    _7846 = mem[_7558 + mem[_7558]]
                                    if mem[_7558 + mem[_7558]] > test266151307():
                                        revert with 0, 65
                                    if _7558 + ceil32(return_data.size) + ceil32(32 * mem[_7558 + mem[_7558]]) + 1 > test266151307() or ceil32(32 * mem[_7558 + mem[_7558]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7558 + ceil32(return_data.size) + ceil32(32 * mem[_7558 + mem[_7558]]) + 1
                                    mem[_7558 + ceil32(return_data.size)] = _7846
                                    require return_data.size >= _7702 + (32 * _7846) + 32
                                    mem[_7558 + ceil32(return_data.size) + 32 len 32 * _7846] = mem[_7558 + _7702 + 32 len 32 * _7846]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7846:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7558 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5014:
                                        revert with 0, 17
                                    mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                    mem[_5018 + 132] = 0
                                    mem[_5018 + 164] = 160
                                    mem[_5018 + 260] = mem[_5018]
                                    idx = 0
                                    s = _5018 + 292
                                    t = _5018 + 32
                                    while idx < mem[_5018]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5018 + 196] = this.address
                                    mem[_5018 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7559 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7703 = mem[_7559]
                                    require mem[_7559] <= test266151307()
                                    require _7559 + mem[_7559] + 31 < _7559 + return_data.size
                                    _7847 = mem[_7559 + mem[_7559]]
                                    if mem[_7559 + mem[_7559]] > test266151307():
                                        revert with 0, 65
                                    if _7559 + ceil32(return_data.size) + ceil32(32 * mem[_7559 + mem[_7559]]) + 1 > test266151307() or ceil32(32 * mem[_7559 + mem[_7559]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7559 + ceil32(return_data.size) + ceil32(32 * mem[_7559 + mem[_7559]]) + 1
                                    mem[_7559 + ceil32(return_data.size)] = _7847
                                    require return_data.size >= _7703 + (32 * _7847) + 32
                                    mem[_7559 + ceil32(return_data.size) + 32 len 32 * _7847] = mem[_7559 + _7703 + 32 len 32 * _7847]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7847:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7559 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5014:
                                        revert with 0, 17
                                    mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                    mem[_5018 + 132] = 0
                                    mem[_5018 + 164] = 160
                                    mem[_5018 + 260] = mem[_5018]
                                    idx = 0
                                    s = _5018 + 292
                                    t = _5018 + 32
                                    while idx < mem[_5018]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5018 + 196] = this.address
                                    mem[_5018 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7560 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7704 = mem[_7560]
                                    require mem[_7560] <= test266151307()
                                    require _7560 + mem[_7560] + 31 < _7560 + return_data.size
                                    _7848 = mem[_7560 + mem[_7560]]
                                    if mem[_7560 + mem[_7560]] > test266151307():
                                        revert with 0, 65
                                    if _7560 + ceil32(return_data.size) + ceil32(32 * mem[_7560 + mem[_7560]]) + 1 > test266151307() or ceil32(32 * mem[_7560 + mem[_7560]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7560 + ceil32(return_data.size) + ceil32(32 * mem[_7560 + mem[_7560]]) + 1
                                    mem[_7560 + ceil32(return_data.size)] = _7848
                                    require return_data.size >= _7704 + (32 * _7848) + 32
                                    mem[_7560 + ceil32(return_data.size) + 32 len 32 * _7848] = mem[_7560 + _7704 + 32 len 32 * _7848]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7848:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7560 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5014:
                                            revert with 0, 17
                                        mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                        mem[_5018 + 132] = 0
                                        mem[_5018 + 164] = 160
                                        mem[_5018 + 260] = mem[_5018]
                                        idx = 0
                                        s = _5018 + 292
                                        t = _5018 + 32
                                        while idx < mem[_5018]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5018 + 196] = this.address
                                        mem[_5018 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7561 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7705 = mem[_7561]
                                        require mem[_7561] <= test266151307()
                                        require _7561 + mem[_7561] + 31 < _7561 + return_data.size
                                        _7849 = mem[_7561 + mem[_7561]]
                                        if mem[_7561 + mem[_7561]] > test266151307():
                                            revert with 0, 65
                                        if _7561 + ceil32(return_data.size) + ceil32(32 * mem[_7561 + mem[_7561]]) + 1 > test266151307() or ceil32(32 * mem[_7561 + mem[_7561]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7561 + ceil32(return_data.size) + ceil32(32 * mem[_7561 + mem[_7561]]) + 1
                                        mem[_7561 + ceil32(return_data.size)] = _7849
                                        require return_data.size >= _7705 + (32 * _7849) + 32
                                        mem[_7561 + ceil32(return_data.size) + 32 len 32 * _7849] = mem[_7561 + _7705 + 32 len 32 * _7849]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _7849:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7561 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5014:
                                                revert with 0, 17
                                            mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                            mem[_5018 + 132] = 0
                                            mem[_5018 + 164] = 160
                                            mem[_5018 + 260] = mem[_5018]
                                            idx = 0
                                            s = _5018 + 292
                                            t = _5018 + 32
                                            while idx < mem[_5018]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5018 + 196] = this.address
                                            mem[_5018 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7562 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7706 = mem[_7562]
                                            require mem[_7562] <= test266151307()
                                            require _7562 + mem[_7562] + 31 < _7562 + return_data.size
                                            _7850 = mem[_7562 + mem[_7562]]
                                            if mem[_7562 + mem[_7562]] > test266151307():
                                                revert with 0, 65
                                            if _7562 + ceil32(return_data.size) + ceil32(32 * mem[_7562 + mem[_7562]]) + 1 > test266151307() or ceil32(32 * mem[_7562 + mem[_7562]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7562 + ceil32(return_data.size) + ceil32(32 * mem[_7562 + mem[_7562]]) + 1
                                            mem[_7562 + ceil32(return_data.size)] = _7850
                                            require return_data.size >= _7706 + (32 * _7850) + 32
                                            mem[_7562 + ceil32(return_data.size) + 32 len 32 * _7850] = mem[_7562 + _7706 + 32 len 32 * _7850]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7850:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7562 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5014:
                                                revert with 0, 17
                                            mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                            mem[_5018 + 132] = 0
                                            mem[_5018 + 164] = 160
                                            mem[_5018 + 260] = mem[_5018]
                                            idx = 0
                                            s = _5018 + 292
                                            t = _5018 + 32
                                            while idx < mem[_5018]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5018 + 196] = this.address
                                            mem[_5018 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7563 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7707 = mem[_7563]
                                            require mem[_7563] <= test266151307()
                                            require _7563 + mem[_7563] + 31 < _7563 + return_data.size
                                            _7851 = mem[_7563 + mem[_7563]]
                                            if mem[_7563 + mem[_7563]] > test266151307():
                                                revert with 0, 65
                                            if _7563 + ceil32(return_data.size) + ceil32(32 * mem[_7563 + mem[_7563]]) + 1 > test266151307() or ceil32(32 * mem[_7563 + mem[_7563]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7563 + ceil32(return_data.size) + ceil32(32 * mem[_7563 + mem[_7563]]) + 1
                                            mem[_7563 + ceil32(return_data.size)] = _7851
                                            require return_data.size >= _7707 + (32 * _7851) + 32
                                            mem[_7563 + ceil32(return_data.size) + 32 len 32 * _7851] = mem[_7563 + _7707 + 32 len 32 * _7851]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7851:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7563 + ceil32(return_data.size) + 64]
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5014:
                                        revert with 0, 17
                                    mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                    mem[_5018 + 132] = 0
                                    mem[_5018 + 164] = 160
                                    mem[_5018 + 260] = mem[_5018]
                                    idx = 0
                                    s = _5018 + 292
                                    t = _5018 + 32
                                    while idx < mem[_5018]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5018 + 196] = this.address
                                    mem[_5018 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7564 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7708 = mem[_7564]
                                    require mem[_7564] <= test266151307()
                                    require _7564 + mem[_7564] + 31 < _7564 + return_data.size
                                    _7852 = mem[_7564 + mem[_7564]]
                                    if mem[_7564 + mem[_7564]] > test266151307():
                                        revert with 0, 65
                                    if _7564 + ceil32(return_data.size) + ceil32(32 * mem[_7564 + mem[_7564]]) + 1 > test266151307() or ceil32(32 * mem[_7564 + mem[_7564]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7564 + ceil32(return_data.size) + ceil32(32 * mem[_7564 + mem[_7564]]) + 1
                                    mem[_7564 + ceil32(return_data.size)] = _7852
                                    require return_data.size >= _7708 + (32 * _7852) + 32
                                    mem[_7564 + ceil32(return_data.size) + 32 len 32 * _7852] = mem[_7564 + _7708 + 32 len 32 * _7852]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7852:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7564 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5014:
                                        revert with 0, 17
                                    mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                    mem[_5018 + 132] = 0
                                    mem[_5018 + 164] = 160
                                    mem[_5018 + 260] = mem[_5018]
                                    idx = 0
                                    s = _5018 + 292
                                    t = _5018 + 32
                                    while idx < mem[_5018]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5018 + 196] = this.address
                                    mem[_5018 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7565 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7709 = mem[_7565]
                                    require mem[_7565] <= test266151307()
                                    require _7565 + mem[_7565] + 31 < _7565 + return_data.size
                                    _7853 = mem[_7565 + mem[_7565]]
                                    if mem[_7565 + mem[_7565]] > test266151307():
                                        revert with 0, 65
                                    if _7565 + ceil32(return_data.size) + ceil32(32 * mem[_7565 + mem[_7565]]) + 1 > test266151307() or ceil32(32 * mem[_7565 + mem[_7565]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7565 + ceil32(return_data.size) + ceil32(32 * mem[_7565 + mem[_7565]]) + 1
                                    mem[_7565 + ceil32(return_data.size)] = _7853
                                    require return_data.size >= _7709 + (32 * _7853) + 32
                                    mem[_7565 + ceil32(return_data.size) + 32 len 32 * _7853] = mem[_7565 + _7709 + 32 len 32 * _7853]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7853:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7565 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5014:
                                        revert with 0, 17
                                    mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                    mem[_5018 + 132] = 0
                                    mem[_5018 + 164] = 160
                                    mem[_5018 + 260] = mem[_5018]
                                    idx = 0
                                    s = _5018 + 292
                                    t = _5018 + 32
                                    while idx < mem[_5018]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5018 + 196] = this.address
                                    mem[_5018 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7566 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7710 = mem[_7566]
                                    require mem[_7566] <= test266151307()
                                    require _7566 + mem[_7566] + 31 < _7566 + return_data.size
                                    _7854 = mem[_7566 + mem[_7566]]
                                    if mem[_7566 + mem[_7566]] > test266151307():
                                        revert with 0, 65
                                    if _7566 + ceil32(return_data.size) + ceil32(32 * mem[_7566 + mem[_7566]]) + 1 > test266151307() or ceil32(32 * mem[_7566 + mem[_7566]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7566 + ceil32(return_data.size) + ceil32(32 * mem[_7566 + mem[_7566]]) + 1
                                    mem[_7566 + ceil32(return_data.size)] = _7854
                                    require return_data.size >= _7710 + (32 * _7854) + 32
                                    mem[_7566 + ceil32(return_data.size) + 32 len 32 * _7854] = mem[_7566 + _7710 + 32 len 32 * _7854]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7854:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7566 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5014:
                                            revert with 0, 17
                                        mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                        mem[_5018 + 132] = 0
                                        mem[_5018 + 164] = 160
                                        mem[_5018 + 260] = mem[_5018]
                                        idx = 0
                                        s = _5018 + 292
                                        t = _5018 + 32
                                        while idx < mem[_5018]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5018 + 196] = this.address
                                        mem[_5018 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7567 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7711 = mem[_7567]
                                        require mem[_7567] <= test266151307()
                                        require _7567 + mem[_7567] + 31 < _7567 + return_data.size
                                        _7855 = mem[_7567 + mem[_7567]]
                                        if mem[_7567 + mem[_7567]] > test266151307():
                                            revert with 0, 65
                                        if _7567 + ceil32(return_data.size) + ceil32(32 * mem[_7567 + mem[_7567]]) + 1 > test266151307() or ceil32(32 * mem[_7567 + mem[_7567]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7567 + ceil32(return_data.size) + ceil32(32 * mem[_7567 + mem[_7567]]) + 1
                                        mem[_7567 + ceil32(return_data.size)] = _7855
                                        require return_data.size >= _7711 + (32 * _7855) + 32
                                        mem[_7567 + ceil32(return_data.size) + 32 len 32 * _7855] = mem[_7567 + _7711 + 32 len 32 * _7855]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _7855:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7567 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5014:
                                                revert with 0, 17
                                            mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                            mem[_5018 + 132] = 0
                                            mem[_5018 + 164] = 160
                                            mem[_5018 + 260] = mem[_5018]
                                            idx = 0
                                            s = _5018 + 292
                                            t = _5018 + 32
                                            while idx < mem[_5018]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5018 + 196] = this.address
                                            mem[_5018 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7568 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7712 = mem[_7568]
                                            require mem[_7568] <= test266151307()
                                            require _7568 + mem[_7568] + 31 < _7568 + return_data.size
                                            _7856 = mem[_7568 + mem[_7568]]
                                            if mem[_7568 + mem[_7568]] > test266151307():
                                                revert with 0, 65
                                            if _7568 + ceil32(return_data.size) + ceil32(32 * mem[_7568 + mem[_7568]]) + 1 > test266151307() or ceil32(32 * mem[_7568 + mem[_7568]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7568 + ceil32(return_data.size) + ceil32(32 * mem[_7568 + mem[_7568]]) + 1
                                            mem[_7568 + ceil32(return_data.size)] = _7856
                                            require return_data.size >= _7712 + (32 * _7856) + 32
                                            mem[_7568 + ceil32(return_data.size) + 32 len 32 * _7856] = mem[_7568 + _7712 + 32 len 32 * _7856]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7856:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7568 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5014:
                                                revert with 0, 17
                                            mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                            mem[_5018 + 132] = 0
                                            mem[_5018 + 164] = 160
                                            mem[_5018 + 260] = mem[_5018]
                                            idx = 0
                                            s = _5018 + 292
                                            t = _5018 + 32
                                            while idx < mem[_5018]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5018 + 196] = this.address
                                            mem[_5018 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7569 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7713 = mem[_7569]
                                            require mem[_7569] <= test266151307()
                                            require _7569 + mem[_7569] + 31 < _7569 + return_data.size
                                            _7857 = mem[_7569 + mem[_7569]]
                                            if mem[_7569 + mem[_7569]] > test266151307():
                                                revert with 0, 65
                                            if _7569 + ceil32(return_data.size) + ceil32(32 * mem[_7569 + mem[_7569]]) + 1 > test266151307() or ceil32(32 * mem[_7569 + mem[_7569]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7569 + ceil32(return_data.size) + ceil32(32 * mem[_7569 + mem[_7569]]) + 1
                                            mem[_7569 + ceil32(return_data.size)] = _7857
                                            require return_data.size >= _7713 + (32 * _7857) + 32
                                            mem[_7569 + ceil32(return_data.size) + 32 len 32 * _7857] = mem[_7569 + _7713 + 32 len 32 * _7857]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7857:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7569 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5014:
                                            revert with 0, 17
                                        mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                        mem[_5018 + 132] = 0
                                        mem[_5018 + 164] = 160
                                        mem[_5018 + 260] = mem[_5018]
                                        idx = 0
                                        s = _5018 + 292
                                        t = _5018 + 32
                                        while idx < mem[_5018]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5018 + 196] = this.address
                                        mem[_5018 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7570 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7714 = mem[_7570]
                                        require mem[_7570] <= test266151307()
                                        require _7570 + mem[_7570] + 31 < _7570 + return_data.size
                                        _7858 = mem[_7570 + mem[_7570]]
                                        if mem[_7570 + mem[_7570]] > test266151307():
                                            revert with 0, 65
                                        if _7570 + ceil32(return_data.size) + ceil32(32 * mem[_7570 + mem[_7570]]) + 1 > test266151307() or ceil32(32 * mem[_7570 + mem[_7570]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7570 + ceil32(return_data.size) + ceil32(32 * mem[_7570 + mem[_7570]]) + 1
                                        mem[_7570 + ceil32(return_data.size)] = _7858
                                        require return_data.size >= _7714 + (32 * _7858) + 32
                                        mem[_7570 + ceil32(return_data.size) + 32 len 32 * _7858] = mem[_7570 + _7714 + 32 len 32 * _7858]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _7858:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7570 + ceil32(return_data.size) + 64]
                                    else:
                                        if ext_call.return_data[0] > !_5014:
                                            revert with 0, 17
                                        mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                        mem[_5018 + 132] = 0
                                        mem[_5018 + 164] = 160
                                        mem[_5018 + 260] = mem[_5018]
                                        idx = 0
                                        s = _5018 + 292
                                        t = _5018 + 32
                                        while idx < mem[_5018]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5018 + 196] = this.address
                                        mem[_5018 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7571 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7715 = mem[_7571]
                                        require mem[_7571] <= test266151307()
                                        require _7571 + mem[_7571] + 31 < _7571 + return_data.size
                                        _7859 = mem[_7571 + mem[_7571]]
                                        if mem[_7571 + mem[_7571]] > test266151307():
                                            revert with 0, 65
                                        if _7571 + ceil32(return_data.size) + ceil32(32 * mem[_7571 + mem[_7571]]) + 1 > test266151307() or ceil32(32 * mem[_7571 + mem[_7571]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7571 + ceil32(return_data.size) + ceil32(32 * mem[_7571 + mem[_7571]]) + 1
                                        mem[_7571 + ceil32(return_data.size)] = _7859
                                        require return_data.size >= _7715 + (32 * _7859) + 32
                                        mem[_7571 + ceil32(return_data.size) + 32 len 32 * _7859] = mem[_7571 + _7715 + 32 len 32 * _7859]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _7859:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7571 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5014:
                                            revert with 0, 17
                                        mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                        mem[_5018 + 132] = 0
                                        mem[_5018 + 164] = 160
                                        mem[_5018 + 260] = mem[_5018]
                                        idx = 0
                                        s = _5018 + 292
                                        t = _5018 + 32
                                        while idx < mem[_5018]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5018 + 196] = this.address
                                        mem[_5018 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7572 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7716 = mem[_7572]
                                        require mem[_7572] <= test266151307()
                                        require _7572 + mem[_7572] + 31 < _7572 + return_data.size
                                        _7860 = mem[_7572 + mem[_7572]]
                                        if mem[_7572 + mem[_7572]] > test266151307():
                                            revert with 0, 65
                                        if _7572 + ceil32(return_data.size) + ceil32(32 * mem[_7572 + mem[_7572]]) + 1 > test266151307() or ceil32(32 * mem[_7572 + mem[_7572]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7572 + ceil32(return_data.size) + ceil32(32 * mem[_7572 + mem[_7572]]) + 1
                                        mem[_7572 + ceil32(return_data.size)] = _7860
                                        require return_data.size >= _7716 + (32 * _7860) + 32
                                        mem[_7572 + ceil32(return_data.size) + 32 len 32 * _7860] = mem[_7572 + _7716 + 32 len 32 * _7860]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _7860:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7572 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > !_5014:
                                                revert with 0, 17
                                            mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                            mem[_5018 + 132] = 0
                                            mem[_5018 + 164] = 160
                                            mem[_5018 + 260] = mem[_5018]
                                            idx = 0
                                            s = _5018 + 292
                                            t = _5018 + 32
                                            while idx < mem[_5018]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5018 + 196] = this.address
                                            mem[_5018 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7573 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7717 = mem[_7573]
                                            require mem[_7573] <= test266151307()
                                            require _7573 + mem[_7573] + 31 < _7573 + return_data.size
                                            _7861 = mem[_7573 + mem[_7573]]
                                            if mem[_7573 + mem[_7573]] > test266151307():
                                                revert with 0, 65
                                            if _7573 + ceil32(return_data.size) + ceil32(32 * mem[_7573 + mem[_7573]]) + 1 > test266151307() or ceil32(32 * mem[_7573 + mem[_7573]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7573 + ceil32(return_data.size) + ceil32(32 * mem[_7573 + mem[_7573]]) + 1
                                            mem[_7573 + ceil32(return_data.size)] = _7861
                                            require return_data.size >= _7717 + (32 * _7861) + 32
                                            mem[_7573 + ceil32(return_data.size) + 32 len 32 * _7861] = mem[_7573 + _7717 + 32 len 32 * _7861]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7861:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7573 + ceil32(return_data.size) + 64]
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > !_5014:
                                                    revert with 0, 17
                                                mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                                mem[_5018 + 132] = 0
                                                mem[_5018 + 164] = 160
                                                mem[_5018 + 260] = mem[_5018]
                                                idx = 0
                                                s = _5018 + 292
                                                t = _5018 + 32
                                                while idx < mem[_5018]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5018 + 196] = this.address
                                                mem[_5018 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7574 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7718 = mem[_7574]
                                                require mem[_7574] <= test266151307()
                                                require _7574 + mem[_7574] + 31 < _7574 + return_data.size
                                                _7862 = mem[_7574 + mem[_7574]]
                                                if mem[_7574 + mem[_7574]] > test266151307():
                                                    revert with 0, 65
                                                if _7574 + ceil32(return_data.size) + ceil32(32 * mem[_7574 + mem[_7574]]) + 1 > test266151307() or ceil32(32 * mem[_7574 + mem[_7574]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7574 + ceil32(return_data.size) + ceil32(32 * mem[_7574 + mem[_7574]]) + 1
                                                mem[_7574 + ceil32(return_data.size)] = _7862
                                                require return_data.size >= _7718 + (32 * _7862) + 32
                                                mem[_7574 + ceil32(return_data.size) + 32 len 32 * _7862] = mem[_7574 + _7718 + 32 len 32 * _7862]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _7862:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7574 + ceil32(return_data.size) + 64]
                                            else:
                                                if ext_call.return_data[0] > !_5014:
                                                    revert with 0, 17
                                                mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                                mem[_5018 + 132] = 0
                                                mem[_5018 + 164] = 160
                                                mem[_5018 + 260] = mem[_5018]
                                                idx = 0
                                                s = _5018 + 292
                                                t = _5018 + 32
                                                while idx < mem[_5018]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5018 + 196] = this.address
                                                mem[_5018 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7575 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7719 = mem[_7575]
                                                require mem[_7575] <= test266151307()
                                                require _7575 + mem[_7575] + 31 < _7575 + return_data.size
                                                _7863 = mem[_7575 + mem[_7575]]
                                                if mem[_7575 + mem[_7575]] > test266151307():
                                                    revert with 0, 65
                                                if _7575 + ceil32(return_data.size) + ceil32(32 * mem[_7575 + mem[_7575]]) + 1 > test266151307() or ceil32(32 * mem[_7575 + mem[_7575]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7575 + ceil32(return_data.size) + ceil32(32 * mem[_7575 + mem[_7575]]) + 1
                                                mem[_7575 + ceil32(return_data.size)] = _7863
                                                require return_data.size >= _7719 + (32 * _7863) + 32
                                                mem[_7575 + ceil32(return_data.size) + 32 len 32 * _7863] = mem[_7575 + _7719 + 32 len 32 * _7863]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _7863:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7575 + ceil32(return_data.size) + 64]
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5014:
                                                revert with 0, 17
                                            mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                            mem[_5018 + 132] = 0
                                            mem[_5018 + 164] = 160
                                            mem[_5018 + 260] = mem[_5018]
                                            idx = 0
                                            s = _5018 + 292
                                            t = _5018 + 32
                                            while idx < mem[_5018]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5018 + 196] = this.address
                                            mem[_5018 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7576 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7720 = mem[_7576]
                                            require mem[_7576] <= test266151307()
                                            require _7576 + mem[_7576] + 31 < _7576 + return_data.size
                                            _7864 = mem[_7576 + mem[_7576]]
                                            if mem[_7576 + mem[_7576]] > test266151307():
                                                revert with 0, 65
                                            if _7576 + ceil32(return_data.size) + ceil32(32 * mem[_7576 + mem[_7576]]) + 1 > test266151307() or ceil32(32 * mem[_7576 + mem[_7576]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7576 + ceil32(return_data.size) + ceil32(32 * mem[_7576 + mem[_7576]]) + 1
                                            mem[_7576 + ceil32(return_data.size)] = _7864
                                            require return_data.size >= _7720 + (32 * _7864) + 32
                                            mem[_7576 + ceil32(return_data.size) + 32 len 32 * _7864] = mem[_7576 + _7720 + 32 len 32 * _7864]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7864:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7576 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5014:
                                                revert with 0, 17
                                            mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                            mem[_5018 + 132] = 0
                                            mem[_5018 + 164] = 160
                                            mem[_5018 + 260] = mem[_5018]
                                            idx = 0
                                            s = _5018 + 292
                                            t = _5018 + 32
                                            while idx < mem[_5018]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5018 + 196] = this.address
                                            mem[_5018 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7577 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7721 = mem[_7577]
                                            require mem[_7577] <= test266151307()
                                            require _7577 + mem[_7577] + 31 < _7577 + return_data.size
                                            _7865 = mem[_7577 + mem[_7577]]
                                            if mem[_7577 + mem[_7577]] > test266151307():
                                                revert with 0, 65
                                            if _7577 + ceil32(return_data.size) + ceil32(32 * mem[_7577 + mem[_7577]]) + 1 > test266151307() or ceil32(32 * mem[_7577 + mem[_7577]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7577 + ceil32(return_data.size) + ceil32(32 * mem[_7577 + mem[_7577]]) + 1
                                            mem[_7577 + ceil32(return_data.size)] = _7865
                                            require return_data.size >= _7721 + (32 * _7865) + 32
                                            mem[_7577 + ceil32(return_data.size) + 32 len 32 * _7865] = mem[_7577 + _7721 + 32 len 32 * _7865]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7865:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7577 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5014:
                                                revert with 0, 17
                                            mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                            mem[_5018 + 132] = 0
                                            mem[_5018 + 164] = 160
                                            mem[_5018 + 260] = mem[_5018]
                                            idx = 0
                                            s = _5018 + 292
                                            t = _5018 + 32
                                            while idx < mem[_5018]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5018 + 196] = this.address
                                            mem[_5018 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7578 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7722 = mem[_7578]
                                            require mem[_7578] <= test266151307()
                                            require _7578 + mem[_7578] + 31 < _7578 + return_data.size
                                            _7866 = mem[_7578 + mem[_7578]]
                                            if mem[_7578 + mem[_7578]] > test266151307():
                                                revert with 0, 65
                                            if _7578 + ceil32(return_data.size) + ceil32(32 * mem[_7578 + mem[_7578]]) + 1 > test266151307() or ceil32(32 * mem[_7578 + mem[_7578]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7578 + ceil32(return_data.size) + ceil32(32 * mem[_7578 + mem[_7578]]) + 1
                                            mem[_7578 + ceil32(return_data.size)] = _7866
                                            require return_data.size >= _7722 + (32 * _7866) + 32
                                            mem[_7578 + ceil32(return_data.size) + 32 len 32 * _7866] = mem[_7578 + _7722 + 32 len 32 * _7866]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7866:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7578 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5014:
                                                    revert with 0, 17
                                                mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                                mem[_5018 + 132] = 0
                                                mem[_5018 + 164] = 160
                                                mem[_5018 + 260] = mem[_5018]
                                                idx = 0
                                                s = _5018 + 292
                                                t = _5018 + 32
                                                while idx < mem[_5018]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5018 + 196] = this.address
                                                mem[_5018 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7579 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7723 = mem[_7579]
                                                require mem[_7579] <= test266151307()
                                                require _7579 + mem[_7579] + 31 < _7579 + return_data.size
                                                _7867 = mem[_7579 + mem[_7579]]
                                                if mem[_7579 + mem[_7579]] > test266151307():
                                                    revert with 0, 65
                                                if _7579 + ceil32(return_data.size) + ceil32(32 * mem[_7579 + mem[_7579]]) + 1 > test266151307() or ceil32(32 * mem[_7579 + mem[_7579]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7579 + ceil32(return_data.size) + ceil32(32 * mem[_7579 + mem[_7579]]) + 1
                                                mem[_7579 + ceil32(return_data.size)] = _7867
                                                require return_data.size >= _7723 + (32 * _7867) + 32
                                                mem[_7579 + ceil32(return_data.size) + 32 len 32 * _7867] = mem[_7579 + _7723 + 32 len 32 * _7867]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _7867:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7579 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5014:
                                                        revert with 0, 17
                                                    mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                                    mem[_5018 + 132] = 0
                                                    mem[_5018 + 164] = 160
                                                    mem[_5018 + 260] = mem[_5018]
                                                    idx = 0
                                                    s = _5018 + 292
                                                    t = _5018 + 32
                                                    while idx < mem[_5018]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5018 + 196] = this.address
                                                    mem[_5018 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7580 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7724 = mem[_7580]
                                                    require mem[_7580] <= test266151307()
                                                    require _7580 + mem[_7580] + 31 < _7580 + return_data.size
                                                    _7868 = mem[_7580 + mem[_7580]]
                                                    if mem[_7580 + mem[_7580]] > test266151307():
                                                        revert with 0, 65
                                                    if _7580 + ceil32(return_data.size) + ceil32(32 * mem[_7580 + mem[_7580]]) + 1 > test266151307() or ceil32(32 * mem[_7580 + mem[_7580]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7580 + ceil32(return_data.size) + ceil32(32 * mem[_7580 + mem[_7580]]) + 1
                                                    mem[_7580 + ceil32(return_data.size)] = _7868
                                                    require return_data.size >= _7724 + (32 * _7868) + 32
                                                    mem[_7580 + ceil32(return_data.size) + 32 len 32 * _7868] = mem[_7580 + _7724 + 32 len 32 * _7868]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _7868:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7580 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5014:
                                                        revert with 0, 17
                                                    mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                                    mem[_5018 + 132] = 0
                                                    mem[_5018 + 164] = 160
                                                    mem[_5018 + 260] = mem[_5018]
                                                    idx = 0
                                                    s = _5018 + 292
                                                    t = _5018 + 32
                                                    while idx < mem[_5018]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5018 + 196] = this.address
                                                    mem[_5018 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7581 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7725 = mem[_7581]
                                                    require mem[_7581] <= test266151307()
                                                    require _7581 + mem[_7581] + 31 < _7581 + return_data.size
                                                    _7869 = mem[_7581 + mem[_7581]]
                                                    if mem[_7581 + mem[_7581]] > test266151307():
                                                        revert with 0, 65
                                                    if _7581 + ceil32(return_data.size) + ceil32(32 * mem[_7581 + mem[_7581]]) + 1 > test266151307() or ceil32(32 * mem[_7581 + mem[_7581]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7581 + ceil32(return_data.size) + ceil32(32 * mem[_7581 + mem[_7581]]) + 1
                                                    mem[_7581 + ceil32(return_data.size)] = _7869
                                                    require return_data.size >= _7725 + (32 * _7869) + 32
                                                    mem[_7581 + ceil32(return_data.size) + 32 len 32 * _7869] = mem[_7581 + _7725 + 32 len 32 * _7869]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _7869:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7581 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5014:
                                                revert with 0, 17
                                            mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                            mem[_5018 + 132] = 0
                                            mem[_5018 + 164] = 160
                                            mem[_5018 + 260] = mem[_5018]
                                            idx = 0
                                            s = _5018 + 292
                                            t = _5018 + 32
                                            while idx < mem[_5018]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5018 + 196] = this.address
                                            mem[_5018 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7582 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7726 = mem[_7582]
                                            require mem[_7582] <= test266151307()
                                            require _7582 + mem[_7582] + 31 < _7582 + return_data.size
                                            _7870 = mem[_7582 + mem[_7582]]
                                            if mem[_7582 + mem[_7582]] > test266151307():
                                                revert with 0, 65
                                            if _7582 + ceil32(return_data.size) + ceil32(32 * mem[_7582 + mem[_7582]]) + 1 > test266151307() or ceil32(32 * mem[_7582 + mem[_7582]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7582 + ceil32(return_data.size) + ceil32(32 * mem[_7582 + mem[_7582]]) + 1
                                            mem[_7582 + ceil32(return_data.size)] = _7870
                                            require return_data.size >= _7726 + (32 * _7870) + 32
                                            mem[_7582 + ceil32(return_data.size) + 32 len 32 * _7870] = mem[_7582 + _7726 + 32 len 32 * _7870]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7870:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7582 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5014:
                                                revert with 0, 17
                                            mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                            mem[_5018 + 132] = 0
                                            mem[_5018 + 164] = 160
                                            mem[_5018 + 260] = mem[_5018]
                                            idx = 0
                                            s = _5018 + 292
                                            t = _5018 + 32
                                            while idx < mem[_5018]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5018 + 196] = this.address
                                            mem[_5018 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7583 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7727 = mem[_7583]
                                            require mem[_7583] <= test266151307()
                                            require _7583 + mem[_7583] + 31 < _7583 + return_data.size
                                            _7871 = mem[_7583 + mem[_7583]]
                                            if mem[_7583 + mem[_7583]] > test266151307():
                                                revert with 0, 65
                                            if _7583 + ceil32(return_data.size) + ceil32(32 * mem[_7583 + mem[_7583]]) + 1 > test266151307() or ceil32(32 * mem[_7583 + mem[_7583]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7583 + ceil32(return_data.size) + ceil32(32 * mem[_7583 + mem[_7583]]) + 1
                                            mem[_7583 + ceil32(return_data.size)] = _7871
                                            require return_data.size >= _7727 + (32 * _7871) + 32
                                            mem[_7583 + ceil32(return_data.size) + 32 len 32 * _7871] = mem[_7583 + _7727 + 32 len 32 * _7871]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7871:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7583 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5014:
                                                revert with 0, 17
                                            mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                            mem[_5018 + 132] = 0
                                            mem[_5018 + 164] = 160
                                            mem[_5018 + 260] = mem[_5018]
                                            idx = 0
                                            s = _5018 + 292
                                            t = _5018 + 32
                                            while idx < mem[_5018]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5018 + 196] = this.address
                                            mem[_5018 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7584 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7728 = mem[_7584]
                                            require mem[_7584] <= test266151307()
                                            require _7584 + mem[_7584] + 31 < _7584 + return_data.size
                                            _7872 = mem[_7584 + mem[_7584]]
                                            if mem[_7584 + mem[_7584]] > test266151307():
                                                revert with 0, 65
                                            if _7584 + ceil32(return_data.size) + ceil32(32 * mem[_7584 + mem[_7584]]) + 1 > test266151307() or ceil32(32 * mem[_7584 + mem[_7584]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7584 + ceil32(return_data.size) + ceil32(32 * mem[_7584 + mem[_7584]]) + 1
                                            mem[_7584 + ceil32(return_data.size)] = _7872
                                            require return_data.size >= _7728 + (32 * _7872) + 32
                                            mem[_7584 + ceil32(return_data.size) + 32 len 32 * _7872] = mem[_7584 + _7728 + 32 len 32 * _7872]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7872:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7584 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5014:
                                                    revert with 0, 17
                                                mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                                mem[_5018 + 132] = 0
                                                mem[_5018 + 164] = 160
                                                mem[_5018 + 260] = mem[_5018]
                                                idx = 0
                                                s = _5018 + 292
                                                t = _5018 + 32
                                                while idx < mem[_5018]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5018 + 196] = this.address
                                                mem[_5018 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7585 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7729 = mem[_7585]
                                                require mem[_7585] <= test266151307()
                                                require _7585 + mem[_7585] + 31 < _7585 + return_data.size
                                                _7873 = mem[_7585 + mem[_7585]]
                                                if mem[_7585 + mem[_7585]] > test266151307():
                                                    revert with 0, 65
                                                if _7585 + ceil32(return_data.size) + ceil32(32 * mem[_7585 + mem[_7585]]) + 1 > test266151307() or ceil32(32 * mem[_7585 + mem[_7585]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7585 + ceil32(return_data.size) + ceil32(32 * mem[_7585 + mem[_7585]]) + 1
                                                mem[_7585 + ceil32(return_data.size)] = _7873
                                                require return_data.size >= _7729 + (32 * _7873) + 32
                                                mem[_7585 + ceil32(return_data.size) + 32 len 32 * _7873] = mem[_7585 + _7729 + 32 len 32 * _7873]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _7873:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7585 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5014:
                                                        revert with 0, 17
                                                    mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                                    mem[_5018 + 132] = 0
                                                    mem[_5018 + 164] = 160
                                                    mem[_5018 + 260] = mem[_5018]
                                                    idx = 0
                                                    s = _5018 + 292
                                                    t = _5018 + 32
                                                    while idx < mem[_5018]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5018 + 196] = this.address
                                                    mem[_5018 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7586 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7730 = mem[_7586]
                                                    require mem[_7586] <= test266151307()
                                                    require _7586 + mem[_7586] + 31 < _7586 + return_data.size
                                                    _7874 = mem[_7586 + mem[_7586]]
                                                    if mem[_7586 + mem[_7586]] > test266151307():
                                                        revert with 0, 65
                                                    if _7586 + ceil32(return_data.size) + ceil32(32 * mem[_7586 + mem[_7586]]) + 1 > test266151307() or ceil32(32 * mem[_7586 + mem[_7586]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7586 + ceil32(return_data.size) + ceil32(32 * mem[_7586 + mem[_7586]]) + 1
                                                    mem[_7586 + ceil32(return_data.size)] = _7874
                                                    require return_data.size >= _7730 + (32 * _7874) + 32
                                                    mem[_7586 + ceil32(return_data.size) + 32 len 32 * _7874] = mem[_7586 + _7730 + 32 len 32 * _7874]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _7874:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7586 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5014:
                                                        revert with 0, 17
                                                    mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                                    mem[_5018 + 132] = 0
                                                    mem[_5018 + 164] = 160
                                                    mem[_5018 + 260] = mem[_5018]
                                                    idx = 0
                                                    s = _5018 + 292
                                                    t = _5018 + 32
                                                    while idx < mem[_5018]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5018 + 196] = this.address
                                                    mem[_5018 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7587 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7731 = mem[_7587]
                                                    require mem[_7587] <= test266151307()
                                                    require _7587 + mem[_7587] + 31 < _7587 + return_data.size
                                                    _7875 = mem[_7587 + mem[_7587]]
                                                    if mem[_7587 + mem[_7587]] > test266151307():
                                                        revert with 0, 65
                                                    if _7587 + ceil32(return_data.size) + ceil32(32 * mem[_7587 + mem[_7587]]) + 1 > test266151307() or ceil32(32 * mem[_7587 + mem[_7587]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7587 + ceil32(return_data.size) + ceil32(32 * mem[_7587 + mem[_7587]]) + 1
                                                    mem[_7587 + ceil32(return_data.size)] = _7875
                                                    require return_data.size >= _7731 + (32 * _7875) + 32
                                                    mem[_7587 + ceil32(return_data.size) + 32 len 32 * _7875] = mem[_7587 + _7731 + 32 len 32 * _7875]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _7875:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7587 + ceil32(return_data.size) + 64]
                else:
                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 388
                    t = (4 * ceil32(return_data.size)) + 128
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2645 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _2676 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                        revert with 0, 65
                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                    require return_data.size >= _2645 + (32 * _2676) + 32
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2676] = mem[(4 * ceil32(return_data.size)) + _2645 + 224 len 32 * _2676]
                    if 1 >= _2676:
                        revert with 0, 50
                    _5015 = mem[(6 * ceil32(return_data.size)) + 256]
                    _5019 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_5019]:
                        revert with 0, 50
                    mem[_5019 + 32] = address(ext_call.return_data[0])
                    if 1 >= mem[_5019]:
                        revert with 0, 50
                    mem[_5019 + 64] = brushAddress
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5015:
                                        revert with 0, 17
                                    mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                    mem[_5019 + 132] = 0
                                    mem[_5019 + 164] = 160
                                    mem[_5019 + 260] = mem[_5019]
                                    idx = 0
                                    s = _5019 + 292
                                    t = _5019 + 32
                                    while idx < mem[_5019]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5019 + 196] = this.address
                                    mem[_5019 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7588 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7732 = mem[_7588]
                                    require mem[_7588] <= test266151307()
                                    require _7588 + mem[_7588] + 31 < _7588 + return_data.size
                                    _7876 = mem[_7588 + mem[_7588]]
                                    if mem[_7588 + mem[_7588]] > test266151307():
                                        revert with 0, 65
                                    if _7588 + ceil32(return_data.size) + ceil32(32 * mem[_7588 + mem[_7588]]) + 1 > test266151307() or ceil32(32 * mem[_7588 + mem[_7588]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7588 + ceil32(return_data.size) + ceil32(32 * mem[_7588 + mem[_7588]]) + 1
                                    mem[_7588 + ceil32(return_data.size)] = _7876
                                    require return_data.size >= _7732 + (32 * _7876) + 32
                                    mem[_7588 + ceil32(return_data.size) + 32 len 32 * _7876] = mem[_7588 + _7732 + 32 len 32 * _7876]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7876:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7588 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5015:
                                        revert with 0, 17
                                    mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                    mem[_5019 + 132] = 0
                                    mem[_5019 + 164] = 160
                                    mem[_5019 + 260] = mem[_5019]
                                    idx = 0
                                    s = _5019 + 292
                                    t = _5019 + 32
                                    while idx < mem[_5019]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5019 + 196] = this.address
                                    mem[_5019 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7589 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7733 = mem[_7589]
                                    require mem[_7589] <= test266151307()
                                    require _7589 + mem[_7589] + 31 < _7589 + return_data.size
                                    _7877 = mem[_7589 + mem[_7589]]
                                    if mem[_7589 + mem[_7589]] > test266151307():
                                        revert with 0, 65
                                    if _7589 + ceil32(return_data.size) + ceil32(32 * mem[_7589 + mem[_7589]]) + 1 > test266151307() or ceil32(32 * mem[_7589 + mem[_7589]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7589 + ceil32(return_data.size) + ceil32(32 * mem[_7589 + mem[_7589]]) + 1
                                    mem[_7589 + ceil32(return_data.size)] = _7877
                                    require return_data.size >= _7733 + (32 * _7877) + 32
                                    mem[_7589 + ceil32(return_data.size) + 32 len 32 * _7877] = mem[_7589 + _7733 + 32 len 32 * _7877]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7877:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7589 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5015:
                                        revert with 0, 17
                                    mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                    mem[_5019 + 132] = 0
                                    mem[_5019 + 164] = 160
                                    mem[_5019 + 260] = mem[_5019]
                                    idx = 0
                                    s = _5019 + 292
                                    t = _5019 + 32
                                    while idx < mem[_5019]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5019 + 196] = this.address
                                    mem[_5019 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7590 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7734 = mem[_7590]
                                    require mem[_7590] <= test266151307()
                                    require _7590 + mem[_7590] + 31 < _7590 + return_data.size
                                    _7878 = mem[_7590 + mem[_7590]]
                                    if mem[_7590 + mem[_7590]] > test266151307():
                                        revert with 0, 65
                                    if _7590 + ceil32(return_data.size) + ceil32(32 * mem[_7590 + mem[_7590]]) + 1 > test266151307() or ceil32(32 * mem[_7590 + mem[_7590]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7590 + ceil32(return_data.size) + ceil32(32 * mem[_7590 + mem[_7590]]) + 1
                                    mem[_7590 + ceil32(return_data.size)] = _7878
                                    require return_data.size >= _7734 + (32 * _7878) + 32
                                    mem[_7590 + ceil32(return_data.size) + 32 len 32 * _7878] = mem[_7590 + _7734 + 32 len 32 * _7878]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7878:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7590 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5015:
                                            revert with 0, 17
                                        mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                        mem[_5019 + 132] = 0
                                        mem[_5019 + 164] = 160
                                        mem[_5019 + 260] = mem[_5019]
                                        idx = 0
                                        s = _5019 + 292
                                        t = _5019 + 32
                                        while idx < mem[_5019]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5019 + 196] = this.address
                                        mem[_5019 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7591 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7735 = mem[_7591]
                                        require mem[_7591] <= test266151307()
                                        require _7591 + mem[_7591] + 31 < _7591 + return_data.size
                                        _7879 = mem[_7591 + mem[_7591]]
                                        if mem[_7591 + mem[_7591]] > test266151307():
                                            revert with 0, 65
                                        if _7591 + ceil32(return_data.size) + ceil32(32 * mem[_7591 + mem[_7591]]) + 1 > test266151307() or ceil32(32 * mem[_7591 + mem[_7591]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7591 + ceil32(return_data.size) + ceil32(32 * mem[_7591 + mem[_7591]]) + 1
                                        mem[_7591 + ceil32(return_data.size)] = _7879
                                        require return_data.size >= _7735 + (32 * _7879) + 32
                                        mem[_7591 + ceil32(return_data.size) + 32 len 32 * _7879] = mem[_7591 + _7735 + 32 len 32 * _7879]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _7879:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7591 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5015:
                                                revert with 0, 17
                                            mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                            mem[_5019 + 132] = 0
                                            mem[_5019 + 164] = 160
                                            mem[_5019 + 260] = mem[_5019]
                                            idx = 0
                                            s = _5019 + 292
                                            t = _5019 + 32
                                            while idx < mem[_5019]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5019 + 196] = this.address
                                            mem[_5019 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7592 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7736 = mem[_7592]
                                            require mem[_7592] <= test266151307()
                                            require _7592 + mem[_7592] + 31 < _7592 + return_data.size
                                            _7880 = mem[_7592 + mem[_7592]]
                                            if mem[_7592 + mem[_7592]] > test266151307():
                                                revert with 0, 65
                                            if _7592 + ceil32(return_data.size) + ceil32(32 * mem[_7592 + mem[_7592]]) + 1 > test266151307() or ceil32(32 * mem[_7592 + mem[_7592]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7592 + ceil32(return_data.size) + ceil32(32 * mem[_7592 + mem[_7592]]) + 1
                                            mem[_7592 + ceil32(return_data.size)] = _7880
                                            require return_data.size >= _7736 + (32 * _7880) + 32
                                            mem[_7592 + ceil32(return_data.size) + 32 len 32 * _7880] = mem[_7592 + _7736 + 32 len 32 * _7880]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7880:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7592 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5015:
                                                revert with 0, 17
                                            mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                            mem[_5019 + 132] = 0
                                            mem[_5019 + 164] = 160
                                            mem[_5019 + 260] = mem[_5019]
                                            idx = 0
                                            s = _5019 + 292
                                            t = _5019 + 32
                                            while idx < mem[_5019]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5019 + 196] = this.address
                                            mem[_5019 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7593 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7737 = mem[_7593]
                                            require mem[_7593] <= test266151307()
                                            require _7593 + mem[_7593] + 31 < _7593 + return_data.size
                                            _7881 = mem[_7593 + mem[_7593]]
                                            if mem[_7593 + mem[_7593]] > test266151307():
                                                revert with 0, 65
                                            if _7593 + ceil32(return_data.size) + ceil32(32 * mem[_7593 + mem[_7593]]) + 1 > test266151307() or ceil32(32 * mem[_7593 + mem[_7593]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7593 + ceil32(return_data.size) + ceil32(32 * mem[_7593 + mem[_7593]]) + 1
                                            mem[_7593 + ceil32(return_data.size)] = _7881
                                            require return_data.size >= _7737 + (32 * _7881) + 32
                                            mem[_7593 + ceil32(return_data.size) + 32 len 32 * _7881] = mem[_7593 + _7737 + 32 len 32 * _7881]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7881:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7593 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5015:
                                        revert with 0, 17
                                    mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                    mem[_5019 + 132] = 0
                                    mem[_5019 + 164] = 160
                                    mem[_5019 + 260] = mem[_5019]
                                    idx = 0
                                    s = _5019 + 292
                                    t = _5019 + 32
                                    while idx < mem[_5019]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5019 + 196] = this.address
                                    mem[_5019 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7594 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7738 = mem[_7594]
                                    require mem[_7594] <= test266151307()
                                    require _7594 + mem[_7594] + 31 < _7594 + return_data.size
                                    _7882 = mem[_7594 + mem[_7594]]
                                    if mem[_7594 + mem[_7594]] > test266151307():
                                        revert with 0, 65
                                    if _7594 + ceil32(return_data.size) + ceil32(32 * mem[_7594 + mem[_7594]]) + 1 > test266151307() or ceil32(32 * mem[_7594 + mem[_7594]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7594 + ceil32(return_data.size) + ceil32(32 * mem[_7594 + mem[_7594]]) + 1
                                    mem[_7594 + ceil32(return_data.size)] = _7882
                                    require return_data.size >= _7738 + (32 * _7882) + 32
                                    mem[_7594 + ceil32(return_data.size) + 32 len 32 * _7882] = mem[_7594 + _7738 + 32 len 32 * _7882]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7882:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7594 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5015:
                                        revert with 0, 17
                                    mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                    mem[_5019 + 132] = 0
                                    mem[_5019 + 164] = 160
                                    mem[_5019 + 260] = mem[_5019]
                                    idx = 0
                                    s = _5019 + 292
                                    t = _5019 + 32
                                    while idx < mem[_5019]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5019 + 196] = this.address
                                    mem[_5019 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7595 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7739 = mem[_7595]
                                    require mem[_7595] <= test266151307()
                                    require _7595 + mem[_7595] + 31 < _7595 + return_data.size
                                    _7883 = mem[_7595 + mem[_7595]]
                                    if mem[_7595 + mem[_7595]] > test266151307():
                                        revert with 0, 65
                                    if _7595 + ceil32(return_data.size) + ceil32(32 * mem[_7595 + mem[_7595]]) + 1 > test266151307() or ceil32(32 * mem[_7595 + mem[_7595]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7595 + ceil32(return_data.size) + ceil32(32 * mem[_7595 + mem[_7595]]) + 1
                                    mem[_7595 + ceil32(return_data.size)] = _7883
                                    require return_data.size >= _7739 + (32 * _7883) + 32
                                    mem[_7595 + ceil32(return_data.size) + 32 len 32 * _7883] = mem[_7595 + _7739 + 32 len 32 * _7883]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7883:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7595 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5015:
                                        revert with 0, 17
                                    mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                    mem[_5019 + 132] = 0
                                    mem[_5019 + 164] = 160
                                    mem[_5019 + 260] = mem[_5019]
                                    idx = 0
                                    s = _5019 + 292
                                    t = _5019 + 32
                                    while idx < mem[_5019]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5019 + 196] = this.address
                                    mem[_5019 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7596 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7740 = mem[_7596]
                                    require mem[_7596] <= test266151307()
                                    require _7596 + mem[_7596] + 31 < _7596 + return_data.size
                                    _7884 = mem[_7596 + mem[_7596]]
                                    if mem[_7596 + mem[_7596]] > test266151307():
                                        revert with 0, 65
                                    if _7596 + ceil32(return_data.size) + ceil32(32 * mem[_7596 + mem[_7596]]) + 1 > test266151307() or ceil32(32 * mem[_7596 + mem[_7596]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7596 + ceil32(return_data.size) + ceil32(32 * mem[_7596 + mem[_7596]]) + 1
                                    mem[_7596 + ceil32(return_data.size)] = _7884
                                    require return_data.size >= _7740 + (32 * _7884) + 32
                                    mem[_7596 + ceil32(return_data.size) + 32 len 32 * _7884] = mem[_7596 + _7740 + 32 len 32 * _7884]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7884:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7596 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5015:
                                            revert with 0, 17
                                        mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                        mem[_5019 + 132] = 0
                                        mem[_5019 + 164] = 160
                                        mem[_5019 + 260] = mem[_5019]
                                        idx = 0
                                        s = _5019 + 292
                                        t = _5019 + 32
                                        while idx < mem[_5019]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5019 + 196] = this.address
                                        mem[_5019 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7597 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7741 = mem[_7597]
                                        require mem[_7597] <= test266151307()
                                        require _7597 + mem[_7597] + 31 < _7597 + return_data.size
                                        _7885 = mem[_7597 + mem[_7597]]
                                        if mem[_7597 + mem[_7597]] > test266151307():
                                            revert with 0, 65
                                        if _7597 + ceil32(return_data.size) + ceil32(32 * mem[_7597 + mem[_7597]]) + 1 > test266151307() or ceil32(32 * mem[_7597 + mem[_7597]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7597 + ceil32(return_data.size) + ceil32(32 * mem[_7597 + mem[_7597]]) + 1
                                        mem[_7597 + ceil32(return_data.size)] = _7885
                                        require return_data.size >= _7741 + (32 * _7885) + 32
                                        mem[_7597 + ceil32(return_data.size) + 32 len 32 * _7885] = mem[_7597 + _7741 + 32 len 32 * _7885]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _7885:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7597 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5015:
                                                revert with 0, 17
                                            mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                            mem[_5019 + 132] = 0
                                            mem[_5019 + 164] = 160
                                            mem[_5019 + 260] = mem[_5019]
                                            idx = 0
                                            s = _5019 + 292
                                            t = _5019 + 32
                                            while idx < mem[_5019]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5019 + 196] = this.address
                                            mem[_5019 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7598 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7742 = mem[_7598]
                                            require mem[_7598] <= test266151307()
                                            require _7598 + mem[_7598] + 31 < _7598 + return_data.size
                                            _7886 = mem[_7598 + mem[_7598]]
                                            if mem[_7598 + mem[_7598]] > test266151307():
                                                revert with 0, 65
                                            if _7598 + ceil32(return_data.size) + ceil32(32 * mem[_7598 + mem[_7598]]) + 1 > test266151307() or ceil32(32 * mem[_7598 + mem[_7598]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7598 + ceil32(return_data.size) + ceil32(32 * mem[_7598 + mem[_7598]]) + 1
                                            mem[_7598 + ceil32(return_data.size)] = _7886
                                            require return_data.size >= _7742 + (32 * _7886) + 32
                                            mem[_7598 + ceil32(return_data.size) + 32 len 32 * _7886] = mem[_7598 + _7742 + 32 len 32 * _7886]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7886:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7598 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5015:
                                                revert with 0, 17
                                            mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                            mem[_5019 + 132] = 0
                                            mem[_5019 + 164] = 160
                                            mem[_5019 + 260] = mem[_5019]
                                            idx = 0
                                            s = _5019 + 292
                                            t = _5019 + 32
                                            while idx < mem[_5019]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5019 + 196] = this.address
                                            mem[_5019 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7599 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7743 = mem[_7599]
                                            require mem[_7599] <= test266151307()
                                            require _7599 + mem[_7599] + 31 < _7599 + return_data.size
                                            _7887 = mem[_7599 + mem[_7599]]
                                            if mem[_7599 + mem[_7599]] > test266151307():
                                                revert with 0, 65
                                            if _7599 + ceil32(return_data.size) + ceil32(32 * mem[_7599 + mem[_7599]]) + 1 > test266151307() or ceil32(32 * mem[_7599 + mem[_7599]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7599 + ceil32(return_data.size) + ceil32(32 * mem[_7599 + mem[_7599]]) + 1
                                            mem[_7599 + ceil32(return_data.size)] = _7887
                                            require return_data.size >= _7743 + (32 * _7887) + 32
                                            mem[_7599 + ceil32(return_data.size) + 32 len 32 * _7887] = mem[_7599 + _7743 + 32 len 32 * _7887]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7887:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7599 + ceil32(return_data.size) + 64]
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5015:
                                        revert with 0, 17
                                    mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                    mem[_5019 + 132] = 0
                                    mem[_5019 + 164] = 160
                                    mem[_5019 + 260] = mem[_5019]
                                    idx = 0
                                    s = _5019 + 292
                                    t = _5019 + 32
                                    while idx < mem[_5019]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5019 + 196] = this.address
                                    mem[_5019 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7600 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7744 = mem[_7600]
                                    require mem[_7600] <= test266151307()
                                    require _7600 + mem[_7600] + 31 < _7600 + return_data.size
                                    _7888 = mem[_7600 + mem[_7600]]
                                    if mem[_7600 + mem[_7600]] > test266151307():
                                        revert with 0, 65
                                    if _7600 + ceil32(return_data.size) + ceil32(32 * mem[_7600 + mem[_7600]]) + 1 > test266151307() or ceil32(32 * mem[_7600 + mem[_7600]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7600 + ceil32(return_data.size) + ceil32(32 * mem[_7600 + mem[_7600]]) + 1
                                    mem[_7600 + ceil32(return_data.size)] = _7888
                                    require return_data.size >= _7744 + (32 * _7888) + 32
                                    mem[_7600 + ceil32(return_data.size) + 32 len 32 * _7888] = mem[_7600 + _7744 + 32 len 32 * _7888]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7888:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7600 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5015:
                                        revert with 0, 17
                                    mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                    mem[_5019 + 132] = 0
                                    mem[_5019 + 164] = 160
                                    mem[_5019 + 260] = mem[_5019]
                                    idx = 0
                                    s = _5019 + 292
                                    t = _5019 + 32
                                    while idx < mem[_5019]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5019 + 196] = this.address
                                    mem[_5019 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7601 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7745 = mem[_7601]
                                    require mem[_7601] <= test266151307()
                                    require _7601 + mem[_7601] + 31 < _7601 + return_data.size
                                    _7889 = mem[_7601 + mem[_7601]]
                                    if mem[_7601 + mem[_7601]] > test266151307():
                                        revert with 0, 65
                                    if _7601 + ceil32(return_data.size) + ceil32(32 * mem[_7601 + mem[_7601]]) + 1 > test266151307() or ceil32(32 * mem[_7601 + mem[_7601]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7601 + ceil32(return_data.size) + ceil32(32 * mem[_7601 + mem[_7601]]) + 1
                                    mem[_7601 + ceil32(return_data.size)] = _7889
                                    require return_data.size >= _7745 + (32 * _7889) + 32
                                    mem[_7601 + ceil32(return_data.size) + 32 len 32 * _7889] = mem[_7601 + _7745 + 32 len 32 * _7889]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7889:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7601 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5015:
                                        revert with 0, 17
                                    mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                    mem[_5019 + 132] = 0
                                    mem[_5019 + 164] = 160
                                    mem[_5019 + 260] = mem[_5019]
                                    idx = 0
                                    s = _5019 + 292
                                    t = _5019 + 32
                                    while idx < mem[_5019]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5019 + 196] = this.address
                                    mem[_5019 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7602 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7746 = mem[_7602]
                                    require mem[_7602] <= test266151307()
                                    require _7602 + mem[_7602] + 31 < _7602 + return_data.size
                                    _7890 = mem[_7602 + mem[_7602]]
                                    if mem[_7602 + mem[_7602]] > test266151307():
                                        revert with 0, 65
                                    if _7602 + ceil32(return_data.size) + ceil32(32 * mem[_7602 + mem[_7602]]) + 1 > test266151307() or ceil32(32 * mem[_7602 + mem[_7602]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7602 + ceil32(return_data.size) + ceil32(32 * mem[_7602 + mem[_7602]]) + 1
                                    mem[_7602 + ceil32(return_data.size)] = _7890
                                    require return_data.size >= _7746 + (32 * _7890) + 32
                                    mem[_7602 + ceil32(return_data.size) + 32 len 32 * _7890] = mem[_7602 + _7746 + 32 len 32 * _7890]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                    if 1 >= _7890:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7602 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5015:
                                            revert with 0, 17
                                        mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                        mem[_5019 + 132] = 0
                                        mem[_5019 + 164] = 160
                                        mem[_5019 + 260] = mem[_5019]
                                        idx = 0
                                        s = _5019 + 292
                                        t = _5019 + 32
                                        while idx < mem[_5019]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5019 + 196] = this.address
                                        mem[_5019 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7603 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7747 = mem[_7603]
                                        require mem[_7603] <= test266151307()
                                        require _7603 + mem[_7603] + 31 < _7603 + return_data.size
                                        _7891 = mem[_7603 + mem[_7603]]
                                        if mem[_7603 + mem[_7603]] > test266151307():
                                            revert with 0, 65
                                        if _7603 + ceil32(return_data.size) + ceil32(32 * mem[_7603 + mem[_7603]]) + 1 > test266151307() or ceil32(32 * mem[_7603 + mem[_7603]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7603 + ceil32(return_data.size) + ceil32(32 * mem[_7603 + mem[_7603]]) + 1
                                        mem[_7603 + ceil32(return_data.size)] = _7891
                                        require return_data.size >= _7747 + (32 * _7891) + 32
                                        mem[_7603 + ceil32(return_data.size) + 32 len 32 * _7891] = mem[_7603 + _7747 + 32 len 32 * _7891]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _7891:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7603 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5015:
                                                revert with 0, 17
                                            mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                            mem[_5019 + 132] = 0
                                            mem[_5019 + 164] = 160
                                            mem[_5019 + 260] = mem[_5019]
                                            idx = 0
                                            s = _5019 + 292
                                            t = _5019 + 32
                                            while idx < mem[_5019]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5019 + 196] = this.address
                                            mem[_5019 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7604 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7748 = mem[_7604]
                                            require mem[_7604] <= test266151307()
                                            require _7604 + mem[_7604] + 31 < _7604 + return_data.size
                                            _7892 = mem[_7604 + mem[_7604]]
                                            if mem[_7604 + mem[_7604]] > test266151307():
                                                revert with 0, 65
                                            if _7604 + ceil32(return_data.size) + ceil32(32 * mem[_7604 + mem[_7604]]) + 1 > test266151307() or ceil32(32 * mem[_7604 + mem[_7604]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7604 + ceil32(return_data.size) + ceil32(32 * mem[_7604 + mem[_7604]]) + 1
                                            mem[_7604 + ceil32(return_data.size)] = _7892
                                            require return_data.size >= _7748 + (32 * _7892) + 32
                                            mem[_7604 + ceil32(return_data.size) + 32 len 32 * _7892] = mem[_7604 + _7748 + 32 len 32 * _7892]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7892:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7604 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5015:
                                                revert with 0, 17
                                            mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                            mem[_5019 + 132] = 0
                                            mem[_5019 + 164] = 160
                                            mem[_5019 + 260] = mem[_5019]
                                            idx = 0
                                            s = _5019 + 292
                                            t = _5019 + 32
                                            while idx < mem[_5019]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5019 + 196] = this.address
                                            mem[_5019 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7605 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7749 = mem[_7605]
                                            require mem[_7605] <= test266151307()
                                            require _7605 + mem[_7605] + 31 < _7605 + return_data.size
                                            _7893 = mem[_7605 + mem[_7605]]
                                            if mem[_7605 + mem[_7605]] > test266151307():
                                                revert with 0, 65
                                            if _7605 + ceil32(return_data.size) + ceil32(32 * mem[_7605 + mem[_7605]]) + 1 > test266151307() or ceil32(32 * mem[_7605 + mem[_7605]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7605 + ceil32(return_data.size) + ceil32(32 * mem[_7605 + mem[_7605]]) + 1
                                            mem[_7605 + ceil32(return_data.size)] = _7893
                                            require return_data.size >= _7749 + (32 * _7893) + 32
                                            mem[_7605 + ceil32(return_data.size) + 32 len 32 * _7893] = mem[_7605 + _7749 + 32 len 32 * _7893]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7893:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7605 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5015:
                                            revert with 0, 17
                                        mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                        mem[_5019 + 132] = 0
                                        mem[_5019 + 164] = 160
                                        mem[_5019 + 260] = mem[_5019]
                                        idx = 0
                                        s = _5019 + 292
                                        t = _5019 + 32
                                        while idx < mem[_5019]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5019 + 196] = this.address
                                        mem[_5019 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7606 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7750 = mem[_7606]
                                        require mem[_7606] <= test266151307()
                                        require _7606 + mem[_7606] + 31 < _7606 + return_data.size
                                        _7894 = mem[_7606 + mem[_7606]]
                                        if mem[_7606 + mem[_7606]] > test266151307():
                                            revert with 0, 65
                                        if _7606 + ceil32(return_data.size) + ceil32(32 * mem[_7606 + mem[_7606]]) + 1 > test266151307() or ceil32(32 * mem[_7606 + mem[_7606]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7606 + ceil32(return_data.size) + ceil32(32 * mem[_7606 + mem[_7606]]) + 1
                                        mem[_7606 + ceil32(return_data.size)] = _7894
                                        require return_data.size >= _7750 + (32 * _7894) + 32
                                        mem[_7606 + ceil32(return_data.size) + 32 len 32 * _7894] = mem[_7606 + _7750 + 32 len 32 * _7894]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _7894:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7606 + ceil32(return_data.size) + 64]
                                    else:
                                        if ext_call.return_data[0] > !_5015:
                                            revert with 0, 17
                                        mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                        mem[_5019 + 132] = 0
                                        mem[_5019 + 164] = 160
                                        mem[_5019 + 260] = mem[_5019]
                                        idx = 0
                                        s = _5019 + 292
                                        t = _5019 + 32
                                        while idx < mem[_5019]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5019 + 196] = this.address
                                        mem[_5019 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7607 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7751 = mem[_7607]
                                        require mem[_7607] <= test266151307()
                                        require _7607 + mem[_7607] + 31 < _7607 + return_data.size
                                        _7895 = mem[_7607 + mem[_7607]]
                                        if mem[_7607 + mem[_7607]] > test266151307():
                                            revert with 0, 65
                                        if _7607 + ceil32(return_data.size) + ceil32(32 * mem[_7607 + mem[_7607]]) + 1 > test266151307() or ceil32(32 * mem[_7607 + mem[_7607]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7607 + ceil32(return_data.size) + ceil32(32 * mem[_7607 + mem[_7607]]) + 1
                                        mem[_7607 + ceil32(return_data.size)] = _7895
                                        require return_data.size >= _7751 + (32 * _7895) + 32
                                        mem[_7607 + ceil32(return_data.size) + 32 len 32 * _7895] = mem[_7607 + _7751 + 32 len 32 * _7895]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _7895:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7607 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5015:
                                            revert with 0, 17
                                        mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                        mem[_5019 + 132] = 0
                                        mem[_5019 + 164] = 160
                                        mem[_5019 + 260] = mem[_5019]
                                        idx = 0
                                        s = _5019 + 292
                                        t = _5019 + 32
                                        while idx < mem[_5019]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5019 + 196] = this.address
                                        mem[_5019 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7608 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7752 = mem[_7608]
                                        require mem[_7608] <= test266151307()
                                        require _7608 + mem[_7608] + 31 < _7608 + return_data.size
                                        _7896 = mem[_7608 + mem[_7608]]
                                        if mem[_7608 + mem[_7608]] > test266151307():
                                            revert with 0, 65
                                        if _7608 + ceil32(return_data.size) + ceil32(32 * mem[_7608 + mem[_7608]]) + 1 > test266151307() or ceil32(32 * mem[_7608 + mem[_7608]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7608 + ceil32(return_data.size) + ceil32(32 * mem[_7608 + mem[_7608]]) + 1
                                        mem[_7608 + ceil32(return_data.size)] = _7896
                                        require return_data.size >= _7752 + (32 * _7896) + 32
                                        mem[_7608 + ceil32(return_data.size) + 32 len 32 * _7896] = mem[_7608 + _7752 + 32 len 32 * _7896]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                        if 1 >= _7896:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7608 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > !_5015:
                                                revert with 0, 17
                                            mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                            mem[_5019 + 132] = 0
                                            mem[_5019 + 164] = 160
                                            mem[_5019 + 260] = mem[_5019]
                                            idx = 0
                                            s = _5019 + 292
                                            t = _5019 + 32
                                            while idx < mem[_5019]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5019 + 196] = this.address
                                            mem[_5019 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7609 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7753 = mem[_7609]
                                            require mem[_7609] <= test266151307()
                                            require _7609 + mem[_7609] + 31 < _7609 + return_data.size
                                            _7897 = mem[_7609 + mem[_7609]]
                                            if mem[_7609 + mem[_7609]] > test266151307():
                                                revert with 0, 65
                                            if _7609 + ceil32(return_data.size) + ceil32(32 * mem[_7609 + mem[_7609]]) + 1 > test266151307() or ceil32(32 * mem[_7609 + mem[_7609]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7609 + ceil32(return_data.size) + ceil32(32 * mem[_7609 + mem[_7609]]) + 1
                                            mem[_7609 + ceil32(return_data.size)] = _7897
                                            require return_data.size >= _7753 + (32 * _7897) + 32
                                            mem[_7609 + ceil32(return_data.size) + 32 len 32 * _7897] = mem[_7609 + _7753 + 32 len 32 * _7897]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7897:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7609 + ceil32(return_data.size) + 64]
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > !_5015:
                                                    revert with 0, 17
                                                mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                                mem[_5019 + 132] = 0
                                                mem[_5019 + 164] = 160
                                                mem[_5019 + 260] = mem[_5019]
                                                idx = 0
                                                s = _5019 + 292
                                                t = _5019 + 32
                                                while idx < mem[_5019]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5019 + 196] = this.address
                                                mem[_5019 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7610 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7754 = mem[_7610]
                                                require mem[_7610] <= test266151307()
                                                require _7610 + mem[_7610] + 31 < _7610 + return_data.size
                                                _7898 = mem[_7610 + mem[_7610]]
                                                if mem[_7610 + mem[_7610]] > test266151307():
                                                    revert with 0, 65
                                                if _7610 + ceil32(return_data.size) + ceil32(32 * mem[_7610 + mem[_7610]]) + 1 > test266151307() or ceil32(32 * mem[_7610 + mem[_7610]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7610 + ceil32(return_data.size) + ceil32(32 * mem[_7610 + mem[_7610]]) + 1
                                                mem[_7610 + ceil32(return_data.size)] = _7898
                                                require return_data.size >= _7754 + (32 * _7898) + 32
                                                mem[_7610 + ceil32(return_data.size) + 32 len 32 * _7898] = mem[_7610 + _7754 + 32 len 32 * _7898]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _7898:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7610 + ceil32(return_data.size) + 64]
                                            else:
                                                if ext_call.return_data[0] > !_5015:
                                                    revert with 0, 17
                                                mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                                mem[_5019 + 132] = 0
                                                mem[_5019 + 164] = 160
                                                mem[_5019 + 260] = mem[_5019]
                                                idx = 0
                                                s = _5019 + 292
                                                t = _5019 + 32
                                                while idx < mem[_5019]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5019 + 196] = this.address
                                                mem[_5019 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7611 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7755 = mem[_7611]
                                                require mem[_7611] <= test266151307()
                                                require _7611 + mem[_7611] + 31 < _7611 + return_data.size
                                                _7899 = mem[_7611 + mem[_7611]]
                                                if mem[_7611 + mem[_7611]] > test266151307():
                                                    revert with 0, 65
                                                if _7611 + ceil32(return_data.size) + ceil32(32 * mem[_7611 + mem[_7611]]) + 1 > test266151307() or ceil32(32 * mem[_7611 + mem[_7611]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7611 + ceil32(return_data.size) + ceil32(32 * mem[_7611 + mem[_7611]]) + 1
                                                mem[_7611 + ceil32(return_data.size)] = _7899
                                                require return_data.size >= _7755 + (32 * _7899) + 32
                                                mem[_7611 + ceil32(return_data.size) + 32 len 32 * _7899] = mem[_7611 + _7755 + 32 len 32 * _7899]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _7899:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7611 + ceil32(return_data.size) + 64]
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5015:
                                                revert with 0, 17
                                            mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                            mem[_5019 + 132] = 0
                                            mem[_5019 + 164] = 160
                                            mem[_5019 + 260] = mem[_5019]
                                            idx = 0
                                            s = _5019 + 292
                                            t = _5019 + 32
                                            while idx < mem[_5019]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5019 + 196] = this.address
                                            mem[_5019 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7612 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7756 = mem[_7612]
                                            require mem[_7612] <= test266151307()
                                            require _7612 + mem[_7612] + 31 < _7612 + return_data.size
                                            _7900 = mem[_7612 + mem[_7612]]
                                            if mem[_7612 + mem[_7612]] > test266151307():
                                                revert with 0, 65
                                            if _7612 + ceil32(return_data.size) + ceil32(32 * mem[_7612 + mem[_7612]]) + 1 > test266151307() or ceil32(32 * mem[_7612 + mem[_7612]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7612 + ceil32(return_data.size) + ceil32(32 * mem[_7612 + mem[_7612]]) + 1
                                            mem[_7612 + ceil32(return_data.size)] = _7900
                                            require return_data.size >= _7756 + (32 * _7900) + 32
                                            mem[_7612 + ceil32(return_data.size) + 32 len 32 * _7900] = mem[_7612 + _7756 + 32 len 32 * _7900]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7900:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7612 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5015:
                                                revert with 0, 17
                                            mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                            mem[_5019 + 132] = 0
                                            mem[_5019 + 164] = 160
                                            mem[_5019 + 260] = mem[_5019]
                                            idx = 0
                                            s = _5019 + 292
                                            t = _5019 + 32
                                            while idx < mem[_5019]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5019 + 196] = this.address
                                            mem[_5019 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7613 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7757 = mem[_7613]
                                            require mem[_7613] <= test266151307()
                                            require _7613 + mem[_7613] + 31 < _7613 + return_data.size
                                            _7901 = mem[_7613 + mem[_7613]]
                                            if mem[_7613 + mem[_7613]] > test266151307():
                                                revert with 0, 65
                                            if _7613 + ceil32(return_data.size) + ceil32(32 * mem[_7613 + mem[_7613]]) + 1 > test266151307() or ceil32(32 * mem[_7613 + mem[_7613]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7613 + ceil32(return_data.size) + ceil32(32 * mem[_7613 + mem[_7613]]) + 1
                                            mem[_7613 + ceil32(return_data.size)] = _7901
                                            require return_data.size >= _7757 + (32 * _7901) + 32
                                            mem[_7613 + ceil32(return_data.size) + 32 len 32 * _7901] = mem[_7613 + _7757 + 32 len 32 * _7901]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7901:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7613 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5015:
                                                revert with 0, 17
                                            mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                            mem[_5019 + 132] = 0
                                            mem[_5019 + 164] = 160
                                            mem[_5019 + 260] = mem[_5019]
                                            idx = 0
                                            s = _5019 + 292
                                            t = _5019 + 32
                                            while idx < mem[_5019]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5019 + 196] = this.address
                                            mem[_5019 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7614 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7758 = mem[_7614]
                                            require mem[_7614] <= test266151307()
                                            require _7614 + mem[_7614] + 31 < _7614 + return_data.size
                                            _7902 = mem[_7614 + mem[_7614]]
                                            if mem[_7614 + mem[_7614]] > test266151307():
                                                revert with 0, 65
                                            if _7614 + ceil32(return_data.size) + ceil32(32 * mem[_7614 + mem[_7614]]) + 1 > test266151307() or ceil32(32 * mem[_7614 + mem[_7614]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7614 + ceil32(return_data.size) + ceil32(32 * mem[_7614 + mem[_7614]]) + 1
                                            mem[_7614 + ceil32(return_data.size)] = _7902
                                            require return_data.size >= _7758 + (32 * _7902) + 32
                                            mem[_7614 + ceil32(return_data.size) + 32 len 32 * _7902] = mem[_7614 + _7758 + 32 len 32 * _7902]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7902:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7614 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5015:
                                                    revert with 0, 17
                                                mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                                mem[_5019 + 132] = 0
                                                mem[_5019 + 164] = 160
                                                mem[_5019 + 260] = mem[_5019]
                                                idx = 0
                                                s = _5019 + 292
                                                t = _5019 + 32
                                                while idx < mem[_5019]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5019 + 196] = this.address
                                                mem[_5019 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7615 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7759 = mem[_7615]
                                                require mem[_7615] <= test266151307()
                                                require _7615 + mem[_7615] + 31 < _7615 + return_data.size
                                                _7903 = mem[_7615 + mem[_7615]]
                                                if mem[_7615 + mem[_7615]] > test266151307():
                                                    revert with 0, 65
                                                if _7615 + ceil32(return_data.size) + ceil32(32 * mem[_7615 + mem[_7615]]) + 1 > test266151307() or ceil32(32 * mem[_7615 + mem[_7615]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7615 + ceil32(return_data.size) + ceil32(32 * mem[_7615 + mem[_7615]]) + 1
                                                mem[_7615 + ceil32(return_data.size)] = _7903
                                                require return_data.size >= _7759 + (32 * _7903) + 32
                                                mem[_7615 + ceil32(return_data.size) + 32 len 32 * _7903] = mem[_7615 + _7759 + 32 len 32 * _7903]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _7903:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7615 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5015:
                                                        revert with 0, 17
                                                    mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                                    mem[_5019 + 132] = 0
                                                    mem[_5019 + 164] = 160
                                                    mem[_5019 + 260] = mem[_5019]
                                                    idx = 0
                                                    s = _5019 + 292
                                                    t = _5019 + 32
                                                    while idx < mem[_5019]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5019 + 196] = this.address
                                                    mem[_5019 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7616 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7760 = mem[_7616]
                                                    require mem[_7616] <= test266151307()
                                                    require _7616 + mem[_7616] + 31 < _7616 + return_data.size
                                                    _7904 = mem[_7616 + mem[_7616]]
                                                    if mem[_7616 + mem[_7616]] > test266151307():
                                                        revert with 0, 65
                                                    if _7616 + ceil32(return_data.size) + ceil32(32 * mem[_7616 + mem[_7616]]) + 1 > test266151307() or ceil32(32 * mem[_7616 + mem[_7616]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7616 + ceil32(return_data.size) + ceil32(32 * mem[_7616 + mem[_7616]]) + 1
                                                    mem[_7616 + ceil32(return_data.size)] = _7904
                                                    require return_data.size >= _7760 + (32 * _7904) + 32
                                                    mem[_7616 + ceil32(return_data.size) + 32 len 32 * _7904] = mem[_7616 + _7760 + 32 len 32 * _7904]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _7904:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7616 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5015:
                                                        revert with 0, 17
                                                    mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                                    mem[_5019 + 132] = 0
                                                    mem[_5019 + 164] = 160
                                                    mem[_5019 + 260] = mem[_5019]
                                                    idx = 0
                                                    s = _5019 + 292
                                                    t = _5019 + 32
                                                    while idx < mem[_5019]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5019 + 196] = this.address
                                                    mem[_5019 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7617 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7761 = mem[_7617]
                                                    require mem[_7617] <= test266151307()
                                                    require _7617 + mem[_7617] + 31 < _7617 + return_data.size
                                                    _7905 = mem[_7617 + mem[_7617]]
                                                    if mem[_7617 + mem[_7617]] > test266151307():
                                                        revert with 0, 65
                                                    if _7617 + ceil32(return_data.size) + ceil32(32 * mem[_7617 + mem[_7617]]) + 1 > test266151307() or ceil32(32 * mem[_7617 + mem[_7617]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7617 + ceil32(return_data.size) + ceil32(32 * mem[_7617 + mem[_7617]]) + 1
                                                    mem[_7617 + ceil32(return_data.size)] = _7905
                                                    require return_data.size >= _7761 + (32 * _7905) + 32
                                                    mem[_7617 + ceil32(return_data.size) + 32 len 32 * _7905] = mem[_7617 + _7761 + 32 len 32 * _7905]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _7905:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7617 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5015:
                                                revert with 0, 17
                                            mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                            mem[_5019 + 132] = 0
                                            mem[_5019 + 164] = 160
                                            mem[_5019 + 260] = mem[_5019]
                                            idx = 0
                                            s = _5019 + 292
                                            t = _5019 + 32
                                            while idx < mem[_5019]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5019 + 196] = this.address
                                            mem[_5019 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7618 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7762 = mem[_7618]
                                            require mem[_7618] <= test266151307()
                                            require _7618 + mem[_7618] + 31 < _7618 + return_data.size
                                            _7906 = mem[_7618 + mem[_7618]]
                                            if mem[_7618 + mem[_7618]] > test266151307():
                                                revert with 0, 65
                                            if _7618 + ceil32(return_data.size) + ceil32(32 * mem[_7618 + mem[_7618]]) + 1 > test266151307() or ceil32(32 * mem[_7618 + mem[_7618]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7618 + ceil32(return_data.size) + ceil32(32 * mem[_7618 + mem[_7618]]) + 1
                                            mem[_7618 + ceil32(return_data.size)] = _7906
                                            require return_data.size >= _7762 + (32 * _7906) + 32
                                            mem[_7618 + ceil32(return_data.size) + 32 len 32 * _7906] = mem[_7618 + _7762 + 32 len 32 * _7906]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7906:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7618 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5015:
                                                revert with 0, 17
                                            mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                            mem[_5019 + 132] = 0
                                            mem[_5019 + 164] = 160
                                            mem[_5019 + 260] = mem[_5019]
                                            idx = 0
                                            s = _5019 + 292
                                            t = _5019 + 32
                                            while idx < mem[_5019]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5019 + 196] = this.address
                                            mem[_5019 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7619 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7763 = mem[_7619]
                                            require mem[_7619] <= test266151307()
                                            require _7619 + mem[_7619] + 31 < _7619 + return_data.size
                                            _7907 = mem[_7619 + mem[_7619]]
                                            if mem[_7619 + mem[_7619]] > test266151307():
                                                revert with 0, 65
                                            if _7619 + ceil32(return_data.size) + ceil32(32 * mem[_7619 + mem[_7619]]) + 1 > test266151307() or ceil32(32 * mem[_7619 + mem[_7619]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7619 + ceil32(return_data.size) + ceil32(32 * mem[_7619 + mem[_7619]]) + 1
                                            mem[_7619 + ceil32(return_data.size)] = _7907
                                            require return_data.size >= _7763 + (32 * _7907) + 32
                                            mem[_7619 + ceil32(return_data.size) + 32 len 32 * _7907] = mem[_7619 + _7763 + 32 len 32 * _7907]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7907:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7619 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5015:
                                                revert with 0, 17
                                            mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                            mem[_5019 + 132] = 0
                                            mem[_5019 + 164] = 160
                                            mem[_5019 + 260] = mem[_5019]
                                            idx = 0
                                            s = _5019 + 292
                                            t = _5019 + 32
                                            while idx < mem[_5019]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5019 + 196] = this.address
                                            mem[_5019 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7620 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7764 = mem[_7620]
                                            require mem[_7620] <= test266151307()
                                            require _7620 + mem[_7620] + 31 < _7620 + return_data.size
                                            _7908 = mem[_7620 + mem[_7620]]
                                            if mem[_7620 + mem[_7620]] > test266151307():
                                                revert with 0, 65
                                            if _7620 + ceil32(return_data.size) + ceil32(32 * mem[_7620 + mem[_7620]]) + 1 > test266151307() or ceil32(32 * mem[_7620 + mem[_7620]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7620 + ceil32(return_data.size) + ceil32(32 * mem[_7620 + mem[_7620]]) + 1
                                            mem[_7620 + ceil32(return_data.size)] = _7908
                                            require return_data.size >= _7764 + (32 * _7908) + 32
                                            mem[_7620 + ceil32(return_data.size) + 32 len 32 * _7908] = mem[_7620 + _7764 + 32 len 32 * _7908]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                            if 1 >= _7908:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7620 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5015:
                                                    revert with 0, 17
                                                mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                                mem[_5019 + 132] = 0
                                                mem[_5019 + 164] = 160
                                                mem[_5019 + 260] = mem[_5019]
                                                idx = 0
                                                s = _5019 + 292
                                                t = _5019 + 32
                                                while idx < mem[_5019]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5019 + 196] = this.address
                                                mem[_5019 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7621 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7765 = mem[_7621]
                                                require mem[_7621] <= test266151307()
                                                require _7621 + mem[_7621] + 31 < _7621 + return_data.size
                                                _7909 = mem[_7621 + mem[_7621]]
                                                if mem[_7621 + mem[_7621]] > test266151307():
                                                    revert with 0, 65
                                                if _7621 + ceil32(return_data.size) + ceil32(32 * mem[_7621 + mem[_7621]]) + 1 > test266151307() or ceil32(32 * mem[_7621 + mem[_7621]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7621 + ceil32(return_data.size) + ceil32(32 * mem[_7621 + mem[_7621]]) + 1
                                                mem[_7621 + ceil32(return_data.size)] = _7909
                                                require return_data.size >= _7765 + (32 * _7909) + 32
                                                mem[_7621 + ceil32(return_data.size) + 32 len 32 * _7909] = mem[_7621 + _7765 + 32 len 32 * _7909]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                if 1 >= _7909:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7621 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5015:
                                                        revert with 0, 17
                                                    mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                                    mem[_5019 + 132] = 0
                                                    mem[_5019 + 164] = 160
                                                    mem[_5019 + 260] = mem[_5019]
                                                    idx = 0
                                                    s = _5019 + 292
                                                    t = _5019 + 32
                                                    while idx < mem[_5019]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5019 + 196] = this.address
                                                    mem[_5019 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7622 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7766 = mem[_7622]
                                                    require mem[_7622] <= test266151307()
                                                    require _7622 + mem[_7622] + 31 < _7622 + return_data.size
                                                    _7910 = mem[_7622 + mem[_7622]]
                                                    if mem[_7622 + mem[_7622]] > test266151307():
                                                        revert with 0, 65
                                                    if _7622 + ceil32(return_data.size) + ceil32(32 * mem[_7622 + mem[_7622]]) + 1 > test266151307() or ceil32(32 * mem[_7622 + mem[_7622]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7622 + ceil32(return_data.size) + ceil32(32 * mem[_7622 + mem[_7622]]) + 1
                                                    mem[_7622 + ceil32(return_data.size)] = _7910
                                                    require return_data.size >= _7766 + (32 * _7910) + 32
                                                    mem[_7622 + ceil32(return_data.size) + 32 len 32 * _7910] = mem[_7622 + _7766 + 32 len 32 * _7910]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _7910:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7622 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5015:
                                                        revert with 0, 17
                                                    mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                                    mem[_5019 + 132] = 0
                                                    mem[_5019 + 164] = 160
                                                    mem[_5019 + 260] = mem[_5019]
                                                    idx = 0
                                                    s = _5019 + 292
                                                    t = _5019 + 32
                                                    while idx < mem[_5019]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5019 + 196] = this.address
                                                    mem[_5019 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7623 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7767 = mem[_7623]
                                                    require mem[_7623] <= test266151307()
                                                    require _7623 + mem[_7623] + 31 < _7623 + return_data.size
                                                    _7911 = mem[_7623 + mem[_7623]]
                                                    if mem[_7623 + mem[_7623]] > test266151307():
                                                        revert with 0, 65
                                                    if _7623 + ceil32(return_data.size) + ceil32(32 * mem[_7623 + mem[_7623]]) + 1 > test266151307() or ceil32(32 * mem[_7623 + mem[_7623]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7623 + ceil32(return_data.size) + ceil32(32 * mem[_7623 + mem[_7623]]) + 1
                                                    mem[_7623 + ceil32(return_data.size)] = _7911
                                                    require return_data.size >= _7767 + (32 * _7911) + 32
                                                    mem[_7623 + ceil32(return_data.size) + 32 len 32 * _7911] = mem[_7623 + _7767 + 32 len 32 * _7911]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < arg2:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] -= arg2
                                                    if 1 >= _7911:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7623 + ceil32(return_data.size) + 64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function buyBackAndBurnAll(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require maxBurnAndBuyBackAmounts[address(arg1)] > 0
    mem[0] = arg1
    mem[32] = 10
    require maxBurnAndBuyBackAmounts[address(arg1)] <= maxBurnAndBuyBackAmounts[address(arg1)]
    require ext_code.size(arg1)
    staticcall arg1.token0() with:
            gas gas_remaining wei
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(arg1)
    staticcall arg1.token1() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if 60 > !block.timestamp:
        revert with 0, 17
    mem[(2 * ceil32(return_data.size)) + 132] = address(ext_call.return_data[0])
    mem[(2 * ceil32(return_data.size)) + 164] = maxBurnAndBuyBackAmounts[address(arg1)]
    mem[(2 * ceil32(return_data.size)) + 196] = 0
    mem[(2 * ceil32(return_data.size)) + 228] = 0
    mem[(2 * ceil32(return_data.size)) + 260] = this.address
    mem[(2 * ceil32(return_data.size)) + 292] = block.timestamp + 60
    require ext_code.size(routerAddress)
    call routerAddress.removeLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, address rg6, uint256 rg7) with:
         gas gas_remaining wei
        args address(ext_call.return_data[0]), address(ext_call.return_data[0]), maxBurnAndBuyBackAmounts[address(arg1)], 0, 0, address(this.address), block.timestamp + 60
    mem[(2 * ceil32(return_data.size)) + 96 len 64] = ext_call.return_data[0 len 64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 64
    if 10000 > !block.timestamp:
        revert with 0, 17
    if brushAddress == address(ext_call.return_data[0]):
        mem[(4 * ceil32(return_data.size)) + 128] = address(ext_call.return_data[0])
        mem[(4 * ceil32(return_data.size)) + 160] = brushAddress
        if brushAddress == address(ext_call.return_data[0]):
            if ext_call.return_data[32] > -1:
                revert with 0, 17
            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
            mem[(4 * ceil32(return_data.size)) + 228] = 0
            mem[(4 * ceil32(return_data.size)) + 260] = 160
            mem[(4 * ceil32(return_data.size)) + 356] = 2
            idx = 0
            s = (4 * ceil32(return_data.size)) + 388
            t = (4 * ceil32(return_data.size)) + 128
            while idx < 2:
                mem[s] = mem[t + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(4 * ceil32(return_data.size)) + 292] = this.address
            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
            require ext_code.size(routerAddress)
            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (6 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _2618 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
            _2649 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                revert with 0, 65
            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                revert with 0, 65
            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
            require return_data.size >= _2618 + (32 * _2649) + 32
            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2649] = mem[(4 * ceil32(return_data.size)) + _2618 + 224 len 32 * _2649]
            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                revert with 0, 17
            maxBurnAndBuyBackAmounts[address(arg1)] = 0
            if 1 >= _2649:
                revert with 0, 50
        else:
            if wftmAddress == address(ext_call.return_data[0]):
                if ext_call.return_data[32] > -1:
                    revert with 0, 17
                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                mem[(4 * ceil32(return_data.size)) + 228] = 0
                mem[(4 * ceil32(return_data.size)) + 260] = 160
                mem[(4 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 388
                t = (4 * ceil32(return_data.size)) + 128
                while idx < 2:
                    mem[s] = mem[t + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                require ext_code.size(routerAddress)
                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _2616 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _2647 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                require return_data.size >= _2616 + (32 * _2647) + 32
                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2647] = mem[(4 * ceil32(return_data.size)) + _2616 + 224 len 32 * _2647]
                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                    revert with 0, 17
                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                if 1 >= _2647:
                    revert with 0, 50
            else:
                if ext_call.return_data[0] > -1:
                    revert with 0, 17
                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                mem[(4 * ceil32(return_data.size)) + 228] = 0
                mem[(4 * ceil32(return_data.size)) + 260] = 160
                mem[(4 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 388
                t = (4 * ceil32(return_data.size)) + 128
                while idx < 2:
                    mem[s] = mem[t + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                require ext_code.size(routerAddress)
                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                     gas gas_remaining wei
                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _2617 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                _2648 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                    revert with 0, 65
                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                require return_data.size >= _2617 + (32 * _2648) + 32
                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2648] = mem[(4 * ceil32(return_data.size)) + _2617 + 224 len 32 * _2648]
                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                    revert with 0, 17
                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                if 1 >= _2648:
                    revert with 0, 50
        require ext_code.size(brushAddress)
        call brushAddress.burn(uint256 rg1) with:
             gas gas_remaining wei
            args mem[(6 * ceil32(return_data.size)) + 256]
    else:
        if brushAddress == address(ext_call.return_data[0]):
            mem[(4 * ceil32(return_data.size)) + 128] = address(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 160] = brushAddress
            if brushAddress == address(ext_call.return_data[0]):
                if brushAddress != address(ext_call.return_data[0]):
                    if wftmAddress == address(ext_call.return_data[0]):
                        if ext_call.return_data[32] > -1:
                            revert with 0, 17
                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (4 * ceil32(return_data.size)) + 388
                        t = (4 * ceil32(return_data.size)) + 128
                        while idx < 2:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (6 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _2619 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                        _2650 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                            revert with 0, 65
                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                        require return_data.size >= _2619 + (32 * _2650) + 32
                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2650] = mem[(4 * ceil32(return_data.size)) + _2619 + 224 len 32 * _2650]
                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                            revert with 0, 17
                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                        if 1 >= _2650:
                            revert with 0, 50
                    else:
                        if ext_call.return_data[0] > -1:
                            revert with 0, 17
                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (4 * ceil32(return_data.size)) + 388
                        t = (4 * ceil32(return_data.size)) + 128
                        while idx < 2:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (6 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _2620 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                        _2651 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                            revert with 0, 65
                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                        require return_data.size >= _2620 + (32 * _2651) + 32
                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2651] = mem[(4 * ceil32(return_data.size)) + _2620 + 224 len 32 * _2651]
                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                            revert with 0, 17
                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                        if 1 >= _2651:
                            revert with 0, 50
                else:
                    if brushAddress == address(ext_call.return_data[0]):
                        if ext_call.return_data[32] > -1:
                            revert with 0, 17
                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (4 * ceil32(return_data.size)) + 388
                        t = (4 * ceil32(return_data.size)) + 128
                        while idx < 2:
                            mem[s] = mem[t + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (6 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _2621 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                        _2652 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                            revert with 0, 65
                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                            revert with 0, 65
                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                        require return_data.size >= _2621 + (32 * _2652) + 32
                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2652] = mem[(4 * ceil32(return_data.size)) + _2621 + 224 len 32 * _2652]
                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                            revert with 0, 17
                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                        if 1 >= _2652:
                            revert with 0, 50
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if ext_call.return_data[0] > -1:
                                revert with 0, 17
                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 388
                            t = (4 * ceil32(return_data.size)) + 128
                            while idx < 2:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _2622 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                            _2653 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                revert with 0, 65
                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                revert with 0, 65
                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                            require return_data.size >= _2622 + (32 * _2653) + 32
                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2653] = mem[(4 * ceil32(return_data.size)) + _2622 + 224 len 32 * _2653]
                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                revert with 0, 17
                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                            if 1 >= _2653:
                                revert with 0, 50
                        else:
                            if wftmAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2623 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _2654 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _2623 + (32 * _2654) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2654] = mem[(4 * ceil32(return_data.size)) + _2623 + 224 len 32 * _2654]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                if 1 >= _2654:
                                    revert with 0, 50
                            else:
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2624 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _2655 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _2624 + (32 * _2655) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2655] = mem[(4 * ceil32(return_data.size)) + _2624 + 224 len 32 * _2655]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                if 1 >= _2655:
                                    revert with 0, 50
            else:
                if brushAddress == address(ext_call.return_data[0]):
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if ext_call.return_data[32] > -1:
                                revert with 0, 17
                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 388
                            t = (4 * ceil32(return_data.size)) + 128
                            while idx < 2:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _2625 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                            _2656 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                revert with 0, 65
                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                revert with 0, 65
                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                            require return_data.size >= _2625 + (32 * _2656) + 32
                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2656] = mem[(4 * ceil32(return_data.size)) + _2625 + 224 len 32 * _2656]
                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                revert with 0, 17
                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                            if 1 >= _2656:
                                revert with 0, 50
                        else:
                            if ext_call.return_data[0] > -1:
                                revert with 0, 17
                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 388
                            t = (4 * ceil32(return_data.size)) + 128
                            while idx < 2:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _2626 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                            _2657 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                revert with 0, 65
                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                revert with 0, 65
                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                            require return_data.size >= _2626 + (32 * _2657) + 32
                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2657] = mem[(4 * ceil32(return_data.size)) + _2626 + 224 len 32 * _2657]
                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                revert with 0, 17
                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                            if 1 >= _2657:
                                revert with 0, 50
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if ext_call.return_data[32] > -1:
                                revert with 0, 17
                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                            mem[(4 * ceil32(return_data.size)) + 228] = 0
                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 388
                            t = (4 * ceil32(return_data.size)) + 128
                            while idx < 2:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 292] = this.address
                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _2627 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                            require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                            _2658 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                revert with 0, 65
                            if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                revert with 0, 65
                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                            mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                            require return_data.size >= _2627 + (32 * _2658) + 32
                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2658] = mem[(4 * ceil32(return_data.size)) + _2627 + 224 len 32 * _2658]
                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                revert with 0, 17
                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                            if 1 >= _2658:
                                revert with 0, 50
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2628 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _2659 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _2628 + (32 * _2659) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2659] = mem[(4 * ceil32(return_data.size)) + _2628 + 224 len 32 * _2659]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                if 1 >= _2659:
                                    revert with 0, 50
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _2629 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _2660 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                    require return_data.size >= _2629 + (32 * _2660) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2660] = mem[(4 * ceil32(return_data.size)) + _2629 + 224 len 32 * _2660]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _2660:
                                        revert with 0, 50
                                else:
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _2630 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _2661 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _2630 + (32 * _2661) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2661] = mem[(4 * ceil32(return_data.size)) + _2630 + 224 len 32 * _2661]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _2661:
                                        revert with 0, 50
                else:
                    if wftmAddress == address(ext_call.return_data[0]):
                        if brushAddress != address(ext_call.return_data[0]):
                            if wftmAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2631 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _2662 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _2631 + (32 * _2662) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2662] = mem[(4 * ceil32(return_data.size)) + _2631 + 224 len 32 * _2662]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                if 1 >= _2662:
                                    revert with 0, 50
                            else:
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2632 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _2663 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _2632 + (32 * _2663) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2663] = mem[(4 * ceil32(return_data.size)) + _2632 + 224 len 32 * _2663]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                if 1 >= _2663:
                                    revert with 0, 50
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2633 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _2664 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _2633 + (32 * _2664) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2664] = mem[(4 * ceil32(return_data.size)) + _2633 + 224 len 32 * _2664]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                if 1 >= _2664:
                                    revert with 0, 50
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _2634 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _2665 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _2634 + (32 * _2665) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2665] = mem[(4 * ceil32(return_data.size)) + _2634 + 224 len 32 * _2665]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _2665:
                                        revert with 0, 50
                                else:
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _2635 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _2666 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _2635 + (32 * _2666) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2666] = mem[(4 * ceil32(return_data.size)) + _2635 + 224 len 32 * _2666]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _2666:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _2636 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _2667 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _2636 + (32 * _2667) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2667] = mem[(4 * ceil32(return_data.size)) + _2636 + 224 len 32 * _2667]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _2667:
                                            revert with 0, 50
                    else:
                        if brushAddress != address(ext_call.return_data[0]):
                            if wftmAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2637 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _2668 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _2637 + (32 * _2668) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2668] = mem[(4 * ceil32(return_data.size)) + _2637 + 224 len 32 * _2668]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                if 1 >= _2668:
                                    revert with 0, 50
                            else:
                                if ext_call.return_data[0] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2638 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _2669 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                require return_data.size >= _2638 + (32 * _2669) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2669] = mem[(4 * ceil32(return_data.size)) + _2638 + 224 len 32 * _2669]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                if 1 >= _2669:
                                    revert with 0, 50
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if ext_call.return_data[32] > -1:
                                    revert with 0, 17
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 228] = 0
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 388
                                t = (4 * ceil32(return_data.size)) + 128
                                while idx < 2:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _2639 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                _2670 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                    revert with 0, 65
                                if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                                mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                require return_data.size >= _2639 + (32 * _2670) + 32
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2670] = mem[(4 * ceil32(return_data.size)) + _2639 + 224 len 32 * _2670]
                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                    revert with 0, 17
                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                if 1 >= _2670:
                                    revert with 0, 50
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[0] > -1:
                                        revert with 0, 17
                                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                                    idx = 0
                                    s = (4 * ceil32(return_data.size)) + 388
                                    t = (4 * ceil32(return_data.size)) + 128
                                    while idx < 2:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (6 * ceil32(return_data.size)) + 192
                                    require return_data.size >= 32
                                    _2640 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                    _2671 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                        revert with 0, 65
                                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                    require return_data.size >= _2640 + (32 * _2671) + 32
                                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2671] = mem[(4 * ceil32(return_data.size)) + _2640 + 224 len 32 * _2671]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _2671:
                                        revert with 0, 50
                                else:
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _2641 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _2672 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                                        require return_data.size >= _2641 + (32 * _2672) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2672] = mem[(4 * ceil32(return_data.size)) + _2641 + 224 len 32 * _2672]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _2672:
                                            revert with 0, 50
                                    else:
                                        if ext_call.return_data[0] > -1:
                                            revert with 0, 17
                                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                                        mem[(4 * ceil32(return_data.size)) + 228] = 0
                                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                                        idx = 0
                                        s = (4 * ceil32(return_data.size)) + 388
                                        t = (4 * ceil32(return_data.size)) + 128
                                        while idx < 2:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(4 * ceil32(return_data.size)) + 292] = this.address
                                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = (6 * ceil32(return_data.size)) + 192
                                        require return_data.size >= 32
                                        _2642 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                        require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                                        _2673 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                                            revert with 0, 65
                                        if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                                        mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                                        require return_data.size >= _2642 + (32 * _2673) + 32
                                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2673] = mem[(4 * ceil32(return_data.size)) + _2642 + 224 len 32 * _2673]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _2673:
                                            revert with 0, 50
            require ext_code.size(brushAddress)
            call brushAddress.burn(uint256 rg1) with:
                 gas gas_remaining wei
                args mem[(6 * ceil32(return_data.size)) + 256]
        else:
            mem[(4 * ceil32(return_data.size)) + 96] = 2
            mem[(4 * ceil32(return_data.size)) + 128] = address(ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 160] = wftmAddress
            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            if wftmAddress == address(ext_call.return_data[0]):
                if wftmAddress == address(ext_call.return_data[0]):
                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 388
                    t = (4 * ceil32(return_data.size)) + 128
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2643 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _2674 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                        revert with 0, 65
                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                    require return_data.size >= _2643 + (32 * _2674) + 32
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2674] = mem[(4 * ceil32(return_data.size)) + _2643 + 224 len 32 * _2674]
                    if 1 >= _2674:
                        revert with 0, 50
                    _5013 = mem[(6 * ceil32(return_data.size)) + 256]
                    _5017 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_5017]:
                        revert with 0, 50
                    mem[_5017 + 32] = address(ext_call.return_data[0])
                    if 1 >= mem[_5017]:
                        revert with 0, 50
                    mem[_5017 + 64] = brushAddress
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5013:
                                        revert with 0, 17
                                    mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                    mem[_5017 + 132] = 0
                                    mem[_5017 + 164] = 160
                                    mem[_5017 + 260] = mem[_5017]
                                    idx = 0
                                    s = _5017 + 292
                                    t = _5017 + 32
                                    while idx < mem[_5017]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5017 + 196] = this.address
                                    mem[_5017 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7481 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7625 = mem[_7481]
                                    require mem[_7481] <= test266151307()
                                    require _7481 + mem[_7481] + 31 < _7481 + return_data.size
                                    _7769 = mem[_7481 + mem[_7481]]
                                    if mem[_7481 + mem[_7481]] > test266151307():
                                        revert with 0, 65
                                    if _7481 + ceil32(return_data.size) + ceil32(32 * mem[_7481 + mem[_7481]]) + 1 > test266151307() or ceil32(32 * mem[_7481 + mem[_7481]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7481 + ceil32(return_data.size) + ceil32(32 * mem[_7481 + mem[_7481]]) + 1
                                    mem[_7481 + ceil32(return_data.size)] = _7769
                                    require return_data.size >= _7625 + (32 * _7769) + 32
                                    mem[_7481 + ceil32(return_data.size) + 32 len 32 * _7769] = mem[_7481 + _7625 + 32 len 32 * _7769]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7769:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7481 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5013:
                                        revert with 0, 17
                                    mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                    mem[_5017 + 132] = 0
                                    mem[_5017 + 164] = 160
                                    mem[_5017 + 260] = mem[_5017]
                                    idx = 0
                                    s = _5017 + 292
                                    t = _5017 + 32
                                    while idx < mem[_5017]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5017 + 196] = this.address
                                    mem[_5017 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7482 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7626 = mem[_7482]
                                    require mem[_7482] <= test266151307()
                                    require _7482 + mem[_7482] + 31 < _7482 + return_data.size
                                    _7770 = mem[_7482 + mem[_7482]]
                                    if mem[_7482 + mem[_7482]] > test266151307():
                                        revert with 0, 65
                                    if _7482 + ceil32(return_data.size) + ceil32(32 * mem[_7482 + mem[_7482]]) + 1 > test266151307() or ceil32(32 * mem[_7482 + mem[_7482]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7482 + ceil32(return_data.size) + ceil32(32 * mem[_7482 + mem[_7482]]) + 1
                                    mem[_7482 + ceil32(return_data.size)] = _7770
                                    require return_data.size >= _7626 + (32 * _7770) + 32
                                    mem[_7482 + ceil32(return_data.size) + 32 len 32 * _7770] = mem[_7482 + _7626 + 32 len 32 * _7770]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7770:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7482 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5013:
                                        revert with 0, 17
                                    mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                    mem[_5017 + 132] = 0
                                    mem[_5017 + 164] = 160
                                    mem[_5017 + 260] = mem[_5017]
                                    idx = 0
                                    s = _5017 + 292
                                    t = _5017 + 32
                                    while idx < mem[_5017]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5017 + 196] = this.address
                                    mem[_5017 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7483 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7627 = mem[_7483]
                                    require mem[_7483] <= test266151307()
                                    require _7483 + mem[_7483] + 31 < _7483 + return_data.size
                                    _7771 = mem[_7483 + mem[_7483]]
                                    if mem[_7483 + mem[_7483]] > test266151307():
                                        revert with 0, 65
                                    if _7483 + ceil32(return_data.size) + ceil32(32 * mem[_7483 + mem[_7483]]) + 1 > test266151307() or ceil32(32 * mem[_7483 + mem[_7483]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7483 + ceil32(return_data.size) + ceil32(32 * mem[_7483 + mem[_7483]]) + 1
                                    mem[_7483 + ceil32(return_data.size)] = _7771
                                    require return_data.size >= _7627 + (32 * _7771) + 32
                                    mem[_7483 + ceil32(return_data.size) + 32 len 32 * _7771] = mem[_7483 + _7627 + 32 len 32 * _7771]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7771:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7483 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5013:
                                            revert with 0, 17
                                        mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                        mem[_5017 + 132] = 0
                                        mem[_5017 + 164] = 160
                                        mem[_5017 + 260] = mem[_5017]
                                        idx = 0
                                        s = _5017 + 292
                                        t = _5017 + 32
                                        while idx < mem[_5017]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5017 + 196] = this.address
                                        mem[_5017 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7484 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7628 = mem[_7484]
                                        require mem[_7484] <= test266151307()
                                        require _7484 + mem[_7484] + 31 < _7484 + return_data.size
                                        _7772 = mem[_7484 + mem[_7484]]
                                        if mem[_7484 + mem[_7484]] > test266151307():
                                            revert with 0, 65
                                        if _7484 + ceil32(return_data.size) + ceil32(32 * mem[_7484 + mem[_7484]]) + 1 > test266151307() or ceil32(32 * mem[_7484 + mem[_7484]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7484 + ceil32(return_data.size) + ceil32(32 * mem[_7484 + mem[_7484]]) + 1
                                        mem[_7484 + ceil32(return_data.size)] = _7772
                                        require return_data.size >= _7628 + (32 * _7772) + 32
                                        mem[_7484 + ceil32(return_data.size) + 32 len 32 * _7772] = mem[_7484 + _7628 + 32 len 32 * _7772]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _7772:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7484 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5013:
                                                revert with 0, 17
                                            mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                            mem[_5017 + 132] = 0
                                            mem[_5017 + 164] = 160
                                            mem[_5017 + 260] = mem[_5017]
                                            idx = 0
                                            s = _5017 + 292
                                            t = _5017 + 32
                                            while idx < mem[_5017]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5017 + 196] = this.address
                                            mem[_5017 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7485 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7629 = mem[_7485]
                                            require mem[_7485] <= test266151307()
                                            require _7485 + mem[_7485] + 31 < _7485 + return_data.size
                                            _7773 = mem[_7485 + mem[_7485]]
                                            if mem[_7485 + mem[_7485]] > test266151307():
                                                revert with 0, 65
                                            if _7485 + ceil32(return_data.size) + ceil32(32 * mem[_7485 + mem[_7485]]) + 1 > test266151307() or ceil32(32 * mem[_7485 + mem[_7485]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7485 + ceil32(return_data.size) + ceil32(32 * mem[_7485 + mem[_7485]]) + 1
                                            mem[_7485 + ceil32(return_data.size)] = _7773
                                            require return_data.size >= _7629 + (32 * _7773) + 32
                                            mem[_7485 + ceil32(return_data.size) + 32 len 32 * _7773] = mem[_7485 + _7629 + 32 len 32 * _7773]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7773:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7485 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5013:
                                                revert with 0, 17
                                            mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                            mem[_5017 + 132] = 0
                                            mem[_5017 + 164] = 160
                                            mem[_5017 + 260] = mem[_5017]
                                            idx = 0
                                            s = _5017 + 292
                                            t = _5017 + 32
                                            while idx < mem[_5017]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5017 + 196] = this.address
                                            mem[_5017 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7486 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7630 = mem[_7486]
                                            require mem[_7486] <= test266151307()
                                            require _7486 + mem[_7486] + 31 < _7486 + return_data.size
                                            _7774 = mem[_7486 + mem[_7486]]
                                            if mem[_7486 + mem[_7486]] > test266151307():
                                                revert with 0, 65
                                            if _7486 + ceil32(return_data.size) + ceil32(32 * mem[_7486 + mem[_7486]]) + 1 > test266151307() or ceil32(32 * mem[_7486 + mem[_7486]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7486 + ceil32(return_data.size) + ceil32(32 * mem[_7486 + mem[_7486]]) + 1
                                            mem[_7486 + ceil32(return_data.size)] = _7774
                                            require return_data.size >= _7630 + (32 * _7774) + 32
                                            mem[_7486 + ceil32(return_data.size) + 32 len 32 * _7774] = mem[_7486 + _7630 + 32 len 32 * _7774]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7774:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7486 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5013:
                                        revert with 0, 17
                                    mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                    mem[_5017 + 132] = 0
                                    mem[_5017 + 164] = 160
                                    mem[_5017 + 260] = mem[_5017]
                                    idx = 0
                                    s = _5017 + 292
                                    t = _5017 + 32
                                    while idx < mem[_5017]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5017 + 196] = this.address
                                    mem[_5017 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7487 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7631 = mem[_7487]
                                    require mem[_7487] <= test266151307()
                                    require _7487 + mem[_7487] + 31 < _7487 + return_data.size
                                    _7775 = mem[_7487 + mem[_7487]]
                                    if mem[_7487 + mem[_7487]] > test266151307():
                                        revert with 0, 65
                                    if _7487 + ceil32(return_data.size) + ceil32(32 * mem[_7487 + mem[_7487]]) + 1 > test266151307() or ceil32(32 * mem[_7487 + mem[_7487]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7487 + ceil32(return_data.size) + ceil32(32 * mem[_7487 + mem[_7487]]) + 1
                                    mem[_7487 + ceil32(return_data.size)] = _7775
                                    require return_data.size >= _7631 + (32 * _7775) + 32
                                    mem[_7487 + ceil32(return_data.size) + 32 len 32 * _7775] = mem[_7487 + _7631 + 32 len 32 * _7775]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7775:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7487 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5013:
                                        revert with 0, 17
                                    mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                    mem[_5017 + 132] = 0
                                    mem[_5017 + 164] = 160
                                    mem[_5017 + 260] = mem[_5017]
                                    idx = 0
                                    s = _5017 + 292
                                    t = _5017 + 32
                                    while idx < mem[_5017]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5017 + 196] = this.address
                                    mem[_5017 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7488 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7632 = mem[_7488]
                                    require mem[_7488] <= test266151307()
                                    require _7488 + mem[_7488] + 31 < _7488 + return_data.size
                                    _7776 = mem[_7488 + mem[_7488]]
                                    if mem[_7488 + mem[_7488]] > test266151307():
                                        revert with 0, 65
                                    if _7488 + ceil32(return_data.size) + ceil32(32 * mem[_7488 + mem[_7488]]) + 1 > test266151307() or ceil32(32 * mem[_7488 + mem[_7488]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7488 + ceil32(return_data.size) + ceil32(32 * mem[_7488 + mem[_7488]]) + 1
                                    mem[_7488 + ceil32(return_data.size)] = _7776
                                    require return_data.size >= _7632 + (32 * _7776) + 32
                                    mem[_7488 + ceil32(return_data.size) + 32 len 32 * _7776] = mem[_7488 + _7632 + 32 len 32 * _7776]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7776:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7488 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5013:
                                        revert with 0, 17
                                    mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                    mem[_5017 + 132] = 0
                                    mem[_5017 + 164] = 160
                                    mem[_5017 + 260] = mem[_5017]
                                    idx = 0
                                    s = _5017 + 292
                                    t = _5017 + 32
                                    while idx < mem[_5017]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5017 + 196] = this.address
                                    mem[_5017 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7489 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7633 = mem[_7489]
                                    require mem[_7489] <= test266151307()
                                    require _7489 + mem[_7489] + 31 < _7489 + return_data.size
                                    _7777 = mem[_7489 + mem[_7489]]
                                    if mem[_7489 + mem[_7489]] > test266151307():
                                        revert with 0, 65
                                    if _7489 + ceil32(return_data.size) + ceil32(32 * mem[_7489 + mem[_7489]]) + 1 > test266151307() or ceil32(32 * mem[_7489 + mem[_7489]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7489 + ceil32(return_data.size) + ceil32(32 * mem[_7489 + mem[_7489]]) + 1
                                    mem[_7489 + ceil32(return_data.size)] = _7777
                                    require return_data.size >= _7633 + (32 * _7777) + 32
                                    mem[_7489 + ceil32(return_data.size) + 32 len 32 * _7777] = mem[_7489 + _7633 + 32 len 32 * _7777]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7777:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7489 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5013:
                                            revert with 0, 17
                                        mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                        mem[_5017 + 132] = 0
                                        mem[_5017 + 164] = 160
                                        mem[_5017 + 260] = mem[_5017]
                                        idx = 0
                                        s = _5017 + 292
                                        t = _5017 + 32
                                        while idx < mem[_5017]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5017 + 196] = this.address
                                        mem[_5017 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7490 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7634 = mem[_7490]
                                        require mem[_7490] <= test266151307()
                                        require _7490 + mem[_7490] + 31 < _7490 + return_data.size
                                        _7778 = mem[_7490 + mem[_7490]]
                                        if mem[_7490 + mem[_7490]] > test266151307():
                                            revert with 0, 65
                                        if _7490 + ceil32(return_data.size) + ceil32(32 * mem[_7490 + mem[_7490]]) + 1 > test266151307() or ceil32(32 * mem[_7490 + mem[_7490]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7490 + ceil32(return_data.size) + ceil32(32 * mem[_7490 + mem[_7490]]) + 1
                                        mem[_7490 + ceil32(return_data.size)] = _7778
                                        require return_data.size >= _7634 + (32 * _7778) + 32
                                        mem[_7490 + ceil32(return_data.size) + 32 len 32 * _7778] = mem[_7490 + _7634 + 32 len 32 * _7778]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _7778:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7490 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5013:
                                                revert with 0, 17
                                            mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                            mem[_5017 + 132] = 0
                                            mem[_5017 + 164] = 160
                                            mem[_5017 + 260] = mem[_5017]
                                            idx = 0
                                            s = _5017 + 292
                                            t = _5017 + 32
                                            while idx < mem[_5017]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5017 + 196] = this.address
                                            mem[_5017 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7491 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7635 = mem[_7491]
                                            require mem[_7491] <= test266151307()
                                            require _7491 + mem[_7491] + 31 < _7491 + return_data.size
                                            _7779 = mem[_7491 + mem[_7491]]
                                            if mem[_7491 + mem[_7491]] > test266151307():
                                                revert with 0, 65
                                            if _7491 + ceil32(return_data.size) + ceil32(32 * mem[_7491 + mem[_7491]]) + 1 > test266151307() or ceil32(32 * mem[_7491 + mem[_7491]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7491 + ceil32(return_data.size) + ceil32(32 * mem[_7491 + mem[_7491]]) + 1
                                            mem[_7491 + ceil32(return_data.size)] = _7779
                                            require return_data.size >= _7635 + (32 * _7779) + 32
                                            mem[_7491 + ceil32(return_data.size) + 32 len 32 * _7779] = mem[_7491 + _7635 + 32 len 32 * _7779]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7779:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7491 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5013:
                                                revert with 0, 17
                                            mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                            mem[_5017 + 132] = 0
                                            mem[_5017 + 164] = 160
                                            mem[_5017 + 260] = mem[_5017]
                                            idx = 0
                                            s = _5017 + 292
                                            t = _5017 + 32
                                            while idx < mem[_5017]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5017 + 196] = this.address
                                            mem[_5017 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7492 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7636 = mem[_7492]
                                            require mem[_7492] <= test266151307()
                                            require _7492 + mem[_7492] + 31 < _7492 + return_data.size
                                            _7780 = mem[_7492 + mem[_7492]]
                                            if mem[_7492 + mem[_7492]] > test266151307():
                                                revert with 0, 65
                                            if _7492 + ceil32(return_data.size) + ceil32(32 * mem[_7492 + mem[_7492]]) + 1 > test266151307() or ceil32(32 * mem[_7492 + mem[_7492]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7492 + ceil32(return_data.size) + ceil32(32 * mem[_7492 + mem[_7492]]) + 1
                                            mem[_7492 + ceil32(return_data.size)] = _7780
                                            require return_data.size >= _7636 + (32 * _7780) + 32
                                            mem[_7492 + ceil32(return_data.size) + 32 len 32 * _7780] = mem[_7492 + _7636 + 32 len 32 * _7780]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7780:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7492 + ceil32(return_data.size) + 64]
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5013:
                                        revert with 0, 17
                                    mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                    mem[_5017 + 132] = 0
                                    mem[_5017 + 164] = 160
                                    mem[_5017 + 260] = mem[_5017]
                                    idx = 0
                                    s = _5017 + 292
                                    t = _5017 + 32
                                    while idx < mem[_5017]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5017 + 196] = this.address
                                    mem[_5017 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7493 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7637 = mem[_7493]
                                    require mem[_7493] <= test266151307()
                                    require _7493 + mem[_7493] + 31 < _7493 + return_data.size
                                    _7781 = mem[_7493 + mem[_7493]]
                                    if mem[_7493 + mem[_7493]] > test266151307():
                                        revert with 0, 65
                                    if _7493 + ceil32(return_data.size) + ceil32(32 * mem[_7493 + mem[_7493]]) + 1 > test266151307() or ceil32(32 * mem[_7493 + mem[_7493]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7493 + ceil32(return_data.size) + ceil32(32 * mem[_7493 + mem[_7493]]) + 1
                                    mem[_7493 + ceil32(return_data.size)] = _7781
                                    require return_data.size >= _7637 + (32 * _7781) + 32
                                    mem[_7493 + ceil32(return_data.size) + 32 len 32 * _7781] = mem[_7493 + _7637 + 32 len 32 * _7781]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7781:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7493 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5013:
                                        revert with 0, 17
                                    mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                    mem[_5017 + 132] = 0
                                    mem[_5017 + 164] = 160
                                    mem[_5017 + 260] = mem[_5017]
                                    idx = 0
                                    s = _5017 + 292
                                    t = _5017 + 32
                                    while idx < mem[_5017]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5017 + 196] = this.address
                                    mem[_5017 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7494 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7638 = mem[_7494]
                                    require mem[_7494] <= test266151307()
                                    require _7494 + mem[_7494] + 31 < _7494 + return_data.size
                                    _7782 = mem[_7494 + mem[_7494]]
                                    if mem[_7494 + mem[_7494]] > test266151307():
                                        revert with 0, 65
                                    if _7494 + ceil32(return_data.size) + ceil32(32 * mem[_7494 + mem[_7494]]) + 1 > test266151307() or ceil32(32 * mem[_7494 + mem[_7494]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7494 + ceil32(return_data.size) + ceil32(32 * mem[_7494 + mem[_7494]]) + 1
                                    mem[_7494 + ceil32(return_data.size)] = _7782
                                    require return_data.size >= _7638 + (32 * _7782) + 32
                                    mem[_7494 + ceil32(return_data.size) + 32 len 32 * _7782] = mem[_7494 + _7638 + 32 len 32 * _7782]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7782:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7494 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5013:
                                        revert with 0, 17
                                    mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                    mem[_5017 + 132] = 0
                                    mem[_5017 + 164] = 160
                                    mem[_5017 + 260] = mem[_5017]
                                    idx = 0
                                    s = _5017 + 292
                                    t = _5017 + 32
                                    while idx < mem[_5017]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5017 + 196] = this.address
                                    mem[_5017 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7495 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7639 = mem[_7495]
                                    require mem[_7495] <= test266151307()
                                    require _7495 + mem[_7495] + 31 < _7495 + return_data.size
                                    _7783 = mem[_7495 + mem[_7495]]
                                    if mem[_7495 + mem[_7495]] > test266151307():
                                        revert with 0, 65
                                    if _7495 + ceil32(return_data.size) + ceil32(32 * mem[_7495 + mem[_7495]]) + 1 > test266151307() or ceil32(32 * mem[_7495 + mem[_7495]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7495 + ceil32(return_data.size) + ceil32(32 * mem[_7495 + mem[_7495]]) + 1
                                    mem[_7495 + ceil32(return_data.size)] = _7783
                                    require return_data.size >= _7639 + (32 * _7783) + 32
                                    mem[_7495 + ceil32(return_data.size) + 32 len 32 * _7783] = mem[_7495 + _7639 + 32 len 32 * _7783]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7783:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7495 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5013:
                                            revert with 0, 17
                                        mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                        mem[_5017 + 132] = 0
                                        mem[_5017 + 164] = 160
                                        mem[_5017 + 260] = mem[_5017]
                                        idx = 0
                                        s = _5017 + 292
                                        t = _5017 + 32
                                        while idx < mem[_5017]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5017 + 196] = this.address
                                        mem[_5017 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7496 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7640 = mem[_7496]
                                        require mem[_7496] <= test266151307()
                                        require _7496 + mem[_7496] + 31 < _7496 + return_data.size
                                        _7784 = mem[_7496 + mem[_7496]]
                                        if mem[_7496 + mem[_7496]] > test266151307():
                                            revert with 0, 65
                                        if _7496 + ceil32(return_data.size) + ceil32(32 * mem[_7496 + mem[_7496]]) + 1 > test266151307() or ceil32(32 * mem[_7496 + mem[_7496]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7496 + ceil32(return_data.size) + ceil32(32 * mem[_7496 + mem[_7496]]) + 1
                                        mem[_7496 + ceil32(return_data.size)] = _7784
                                        require return_data.size >= _7640 + (32 * _7784) + 32
                                        mem[_7496 + ceil32(return_data.size) + 32 len 32 * _7784] = mem[_7496 + _7640 + 32 len 32 * _7784]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _7784:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7496 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5013:
                                                revert with 0, 17
                                            mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                            mem[_5017 + 132] = 0
                                            mem[_5017 + 164] = 160
                                            mem[_5017 + 260] = mem[_5017]
                                            idx = 0
                                            s = _5017 + 292
                                            t = _5017 + 32
                                            while idx < mem[_5017]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5017 + 196] = this.address
                                            mem[_5017 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7497 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7641 = mem[_7497]
                                            require mem[_7497] <= test266151307()
                                            require _7497 + mem[_7497] + 31 < _7497 + return_data.size
                                            _7785 = mem[_7497 + mem[_7497]]
                                            if mem[_7497 + mem[_7497]] > test266151307():
                                                revert with 0, 65
                                            if _7497 + ceil32(return_data.size) + ceil32(32 * mem[_7497 + mem[_7497]]) + 1 > test266151307() or ceil32(32 * mem[_7497 + mem[_7497]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7497 + ceil32(return_data.size) + ceil32(32 * mem[_7497 + mem[_7497]]) + 1
                                            mem[_7497 + ceil32(return_data.size)] = _7785
                                            require return_data.size >= _7641 + (32 * _7785) + 32
                                            mem[_7497 + ceil32(return_data.size) + 32 len 32 * _7785] = mem[_7497 + _7641 + 32 len 32 * _7785]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7785:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7497 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5013:
                                                revert with 0, 17
                                            mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                            mem[_5017 + 132] = 0
                                            mem[_5017 + 164] = 160
                                            mem[_5017 + 260] = mem[_5017]
                                            idx = 0
                                            s = _5017 + 292
                                            t = _5017 + 32
                                            while idx < mem[_5017]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5017 + 196] = this.address
                                            mem[_5017 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7498 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7642 = mem[_7498]
                                            require mem[_7498] <= test266151307()
                                            require _7498 + mem[_7498] + 31 < _7498 + return_data.size
                                            _7786 = mem[_7498 + mem[_7498]]
                                            if mem[_7498 + mem[_7498]] > test266151307():
                                                revert with 0, 65
                                            if _7498 + ceil32(return_data.size) + ceil32(32 * mem[_7498 + mem[_7498]]) + 1 > test266151307() or ceil32(32 * mem[_7498 + mem[_7498]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7498 + ceil32(return_data.size) + ceil32(32 * mem[_7498 + mem[_7498]]) + 1
                                            mem[_7498 + ceil32(return_data.size)] = _7786
                                            require return_data.size >= _7642 + (32 * _7786) + 32
                                            mem[_7498 + ceil32(return_data.size) + 32 len 32 * _7786] = mem[_7498 + _7642 + 32 len 32 * _7786]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7786:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7498 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5013:
                                            revert with 0, 17
                                        mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                        mem[_5017 + 132] = 0
                                        mem[_5017 + 164] = 160
                                        mem[_5017 + 260] = mem[_5017]
                                        idx = 0
                                        s = _5017 + 292
                                        t = _5017 + 32
                                        while idx < mem[_5017]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5017 + 196] = this.address
                                        mem[_5017 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7499 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7643 = mem[_7499]
                                        require mem[_7499] <= test266151307()
                                        require _7499 + mem[_7499] + 31 < _7499 + return_data.size
                                        _7787 = mem[_7499 + mem[_7499]]
                                        if mem[_7499 + mem[_7499]] > test266151307():
                                            revert with 0, 65
                                        if _7499 + ceil32(return_data.size) + ceil32(32 * mem[_7499 + mem[_7499]]) + 1 > test266151307() or ceil32(32 * mem[_7499 + mem[_7499]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7499 + ceil32(return_data.size) + ceil32(32 * mem[_7499 + mem[_7499]]) + 1
                                        mem[_7499 + ceil32(return_data.size)] = _7787
                                        require return_data.size >= _7643 + (32 * _7787) + 32
                                        mem[_7499 + ceil32(return_data.size) + 32 len 32 * _7787] = mem[_7499 + _7643 + 32 len 32 * _7787]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _7787:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7499 + ceil32(return_data.size) + 64]
                                    else:
                                        if ext_call.return_data[0] > !_5013:
                                            revert with 0, 17
                                        mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                        mem[_5017 + 132] = 0
                                        mem[_5017 + 164] = 160
                                        mem[_5017 + 260] = mem[_5017]
                                        idx = 0
                                        s = _5017 + 292
                                        t = _5017 + 32
                                        while idx < mem[_5017]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5017 + 196] = this.address
                                        mem[_5017 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7500 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7644 = mem[_7500]
                                        require mem[_7500] <= test266151307()
                                        require _7500 + mem[_7500] + 31 < _7500 + return_data.size
                                        _7788 = mem[_7500 + mem[_7500]]
                                        if mem[_7500 + mem[_7500]] > test266151307():
                                            revert with 0, 65
                                        if _7500 + ceil32(return_data.size) + ceil32(32 * mem[_7500 + mem[_7500]]) + 1 > test266151307() or ceil32(32 * mem[_7500 + mem[_7500]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7500 + ceil32(return_data.size) + ceil32(32 * mem[_7500 + mem[_7500]]) + 1
                                        mem[_7500 + ceil32(return_data.size)] = _7788
                                        require return_data.size >= _7644 + (32 * _7788) + 32
                                        mem[_7500 + ceil32(return_data.size) + 32 len 32 * _7788] = mem[_7500 + _7644 + 32 len 32 * _7788]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _7788:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7500 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5013:
                                            revert with 0, 17
                                        mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                        mem[_5017 + 132] = 0
                                        mem[_5017 + 164] = 160
                                        mem[_5017 + 260] = mem[_5017]
                                        idx = 0
                                        s = _5017 + 292
                                        t = _5017 + 32
                                        while idx < mem[_5017]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5017 + 196] = this.address
                                        mem[_5017 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7501 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7645 = mem[_7501]
                                        require mem[_7501] <= test266151307()
                                        require _7501 + mem[_7501] + 31 < _7501 + return_data.size
                                        _7789 = mem[_7501 + mem[_7501]]
                                        if mem[_7501 + mem[_7501]] > test266151307():
                                            revert with 0, 65
                                        if _7501 + ceil32(return_data.size) + ceil32(32 * mem[_7501 + mem[_7501]]) + 1 > test266151307() or ceil32(32 * mem[_7501 + mem[_7501]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7501 + ceil32(return_data.size) + ceil32(32 * mem[_7501 + mem[_7501]]) + 1
                                        mem[_7501 + ceil32(return_data.size)] = _7789
                                        require return_data.size >= _7645 + (32 * _7789) + 32
                                        mem[_7501 + ceil32(return_data.size) + 32 len 32 * _7789] = mem[_7501 + _7645 + 32 len 32 * _7789]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _7789:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7501 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > !_5013:
                                                revert with 0, 17
                                            mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                            mem[_5017 + 132] = 0
                                            mem[_5017 + 164] = 160
                                            mem[_5017 + 260] = mem[_5017]
                                            idx = 0
                                            s = _5017 + 292
                                            t = _5017 + 32
                                            while idx < mem[_5017]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5017 + 196] = this.address
                                            mem[_5017 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7502 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7646 = mem[_7502]
                                            require mem[_7502] <= test266151307()
                                            require _7502 + mem[_7502] + 31 < _7502 + return_data.size
                                            _7790 = mem[_7502 + mem[_7502]]
                                            if mem[_7502 + mem[_7502]] > test266151307():
                                                revert with 0, 65
                                            if _7502 + ceil32(return_data.size) + ceil32(32 * mem[_7502 + mem[_7502]]) + 1 > test266151307() or ceil32(32 * mem[_7502 + mem[_7502]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7502 + ceil32(return_data.size) + ceil32(32 * mem[_7502 + mem[_7502]]) + 1
                                            mem[_7502 + ceil32(return_data.size)] = _7790
                                            require return_data.size >= _7646 + (32 * _7790) + 32
                                            mem[_7502 + ceil32(return_data.size) + 32 len 32 * _7790] = mem[_7502 + _7646 + 32 len 32 * _7790]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7790:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7502 + ceil32(return_data.size) + 64]
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > !_5013:
                                                    revert with 0, 17
                                                mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                                mem[_5017 + 132] = 0
                                                mem[_5017 + 164] = 160
                                                mem[_5017 + 260] = mem[_5017]
                                                idx = 0
                                                s = _5017 + 292
                                                t = _5017 + 32
                                                while idx < mem[_5017]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5017 + 196] = this.address
                                                mem[_5017 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7503 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7647 = mem[_7503]
                                                require mem[_7503] <= test266151307()
                                                require _7503 + mem[_7503] + 31 < _7503 + return_data.size
                                                _7791 = mem[_7503 + mem[_7503]]
                                                if mem[_7503 + mem[_7503]] > test266151307():
                                                    revert with 0, 65
                                                if _7503 + ceil32(return_data.size) + ceil32(32 * mem[_7503 + mem[_7503]]) + 1 > test266151307() or ceil32(32 * mem[_7503 + mem[_7503]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7503 + ceil32(return_data.size) + ceil32(32 * mem[_7503 + mem[_7503]]) + 1
                                                mem[_7503 + ceil32(return_data.size)] = _7791
                                                require return_data.size >= _7647 + (32 * _7791) + 32
                                                mem[_7503 + ceil32(return_data.size) + 32 len 32 * _7791] = mem[_7503 + _7647 + 32 len 32 * _7791]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _7791:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7503 + ceil32(return_data.size) + 64]
                                            else:
                                                if ext_call.return_data[0] > !_5013:
                                                    revert with 0, 17
                                                mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                                mem[_5017 + 132] = 0
                                                mem[_5017 + 164] = 160
                                                mem[_5017 + 260] = mem[_5017]
                                                idx = 0
                                                s = _5017 + 292
                                                t = _5017 + 32
                                                while idx < mem[_5017]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5017 + 196] = this.address
                                                mem[_5017 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7504 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7648 = mem[_7504]
                                                require mem[_7504] <= test266151307()
                                                require _7504 + mem[_7504] + 31 < _7504 + return_data.size
                                                _7792 = mem[_7504 + mem[_7504]]
                                                if mem[_7504 + mem[_7504]] > test266151307():
                                                    revert with 0, 65
                                                if _7504 + ceil32(return_data.size) + ceil32(32 * mem[_7504 + mem[_7504]]) + 1 > test266151307() or ceil32(32 * mem[_7504 + mem[_7504]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7504 + ceil32(return_data.size) + ceil32(32 * mem[_7504 + mem[_7504]]) + 1
                                                mem[_7504 + ceil32(return_data.size)] = _7792
                                                require return_data.size >= _7648 + (32 * _7792) + 32
                                                mem[_7504 + ceil32(return_data.size) + 32 len 32 * _7792] = mem[_7504 + _7648 + 32 len 32 * _7792]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _7792:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7504 + ceil32(return_data.size) + 64]
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5013:
                                                revert with 0, 17
                                            mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                            mem[_5017 + 132] = 0
                                            mem[_5017 + 164] = 160
                                            mem[_5017 + 260] = mem[_5017]
                                            idx = 0
                                            s = _5017 + 292
                                            t = _5017 + 32
                                            while idx < mem[_5017]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5017 + 196] = this.address
                                            mem[_5017 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7505 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7649 = mem[_7505]
                                            require mem[_7505] <= test266151307()
                                            require _7505 + mem[_7505] + 31 < _7505 + return_data.size
                                            _7793 = mem[_7505 + mem[_7505]]
                                            if mem[_7505 + mem[_7505]] > test266151307():
                                                revert with 0, 65
                                            if _7505 + ceil32(return_data.size) + ceil32(32 * mem[_7505 + mem[_7505]]) + 1 > test266151307() or ceil32(32 * mem[_7505 + mem[_7505]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7505 + ceil32(return_data.size) + ceil32(32 * mem[_7505 + mem[_7505]]) + 1
                                            mem[_7505 + ceil32(return_data.size)] = _7793
                                            require return_data.size >= _7649 + (32 * _7793) + 32
                                            mem[_7505 + ceil32(return_data.size) + 32 len 32 * _7793] = mem[_7505 + _7649 + 32 len 32 * _7793]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7793:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7505 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5013:
                                                revert with 0, 17
                                            mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                            mem[_5017 + 132] = 0
                                            mem[_5017 + 164] = 160
                                            mem[_5017 + 260] = mem[_5017]
                                            idx = 0
                                            s = _5017 + 292
                                            t = _5017 + 32
                                            while idx < mem[_5017]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5017 + 196] = this.address
                                            mem[_5017 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7506 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7650 = mem[_7506]
                                            require mem[_7506] <= test266151307()
                                            require _7506 + mem[_7506] + 31 < _7506 + return_data.size
                                            _7794 = mem[_7506 + mem[_7506]]
                                            if mem[_7506 + mem[_7506]] > test266151307():
                                                revert with 0, 65
                                            if _7506 + ceil32(return_data.size) + ceil32(32 * mem[_7506 + mem[_7506]]) + 1 > test266151307() or ceil32(32 * mem[_7506 + mem[_7506]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7506 + ceil32(return_data.size) + ceil32(32 * mem[_7506 + mem[_7506]]) + 1
                                            mem[_7506 + ceil32(return_data.size)] = _7794
                                            require return_data.size >= _7650 + (32 * _7794) + 32
                                            mem[_7506 + ceil32(return_data.size) + 32 len 32 * _7794] = mem[_7506 + _7650 + 32 len 32 * _7794]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7794:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7506 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5013:
                                                revert with 0, 17
                                            mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                            mem[_5017 + 132] = 0
                                            mem[_5017 + 164] = 160
                                            mem[_5017 + 260] = mem[_5017]
                                            idx = 0
                                            s = _5017 + 292
                                            t = _5017 + 32
                                            while idx < mem[_5017]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5017 + 196] = this.address
                                            mem[_5017 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7507 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7651 = mem[_7507]
                                            require mem[_7507] <= test266151307()
                                            require _7507 + mem[_7507] + 31 < _7507 + return_data.size
                                            _7795 = mem[_7507 + mem[_7507]]
                                            if mem[_7507 + mem[_7507]] > test266151307():
                                                revert with 0, 65
                                            if _7507 + ceil32(return_data.size) + ceil32(32 * mem[_7507 + mem[_7507]]) + 1 > test266151307() or ceil32(32 * mem[_7507 + mem[_7507]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7507 + ceil32(return_data.size) + ceil32(32 * mem[_7507 + mem[_7507]]) + 1
                                            mem[_7507 + ceil32(return_data.size)] = _7795
                                            require return_data.size >= _7651 + (32 * _7795) + 32
                                            mem[_7507 + ceil32(return_data.size) + 32 len 32 * _7795] = mem[_7507 + _7651 + 32 len 32 * _7795]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7795:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7507 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5013:
                                                    revert with 0, 17
                                                mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                                mem[_5017 + 132] = 0
                                                mem[_5017 + 164] = 160
                                                mem[_5017 + 260] = mem[_5017]
                                                idx = 0
                                                s = _5017 + 292
                                                t = _5017 + 32
                                                while idx < mem[_5017]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5017 + 196] = this.address
                                                mem[_5017 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7508 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7652 = mem[_7508]
                                                require mem[_7508] <= test266151307()
                                                require _7508 + mem[_7508] + 31 < _7508 + return_data.size
                                                _7796 = mem[_7508 + mem[_7508]]
                                                if mem[_7508 + mem[_7508]] > test266151307():
                                                    revert with 0, 65
                                                if _7508 + ceil32(return_data.size) + ceil32(32 * mem[_7508 + mem[_7508]]) + 1 > test266151307() or ceil32(32 * mem[_7508 + mem[_7508]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7508 + ceil32(return_data.size) + ceil32(32 * mem[_7508 + mem[_7508]]) + 1
                                                mem[_7508 + ceil32(return_data.size)] = _7796
                                                require return_data.size >= _7652 + (32 * _7796) + 32
                                                mem[_7508 + ceil32(return_data.size) + 32 len 32 * _7796] = mem[_7508 + _7652 + 32 len 32 * _7796]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _7796:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7508 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5013:
                                                        revert with 0, 17
                                                    mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                                    mem[_5017 + 132] = 0
                                                    mem[_5017 + 164] = 160
                                                    mem[_5017 + 260] = mem[_5017]
                                                    idx = 0
                                                    s = _5017 + 292
                                                    t = _5017 + 32
                                                    while idx < mem[_5017]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5017 + 196] = this.address
                                                    mem[_5017 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7509 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7653 = mem[_7509]
                                                    require mem[_7509] <= test266151307()
                                                    require _7509 + mem[_7509] + 31 < _7509 + return_data.size
                                                    _7797 = mem[_7509 + mem[_7509]]
                                                    if mem[_7509 + mem[_7509]] > test266151307():
                                                        revert with 0, 65
                                                    if _7509 + ceil32(return_data.size) + ceil32(32 * mem[_7509 + mem[_7509]]) + 1 > test266151307() or ceil32(32 * mem[_7509 + mem[_7509]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7509 + ceil32(return_data.size) + ceil32(32 * mem[_7509 + mem[_7509]]) + 1
                                                    mem[_7509 + ceil32(return_data.size)] = _7797
                                                    require return_data.size >= _7653 + (32 * _7797) + 32
                                                    mem[_7509 + ceil32(return_data.size) + 32 len 32 * _7797] = mem[_7509 + _7653 + 32 len 32 * _7797]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _7797:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7509 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5013:
                                                        revert with 0, 17
                                                    mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                                    mem[_5017 + 132] = 0
                                                    mem[_5017 + 164] = 160
                                                    mem[_5017 + 260] = mem[_5017]
                                                    idx = 0
                                                    s = _5017 + 292
                                                    t = _5017 + 32
                                                    while idx < mem[_5017]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5017 + 196] = this.address
                                                    mem[_5017 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7510 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7654 = mem[_7510]
                                                    require mem[_7510] <= test266151307()
                                                    require _7510 + mem[_7510] + 31 < _7510 + return_data.size
                                                    _7798 = mem[_7510 + mem[_7510]]
                                                    if mem[_7510 + mem[_7510]] > test266151307():
                                                        revert with 0, 65
                                                    if _7510 + ceil32(return_data.size) + ceil32(32 * mem[_7510 + mem[_7510]]) + 1 > test266151307() or ceil32(32 * mem[_7510 + mem[_7510]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7510 + ceil32(return_data.size) + ceil32(32 * mem[_7510 + mem[_7510]]) + 1
                                                    mem[_7510 + ceil32(return_data.size)] = _7798
                                                    require return_data.size >= _7654 + (32 * _7798) + 32
                                                    mem[_7510 + ceil32(return_data.size) + 32 len 32 * _7798] = mem[_7510 + _7654 + 32 len 32 * _7798]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _7798:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7510 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5013:
                                                revert with 0, 17
                                            mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                            mem[_5017 + 132] = 0
                                            mem[_5017 + 164] = 160
                                            mem[_5017 + 260] = mem[_5017]
                                            idx = 0
                                            s = _5017 + 292
                                            t = _5017 + 32
                                            while idx < mem[_5017]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5017 + 196] = this.address
                                            mem[_5017 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7511 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7655 = mem[_7511]
                                            require mem[_7511] <= test266151307()
                                            require _7511 + mem[_7511] + 31 < _7511 + return_data.size
                                            _7799 = mem[_7511 + mem[_7511]]
                                            if mem[_7511 + mem[_7511]] > test266151307():
                                                revert with 0, 65
                                            if _7511 + ceil32(return_data.size) + ceil32(32 * mem[_7511 + mem[_7511]]) + 1 > test266151307() or ceil32(32 * mem[_7511 + mem[_7511]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7511 + ceil32(return_data.size) + ceil32(32 * mem[_7511 + mem[_7511]]) + 1
                                            mem[_7511 + ceil32(return_data.size)] = _7799
                                            require return_data.size >= _7655 + (32 * _7799) + 32
                                            mem[_7511 + ceil32(return_data.size) + 32 len 32 * _7799] = mem[_7511 + _7655 + 32 len 32 * _7799]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7799:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7511 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5013:
                                                revert with 0, 17
                                            mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                            mem[_5017 + 132] = 0
                                            mem[_5017 + 164] = 160
                                            mem[_5017 + 260] = mem[_5017]
                                            idx = 0
                                            s = _5017 + 292
                                            t = _5017 + 32
                                            while idx < mem[_5017]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5017 + 196] = this.address
                                            mem[_5017 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7512 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7656 = mem[_7512]
                                            require mem[_7512] <= test266151307()
                                            require _7512 + mem[_7512] + 31 < _7512 + return_data.size
                                            _7800 = mem[_7512 + mem[_7512]]
                                            if mem[_7512 + mem[_7512]] > test266151307():
                                                revert with 0, 65
                                            if _7512 + ceil32(return_data.size) + ceil32(32 * mem[_7512 + mem[_7512]]) + 1 > test266151307() or ceil32(32 * mem[_7512 + mem[_7512]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7512 + ceil32(return_data.size) + ceil32(32 * mem[_7512 + mem[_7512]]) + 1
                                            mem[_7512 + ceil32(return_data.size)] = _7800
                                            require return_data.size >= _7656 + (32 * _7800) + 32
                                            mem[_7512 + ceil32(return_data.size) + 32 len 32 * _7800] = mem[_7512 + _7656 + 32 len 32 * _7800]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7800:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7512 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5013:
                                                revert with 0, 17
                                            mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                            mem[_5017 + 132] = 0
                                            mem[_5017 + 164] = 160
                                            mem[_5017 + 260] = mem[_5017]
                                            idx = 0
                                            s = _5017 + 292
                                            t = _5017 + 32
                                            while idx < mem[_5017]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5017 + 196] = this.address
                                            mem[_5017 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7513 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7657 = mem[_7513]
                                            require mem[_7513] <= test266151307()
                                            require _7513 + mem[_7513] + 31 < _7513 + return_data.size
                                            _7801 = mem[_7513 + mem[_7513]]
                                            if mem[_7513 + mem[_7513]] > test266151307():
                                                revert with 0, 65
                                            if _7513 + ceil32(return_data.size) + ceil32(32 * mem[_7513 + mem[_7513]]) + 1 > test266151307() or ceil32(32 * mem[_7513 + mem[_7513]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7513 + ceil32(return_data.size) + ceil32(32 * mem[_7513 + mem[_7513]]) + 1
                                            mem[_7513 + ceil32(return_data.size)] = _7801
                                            require return_data.size >= _7657 + (32 * _7801) + 32
                                            mem[_7513 + ceil32(return_data.size) + 32 len 32 * _7801] = mem[_7513 + _7657 + 32 len 32 * _7801]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7801:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7513 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5013:
                                                    revert with 0, 17
                                                mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                                mem[_5017 + 132] = 0
                                                mem[_5017 + 164] = 160
                                                mem[_5017 + 260] = mem[_5017]
                                                idx = 0
                                                s = _5017 + 292
                                                t = _5017 + 32
                                                while idx < mem[_5017]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5017 + 196] = this.address
                                                mem[_5017 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7514 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7658 = mem[_7514]
                                                require mem[_7514] <= test266151307()
                                                require _7514 + mem[_7514] + 31 < _7514 + return_data.size
                                                _7802 = mem[_7514 + mem[_7514]]
                                                if mem[_7514 + mem[_7514]] > test266151307():
                                                    revert with 0, 65
                                                if _7514 + ceil32(return_data.size) + ceil32(32 * mem[_7514 + mem[_7514]]) + 1 > test266151307() or ceil32(32 * mem[_7514 + mem[_7514]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7514 + ceil32(return_data.size) + ceil32(32 * mem[_7514 + mem[_7514]]) + 1
                                                mem[_7514 + ceil32(return_data.size)] = _7802
                                                require return_data.size >= _7658 + (32 * _7802) + 32
                                                mem[_7514 + ceil32(return_data.size) + 32 len 32 * _7802] = mem[_7514 + _7658 + 32 len 32 * _7802]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _7802:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7514 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5013:
                                                        revert with 0, 17
                                                    mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5017 + 100] = ext_call.return_data[32] + _5013
                                                    mem[_5017 + 132] = 0
                                                    mem[_5017 + 164] = 160
                                                    mem[_5017 + 260] = mem[_5017]
                                                    idx = 0
                                                    s = _5017 + 292
                                                    t = _5017 + 32
                                                    while idx < mem[_5017]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5017 + 196] = this.address
                                                    mem[_5017 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7515 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7659 = mem[_7515]
                                                    require mem[_7515] <= test266151307()
                                                    require _7515 + mem[_7515] + 31 < _7515 + return_data.size
                                                    _7803 = mem[_7515 + mem[_7515]]
                                                    if mem[_7515 + mem[_7515]] > test266151307():
                                                        revert with 0, 65
                                                    if _7515 + ceil32(return_data.size) + ceil32(32 * mem[_7515 + mem[_7515]]) + 1 > test266151307() or ceil32(32 * mem[_7515 + mem[_7515]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7515 + ceil32(return_data.size) + ceil32(32 * mem[_7515 + mem[_7515]]) + 1
                                                    mem[_7515 + ceil32(return_data.size)] = _7803
                                                    require return_data.size >= _7659 + (32 * _7803) + 32
                                                    mem[_7515 + ceil32(return_data.size) + 32 len 32 * _7803] = mem[_7515 + _7659 + 32 len 32 * _7803]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _7803:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7515 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5013:
                                                        revert with 0, 17
                                                    mem[_5017 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5017 + 100] = ext_call.return_data[0] + _5013
                                                    mem[_5017 + 132] = 0
                                                    mem[_5017 + 164] = 160
                                                    mem[_5017 + 260] = mem[_5017]
                                                    idx = 0
                                                    s = _5017 + 292
                                                    t = _5017 + 32
                                                    while idx < mem[_5017]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5017 + 196] = this.address
                                                    mem[_5017 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5017 + (32 * mem[_5017]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7516 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7660 = mem[_7516]
                                                    require mem[_7516] <= test266151307()
                                                    require _7516 + mem[_7516] + 31 < _7516 + return_data.size
                                                    _7804 = mem[_7516 + mem[_7516]]
                                                    if mem[_7516 + mem[_7516]] > test266151307():
                                                        revert with 0, 65
                                                    if _7516 + ceil32(return_data.size) + ceil32(32 * mem[_7516 + mem[_7516]]) + 1 > test266151307() or ceil32(32 * mem[_7516 + mem[_7516]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7516 + ceil32(return_data.size) + ceil32(32 * mem[_7516 + mem[_7516]]) + 1
                                                    mem[_7516 + ceil32(return_data.size)] = _7804
                                                    require return_data.size >= _7660 + (32 * _7804) + 32
                                                    mem[_7516 + ceil32(return_data.size) + 32 len 32 * _7804] = mem[_7516 + _7660 + 32 len 32 * _7804]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _7804:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7516 + ceil32(return_data.size) + 64]
                else:
                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 388
                    t = (4 * ceil32(return_data.size)) + 128
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2644 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _2675 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                        revert with 0, 65
                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                    require return_data.size >= _2644 + (32 * _2675) + 32
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2675] = mem[(4 * ceil32(return_data.size)) + _2644 + 224 len 32 * _2675]
                    if 1 >= _2675:
                        revert with 0, 50
                    _5014 = mem[(6 * ceil32(return_data.size)) + 256]
                    _5018 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_5018]:
                        revert with 0, 50
                    mem[_5018 + 32] = address(ext_call.return_data[0])
                    if 1 >= mem[_5018]:
                        revert with 0, 50
                    mem[_5018 + 64] = brushAddress
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5014:
                                        revert with 0, 17
                                    mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                    mem[_5018 + 132] = 0
                                    mem[_5018 + 164] = 160
                                    mem[_5018 + 260] = mem[_5018]
                                    idx = 0
                                    s = _5018 + 292
                                    t = _5018 + 32
                                    while idx < mem[_5018]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5018 + 196] = this.address
                                    mem[_5018 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7517 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7661 = mem[_7517]
                                    require mem[_7517] <= test266151307()
                                    require _7517 + mem[_7517] + 31 < _7517 + return_data.size
                                    _7805 = mem[_7517 + mem[_7517]]
                                    if mem[_7517 + mem[_7517]] > test266151307():
                                        revert with 0, 65
                                    if _7517 + ceil32(return_data.size) + ceil32(32 * mem[_7517 + mem[_7517]]) + 1 > test266151307() or ceil32(32 * mem[_7517 + mem[_7517]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7517 + ceil32(return_data.size) + ceil32(32 * mem[_7517 + mem[_7517]]) + 1
                                    mem[_7517 + ceil32(return_data.size)] = _7805
                                    require return_data.size >= _7661 + (32 * _7805) + 32
                                    mem[_7517 + ceil32(return_data.size) + 32 len 32 * _7805] = mem[_7517 + _7661 + 32 len 32 * _7805]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7805:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7517 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5014:
                                        revert with 0, 17
                                    mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                    mem[_5018 + 132] = 0
                                    mem[_5018 + 164] = 160
                                    mem[_5018 + 260] = mem[_5018]
                                    idx = 0
                                    s = _5018 + 292
                                    t = _5018 + 32
                                    while idx < mem[_5018]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5018 + 196] = this.address
                                    mem[_5018 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7518 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7662 = mem[_7518]
                                    require mem[_7518] <= test266151307()
                                    require _7518 + mem[_7518] + 31 < _7518 + return_data.size
                                    _7806 = mem[_7518 + mem[_7518]]
                                    if mem[_7518 + mem[_7518]] > test266151307():
                                        revert with 0, 65
                                    if _7518 + ceil32(return_data.size) + ceil32(32 * mem[_7518 + mem[_7518]]) + 1 > test266151307() or ceil32(32 * mem[_7518 + mem[_7518]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7518 + ceil32(return_data.size) + ceil32(32 * mem[_7518 + mem[_7518]]) + 1
                                    mem[_7518 + ceil32(return_data.size)] = _7806
                                    require return_data.size >= _7662 + (32 * _7806) + 32
                                    mem[_7518 + ceil32(return_data.size) + 32 len 32 * _7806] = mem[_7518 + _7662 + 32 len 32 * _7806]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7806:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7518 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5014:
                                        revert with 0, 17
                                    mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                    mem[_5018 + 132] = 0
                                    mem[_5018 + 164] = 160
                                    mem[_5018 + 260] = mem[_5018]
                                    idx = 0
                                    s = _5018 + 292
                                    t = _5018 + 32
                                    while idx < mem[_5018]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5018 + 196] = this.address
                                    mem[_5018 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7519 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7663 = mem[_7519]
                                    require mem[_7519] <= test266151307()
                                    require _7519 + mem[_7519] + 31 < _7519 + return_data.size
                                    _7807 = mem[_7519 + mem[_7519]]
                                    if mem[_7519 + mem[_7519]] > test266151307():
                                        revert with 0, 65
                                    if _7519 + ceil32(return_data.size) + ceil32(32 * mem[_7519 + mem[_7519]]) + 1 > test266151307() or ceil32(32 * mem[_7519 + mem[_7519]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7519 + ceil32(return_data.size) + ceil32(32 * mem[_7519 + mem[_7519]]) + 1
                                    mem[_7519 + ceil32(return_data.size)] = _7807
                                    require return_data.size >= _7663 + (32 * _7807) + 32
                                    mem[_7519 + ceil32(return_data.size) + 32 len 32 * _7807] = mem[_7519 + _7663 + 32 len 32 * _7807]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7807:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7519 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5014:
                                            revert with 0, 17
                                        mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                        mem[_5018 + 132] = 0
                                        mem[_5018 + 164] = 160
                                        mem[_5018 + 260] = mem[_5018]
                                        idx = 0
                                        s = _5018 + 292
                                        t = _5018 + 32
                                        while idx < mem[_5018]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5018 + 196] = this.address
                                        mem[_5018 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7520 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7664 = mem[_7520]
                                        require mem[_7520] <= test266151307()
                                        require _7520 + mem[_7520] + 31 < _7520 + return_data.size
                                        _7808 = mem[_7520 + mem[_7520]]
                                        if mem[_7520 + mem[_7520]] > test266151307():
                                            revert with 0, 65
                                        if _7520 + ceil32(return_data.size) + ceil32(32 * mem[_7520 + mem[_7520]]) + 1 > test266151307() or ceil32(32 * mem[_7520 + mem[_7520]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7520 + ceil32(return_data.size) + ceil32(32 * mem[_7520 + mem[_7520]]) + 1
                                        mem[_7520 + ceil32(return_data.size)] = _7808
                                        require return_data.size >= _7664 + (32 * _7808) + 32
                                        mem[_7520 + ceil32(return_data.size) + 32 len 32 * _7808] = mem[_7520 + _7664 + 32 len 32 * _7808]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _7808:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7520 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5014:
                                                revert with 0, 17
                                            mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                            mem[_5018 + 132] = 0
                                            mem[_5018 + 164] = 160
                                            mem[_5018 + 260] = mem[_5018]
                                            idx = 0
                                            s = _5018 + 292
                                            t = _5018 + 32
                                            while idx < mem[_5018]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5018 + 196] = this.address
                                            mem[_5018 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7521 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7665 = mem[_7521]
                                            require mem[_7521] <= test266151307()
                                            require _7521 + mem[_7521] + 31 < _7521 + return_data.size
                                            _7809 = mem[_7521 + mem[_7521]]
                                            if mem[_7521 + mem[_7521]] > test266151307():
                                                revert with 0, 65
                                            if _7521 + ceil32(return_data.size) + ceil32(32 * mem[_7521 + mem[_7521]]) + 1 > test266151307() or ceil32(32 * mem[_7521 + mem[_7521]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7521 + ceil32(return_data.size) + ceil32(32 * mem[_7521 + mem[_7521]]) + 1
                                            mem[_7521 + ceil32(return_data.size)] = _7809
                                            require return_data.size >= _7665 + (32 * _7809) + 32
                                            mem[_7521 + ceil32(return_data.size) + 32 len 32 * _7809] = mem[_7521 + _7665 + 32 len 32 * _7809]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7809:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7521 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5014:
                                                revert with 0, 17
                                            mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                            mem[_5018 + 132] = 0
                                            mem[_5018 + 164] = 160
                                            mem[_5018 + 260] = mem[_5018]
                                            idx = 0
                                            s = _5018 + 292
                                            t = _5018 + 32
                                            while idx < mem[_5018]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5018 + 196] = this.address
                                            mem[_5018 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7522 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7666 = mem[_7522]
                                            require mem[_7522] <= test266151307()
                                            require _7522 + mem[_7522] + 31 < _7522 + return_data.size
                                            _7810 = mem[_7522 + mem[_7522]]
                                            if mem[_7522 + mem[_7522]] > test266151307():
                                                revert with 0, 65
                                            if _7522 + ceil32(return_data.size) + ceil32(32 * mem[_7522 + mem[_7522]]) + 1 > test266151307() or ceil32(32 * mem[_7522 + mem[_7522]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7522 + ceil32(return_data.size) + ceil32(32 * mem[_7522 + mem[_7522]]) + 1
                                            mem[_7522 + ceil32(return_data.size)] = _7810
                                            require return_data.size >= _7666 + (32 * _7810) + 32
                                            mem[_7522 + ceil32(return_data.size) + 32 len 32 * _7810] = mem[_7522 + _7666 + 32 len 32 * _7810]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7810:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7522 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5014:
                                        revert with 0, 17
                                    mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                    mem[_5018 + 132] = 0
                                    mem[_5018 + 164] = 160
                                    mem[_5018 + 260] = mem[_5018]
                                    idx = 0
                                    s = _5018 + 292
                                    t = _5018 + 32
                                    while idx < mem[_5018]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5018 + 196] = this.address
                                    mem[_5018 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7523 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7667 = mem[_7523]
                                    require mem[_7523] <= test266151307()
                                    require _7523 + mem[_7523] + 31 < _7523 + return_data.size
                                    _7811 = mem[_7523 + mem[_7523]]
                                    if mem[_7523 + mem[_7523]] > test266151307():
                                        revert with 0, 65
                                    if _7523 + ceil32(return_data.size) + ceil32(32 * mem[_7523 + mem[_7523]]) + 1 > test266151307() or ceil32(32 * mem[_7523 + mem[_7523]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7523 + ceil32(return_data.size) + ceil32(32 * mem[_7523 + mem[_7523]]) + 1
                                    mem[_7523 + ceil32(return_data.size)] = _7811
                                    require return_data.size >= _7667 + (32 * _7811) + 32
                                    mem[_7523 + ceil32(return_data.size) + 32 len 32 * _7811] = mem[_7523 + _7667 + 32 len 32 * _7811]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7811:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7523 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5014:
                                        revert with 0, 17
                                    mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                    mem[_5018 + 132] = 0
                                    mem[_5018 + 164] = 160
                                    mem[_5018 + 260] = mem[_5018]
                                    idx = 0
                                    s = _5018 + 292
                                    t = _5018 + 32
                                    while idx < mem[_5018]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5018 + 196] = this.address
                                    mem[_5018 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7524 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7668 = mem[_7524]
                                    require mem[_7524] <= test266151307()
                                    require _7524 + mem[_7524] + 31 < _7524 + return_data.size
                                    _7812 = mem[_7524 + mem[_7524]]
                                    if mem[_7524 + mem[_7524]] > test266151307():
                                        revert with 0, 65
                                    if _7524 + ceil32(return_data.size) + ceil32(32 * mem[_7524 + mem[_7524]]) + 1 > test266151307() or ceil32(32 * mem[_7524 + mem[_7524]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7524 + ceil32(return_data.size) + ceil32(32 * mem[_7524 + mem[_7524]]) + 1
                                    mem[_7524 + ceil32(return_data.size)] = _7812
                                    require return_data.size >= _7668 + (32 * _7812) + 32
                                    mem[_7524 + ceil32(return_data.size) + 32 len 32 * _7812] = mem[_7524 + _7668 + 32 len 32 * _7812]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7812:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7524 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5014:
                                        revert with 0, 17
                                    mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                    mem[_5018 + 132] = 0
                                    mem[_5018 + 164] = 160
                                    mem[_5018 + 260] = mem[_5018]
                                    idx = 0
                                    s = _5018 + 292
                                    t = _5018 + 32
                                    while idx < mem[_5018]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5018 + 196] = this.address
                                    mem[_5018 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7525 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7669 = mem[_7525]
                                    require mem[_7525] <= test266151307()
                                    require _7525 + mem[_7525] + 31 < _7525 + return_data.size
                                    _7813 = mem[_7525 + mem[_7525]]
                                    if mem[_7525 + mem[_7525]] > test266151307():
                                        revert with 0, 65
                                    if _7525 + ceil32(return_data.size) + ceil32(32 * mem[_7525 + mem[_7525]]) + 1 > test266151307() or ceil32(32 * mem[_7525 + mem[_7525]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7525 + ceil32(return_data.size) + ceil32(32 * mem[_7525 + mem[_7525]]) + 1
                                    mem[_7525 + ceil32(return_data.size)] = _7813
                                    require return_data.size >= _7669 + (32 * _7813) + 32
                                    mem[_7525 + ceil32(return_data.size) + 32 len 32 * _7813] = mem[_7525 + _7669 + 32 len 32 * _7813]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7813:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7525 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5014:
                                            revert with 0, 17
                                        mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                        mem[_5018 + 132] = 0
                                        mem[_5018 + 164] = 160
                                        mem[_5018 + 260] = mem[_5018]
                                        idx = 0
                                        s = _5018 + 292
                                        t = _5018 + 32
                                        while idx < mem[_5018]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5018 + 196] = this.address
                                        mem[_5018 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7526 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7670 = mem[_7526]
                                        require mem[_7526] <= test266151307()
                                        require _7526 + mem[_7526] + 31 < _7526 + return_data.size
                                        _7814 = mem[_7526 + mem[_7526]]
                                        if mem[_7526 + mem[_7526]] > test266151307():
                                            revert with 0, 65
                                        if _7526 + ceil32(return_data.size) + ceil32(32 * mem[_7526 + mem[_7526]]) + 1 > test266151307() or ceil32(32 * mem[_7526 + mem[_7526]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7526 + ceil32(return_data.size) + ceil32(32 * mem[_7526 + mem[_7526]]) + 1
                                        mem[_7526 + ceil32(return_data.size)] = _7814
                                        require return_data.size >= _7670 + (32 * _7814) + 32
                                        mem[_7526 + ceil32(return_data.size) + 32 len 32 * _7814] = mem[_7526 + _7670 + 32 len 32 * _7814]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _7814:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7526 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5014:
                                                revert with 0, 17
                                            mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                            mem[_5018 + 132] = 0
                                            mem[_5018 + 164] = 160
                                            mem[_5018 + 260] = mem[_5018]
                                            idx = 0
                                            s = _5018 + 292
                                            t = _5018 + 32
                                            while idx < mem[_5018]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5018 + 196] = this.address
                                            mem[_5018 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7527 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7671 = mem[_7527]
                                            require mem[_7527] <= test266151307()
                                            require _7527 + mem[_7527] + 31 < _7527 + return_data.size
                                            _7815 = mem[_7527 + mem[_7527]]
                                            if mem[_7527 + mem[_7527]] > test266151307():
                                                revert with 0, 65
                                            if _7527 + ceil32(return_data.size) + ceil32(32 * mem[_7527 + mem[_7527]]) + 1 > test266151307() or ceil32(32 * mem[_7527 + mem[_7527]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7527 + ceil32(return_data.size) + ceil32(32 * mem[_7527 + mem[_7527]]) + 1
                                            mem[_7527 + ceil32(return_data.size)] = _7815
                                            require return_data.size >= _7671 + (32 * _7815) + 32
                                            mem[_7527 + ceil32(return_data.size) + 32 len 32 * _7815] = mem[_7527 + _7671 + 32 len 32 * _7815]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7815:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7527 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5014:
                                                revert with 0, 17
                                            mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                            mem[_5018 + 132] = 0
                                            mem[_5018 + 164] = 160
                                            mem[_5018 + 260] = mem[_5018]
                                            idx = 0
                                            s = _5018 + 292
                                            t = _5018 + 32
                                            while idx < mem[_5018]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5018 + 196] = this.address
                                            mem[_5018 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7528 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7672 = mem[_7528]
                                            require mem[_7528] <= test266151307()
                                            require _7528 + mem[_7528] + 31 < _7528 + return_data.size
                                            _7816 = mem[_7528 + mem[_7528]]
                                            if mem[_7528 + mem[_7528]] > test266151307():
                                                revert with 0, 65
                                            if _7528 + ceil32(return_data.size) + ceil32(32 * mem[_7528 + mem[_7528]]) + 1 > test266151307() or ceil32(32 * mem[_7528 + mem[_7528]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7528 + ceil32(return_data.size) + ceil32(32 * mem[_7528 + mem[_7528]]) + 1
                                            mem[_7528 + ceil32(return_data.size)] = _7816
                                            require return_data.size >= _7672 + (32 * _7816) + 32
                                            mem[_7528 + ceil32(return_data.size) + 32 len 32 * _7816] = mem[_7528 + _7672 + 32 len 32 * _7816]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7816:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7528 + ceil32(return_data.size) + 64]
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5014:
                                        revert with 0, 17
                                    mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                    mem[_5018 + 132] = 0
                                    mem[_5018 + 164] = 160
                                    mem[_5018 + 260] = mem[_5018]
                                    idx = 0
                                    s = _5018 + 292
                                    t = _5018 + 32
                                    while idx < mem[_5018]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5018 + 196] = this.address
                                    mem[_5018 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7529 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7673 = mem[_7529]
                                    require mem[_7529] <= test266151307()
                                    require _7529 + mem[_7529] + 31 < _7529 + return_data.size
                                    _7817 = mem[_7529 + mem[_7529]]
                                    if mem[_7529 + mem[_7529]] > test266151307():
                                        revert with 0, 65
                                    if _7529 + ceil32(return_data.size) + ceil32(32 * mem[_7529 + mem[_7529]]) + 1 > test266151307() or ceil32(32 * mem[_7529 + mem[_7529]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7529 + ceil32(return_data.size) + ceil32(32 * mem[_7529 + mem[_7529]]) + 1
                                    mem[_7529 + ceil32(return_data.size)] = _7817
                                    require return_data.size >= _7673 + (32 * _7817) + 32
                                    mem[_7529 + ceil32(return_data.size) + 32 len 32 * _7817] = mem[_7529 + _7673 + 32 len 32 * _7817]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7817:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7529 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5014:
                                        revert with 0, 17
                                    mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                    mem[_5018 + 132] = 0
                                    mem[_5018 + 164] = 160
                                    mem[_5018 + 260] = mem[_5018]
                                    idx = 0
                                    s = _5018 + 292
                                    t = _5018 + 32
                                    while idx < mem[_5018]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5018 + 196] = this.address
                                    mem[_5018 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7530 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7674 = mem[_7530]
                                    require mem[_7530] <= test266151307()
                                    require _7530 + mem[_7530] + 31 < _7530 + return_data.size
                                    _7818 = mem[_7530 + mem[_7530]]
                                    if mem[_7530 + mem[_7530]] > test266151307():
                                        revert with 0, 65
                                    if _7530 + ceil32(return_data.size) + ceil32(32 * mem[_7530 + mem[_7530]]) + 1 > test266151307() or ceil32(32 * mem[_7530 + mem[_7530]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7530 + ceil32(return_data.size) + ceil32(32 * mem[_7530 + mem[_7530]]) + 1
                                    mem[_7530 + ceil32(return_data.size)] = _7818
                                    require return_data.size >= _7674 + (32 * _7818) + 32
                                    mem[_7530 + ceil32(return_data.size) + 32 len 32 * _7818] = mem[_7530 + _7674 + 32 len 32 * _7818]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7818:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7530 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5014:
                                        revert with 0, 17
                                    mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                    mem[_5018 + 132] = 0
                                    mem[_5018 + 164] = 160
                                    mem[_5018 + 260] = mem[_5018]
                                    idx = 0
                                    s = _5018 + 292
                                    t = _5018 + 32
                                    while idx < mem[_5018]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5018 + 196] = this.address
                                    mem[_5018 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7531 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7675 = mem[_7531]
                                    require mem[_7531] <= test266151307()
                                    require _7531 + mem[_7531] + 31 < _7531 + return_data.size
                                    _7819 = mem[_7531 + mem[_7531]]
                                    if mem[_7531 + mem[_7531]] > test266151307():
                                        revert with 0, 65
                                    if _7531 + ceil32(return_data.size) + ceil32(32 * mem[_7531 + mem[_7531]]) + 1 > test266151307() or ceil32(32 * mem[_7531 + mem[_7531]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7531 + ceil32(return_data.size) + ceil32(32 * mem[_7531 + mem[_7531]]) + 1
                                    mem[_7531 + ceil32(return_data.size)] = _7819
                                    require return_data.size >= _7675 + (32 * _7819) + 32
                                    mem[_7531 + ceil32(return_data.size) + 32 len 32 * _7819] = mem[_7531 + _7675 + 32 len 32 * _7819]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7819:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7531 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5014:
                                            revert with 0, 17
                                        mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                        mem[_5018 + 132] = 0
                                        mem[_5018 + 164] = 160
                                        mem[_5018 + 260] = mem[_5018]
                                        idx = 0
                                        s = _5018 + 292
                                        t = _5018 + 32
                                        while idx < mem[_5018]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5018 + 196] = this.address
                                        mem[_5018 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7532 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7676 = mem[_7532]
                                        require mem[_7532] <= test266151307()
                                        require _7532 + mem[_7532] + 31 < _7532 + return_data.size
                                        _7820 = mem[_7532 + mem[_7532]]
                                        if mem[_7532 + mem[_7532]] > test266151307():
                                            revert with 0, 65
                                        if _7532 + ceil32(return_data.size) + ceil32(32 * mem[_7532 + mem[_7532]]) + 1 > test266151307() or ceil32(32 * mem[_7532 + mem[_7532]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7532 + ceil32(return_data.size) + ceil32(32 * mem[_7532 + mem[_7532]]) + 1
                                        mem[_7532 + ceil32(return_data.size)] = _7820
                                        require return_data.size >= _7676 + (32 * _7820) + 32
                                        mem[_7532 + ceil32(return_data.size) + 32 len 32 * _7820] = mem[_7532 + _7676 + 32 len 32 * _7820]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _7820:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7532 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5014:
                                                revert with 0, 17
                                            mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                            mem[_5018 + 132] = 0
                                            mem[_5018 + 164] = 160
                                            mem[_5018 + 260] = mem[_5018]
                                            idx = 0
                                            s = _5018 + 292
                                            t = _5018 + 32
                                            while idx < mem[_5018]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5018 + 196] = this.address
                                            mem[_5018 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7533 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7677 = mem[_7533]
                                            require mem[_7533] <= test266151307()
                                            require _7533 + mem[_7533] + 31 < _7533 + return_data.size
                                            _7821 = mem[_7533 + mem[_7533]]
                                            if mem[_7533 + mem[_7533]] > test266151307():
                                                revert with 0, 65
                                            if _7533 + ceil32(return_data.size) + ceil32(32 * mem[_7533 + mem[_7533]]) + 1 > test266151307() or ceil32(32 * mem[_7533 + mem[_7533]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7533 + ceil32(return_data.size) + ceil32(32 * mem[_7533 + mem[_7533]]) + 1
                                            mem[_7533 + ceil32(return_data.size)] = _7821
                                            require return_data.size >= _7677 + (32 * _7821) + 32
                                            mem[_7533 + ceil32(return_data.size) + 32 len 32 * _7821] = mem[_7533 + _7677 + 32 len 32 * _7821]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7821:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7533 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5014:
                                                revert with 0, 17
                                            mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                            mem[_5018 + 132] = 0
                                            mem[_5018 + 164] = 160
                                            mem[_5018 + 260] = mem[_5018]
                                            idx = 0
                                            s = _5018 + 292
                                            t = _5018 + 32
                                            while idx < mem[_5018]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5018 + 196] = this.address
                                            mem[_5018 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7534 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7678 = mem[_7534]
                                            require mem[_7534] <= test266151307()
                                            require _7534 + mem[_7534] + 31 < _7534 + return_data.size
                                            _7822 = mem[_7534 + mem[_7534]]
                                            if mem[_7534 + mem[_7534]] > test266151307():
                                                revert with 0, 65
                                            if _7534 + ceil32(return_data.size) + ceil32(32 * mem[_7534 + mem[_7534]]) + 1 > test266151307() or ceil32(32 * mem[_7534 + mem[_7534]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7534 + ceil32(return_data.size) + ceil32(32 * mem[_7534 + mem[_7534]]) + 1
                                            mem[_7534 + ceil32(return_data.size)] = _7822
                                            require return_data.size >= _7678 + (32 * _7822) + 32
                                            mem[_7534 + ceil32(return_data.size) + 32 len 32 * _7822] = mem[_7534 + _7678 + 32 len 32 * _7822]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7822:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7534 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5014:
                                            revert with 0, 17
                                        mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                        mem[_5018 + 132] = 0
                                        mem[_5018 + 164] = 160
                                        mem[_5018 + 260] = mem[_5018]
                                        idx = 0
                                        s = _5018 + 292
                                        t = _5018 + 32
                                        while idx < mem[_5018]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5018 + 196] = this.address
                                        mem[_5018 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7535 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7679 = mem[_7535]
                                        require mem[_7535] <= test266151307()
                                        require _7535 + mem[_7535] + 31 < _7535 + return_data.size
                                        _7823 = mem[_7535 + mem[_7535]]
                                        if mem[_7535 + mem[_7535]] > test266151307():
                                            revert with 0, 65
                                        if _7535 + ceil32(return_data.size) + ceil32(32 * mem[_7535 + mem[_7535]]) + 1 > test266151307() or ceil32(32 * mem[_7535 + mem[_7535]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7535 + ceil32(return_data.size) + ceil32(32 * mem[_7535 + mem[_7535]]) + 1
                                        mem[_7535 + ceil32(return_data.size)] = _7823
                                        require return_data.size >= _7679 + (32 * _7823) + 32
                                        mem[_7535 + ceil32(return_data.size) + 32 len 32 * _7823] = mem[_7535 + _7679 + 32 len 32 * _7823]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _7823:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7535 + ceil32(return_data.size) + 64]
                                    else:
                                        if ext_call.return_data[0] > !_5014:
                                            revert with 0, 17
                                        mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                        mem[_5018 + 132] = 0
                                        mem[_5018 + 164] = 160
                                        mem[_5018 + 260] = mem[_5018]
                                        idx = 0
                                        s = _5018 + 292
                                        t = _5018 + 32
                                        while idx < mem[_5018]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5018 + 196] = this.address
                                        mem[_5018 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7536 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7680 = mem[_7536]
                                        require mem[_7536] <= test266151307()
                                        require _7536 + mem[_7536] + 31 < _7536 + return_data.size
                                        _7824 = mem[_7536 + mem[_7536]]
                                        if mem[_7536 + mem[_7536]] > test266151307():
                                            revert with 0, 65
                                        if _7536 + ceil32(return_data.size) + ceil32(32 * mem[_7536 + mem[_7536]]) + 1 > test266151307() or ceil32(32 * mem[_7536 + mem[_7536]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7536 + ceil32(return_data.size) + ceil32(32 * mem[_7536 + mem[_7536]]) + 1
                                        mem[_7536 + ceil32(return_data.size)] = _7824
                                        require return_data.size >= _7680 + (32 * _7824) + 32
                                        mem[_7536 + ceil32(return_data.size) + 32 len 32 * _7824] = mem[_7536 + _7680 + 32 len 32 * _7824]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _7824:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7536 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5014:
                                            revert with 0, 17
                                        mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                        mem[_5018 + 132] = 0
                                        mem[_5018 + 164] = 160
                                        mem[_5018 + 260] = mem[_5018]
                                        idx = 0
                                        s = _5018 + 292
                                        t = _5018 + 32
                                        while idx < mem[_5018]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5018 + 196] = this.address
                                        mem[_5018 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7537 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7681 = mem[_7537]
                                        require mem[_7537] <= test266151307()
                                        require _7537 + mem[_7537] + 31 < _7537 + return_data.size
                                        _7825 = mem[_7537 + mem[_7537]]
                                        if mem[_7537 + mem[_7537]] > test266151307():
                                            revert with 0, 65
                                        if _7537 + ceil32(return_data.size) + ceil32(32 * mem[_7537 + mem[_7537]]) + 1 > test266151307() or ceil32(32 * mem[_7537 + mem[_7537]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7537 + ceil32(return_data.size) + ceil32(32 * mem[_7537 + mem[_7537]]) + 1
                                        mem[_7537 + ceil32(return_data.size)] = _7825
                                        require return_data.size >= _7681 + (32 * _7825) + 32
                                        mem[_7537 + ceil32(return_data.size) + 32 len 32 * _7825] = mem[_7537 + _7681 + 32 len 32 * _7825]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _7825:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7537 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > !_5014:
                                                revert with 0, 17
                                            mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                            mem[_5018 + 132] = 0
                                            mem[_5018 + 164] = 160
                                            mem[_5018 + 260] = mem[_5018]
                                            idx = 0
                                            s = _5018 + 292
                                            t = _5018 + 32
                                            while idx < mem[_5018]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5018 + 196] = this.address
                                            mem[_5018 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7538 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7682 = mem[_7538]
                                            require mem[_7538] <= test266151307()
                                            require _7538 + mem[_7538] + 31 < _7538 + return_data.size
                                            _7826 = mem[_7538 + mem[_7538]]
                                            if mem[_7538 + mem[_7538]] > test266151307():
                                                revert with 0, 65
                                            if _7538 + ceil32(return_data.size) + ceil32(32 * mem[_7538 + mem[_7538]]) + 1 > test266151307() or ceil32(32 * mem[_7538 + mem[_7538]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7538 + ceil32(return_data.size) + ceil32(32 * mem[_7538 + mem[_7538]]) + 1
                                            mem[_7538 + ceil32(return_data.size)] = _7826
                                            require return_data.size >= _7682 + (32 * _7826) + 32
                                            mem[_7538 + ceil32(return_data.size) + 32 len 32 * _7826] = mem[_7538 + _7682 + 32 len 32 * _7826]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7826:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7538 + ceil32(return_data.size) + 64]
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > !_5014:
                                                    revert with 0, 17
                                                mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                                mem[_5018 + 132] = 0
                                                mem[_5018 + 164] = 160
                                                mem[_5018 + 260] = mem[_5018]
                                                idx = 0
                                                s = _5018 + 292
                                                t = _5018 + 32
                                                while idx < mem[_5018]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5018 + 196] = this.address
                                                mem[_5018 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7539 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7683 = mem[_7539]
                                                require mem[_7539] <= test266151307()
                                                require _7539 + mem[_7539] + 31 < _7539 + return_data.size
                                                _7827 = mem[_7539 + mem[_7539]]
                                                if mem[_7539 + mem[_7539]] > test266151307():
                                                    revert with 0, 65
                                                if _7539 + ceil32(return_data.size) + ceil32(32 * mem[_7539 + mem[_7539]]) + 1 > test266151307() or ceil32(32 * mem[_7539 + mem[_7539]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7539 + ceil32(return_data.size) + ceil32(32 * mem[_7539 + mem[_7539]]) + 1
                                                mem[_7539 + ceil32(return_data.size)] = _7827
                                                require return_data.size >= _7683 + (32 * _7827) + 32
                                                mem[_7539 + ceil32(return_data.size) + 32 len 32 * _7827] = mem[_7539 + _7683 + 32 len 32 * _7827]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _7827:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7539 + ceil32(return_data.size) + 64]
                                            else:
                                                if ext_call.return_data[0] > !_5014:
                                                    revert with 0, 17
                                                mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                                mem[_5018 + 132] = 0
                                                mem[_5018 + 164] = 160
                                                mem[_5018 + 260] = mem[_5018]
                                                idx = 0
                                                s = _5018 + 292
                                                t = _5018 + 32
                                                while idx < mem[_5018]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5018 + 196] = this.address
                                                mem[_5018 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7540 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7684 = mem[_7540]
                                                require mem[_7540] <= test266151307()
                                                require _7540 + mem[_7540] + 31 < _7540 + return_data.size
                                                _7828 = mem[_7540 + mem[_7540]]
                                                if mem[_7540 + mem[_7540]] > test266151307():
                                                    revert with 0, 65
                                                if _7540 + ceil32(return_data.size) + ceil32(32 * mem[_7540 + mem[_7540]]) + 1 > test266151307() or ceil32(32 * mem[_7540 + mem[_7540]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7540 + ceil32(return_data.size) + ceil32(32 * mem[_7540 + mem[_7540]]) + 1
                                                mem[_7540 + ceil32(return_data.size)] = _7828
                                                require return_data.size >= _7684 + (32 * _7828) + 32
                                                mem[_7540 + ceil32(return_data.size) + 32 len 32 * _7828] = mem[_7540 + _7684 + 32 len 32 * _7828]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _7828:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7540 + ceil32(return_data.size) + 64]
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5014:
                                                revert with 0, 17
                                            mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                            mem[_5018 + 132] = 0
                                            mem[_5018 + 164] = 160
                                            mem[_5018 + 260] = mem[_5018]
                                            idx = 0
                                            s = _5018 + 292
                                            t = _5018 + 32
                                            while idx < mem[_5018]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5018 + 196] = this.address
                                            mem[_5018 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7541 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7685 = mem[_7541]
                                            require mem[_7541] <= test266151307()
                                            require _7541 + mem[_7541] + 31 < _7541 + return_data.size
                                            _7829 = mem[_7541 + mem[_7541]]
                                            if mem[_7541 + mem[_7541]] > test266151307():
                                                revert with 0, 65
                                            if _7541 + ceil32(return_data.size) + ceil32(32 * mem[_7541 + mem[_7541]]) + 1 > test266151307() or ceil32(32 * mem[_7541 + mem[_7541]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7541 + ceil32(return_data.size) + ceil32(32 * mem[_7541 + mem[_7541]]) + 1
                                            mem[_7541 + ceil32(return_data.size)] = _7829
                                            require return_data.size >= _7685 + (32 * _7829) + 32
                                            mem[_7541 + ceil32(return_data.size) + 32 len 32 * _7829] = mem[_7541 + _7685 + 32 len 32 * _7829]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7829:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7541 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5014:
                                                revert with 0, 17
                                            mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                            mem[_5018 + 132] = 0
                                            mem[_5018 + 164] = 160
                                            mem[_5018 + 260] = mem[_5018]
                                            idx = 0
                                            s = _5018 + 292
                                            t = _5018 + 32
                                            while idx < mem[_5018]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5018 + 196] = this.address
                                            mem[_5018 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7542 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7686 = mem[_7542]
                                            require mem[_7542] <= test266151307()
                                            require _7542 + mem[_7542] + 31 < _7542 + return_data.size
                                            _7830 = mem[_7542 + mem[_7542]]
                                            if mem[_7542 + mem[_7542]] > test266151307():
                                                revert with 0, 65
                                            if _7542 + ceil32(return_data.size) + ceil32(32 * mem[_7542 + mem[_7542]]) + 1 > test266151307() or ceil32(32 * mem[_7542 + mem[_7542]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7542 + ceil32(return_data.size) + ceil32(32 * mem[_7542 + mem[_7542]]) + 1
                                            mem[_7542 + ceil32(return_data.size)] = _7830
                                            require return_data.size >= _7686 + (32 * _7830) + 32
                                            mem[_7542 + ceil32(return_data.size) + 32 len 32 * _7830] = mem[_7542 + _7686 + 32 len 32 * _7830]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7830:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7542 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5014:
                                                revert with 0, 17
                                            mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                            mem[_5018 + 132] = 0
                                            mem[_5018 + 164] = 160
                                            mem[_5018 + 260] = mem[_5018]
                                            idx = 0
                                            s = _5018 + 292
                                            t = _5018 + 32
                                            while idx < mem[_5018]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5018 + 196] = this.address
                                            mem[_5018 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7543 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7687 = mem[_7543]
                                            require mem[_7543] <= test266151307()
                                            require _7543 + mem[_7543] + 31 < _7543 + return_data.size
                                            _7831 = mem[_7543 + mem[_7543]]
                                            if mem[_7543 + mem[_7543]] > test266151307():
                                                revert with 0, 65
                                            if _7543 + ceil32(return_data.size) + ceil32(32 * mem[_7543 + mem[_7543]]) + 1 > test266151307() or ceil32(32 * mem[_7543 + mem[_7543]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7543 + ceil32(return_data.size) + ceil32(32 * mem[_7543 + mem[_7543]]) + 1
                                            mem[_7543 + ceil32(return_data.size)] = _7831
                                            require return_data.size >= _7687 + (32 * _7831) + 32
                                            mem[_7543 + ceil32(return_data.size) + 32 len 32 * _7831] = mem[_7543 + _7687 + 32 len 32 * _7831]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7831:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7543 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5014:
                                                    revert with 0, 17
                                                mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                                mem[_5018 + 132] = 0
                                                mem[_5018 + 164] = 160
                                                mem[_5018 + 260] = mem[_5018]
                                                idx = 0
                                                s = _5018 + 292
                                                t = _5018 + 32
                                                while idx < mem[_5018]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5018 + 196] = this.address
                                                mem[_5018 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7544 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7688 = mem[_7544]
                                                require mem[_7544] <= test266151307()
                                                require _7544 + mem[_7544] + 31 < _7544 + return_data.size
                                                _7832 = mem[_7544 + mem[_7544]]
                                                if mem[_7544 + mem[_7544]] > test266151307():
                                                    revert with 0, 65
                                                if _7544 + ceil32(return_data.size) + ceil32(32 * mem[_7544 + mem[_7544]]) + 1 > test266151307() or ceil32(32 * mem[_7544 + mem[_7544]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7544 + ceil32(return_data.size) + ceil32(32 * mem[_7544 + mem[_7544]]) + 1
                                                mem[_7544 + ceil32(return_data.size)] = _7832
                                                require return_data.size >= _7688 + (32 * _7832) + 32
                                                mem[_7544 + ceil32(return_data.size) + 32 len 32 * _7832] = mem[_7544 + _7688 + 32 len 32 * _7832]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _7832:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7544 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5014:
                                                        revert with 0, 17
                                                    mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                                    mem[_5018 + 132] = 0
                                                    mem[_5018 + 164] = 160
                                                    mem[_5018 + 260] = mem[_5018]
                                                    idx = 0
                                                    s = _5018 + 292
                                                    t = _5018 + 32
                                                    while idx < mem[_5018]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5018 + 196] = this.address
                                                    mem[_5018 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7545 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7689 = mem[_7545]
                                                    require mem[_7545] <= test266151307()
                                                    require _7545 + mem[_7545] + 31 < _7545 + return_data.size
                                                    _7833 = mem[_7545 + mem[_7545]]
                                                    if mem[_7545 + mem[_7545]] > test266151307():
                                                        revert with 0, 65
                                                    if _7545 + ceil32(return_data.size) + ceil32(32 * mem[_7545 + mem[_7545]]) + 1 > test266151307() or ceil32(32 * mem[_7545 + mem[_7545]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7545 + ceil32(return_data.size) + ceil32(32 * mem[_7545 + mem[_7545]]) + 1
                                                    mem[_7545 + ceil32(return_data.size)] = _7833
                                                    require return_data.size >= _7689 + (32 * _7833) + 32
                                                    mem[_7545 + ceil32(return_data.size) + 32 len 32 * _7833] = mem[_7545 + _7689 + 32 len 32 * _7833]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _7833:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7545 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5014:
                                                        revert with 0, 17
                                                    mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                                    mem[_5018 + 132] = 0
                                                    mem[_5018 + 164] = 160
                                                    mem[_5018 + 260] = mem[_5018]
                                                    idx = 0
                                                    s = _5018 + 292
                                                    t = _5018 + 32
                                                    while idx < mem[_5018]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5018 + 196] = this.address
                                                    mem[_5018 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7546 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7690 = mem[_7546]
                                                    require mem[_7546] <= test266151307()
                                                    require _7546 + mem[_7546] + 31 < _7546 + return_data.size
                                                    _7834 = mem[_7546 + mem[_7546]]
                                                    if mem[_7546 + mem[_7546]] > test266151307():
                                                        revert with 0, 65
                                                    if _7546 + ceil32(return_data.size) + ceil32(32 * mem[_7546 + mem[_7546]]) + 1 > test266151307() or ceil32(32 * mem[_7546 + mem[_7546]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7546 + ceil32(return_data.size) + ceil32(32 * mem[_7546 + mem[_7546]]) + 1
                                                    mem[_7546 + ceil32(return_data.size)] = _7834
                                                    require return_data.size >= _7690 + (32 * _7834) + 32
                                                    mem[_7546 + ceil32(return_data.size) + 32 len 32 * _7834] = mem[_7546 + _7690 + 32 len 32 * _7834]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _7834:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7546 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5014:
                                                revert with 0, 17
                                            mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                            mem[_5018 + 132] = 0
                                            mem[_5018 + 164] = 160
                                            mem[_5018 + 260] = mem[_5018]
                                            idx = 0
                                            s = _5018 + 292
                                            t = _5018 + 32
                                            while idx < mem[_5018]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5018 + 196] = this.address
                                            mem[_5018 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7547 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7691 = mem[_7547]
                                            require mem[_7547] <= test266151307()
                                            require _7547 + mem[_7547] + 31 < _7547 + return_data.size
                                            _7835 = mem[_7547 + mem[_7547]]
                                            if mem[_7547 + mem[_7547]] > test266151307():
                                                revert with 0, 65
                                            if _7547 + ceil32(return_data.size) + ceil32(32 * mem[_7547 + mem[_7547]]) + 1 > test266151307() or ceil32(32 * mem[_7547 + mem[_7547]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7547 + ceil32(return_data.size) + ceil32(32 * mem[_7547 + mem[_7547]]) + 1
                                            mem[_7547 + ceil32(return_data.size)] = _7835
                                            require return_data.size >= _7691 + (32 * _7835) + 32
                                            mem[_7547 + ceil32(return_data.size) + 32 len 32 * _7835] = mem[_7547 + _7691 + 32 len 32 * _7835]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7835:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7547 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5014:
                                                revert with 0, 17
                                            mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                            mem[_5018 + 132] = 0
                                            mem[_5018 + 164] = 160
                                            mem[_5018 + 260] = mem[_5018]
                                            idx = 0
                                            s = _5018 + 292
                                            t = _5018 + 32
                                            while idx < mem[_5018]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5018 + 196] = this.address
                                            mem[_5018 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7548 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7692 = mem[_7548]
                                            require mem[_7548] <= test266151307()
                                            require _7548 + mem[_7548] + 31 < _7548 + return_data.size
                                            _7836 = mem[_7548 + mem[_7548]]
                                            if mem[_7548 + mem[_7548]] > test266151307():
                                                revert with 0, 65
                                            if _7548 + ceil32(return_data.size) + ceil32(32 * mem[_7548 + mem[_7548]]) + 1 > test266151307() or ceil32(32 * mem[_7548 + mem[_7548]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7548 + ceil32(return_data.size) + ceil32(32 * mem[_7548 + mem[_7548]]) + 1
                                            mem[_7548 + ceil32(return_data.size)] = _7836
                                            require return_data.size >= _7692 + (32 * _7836) + 32
                                            mem[_7548 + ceil32(return_data.size) + 32 len 32 * _7836] = mem[_7548 + _7692 + 32 len 32 * _7836]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7836:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7548 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5014:
                                                revert with 0, 17
                                            mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                            mem[_5018 + 132] = 0
                                            mem[_5018 + 164] = 160
                                            mem[_5018 + 260] = mem[_5018]
                                            idx = 0
                                            s = _5018 + 292
                                            t = _5018 + 32
                                            while idx < mem[_5018]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5018 + 196] = this.address
                                            mem[_5018 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7549 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7693 = mem[_7549]
                                            require mem[_7549] <= test266151307()
                                            require _7549 + mem[_7549] + 31 < _7549 + return_data.size
                                            _7837 = mem[_7549 + mem[_7549]]
                                            if mem[_7549 + mem[_7549]] > test266151307():
                                                revert with 0, 65
                                            if _7549 + ceil32(return_data.size) + ceil32(32 * mem[_7549 + mem[_7549]]) + 1 > test266151307() or ceil32(32 * mem[_7549 + mem[_7549]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7549 + ceil32(return_data.size) + ceil32(32 * mem[_7549 + mem[_7549]]) + 1
                                            mem[_7549 + ceil32(return_data.size)] = _7837
                                            require return_data.size >= _7693 + (32 * _7837) + 32
                                            mem[_7549 + ceil32(return_data.size) + 32 len 32 * _7837] = mem[_7549 + _7693 + 32 len 32 * _7837]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7837:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7549 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5014:
                                                    revert with 0, 17
                                                mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                                mem[_5018 + 132] = 0
                                                mem[_5018 + 164] = 160
                                                mem[_5018 + 260] = mem[_5018]
                                                idx = 0
                                                s = _5018 + 292
                                                t = _5018 + 32
                                                while idx < mem[_5018]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5018 + 196] = this.address
                                                mem[_5018 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7550 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7694 = mem[_7550]
                                                require mem[_7550] <= test266151307()
                                                require _7550 + mem[_7550] + 31 < _7550 + return_data.size
                                                _7838 = mem[_7550 + mem[_7550]]
                                                if mem[_7550 + mem[_7550]] > test266151307():
                                                    revert with 0, 65
                                                if _7550 + ceil32(return_data.size) + ceil32(32 * mem[_7550 + mem[_7550]]) + 1 > test266151307() or ceil32(32 * mem[_7550 + mem[_7550]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7550 + ceil32(return_data.size) + ceil32(32 * mem[_7550 + mem[_7550]]) + 1
                                                mem[_7550 + ceil32(return_data.size)] = _7838
                                                require return_data.size >= _7694 + (32 * _7838) + 32
                                                mem[_7550 + ceil32(return_data.size) + 32 len 32 * _7838] = mem[_7550 + _7694 + 32 len 32 * _7838]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _7838:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7550 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5014:
                                                        revert with 0, 17
                                                    mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5018 + 100] = ext_call.return_data[32] + _5014
                                                    mem[_5018 + 132] = 0
                                                    mem[_5018 + 164] = 160
                                                    mem[_5018 + 260] = mem[_5018]
                                                    idx = 0
                                                    s = _5018 + 292
                                                    t = _5018 + 32
                                                    while idx < mem[_5018]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5018 + 196] = this.address
                                                    mem[_5018 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7551 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7695 = mem[_7551]
                                                    require mem[_7551] <= test266151307()
                                                    require _7551 + mem[_7551] + 31 < _7551 + return_data.size
                                                    _7839 = mem[_7551 + mem[_7551]]
                                                    if mem[_7551 + mem[_7551]] > test266151307():
                                                        revert with 0, 65
                                                    if _7551 + ceil32(return_data.size) + ceil32(32 * mem[_7551 + mem[_7551]]) + 1 > test266151307() or ceil32(32 * mem[_7551 + mem[_7551]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7551 + ceil32(return_data.size) + ceil32(32 * mem[_7551 + mem[_7551]]) + 1
                                                    mem[_7551 + ceil32(return_data.size)] = _7839
                                                    require return_data.size >= _7695 + (32 * _7839) + 32
                                                    mem[_7551 + ceil32(return_data.size) + 32 len 32 * _7839] = mem[_7551 + _7695 + 32 len 32 * _7839]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _7839:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7551 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5014:
                                                        revert with 0, 17
                                                    mem[_5018 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5018 + 100] = ext_call.return_data[0] + _5014
                                                    mem[_5018 + 132] = 0
                                                    mem[_5018 + 164] = 160
                                                    mem[_5018 + 260] = mem[_5018]
                                                    idx = 0
                                                    s = _5018 + 292
                                                    t = _5018 + 32
                                                    while idx < mem[_5018]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5018 + 196] = this.address
                                                    mem[_5018 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5018 + (32 * mem[_5018]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7552 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7696 = mem[_7552]
                                                    require mem[_7552] <= test266151307()
                                                    require _7552 + mem[_7552] + 31 < _7552 + return_data.size
                                                    _7840 = mem[_7552 + mem[_7552]]
                                                    if mem[_7552 + mem[_7552]] > test266151307():
                                                        revert with 0, 65
                                                    if _7552 + ceil32(return_data.size) + ceil32(32 * mem[_7552 + mem[_7552]]) + 1 > test266151307() or ceil32(32 * mem[_7552 + mem[_7552]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7552 + ceil32(return_data.size) + ceil32(32 * mem[_7552 + mem[_7552]]) + 1
                                                    mem[_7552 + ceil32(return_data.size)] = _7840
                                                    require return_data.size >= _7696 + (32 * _7840) + 32
                                                    mem[_7552 + ceil32(return_data.size) + 32 len 32 * _7840] = mem[_7552 + _7696 + 32 len 32 * _7840]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _7840:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7552 + ceil32(return_data.size) + 64]
            else:
                if wftmAddress == address(ext_call.return_data[0]):
                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[32]
                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 388
                    t = (4 * ceil32(return_data.size)) + 128
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[32], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2645 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28]
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _2676 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192] > test266151307():
                        revert with 0, 65
                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[32 len 28] + 192]
                    require return_data.size >= _2645 + (32 * _2676) + 32
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2676] = mem[(4 * ceil32(return_data.size)) + _2645 + 224 len 32 * _2676]
                    if 1 >= _2676:
                        revert with 0, 50
                    _5015 = mem[(6 * ceil32(return_data.size)) + 256]
                    _5019 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_5019]:
                        revert with 0, 50
                    mem[_5019 + 32] = address(ext_call.return_data[0])
                    if 1 >= mem[_5019]:
                        revert with 0, 50
                    mem[_5019 + 64] = brushAddress
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5015:
                                        revert with 0, 17
                                    mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                    mem[_5019 + 132] = 0
                                    mem[_5019 + 164] = 160
                                    mem[_5019 + 260] = mem[_5019]
                                    idx = 0
                                    s = _5019 + 292
                                    t = _5019 + 32
                                    while idx < mem[_5019]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5019 + 196] = this.address
                                    mem[_5019 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7553 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7697 = mem[_7553]
                                    require mem[_7553] <= test266151307()
                                    require _7553 + mem[_7553] + 31 < _7553 + return_data.size
                                    _7841 = mem[_7553 + mem[_7553]]
                                    if mem[_7553 + mem[_7553]] > test266151307():
                                        revert with 0, 65
                                    if _7553 + ceil32(return_data.size) + ceil32(32 * mem[_7553 + mem[_7553]]) + 1 > test266151307() or ceil32(32 * mem[_7553 + mem[_7553]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7553 + ceil32(return_data.size) + ceil32(32 * mem[_7553 + mem[_7553]]) + 1
                                    mem[_7553 + ceil32(return_data.size)] = _7841
                                    require return_data.size >= _7697 + (32 * _7841) + 32
                                    mem[_7553 + ceil32(return_data.size) + 32 len 32 * _7841] = mem[_7553 + _7697 + 32 len 32 * _7841]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7841:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7553 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5015:
                                        revert with 0, 17
                                    mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                    mem[_5019 + 132] = 0
                                    mem[_5019 + 164] = 160
                                    mem[_5019 + 260] = mem[_5019]
                                    idx = 0
                                    s = _5019 + 292
                                    t = _5019 + 32
                                    while idx < mem[_5019]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5019 + 196] = this.address
                                    mem[_5019 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7554 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7698 = mem[_7554]
                                    require mem[_7554] <= test266151307()
                                    require _7554 + mem[_7554] + 31 < _7554 + return_data.size
                                    _7842 = mem[_7554 + mem[_7554]]
                                    if mem[_7554 + mem[_7554]] > test266151307():
                                        revert with 0, 65
                                    if _7554 + ceil32(return_data.size) + ceil32(32 * mem[_7554 + mem[_7554]]) + 1 > test266151307() or ceil32(32 * mem[_7554 + mem[_7554]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7554 + ceil32(return_data.size) + ceil32(32 * mem[_7554 + mem[_7554]]) + 1
                                    mem[_7554 + ceil32(return_data.size)] = _7842
                                    require return_data.size >= _7698 + (32 * _7842) + 32
                                    mem[_7554 + ceil32(return_data.size) + 32 len 32 * _7842] = mem[_7554 + _7698 + 32 len 32 * _7842]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7842:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7554 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5015:
                                        revert with 0, 17
                                    mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                    mem[_5019 + 132] = 0
                                    mem[_5019 + 164] = 160
                                    mem[_5019 + 260] = mem[_5019]
                                    idx = 0
                                    s = _5019 + 292
                                    t = _5019 + 32
                                    while idx < mem[_5019]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5019 + 196] = this.address
                                    mem[_5019 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7555 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7699 = mem[_7555]
                                    require mem[_7555] <= test266151307()
                                    require _7555 + mem[_7555] + 31 < _7555 + return_data.size
                                    _7843 = mem[_7555 + mem[_7555]]
                                    if mem[_7555 + mem[_7555]] > test266151307():
                                        revert with 0, 65
                                    if _7555 + ceil32(return_data.size) + ceil32(32 * mem[_7555 + mem[_7555]]) + 1 > test266151307() or ceil32(32 * mem[_7555 + mem[_7555]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7555 + ceil32(return_data.size) + ceil32(32 * mem[_7555 + mem[_7555]]) + 1
                                    mem[_7555 + ceil32(return_data.size)] = _7843
                                    require return_data.size >= _7699 + (32 * _7843) + 32
                                    mem[_7555 + ceil32(return_data.size) + 32 len 32 * _7843] = mem[_7555 + _7699 + 32 len 32 * _7843]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7843:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7555 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5015:
                                            revert with 0, 17
                                        mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                        mem[_5019 + 132] = 0
                                        mem[_5019 + 164] = 160
                                        mem[_5019 + 260] = mem[_5019]
                                        idx = 0
                                        s = _5019 + 292
                                        t = _5019 + 32
                                        while idx < mem[_5019]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5019 + 196] = this.address
                                        mem[_5019 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7556 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7700 = mem[_7556]
                                        require mem[_7556] <= test266151307()
                                        require _7556 + mem[_7556] + 31 < _7556 + return_data.size
                                        _7844 = mem[_7556 + mem[_7556]]
                                        if mem[_7556 + mem[_7556]] > test266151307():
                                            revert with 0, 65
                                        if _7556 + ceil32(return_data.size) + ceil32(32 * mem[_7556 + mem[_7556]]) + 1 > test266151307() or ceil32(32 * mem[_7556 + mem[_7556]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7556 + ceil32(return_data.size) + ceil32(32 * mem[_7556 + mem[_7556]]) + 1
                                        mem[_7556 + ceil32(return_data.size)] = _7844
                                        require return_data.size >= _7700 + (32 * _7844) + 32
                                        mem[_7556 + ceil32(return_data.size) + 32 len 32 * _7844] = mem[_7556 + _7700 + 32 len 32 * _7844]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _7844:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7556 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5015:
                                                revert with 0, 17
                                            mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                            mem[_5019 + 132] = 0
                                            mem[_5019 + 164] = 160
                                            mem[_5019 + 260] = mem[_5019]
                                            idx = 0
                                            s = _5019 + 292
                                            t = _5019 + 32
                                            while idx < mem[_5019]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5019 + 196] = this.address
                                            mem[_5019 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7557 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7701 = mem[_7557]
                                            require mem[_7557] <= test266151307()
                                            require _7557 + mem[_7557] + 31 < _7557 + return_data.size
                                            _7845 = mem[_7557 + mem[_7557]]
                                            if mem[_7557 + mem[_7557]] > test266151307():
                                                revert with 0, 65
                                            if _7557 + ceil32(return_data.size) + ceil32(32 * mem[_7557 + mem[_7557]]) + 1 > test266151307() or ceil32(32 * mem[_7557 + mem[_7557]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7557 + ceil32(return_data.size) + ceil32(32 * mem[_7557 + mem[_7557]]) + 1
                                            mem[_7557 + ceil32(return_data.size)] = _7845
                                            require return_data.size >= _7701 + (32 * _7845) + 32
                                            mem[_7557 + ceil32(return_data.size) + 32 len 32 * _7845] = mem[_7557 + _7701 + 32 len 32 * _7845]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7845:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7557 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5015:
                                                revert with 0, 17
                                            mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                            mem[_5019 + 132] = 0
                                            mem[_5019 + 164] = 160
                                            mem[_5019 + 260] = mem[_5019]
                                            idx = 0
                                            s = _5019 + 292
                                            t = _5019 + 32
                                            while idx < mem[_5019]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5019 + 196] = this.address
                                            mem[_5019 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7558 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7702 = mem[_7558]
                                            require mem[_7558] <= test266151307()
                                            require _7558 + mem[_7558] + 31 < _7558 + return_data.size
                                            _7846 = mem[_7558 + mem[_7558]]
                                            if mem[_7558 + mem[_7558]] > test266151307():
                                                revert with 0, 65
                                            if _7558 + ceil32(return_data.size) + ceil32(32 * mem[_7558 + mem[_7558]]) + 1 > test266151307() or ceil32(32 * mem[_7558 + mem[_7558]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7558 + ceil32(return_data.size) + ceil32(32 * mem[_7558 + mem[_7558]]) + 1
                                            mem[_7558 + ceil32(return_data.size)] = _7846
                                            require return_data.size >= _7702 + (32 * _7846) + 32
                                            mem[_7558 + ceil32(return_data.size) + 32 len 32 * _7846] = mem[_7558 + _7702 + 32 len 32 * _7846]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7846:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7558 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5015:
                                        revert with 0, 17
                                    mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                    mem[_5019 + 132] = 0
                                    mem[_5019 + 164] = 160
                                    mem[_5019 + 260] = mem[_5019]
                                    idx = 0
                                    s = _5019 + 292
                                    t = _5019 + 32
                                    while idx < mem[_5019]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5019 + 196] = this.address
                                    mem[_5019 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7559 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7703 = mem[_7559]
                                    require mem[_7559] <= test266151307()
                                    require _7559 + mem[_7559] + 31 < _7559 + return_data.size
                                    _7847 = mem[_7559 + mem[_7559]]
                                    if mem[_7559 + mem[_7559]] > test266151307():
                                        revert with 0, 65
                                    if _7559 + ceil32(return_data.size) + ceil32(32 * mem[_7559 + mem[_7559]]) + 1 > test266151307() or ceil32(32 * mem[_7559 + mem[_7559]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7559 + ceil32(return_data.size) + ceil32(32 * mem[_7559 + mem[_7559]]) + 1
                                    mem[_7559 + ceil32(return_data.size)] = _7847
                                    require return_data.size >= _7703 + (32 * _7847) + 32
                                    mem[_7559 + ceil32(return_data.size) + 32 len 32 * _7847] = mem[_7559 + _7703 + 32 len 32 * _7847]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7847:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7559 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5015:
                                        revert with 0, 17
                                    mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                    mem[_5019 + 132] = 0
                                    mem[_5019 + 164] = 160
                                    mem[_5019 + 260] = mem[_5019]
                                    idx = 0
                                    s = _5019 + 292
                                    t = _5019 + 32
                                    while idx < mem[_5019]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5019 + 196] = this.address
                                    mem[_5019 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7560 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7704 = mem[_7560]
                                    require mem[_7560] <= test266151307()
                                    require _7560 + mem[_7560] + 31 < _7560 + return_data.size
                                    _7848 = mem[_7560 + mem[_7560]]
                                    if mem[_7560 + mem[_7560]] > test266151307():
                                        revert with 0, 65
                                    if _7560 + ceil32(return_data.size) + ceil32(32 * mem[_7560 + mem[_7560]]) + 1 > test266151307() or ceil32(32 * mem[_7560 + mem[_7560]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7560 + ceil32(return_data.size) + ceil32(32 * mem[_7560 + mem[_7560]]) + 1
                                    mem[_7560 + ceil32(return_data.size)] = _7848
                                    require return_data.size >= _7704 + (32 * _7848) + 32
                                    mem[_7560 + ceil32(return_data.size) + 32 len 32 * _7848] = mem[_7560 + _7704 + 32 len 32 * _7848]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7848:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7560 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5015:
                                        revert with 0, 17
                                    mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                    mem[_5019 + 132] = 0
                                    mem[_5019 + 164] = 160
                                    mem[_5019 + 260] = mem[_5019]
                                    idx = 0
                                    s = _5019 + 292
                                    t = _5019 + 32
                                    while idx < mem[_5019]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5019 + 196] = this.address
                                    mem[_5019 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7561 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7705 = mem[_7561]
                                    require mem[_7561] <= test266151307()
                                    require _7561 + mem[_7561] + 31 < _7561 + return_data.size
                                    _7849 = mem[_7561 + mem[_7561]]
                                    if mem[_7561 + mem[_7561]] > test266151307():
                                        revert with 0, 65
                                    if _7561 + ceil32(return_data.size) + ceil32(32 * mem[_7561 + mem[_7561]]) + 1 > test266151307() or ceil32(32 * mem[_7561 + mem[_7561]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7561 + ceil32(return_data.size) + ceil32(32 * mem[_7561 + mem[_7561]]) + 1
                                    mem[_7561 + ceil32(return_data.size)] = _7849
                                    require return_data.size >= _7705 + (32 * _7849) + 32
                                    mem[_7561 + ceil32(return_data.size) + 32 len 32 * _7849] = mem[_7561 + _7705 + 32 len 32 * _7849]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7849:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7561 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5015:
                                            revert with 0, 17
                                        mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                        mem[_5019 + 132] = 0
                                        mem[_5019 + 164] = 160
                                        mem[_5019 + 260] = mem[_5019]
                                        idx = 0
                                        s = _5019 + 292
                                        t = _5019 + 32
                                        while idx < mem[_5019]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5019 + 196] = this.address
                                        mem[_5019 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7562 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7706 = mem[_7562]
                                        require mem[_7562] <= test266151307()
                                        require _7562 + mem[_7562] + 31 < _7562 + return_data.size
                                        _7850 = mem[_7562 + mem[_7562]]
                                        if mem[_7562 + mem[_7562]] > test266151307():
                                            revert with 0, 65
                                        if _7562 + ceil32(return_data.size) + ceil32(32 * mem[_7562 + mem[_7562]]) + 1 > test266151307() or ceil32(32 * mem[_7562 + mem[_7562]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7562 + ceil32(return_data.size) + ceil32(32 * mem[_7562 + mem[_7562]]) + 1
                                        mem[_7562 + ceil32(return_data.size)] = _7850
                                        require return_data.size >= _7706 + (32 * _7850) + 32
                                        mem[_7562 + ceil32(return_data.size) + 32 len 32 * _7850] = mem[_7562 + _7706 + 32 len 32 * _7850]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _7850:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7562 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5015:
                                                revert with 0, 17
                                            mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                            mem[_5019 + 132] = 0
                                            mem[_5019 + 164] = 160
                                            mem[_5019 + 260] = mem[_5019]
                                            idx = 0
                                            s = _5019 + 292
                                            t = _5019 + 32
                                            while idx < mem[_5019]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5019 + 196] = this.address
                                            mem[_5019 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7563 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7707 = mem[_7563]
                                            require mem[_7563] <= test266151307()
                                            require _7563 + mem[_7563] + 31 < _7563 + return_data.size
                                            _7851 = mem[_7563 + mem[_7563]]
                                            if mem[_7563 + mem[_7563]] > test266151307():
                                                revert with 0, 65
                                            if _7563 + ceil32(return_data.size) + ceil32(32 * mem[_7563 + mem[_7563]]) + 1 > test266151307() or ceil32(32 * mem[_7563 + mem[_7563]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7563 + ceil32(return_data.size) + ceil32(32 * mem[_7563 + mem[_7563]]) + 1
                                            mem[_7563 + ceil32(return_data.size)] = _7851
                                            require return_data.size >= _7707 + (32 * _7851) + 32
                                            mem[_7563 + ceil32(return_data.size) + 32 len 32 * _7851] = mem[_7563 + _7707 + 32 len 32 * _7851]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7851:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7563 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5015:
                                                revert with 0, 17
                                            mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                            mem[_5019 + 132] = 0
                                            mem[_5019 + 164] = 160
                                            mem[_5019 + 260] = mem[_5019]
                                            idx = 0
                                            s = _5019 + 292
                                            t = _5019 + 32
                                            while idx < mem[_5019]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5019 + 196] = this.address
                                            mem[_5019 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7564 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7708 = mem[_7564]
                                            require mem[_7564] <= test266151307()
                                            require _7564 + mem[_7564] + 31 < _7564 + return_data.size
                                            _7852 = mem[_7564 + mem[_7564]]
                                            if mem[_7564 + mem[_7564]] > test266151307():
                                                revert with 0, 65
                                            if _7564 + ceil32(return_data.size) + ceil32(32 * mem[_7564 + mem[_7564]]) + 1 > test266151307() or ceil32(32 * mem[_7564 + mem[_7564]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7564 + ceil32(return_data.size) + ceil32(32 * mem[_7564 + mem[_7564]]) + 1
                                            mem[_7564 + ceil32(return_data.size)] = _7852
                                            require return_data.size >= _7708 + (32 * _7852) + 32
                                            mem[_7564 + ceil32(return_data.size) + 32 len 32 * _7852] = mem[_7564 + _7708 + 32 len 32 * _7852]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7852:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7564 + ceil32(return_data.size) + 64]
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5015:
                                        revert with 0, 17
                                    mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                    mem[_5019 + 132] = 0
                                    mem[_5019 + 164] = 160
                                    mem[_5019 + 260] = mem[_5019]
                                    idx = 0
                                    s = _5019 + 292
                                    t = _5019 + 32
                                    while idx < mem[_5019]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5019 + 196] = this.address
                                    mem[_5019 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7565 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7709 = mem[_7565]
                                    require mem[_7565] <= test266151307()
                                    require _7565 + mem[_7565] + 31 < _7565 + return_data.size
                                    _7853 = mem[_7565 + mem[_7565]]
                                    if mem[_7565 + mem[_7565]] > test266151307():
                                        revert with 0, 65
                                    if _7565 + ceil32(return_data.size) + ceil32(32 * mem[_7565 + mem[_7565]]) + 1 > test266151307() or ceil32(32 * mem[_7565 + mem[_7565]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7565 + ceil32(return_data.size) + ceil32(32 * mem[_7565 + mem[_7565]]) + 1
                                    mem[_7565 + ceil32(return_data.size)] = _7853
                                    require return_data.size >= _7709 + (32 * _7853) + 32
                                    mem[_7565 + ceil32(return_data.size) + 32 len 32 * _7853] = mem[_7565 + _7709 + 32 len 32 * _7853]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7853:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7565 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5015:
                                        revert with 0, 17
                                    mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                    mem[_5019 + 132] = 0
                                    mem[_5019 + 164] = 160
                                    mem[_5019 + 260] = mem[_5019]
                                    idx = 0
                                    s = _5019 + 292
                                    t = _5019 + 32
                                    while idx < mem[_5019]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5019 + 196] = this.address
                                    mem[_5019 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7566 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7710 = mem[_7566]
                                    require mem[_7566] <= test266151307()
                                    require _7566 + mem[_7566] + 31 < _7566 + return_data.size
                                    _7854 = mem[_7566 + mem[_7566]]
                                    if mem[_7566 + mem[_7566]] > test266151307():
                                        revert with 0, 65
                                    if _7566 + ceil32(return_data.size) + ceil32(32 * mem[_7566 + mem[_7566]]) + 1 > test266151307() or ceil32(32 * mem[_7566 + mem[_7566]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7566 + ceil32(return_data.size) + ceil32(32 * mem[_7566 + mem[_7566]]) + 1
                                    mem[_7566 + ceil32(return_data.size)] = _7854
                                    require return_data.size >= _7710 + (32 * _7854) + 32
                                    mem[_7566 + ceil32(return_data.size) + 32 len 32 * _7854] = mem[_7566 + _7710 + 32 len 32 * _7854]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7854:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7566 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5015:
                                        revert with 0, 17
                                    mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                    mem[_5019 + 132] = 0
                                    mem[_5019 + 164] = 160
                                    mem[_5019 + 260] = mem[_5019]
                                    idx = 0
                                    s = _5019 + 292
                                    t = _5019 + 32
                                    while idx < mem[_5019]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5019 + 196] = this.address
                                    mem[_5019 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7567 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7711 = mem[_7567]
                                    require mem[_7567] <= test266151307()
                                    require _7567 + mem[_7567] + 31 < _7567 + return_data.size
                                    _7855 = mem[_7567 + mem[_7567]]
                                    if mem[_7567 + mem[_7567]] > test266151307():
                                        revert with 0, 65
                                    if _7567 + ceil32(return_data.size) + ceil32(32 * mem[_7567 + mem[_7567]]) + 1 > test266151307() or ceil32(32 * mem[_7567 + mem[_7567]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7567 + ceil32(return_data.size) + ceil32(32 * mem[_7567 + mem[_7567]]) + 1
                                    mem[_7567 + ceil32(return_data.size)] = _7855
                                    require return_data.size >= _7711 + (32 * _7855) + 32
                                    mem[_7567 + ceil32(return_data.size) + 32 len 32 * _7855] = mem[_7567 + _7711 + 32 len 32 * _7855]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7855:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7567 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5015:
                                            revert with 0, 17
                                        mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                        mem[_5019 + 132] = 0
                                        mem[_5019 + 164] = 160
                                        mem[_5019 + 260] = mem[_5019]
                                        idx = 0
                                        s = _5019 + 292
                                        t = _5019 + 32
                                        while idx < mem[_5019]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5019 + 196] = this.address
                                        mem[_5019 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7568 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7712 = mem[_7568]
                                        require mem[_7568] <= test266151307()
                                        require _7568 + mem[_7568] + 31 < _7568 + return_data.size
                                        _7856 = mem[_7568 + mem[_7568]]
                                        if mem[_7568 + mem[_7568]] > test266151307():
                                            revert with 0, 65
                                        if _7568 + ceil32(return_data.size) + ceil32(32 * mem[_7568 + mem[_7568]]) + 1 > test266151307() or ceil32(32 * mem[_7568 + mem[_7568]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7568 + ceil32(return_data.size) + ceil32(32 * mem[_7568 + mem[_7568]]) + 1
                                        mem[_7568 + ceil32(return_data.size)] = _7856
                                        require return_data.size >= _7712 + (32 * _7856) + 32
                                        mem[_7568 + ceil32(return_data.size) + 32 len 32 * _7856] = mem[_7568 + _7712 + 32 len 32 * _7856]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _7856:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7568 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5015:
                                                revert with 0, 17
                                            mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                            mem[_5019 + 132] = 0
                                            mem[_5019 + 164] = 160
                                            mem[_5019 + 260] = mem[_5019]
                                            idx = 0
                                            s = _5019 + 292
                                            t = _5019 + 32
                                            while idx < mem[_5019]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5019 + 196] = this.address
                                            mem[_5019 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7569 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7713 = mem[_7569]
                                            require mem[_7569] <= test266151307()
                                            require _7569 + mem[_7569] + 31 < _7569 + return_data.size
                                            _7857 = mem[_7569 + mem[_7569]]
                                            if mem[_7569 + mem[_7569]] > test266151307():
                                                revert with 0, 65
                                            if _7569 + ceil32(return_data.size) + ceil32(32 * mem[_7569 + mem[_7569]]) + 1 > test266151307() or ceil32(32 * mem[_7569 + mem[_7569]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7569 + ceil32(return_data.size) + ceil32(32 * mem[_7569 + mem[_7569]]) + 1
                                            mem[_7569 + ceil32(return_data.size)] = _7857
                                            require return_data.size >= _7713 + (32 * _7857) + 32
                                            mem[_7569 + ceil32(return_data.size) + 32 len 32 * _7857] = mem[_7569 + _7713 + 32 len 32 * _7857]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7857:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7569 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5015:
                                                revert with 0, 17
                                            mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                            mem[_5019 + 132] = 0
                                            mem[_5019 + 164] = 160
                                            mem[_5019 + 260] = mem[_5019]
                                            idx = 0
                                            s = _5019 + 292
                                            t = _5019 + 32
                                            while idx < mem[_5019]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5019 + 196] = this.address
                                            mem[_5019 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7570 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7714 = mem[_7570]
                                            require mem[_7570] <= test266151307()
                                            require _7570 + mem[_7570] + 31 < _7570 + return_data.size
                                            _7858 = mem[_7570 + mem[_7570]]
                                            if mem[_7570 + mem[_7570]] > test266151307():
                                                revert with 0, 65
                                            if _7570 + ceil32(return_data.size) + ceil32(32 * mem[_7570 + mem[_7570]]) + 1 > test266151307() or ceil32(32 * mem[_7570 + mem[_7570]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7570 + ceil32(return_data.size) + ceil32(32 * mem[_7570 + mem[_7570]]) + 1
                                            mem[_7570 + ceil32(return_data.size)] = _7858
                                            require return_data.size >= _7714 + (32 * _7858) + 32
                                            mem[_7570 + ceil32(return_data.size) + 32 len 32 * _7858] = mem[_7570 + _7714 + 32 len 32 * _7858]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7858:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7570 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5015:
                                            revert with 0, 17
                                        mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                        mem[_5019 + 132] = 0
                                        mem[_5019 + 164] = 160
                                        mem[_5019 + 260] = mem[_5019]
                                        idx = 0
                                        s = _5019 + 292
                                        t = _5019 + 32
                                        while idx < mem[_5019]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5019 + 196] = this.address
                                        mem[_5019 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7571 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7715 = mem[_7571]
                                        require mem[_7571] <= test266151307()
                                        require _7571 + mem[_7571] + 31 < _7571 + return_data.size
                                        _7859 = mem[_7571 + mem[_7571]]
                                        if mem[_7571 + mem[_7571]] > test266151307():
                                            revert with 0, 65
                                        if _7571 + ceil32(return_data.size) + ceil32(32 * mem[_7571 + mem[_7571]]) + 1 > test266151307() or ceil32(32 * mem[_7571 + mem[_7571]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7571 + ceil32(return_data.size) + ceil32(32 * mem[_7571 + mem[_7571]]) + 1
                                        mem[_7571 + ceil32(return_data.size)] = _7859
                                        require return_data.size >= _7715 + (32 * _7859) + 32
                                        mem[_7571 + ceil32(return_data.size) + 32 len 32 * _7859] = mem[_7571 + _7715 + 32 len 32 * _7859]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _7859:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7571 + ceil32(return_data.size) + 64]
                                    else:
                                        if ext_call.return_data[0] > !_5015:
                                            revert with 0, 17
                                        mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                        mem[_5019 + 132] = 0
                                        mem[_5019 + 164] = 160
                                        mem[_5019 + 260] = mem[_5019]
                                        idx = 0
                                        s = _5019 + 292
                                        t = _5019 + 32
                                        while idx < mem[_5019]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5019 + 196] = this.address
                                        mem[_5019 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7572 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7716 = mem[_7572]
                                        require mem[_7572] <= test266151307()
                                        require _7572 + mem[_7572] + 31 < _7572 + return_data.size
                                        _7860 = mem[_7572 + mem[_7572]]
                                        if mem[_7572 + mem[_7572]] > test266151307():
                                            revert with 0, 65
                                        if _7572 + ceil32(return_data.size) + ceil32(32 * mem[_7572 + mem[_7572]]) + 1 > test266151307() or ceil32(32 * mem[_7572 + mem[_7572]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7572 + ceil32(return_data.size) + ceil32(32 * mem[_7572 + mem[_7572]]) + 1
                                        mem[_7572 + ceil32(return_data.size)] = _7860
                                        require return_data.size >= _7716 + (32 * _7860) + 32
                                        mem[_7572 + ceil32(return_data.size) + 32 len 32 * _7860] = mem[_7572 + _7716 + 32 len 32 * _7860]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _7860:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7572 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5015:
                                            revert with 0, 17
                                        mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                        mem[_5019 + 132] = 0
                                        mem[_5019 + 164] = 160
                                        mem[_5019 + 260] = mem[_5019]
                                        idx = 0
                                        s = _5019 + 292
                                        t = _5019 + 32
                                        while idx < mem[_5019]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5019 + 196] = this.address
                                        mem[_5019 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7573 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7717 = mem[_7573]
                                        require mem[_7573] <= test266151307()
                                        require _7573 + mem[_7573] + 31 < _7573 + return_data.size
                                        _7861 = mem[_7573 + mem[_7573]]
                                        if mem[_7573 + mem[_7573]] > test266151307():
                                            revert with 0, 65
                                        if _7573 + ceil32(return_data.size) + ceil32(32 * mem[_7573 + mem[_7573]]) + 1 > test266151307() or ceil32(32 * mem[_7573 + mem[_7573]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7573 + ceil32(return_data.size) + ceil32(32 * mem[_7573 + mem[_7573]]) + 1
                                        mem[_7573 + ceil32(return_data.size)] = _7861
                                        require return_data.size >= _7717 + (32 * _7861) + 32
                                        mem[_7573 + ceil32(return_data.size) + 32 len 32 * _7861] = mem[_7573 + _7717 + 32 len 32 * _7861]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _7861:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7573 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > !_5015:
                                                revert with 0, 17
                                            mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                            mem[_5019 + 132] = 0
                                            mem[_5019 + 164] = 160
                                            mem[_5019 + 260] = mem[_5019]
                                            idx = 0
                                            s = _5019 + 292
                                            t = _5019 + 32
                                            while idx < mem[_5019]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5019 + 196] = this.address
                                            mem[_5019 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7574 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7718 = mem[_7574]
                                            require mem[_7574] <= test266151307()
                                            require _7574 + mem[_7574] + 31 < _7574 + return_data.size
                                            _7862 = mem[_7574 + mem[_7574]]
                                            if mem[_7574 + mem[_7574]] > test266151307():
                                                revert with 0, 65
                                            if _7574 + ceil32(return_data.size) + ceil32(32 * mem[_7574 + mem[_7574]]) + 1 > test266151307() or ceil32(32 * mem[_7574 + mem[_7574]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7574 + ceil32(return_data.size) + ceil32(32 * mem[_7574 + mem[_7574]]) + 1
                                            mem[_7574 + ceil32(return_data.size)] = _7862
                                            require return_data.size >= _7718 + (32 * _7862) + 32
                                            mem[_7574 + ceil32(return_data.size) + 32 len 32 * _7862] = mem[_7574 + _7718 + 32 len 32 * _7862]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7862:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7574 + ceil32(return_data.size) + 64]
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > !_5015:
                                                    revert with 0, 17
                                                mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                                mem[_5019 + 132] = 0
                                                mem[_5019 + 164] = 160
                                                mem[_5019 + 260] = mem[_5019]
                                                idx = 0
                                                s = _5019 + 292
                                                t = _5019 + 32
                                                while idx < mem[_5019]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5019 + 196] = this.address
                                                mem[_5019 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7575 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7719 = mem[_7575]
                                                require mem[_7575] <= test266151307()
                                                require _7575 + mem[_7575] + 31 < _7575 + return_data.size
                                                _7863 = mem[_7575 + mem[_7575]]
                                                if mem[_7575 + mem[_7575]] > test266151307():
                                                    revert with 0, 65
                                                if _7575 + ceil32(return_data.size) + ceil32(32 * mem[_7575 + mem[_7575]]) + 1 > test266151307() or ceil32(32 * mem[_7575 + mem[_7575]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7575 + ceil32(return_data.size) + ceil32(32 * mem[_7575 + mem[_7575]]) + 1
                                                mem[_7575 + ceil32(return_data.size)] = _7863
                                                require return_data.size >= _7719 + (32 * _7863) + 32
                                                mem[_7575 + ceil32(return_data.size) + 32 len 32 * _7863] = mem[_7575 + _7719 + 32 len 32 * _7863]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _7863:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7575 + ceil32(return_data.size) + 64]
                                            else:
                                                if ext_call.return_data[0] > !_5015:
                                                    revert with 0, 17
                                                mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                                mem[_5019 + 132] = 0
                                                mem[_5019 + 164] = 160
                                                mem[_5019 + 260] = mem[_5019]
                                                idx = 0
                                                s = _5019 + 292
                                                t = _5019 + 32
                                                while idx < mem[_5019]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5019 + 196] = this.address
                                                mem[_5019 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7576 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7720 = mem[_7576]
                                                require mem[_7576] <= test266151307()
                                                require _7576 + mem[_7576] + 31 < _7576 + return_data.size
                                                _7864 = mem[_7576 + mem[_7576]]
                                                if mem[_7576 + mem[_7576]] > test266151307():
                                                    revert with 0, 65
                                                if _7576 + ceil32(return_data.size) + ceil32(32 * mem[_7576 + mem[_7576]]) + 1 > test266151307() or ceil32(32 * mem[_7576 + mem[_7576]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7576 + ceil32(return_data.size) + ceil32(32 * mem[_7576 + mem[_7576]]) + 1
                                                mem[_7576 + ceil32(return_data.size)] = _7864
                                                require return_data.size >= _7720 + (32 * _7864) + 32
                                                mem[_7576 + ceil32(return_data.size) + 32 len 32 * _7864] = mem[_7576 + _7720 + 32 len 32 * _7864]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _7864:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7576 + ceil32(return_data.size) + 64]
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5015:
                                                revert with 0, 17
                                            mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                            mem[_5019 + 132] = 0
                                            mem[_5019 + 164] = 160
                                            mem[_5019 + 260] = mem[_5019]
                                            idx = 0
                                            s = _5019 + 292
                                            t = _5019 + 32
                                            while idx < mem[_5019]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5019 + 196] = this.address
                                            mem[_5019 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7577 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7721 = mem[_7577]
                                            require mem[_7577] <= test266151307()
                                            require _7577 + mem[_7577] + 31 < _7577 + return_data.size
                                            _7865 = mem[_7577 + mem[_7577]]
                                            if mem[_7577 + mem[_7577]] > test266151307():
                                                revert with 0, 65
                                            if _7577 + ceil32(return_data.size) + ceil32(32 * mem[_7577 + mem[_7577]]) + 1 > test266151307() or ceil32(32 * mem[_7577 + mem[_7577]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7577 + ceil32(return_data.size) + ceil32(32 * mem[_7577 + mem[_7577]]) + 1
                                            mem[_7577 + ceil32(return_data.size)] = _7865
                                            require return_data.size >= _7721 + (32 * _7865) + 32
                                            mem[_7577 + ceil32(return_data.size) + 32 len 32 * _7865] = mem[_7577 + _7721 + 32 len 32 * _7865]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7865:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7577 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5015:
                                                revert with 0, 17
                                            mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                            mem[_5019 + 132] = 0
                                            mem[_5019 + 164] = 160
                                            mem[_5019 + 260] = mem[_5019]
                                            idx = 0
                                            s = _5019 + 292
                                            t = _5019 + 32
                                            while idx < mem[_5019]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5019 + 196] = this.address
                                            mem[_5019 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7578 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7722 = mem[_7578]
                                            require mem[_7578] <= test266151307()
                                            require _7578 + mem[_7578] + 31 < _7578 + return_data.size
                                            _7866 = mem[_7578 + mem[_7578]]
                                            if mem[_7578 + mem[_7578]] > test266151307():
                                                revert with 0, 65
                                            if _7578 + ceil32(return_data.size) + ceil32(32 * mem[_7578 + mem[_7578]]) + 1 > test266151307() or ceil32(32 * mem[_7578 + mem[_7578]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7578 + ceil32(return_data.size) + ceil32(32 * mem[_7578 + mem[_7578]]) + 1
                                            mem[_7578 + ceil32(return_data.size)] = _7866
                                            require return_data.size >= _7722 + (32 * _7866) + 32
                                            mem[_7578 + ceil32(return_data.size) + 32 len 32 * _7866] = mem[_7578 + _7722 + 32 len 32 * _7866]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7866:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7578 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5015:
                                                revert with 0, 17
                                            mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                            mem[_5019 + 132] = 0
                                            mem[_5019 + 164] = 160
                                            mem[_5019 + 260] = mem[_5019]
                                            idx = 0
                                            s = _5019 + 292
                                            t = _5019 + 32
                                            while idx < mem[_5019]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5019 + 196] = this.address
                                            mem[_5019 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7579 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7723 = mem[_7579]
                                            require mem[_7579] <= test266151307()
                                            require _7579 + mem[_7579] + 31 < _7579 + return_data.size
                                            _7867 = mem[_7579 + mem[_7579]]
                                            if mem[_7579 + mem[_7579]] > test266151307():
                                                revert with 0, 65
                                            if _7579 + ceil32(return_data.size) + ceil32(32 * mem[_7579 + mem[_7579]]) + 1 > test266151307() or ceil32(32 * mem[_7579 + mem[_7579]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7579 + ceil32(return_data.size) + ceil32(32 * mem[_7579 + mem[_7579]]) + 1
                                            mem[_7579 + ceil32(return_data.size)] = _7867
                                            require return_data.size >= _7723 + (32 * _7867) + 32
                                            mem[_7579 + ceil32(return_data.size) + 32 len 32 * _7867] = mem[_7579 + _7723 + 32 len 32 * _7867]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7867:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7579 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5015:
                                                    revert with 0, 17
                                                mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                                mem[_5019 + 132] = 0
                                                mem[_5019 + 164] = 160
                                                mem[_5019 + 260] = mem[_5019]
                                                idx = 0
                                                s = _5019 + 292
                                                t = _5019 + 32
                                                while idx < mem[_5019]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5019 + 196] = this.address
                                                mem[_5019 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7580 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7724 = mem[_7580]
                                                require mem[_7580] <= test266151307()
                                                require _7580 + mem[_7580] + 31 < _7580 + return_data.size
                                                _7868 = mem[_7580 + mem[_7580]]
                                                if mem[_7580 + mem[_7580]] > test266151307():
                                                    revert with 0, 65
                                                if _7580 + ceil32(return_data.size) + ceil32(32 * mem[_7580 + mem[_7580]]) + 1 > test266151307() or ceil32(32 * mem[_7580 + mem[_7580]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7580 + ceil32(return_data.size) + ceil32(32 * mem[_7580 + mem[_7580]]) + 1
                                                mem[_7580 + ceil32(return_data.size)] = _7868
                                                require return_data.size >= _7724 + (32 * _7868) + 32
                                                mem[_7580 + ceil32(return_data.size) + 32 len 32 * _7868] = mem[_7580 + _7724 + 32 len 32 * _7868]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _7868:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7580 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5015:
                                                        revert with 0, 17
                                                    mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                                    mem[_5019 + 132] = 0
                                                    mem[_5019 + 164] = 160
                                                    mem[_5019 + 260] = mem[_5019]
                                                    idx = 0
                                                    s = _5019 + 292
                                                    t = _5019 + 32
                                                    while idx < mem[_5019]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5019 + 196] = this.address
                                                    mem[_5019 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7581 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7725 = mem[_7581]
                                                    require mem[_7581] <= test266151307()
                                                    require _7581 + mem[_7581] + 31 < _7581 + return_data.size
                                                    _7869 = mem[_7581 + mem[_7581]]
                                                    if mem[_7581 + mem[_7581]] > test266151307():
                                                        revert with 0, 65
                                                    if _7581 + ceil32(return_data.size) + ceil32(32 * mem[_7581 + mem[_7581]]) + 1 > test266151307() or ceil32(32 * mem[_7581 + mem[_7581]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7581 + ceil32(return_data.size) + ceil32(32 * mem[_7581 + mem[_7581]]) + 1
                                                    mem[_7581 + ceil32(return_data.size)] = _7869
                                                    require return_data.size >= _7725 + (32 * _7869) + 32
                                                    mem[_7581 + ceil32(return_data.size) + 32 len 32 * _7869] = mem[_7581 + _7725 + 32 len 32 * _7869]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _7869:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7581 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5015:
                                                        revert with 0, 17
                                                    mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                                    mem[_5019 + 132] = 0
                                                    mem[_5019 + 164] = 160
                                                    mem[_5019 + 260] = mem[_5019]
                                                    idx = 0
                                                    s = _5019 + 292
                                                    t = _5019 + 32
                                                    while idx < mem[_5019]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5019 + 196] = this.address
                                                    mem[_5019 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7582 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7726 = mem[_7582]
                                                    require mem[_7582] <= test266151307()
                                                    require _7582 + mem[_7582] + 31 < _7582 + return_data.size
                                                    _7870 = mem[_7582 + mem[_7582]]
                                                    if mem[_7582 + mem[_7582]] > test266151307():
                                                        revert with 0, 65
                                                    if _7582 + ceil32(return_data.size) + ceil32(32 * mem[_7582 + mem[_7582]]) + 1 > test266151307() or ceil32(32 * mem[_7582 + mem[_7582]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7582 + ceil32(return_data.size) + ceil32(32 * mem[_7582 + mem[_7582]]) + 1
                                                    mem[_7582 + ceil32(return_data.size)] = _7870
                                                    require return_data.size >= _7726 + (32 * _7870) + 32
                                                    mem[_7582 + ceil32(return_data.size) + 32 len 32 * _7870] = mem[_7582 + _7726 + 32 len 32 * _7870]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _7870:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7582 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5015:
                                                revert with 0, 17
                                            mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                            mem[_5019 + 132] = 0
                                            mem[_5019 + 164] = 160
                                            mem[_5019 + 260] = mem[_5019]
                                            idx = 0
                                            s = _5019 + 292
                                            t = _5019 + 32
                                            while idx < mem[_5019]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5019 + 196] = this.address
                                            mem[_5019 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7583 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7727 = mem[_7583]
                                            require mem[_7583] <= test266151307()
                                            require _7583 + mem[_7583] + 31 < _7583 + return_data.size
                                            _7871 = mem[_7583 + mem[_7583]]
                                            if mem[_7583 + mem[_7583]] > test266151307():
                                                revert with 0, 65
                                            if _7583 + ceil32(return_data.size) + ceil32(32 * mem[_7583 + mem[_7583]]) + 1 > test266151307() or ceil32(32 * mem[_7583 + mem[_7583]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7583 + ceil32(return_data.size) + ceil32(32 * mem[_7583 + mem[_7583]]) + 1
                                            mem[_7583 + ceil32(return_data.size)] = _7871
                                            require return_data.size >= _7727 + (32 * _7871) + 32
                                            mem[_7583 + ceil32(return_data.size) + 32 len 32 * _7871] = mem[_7583 + _7727 + 32 len 32 * _7871]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7871:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7583 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5015:
                                                revert with 0, 17
                                            mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                            mem[_5019 + 132] = 0
                                            mem[_5019 + 164] = 160
                                            mem[_5019 + 260] = mem[_5019]
                                            idx = 0
                                            s = _5019 + 292
                                            t = _5019 + 32
                                            while idx < mem[_5019]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5019 + 196] = this.address
                                            mem[_5019 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7584 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7728 = mem[_7584]
                                            require mem[_7584] <= test266151307()
                                            require _7584 + mem[_7584] + 31 < _7584 + return_data.size
                                            _7872 = mem[_7584 + mem[_7584]]
                                            if mem[_7584 + mem[_7584]] > test266151307():
                                                revert with 0, 65
                                            if _7584 + ceil32(return_data.size) + ceil32(32 * mem[_7584 + mem[_7584]]) + 1 > test266151307() or ceil32(32 * mem[_7584 + mem[_7584]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7584 + ceil32(return_data.size) + ceil32(32 * mem[_7584 + mem[_7584]]) + 1
                                            mem[_7584 + ceil32(return_data.size)] = _7872
                                            require return_data.size >= _7728 + (32 * _7872) + 32
                                            mem[_7584 + ceil32(return_data.size) + 32 len 32 * _7872] = mem[_7584 + _7728 + 32 len 32 * _7872]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7872:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7584 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5015:
                                                revert with 0, 17
                                            mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                            mem[_5019 + 132] = 0
                                            mem[_5019 + 164] = 160
                                            mem[_5019 + 260] = mem[_5019]
                                            idx = 0
                                            s = _5019 + 292
                                            t = _5019 + 32
                                            while idx < mem[_5019]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5019 + 196] = this.address
                                            mem[_5019 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7585 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7729 = mem[_7585]
                                            require mem[_7585] <= test266151307()
                                            require _7585 + mem[_7585] + 31 < _7585 + return_data.size
                                            _7873 = mem[_7585 + mem[_7585]]
                                            if mem[_7585 + mem[_7585]] > test266151307():
                                                revert with 0, 65
                                            if _7585 + ceil32(return_data.size) + ceil32(32 * mem[_7585 + mem[_7585]]) + 1 > test266151307() or ceil32(32 * mem[_7585 + mem[_7585]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7585 + ceil32(return_data.size) + ceil32(32 * mem[_7585 + mem[_7585]]) + 1
                                            mem[_7585 + ceil32(return_data.size)] = _7873
                                            require return_data.size >= _7729 + (32 * _7873) + 32
                                            mem[_7585 + ceil32(return_data.size) + 32 len 32 * _7873] = mem[_7585 + _7729 + 32 len 32 * _7873]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7873:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7585 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5015:
                                                    revert with 0, 17
                                                mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                                mem[_5019 + 132] = 0
                                                mem[_5019 + 164] = 160
                                                mem[_5019 + 260] = mem[_5019]
                                                idx = 0
                                                s = _5019 + 292
                                                t = _5019 + 32
                                                while idx < mem[_5019]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5019 + 196] = this.address
                                                mem[_5019 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7586 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7730 = mem[_7586]
                                                require mem[_7586] <= test266151307()
                                                require _7586 + mem[_7586] + 31 < _7586 + return_data.size
                                                _7874 = mem[_7586 + mem[_7586]]
                                                if mem[_7586 + mem[_7586]] > test266151307():
                                                    revert with 0, 65
                                                if _7586 + ceil32(return_data.size) + ceil32(32 * mem[_7586 + mem[_7586]]) + 1 > test266151307() or ceil32(32 * mem[_7586 + mem[_7586]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7586 + ceil32(return_data.size) + ceil32(32 * mem[_7586 + mem[_7586]]) + 1
                                                mem[_7586 + ceil32(return_data.size)] = _7874
                                                require return_data.size >= _7730 + (32 * _7874) + 32
                                                mem[_7586 + ceil32(return_data.size) + 32 len 32 * _7874] = mem[_7586 + _7730 + 32 len 32 * _7874]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _7874:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7586 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5015:
                                                        revert with 0, 17
                                                    mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5019 + 100] = ext_call.return_data[32] + _5015
                                                    mem[_5019 + 132] = 0
                                                    mem[_5019 + 164] = 160
                                                    mem[_5019 + 260] = mem[_5019]
                                                    idx = 0
                                                    s = _5019 + 292
                                                    t = _5019 + 32
                                                    while idx < mem[_5019]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5019 + 196] = this.address
                                                    mem[_5019 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7587 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7731 = mem[_7587]
                                                    require mem[_7587] <= test266151307()
                                                    require _7587 + mem[_7587] + 31 < _7587 + return_data.size
                                                    _7875 = mem[_7587 + mem[_7587]]
                                                    if mem[_7587 + mem[_7587]] > test266151307():
                                                        revert with 0, 65
                                                    if _7587 + ceil32(return_data.size) + ceil32(32 * mem[_7587 + mem[_7587]]) + 1 > test266151307() or ceil32(32 * mem[_7587 + mem[_7587]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7587 + ceil32(return_data.size) + ceil32(32 * mem[_7587 + mem[_7587]]) + 1
                                                    mem[_7587 + ceil32(return_data.size)] = _7875
                                                    require return_data.size >= _7731 + (32 * _7875) + 32
                                                    mem[_7587 + ceil32(return_data.size) + 32 len 32 * _7875] = mem[_7587 + _7731 + 32 len 32 * _7875]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _7875:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7587 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5015:
                                                        revert with 0, 17
                                                    mem[_5019 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5019 + 100] = ext_call.return_data[0] + _5015
                                                    mem[_5019 + 132] = 0
                                                    mem[_5019 + 164] = 160
                                                    mem[_5019 + 260] = mem[_5019]
                                                    idx = 0
                                                    s = _5019 + 292
                                                    t = _5019 + 32
                                                    while idx < mem[_5019]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5019 + 196] = this.address
                                                    mem[_5019 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5019 + (32 * mem[_5019]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7588 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7732 = mem[_7588]
                                                    require mem[_7588] <= test266151307()
                                                    require _7588 + mem[_7588] + 31 < _7588 + return_data.size
                                                    _7876 = mem[_7588 + mem[_7588]]
                                                    if mem[_7588 + mem[_7588]] > test266151307():
                                                        revert with 0, 65
                                                    if _7588 + ceil32(return_data.size) + ceil32(32 * mem[_7588 + mem[_7588]]) + 1 > test266151307() or ceil32(32 * mem[_7588 + mem[_7588]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7588 + ceil32(return_data.size) + ceil32(32 * mem[_7588 + mem[_7588]]) + 1
                                                    mem[_7588 + ceil32(return_data.size)] = _7876
                                                    require return_data.size >= _7732 + (32 * _7876) + 32
                                                    mem[_7588 + ceil32(return_data.size) + 32 len 32 * _7876] = mem[_7588 + _7732 + 32 len 32 * _7876]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _7876:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7588 + ceil32(return_data.size) + 64]
                else:
                    mem[(4 * ceil32(return_data.size)) + 196] = ext_call.return_data[0]
                    mem[(4 * ceil32(return_data.size)) + 228] = 0
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 388
                    t = (4 * ceil32(return_data.size)) + 128
                    while idx < 2:
                        mem[s] = mem[t + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = this.address
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp + 10000
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 0, 160, address(this.address), block.timestamp + 10000, 2, mem[(4 * ceil32(return_data.size)) + 388 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _2646 = mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28]
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 223 < (4 * ceil32(return_data.size)) + return_data.size + 192
                    _2677 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192] > test266151307():
                        revert with 0, 65
                    if (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193 > test266151307() or ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 1 < 0:
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], ext_call.return_data[0 len 28] + 192]
                    require return_data.size >= _2646 + (32 * _2677) + 32
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _2677] = mem[(4 * ceil32(return_data.size)) + _2646 + 224 len 32 * _2677]
                    if 1 >= _2677:
                        revert with 0, 50
                    _5016 = mem[(6 * ceil32(return_data.size)) + 256]
                    _5020 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_5020]:
                        revert with 0, 50
                    mem[_5020 + 32] = address(ext_call.return_data[0])
                    if 1 >= mem[_5020]:
                        revert with 0, 50
                    mem[_5020 + 64] = brushAddress
                    if brushAddress != address(ext_call.return_data[0]):
                        if wftmAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5016:
                                        revert with 0, 17
                                    mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5020 + 100] = ext_call.return_data[32] + _5016
                                    mem[_5020 + 132] = 0
                                    mem[_5020 + 164] = 160
                                    mem[_5020 + 260] = mem[_5020]
                                    idx = 0
                                    s = _5020 + 292
                                    t = _5020 + 32
                                    while idx < mem[_5020]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5020 + 196] = this.address
                                    mem[_5020 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7589 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7733 = mem[_7589]
                                    require mem[_7589] <= test266151307()
                                    require _7589 + mem[_7589] + 31 < _7589 + return_data.size
                                    _7877 = mem[_7589 + mem[_7589]]
                                    if mem[_7589 + mem[_7589]] > test266151307():
                                        revert with 0, 65
                                    if _7589 + ceil32(return_data.size) + ceil32(32 * mem[_7589 + mem[_7589]]) + 1 > test266151307() or ceil32(32 * mem[_7589 + mem[_7589]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7589 + ceil32(return_data.size) + ceil32(32 * mem[_7589 + mem[_7589]]) + 1
                                    mem[_7589 + ceil32(return_data.size)] = _7877
                                    require return_data.size >= _7733 + (32 * _7877) + 32
                                    mem[_7589 + ceil32(return_data.size) + 32 len 32 * _7877] = mem[_7589 + _7733 + 32 len 32 * _7877]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7877:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7589 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5016:
                                        revert with 0, 17
                                    mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5020 + 100] = ext_call.return_data[0] + _5016
                                    mem[_5020 + 132] = 0
                                    mem[_5020 + 164] = 160
                                    mem[_5020 + 260] = mem[_5020]
                                    idx = 0
                                    s = _5020 + 292
                                    t = _5020 + 32
                                    while idx < mem[_5020]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5020 + 196] = this.address
                                    mem[_5020 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7590 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7734 = mem[_7590]
                                    require mem[_7590] <= test266151307()
                                    require _7590 + mem[_7590] + 31 < _7590 + return_data.size
                                    _7878 = mem[_7590 + mem[_7590]]
                                    if mem[_7590 + mem[_7590]] > test266151307():
                                        revert with 0, 65
                                    if _7590 + ceil32(return_data.size) + ceil32(32 * mem[_7590 + mem[_7590]]) + 1 > test266151307() or ceil32(32 * mem[_7590 + mem[_7590]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7590 + ceil32(return_data.size) + ceil32(32 * mem[_7590 + mem[_7590]]) + 1
                                    mem[_7590 + ceil32(return_data.size)] = _7878
                                    require return_data.size >= _7734 + (32 * _7878) + 32
                                    mem[_7590 + ceil32(return_data.size) + 32 len 32 * _7878] = mem[_7590 + _7734 + 32 len 32 * _7878]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7878:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7590 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5016:
                                        revert with 0, 17
                                    mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5020 + 100] = ext_call.return_data[32] + _5016
                                    mem[_5020 + 132] = 0
                                    mem[_5020 + 164] = 160
                                    mem[_5020 + 260] = mem[_5020]
                                    idx = 0
                                    s = _5020 + 292
                                    t = _5020 + 32
                                    while idx < mem[_5020]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5020 + 196] = this.address
                                    mem[_5020 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7591 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7735 = mem[_7591]
                                    require mem[_7591] <= test266151307()
                                    require _7591 + mem[_7591] + 31 < _7591 + return_data.size
                                    _7879 = mem[_7591 + mem[_7591]]
                                    if mem[_7591 + mem[_7591]] > test266151307():
                                        revert with 0, 65
                                    if _7591 + ceil32(return_data.size) + ceil32(32 * mem[_7591 + mem[_7591]]) + 1 > test266151307() or ceil32(32 * mem[_7591 + mem[_7591]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7591 + ceil32(return_data.size) + ceil32(32 * mem[_7591 + mem[_7591]]) + 1
                                    mem[_7591 + ceil32(return_data.size)] = _7879
                                    require return_data.size >= _7735 + (32 * _7879) + 32
                                    mem[_7591 + ceil32(return_data.size) + 32 len 32 * _7879] = mem[_7591 + _7735 + 32 len 32 * _7879]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7879:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7591 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5016:
                                            revert with 0, 17
                                        mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5020 + 100] = ext_call.return_data[0] + _5016
                                        mem[_5020 + 132] = 0
                                        mem[_5020 + 164] = 160
                                        mem[_5020 + 260] = mem[_5020]
                                        idx = 0
                                        s = _5020 + 292
                                        t = _5020 + 32
                                        while idx < mem[_5020]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5020 + 196] = this.address
                                        mem[_5020 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7592 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7736 = mem[_7592]
                                        require mem[_7592] <= test266151307()
                                        require _7592 + mem[_7592] + 31 < _7592 + return_data.size
                                        _7880 = mem[_7592 + mem[_7592]]
                                        if mem[_7592 + mem[_7592]] > test266151307():
                                            revert with 0, 65
                                        if _7592 + ceil32(return_data.size) + ceil32(32 * mem[_7592 + mem[_7592]]) + 1 > test266151307() or ceil32(32 * mem[_7592 + mem[_7592]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7592 + ceil32(return_data.size) + ceil32(32 * mem[_7592 + mem[_7592]]) + 1
                                        mem[_7592 + ceil32(return_data.size)] = _7880
                                        require return_data.size >= _7736 + (32 * _7880) + 32
                                        mem[_7592 + ceil32(return_data.size) + 32 len 32 * _7880] = mem[_7592 + _7736 + 32 len 32 * _7880]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _7880:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7592 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5016:
                                                revert with 0, 17
                                            mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5020 + 100] = ext_call.return_data[32] + _5016
                                            mem[_5020 + 132] = 0
                                            mem[_5020 + 164] = 160
                                            mem[_5020 + 260] = mem[_5020]
                                            idx = 0
                                            s = _5020 + 292
                                            t = _5020 + 32
                                            while idx < mem[_5020]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5020 + 196] = this.address
                                            mem[_5020 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7593 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7737 = mem[_7593]
                                            require mem[_7593] <= test266151307()
                                            require _7593 + mem[_7593] + 31 < _7593 + return_data.size
                                            _7881 = mem[_7593 + mem[_7593]]
                                            if mem[_7593 + mem[_7593]] > test266151307():
                                                revert with 0, 65
                                            if _7593 + ceil32(return_data.size) + ceil32(32 * mem[_7593 + mem[_7593]]) + 1 > test266151307() or ceil32(32 * mem[_7593 + mem[_7593]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7593 + ceil32(return_data.size) + ceil32(32 * mem[_7593 + mem[_7593]]) + 1
                                            mem[_7593 + ceil32(return_data.size)] = _7881
                                            require return_data.size >= _7737 + (32 * _7881) + 32
                                            mem[_7593 + ceil32(return_data.size) + 32 len 32 * _7881] = mem[_7593 + _7737 + 32 len 32 * _7881]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7881:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7593 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5016:
                                                revert with 0, 17
                                            mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5020 + 100] = ext_call.return_data[0] + _5016
                                            mem[_5020 + 132] = 0
                                            mem[_5020 + 164] = 160
                                            mem[_5020 + 260] = mem[_5020]
                                            idx = 0
                                            s = _5020 + 292
                                            t = _5020 + 32
                                            while idx < mem[_5020]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5020 + 196] = this.address
                                            mem[_5020 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7594 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7738 = mem[_7594]
                                            require mem[_7594] <= test266151307()
                                            require _7594 + mem[_7594] + 31 < _7594 + return_data.size
                                            _7882 = mem[_7594 + mem[_7594]]
                                            if mem[_7594 + mem[_7594]] > test266151307():
                                                revert with 0, 65
                                            if _7594 + ceil32(return_data.size) + ceil32(32 * mem[_7594 + mem[_7594]]) + 1 > test266151307() or ceil32(32 * mem[_7594 + mem[_7594]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7594 + ceil32(return_data.size) + ceil32(32 * mem[_7594 + mem[_7594]]) + 1
                                            mem[_7594 + ceil32(return_data.size)] = _7882
                                            require return_data.size >= _7738 + (32 * _7882) + 32
                                            mem[_7594 + ceil32(return_data.size) + 32 len 32 * _7882] = mem[_7594 + _7738 + 32 len 32 * _7882]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7882:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7594 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5016:
                                        revert with 0, 17
                                    mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5020 + 100] = ext_call.return_data[32] + _5016
                                    mem[_5020 + 132] = 0
                                    mem[_5020 + 164] = 160
                                    mem[_5020 + 260] = mem[_5020]
                                    idx = 0
                                    s = _5020 + 292
                                    t = _5020 + 32
                                    while idx < mem[_5020]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5020 + 196] = this.address
                                    mem[_5020 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7595 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7739 = mem[_7595]
                                    require mem[_7595] <= test266151307()
                                    require _7595 + mem[_7595] + 31 < _7595 + return_data.size
                                    _7883 = mem[_7595 + mem[_7595]]
                                    if mem[_7595 + mem[_7595]] > test266151307():
                                        revert with 0, 65
                                    if _7595 + ceil32(return_data.size) + ceil32(32 * mem[_7595 + mem[_7595]]) + 1 > test266151307() or ceil32(32 * mem[_7595 + mem[_7595]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7595 + ceil32(return_data.size) + ceil32(32 * mem[_7595 + mem[_7595]]) + 1
                                    mem[_7595 + ceil32(return_data.size)] = _7883
                                    require return_data.size >= _7739 + (32 * _7883) + 32
                                    mem[_7595 + ceil32(return_data.size) + 32 len 32 * _7883] = mem[_7595 + _7739 + 32 len 32 * _7883]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7883:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7595 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5016:
                                        revert with 0, 17
                                    mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5020 + 100] = ext_call.return_data[0] + _5016
                                    mem[_5020 + 132] = 0
                                    mem[_5020 + 164] = 160
                                    mem[_5020 + 260] = mem[_5020]
                                    idx = 0
                                    s = _5020 + 292
                                    t = _5020 + 32
                                    while idx < mem[_5020]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5020 + 196] = this.address
                                    mem[_5020 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7596 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7740 = mem[_7596]
                                    require mem[_7596] <= test266151307()
                                    require _7596 + mem[_7596] + 31 < _7596 + return_data.size
                                    _7884 = mem[_7596 + mem[_7596]]
                                    if mem[_7596 + mem[_7596]] > test266151307():
                                        revert with 0, 65
                                    if _7596 + ceil32(return_data.size) + ceil32(32 * mem[_7596 + mem[_7596]]) + 1 > test266151307() or ceil32(32 * mem[_7596 + mem[_7596]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7596 + ceil32(return_data.size) + ceil32(32 * mem[_7596 + mem[_7596]]) + 1
                                    mem[_7596 + ceil32(return_data.size)] = _7884
                                    require return_data.size >= _7740 + (32 * _7884) + 32
                                    mem[_7596 + ceil32(return_data.size) + 32 len 32 * _7884] = mem[_7596 + _7740 + 32 len 32 * _7884]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7884:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7596 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5016:
                                        revert with 0, 17
                                    mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5020 + 100] = ext_call.return_data[32] + _5016
                                    mem[_5020 + 132] = 0
                                    mem[_5020 + 164] = 160
                                    mem[_5020 + 260] = mem[_5020]
                                    idx = 0
                                    s = _5020 + 292
                                    t = _5020 + 32
                                    while idx < mem[_5020]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5020 + 196] = this.address
                                    mem[_5020 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7597 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7741 = mem[_7597]
                                    require mem[_7597] <= test266151307()
                                    require _7597 + mem[_7597] + 31 < _7597 + return_data.size
                                    _7885 = mem[_7597 + mem[_7597]]
                                    if mem[_7597 + mem[_7597]] > test266151307():
                                        revert with 0, 65
                                    if _7597 + ceil32(return_data.size) + ceil32(32 * mem[_7597 + mem[_7597]]) + 1 > test266151307() or ceil32(32 * mem[_7597 + mem[_7597]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7597 + ceil32(return_data.size) + ceil32(32 * mem[_7597 + mem[_7597]]) + 1
                                    mem[_7597 + ceil32(return_data.size)] = _7885
                                    require return_data.size >= _7741 + (32 * _7885) + 32
                                    mem[_7597 + ceil32(return_data.size) + 32 len 32 * _7885] = mem[_7597 + _7741 + 32 len 32 * _7885]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7885:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7597 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5016:
                                            revert with 0, 17
                                        mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5020 + 100] = ext_call.return_data[0] + _5016
                                        mem[_5020 + 132] = 0
                                        mem[_5020 + 164] = 160
                                        mem[_5020 + 260] = mem[_5020]
                                        idx = 0
                                        s = _5020 + 292
                                        t = _5020 + 32
                                        while idx < mem[_5020]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5020 + 196] = this.address
                                        mem[_5020 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7598 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7742 = mem[_7598]
                                        require mem[_7598] <= test266151307()
                                        require _7598 + mem[_7598] + 31 < _7598 + return_data.size
                                        _7886 = mem[_7598 + mem[_7598]]
                                        if mem[_7598 + mem[_7598]] > test266151307():
                                            revert with 0, 65
                                        if _7598 + ceil32(return_data.size) + ceil32(32 * mem[_7598 + mem[_7598]]) + 1 > test266151307() or ceil32(32 * mem[_7598 + mem[_7598]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7598 + ceil32(return_data.size) + ceil32(32 * mem[_7598 + mem[_7598]]) + 1
                                        mem[_7598 + ceil32(return_data.size)] = _7886
                                        require return_data.size >= _7742 + (32 * _7886) + 32
                                        mem[_7598 + ceil32(return_data.size) + 32 len 32 * _7886] = mem[_7598 + _7742 + 32 len 32 * _7886]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _7886:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7598 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5016:
                                                revert with 0, 17
                                            mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5020 + 100] = ext_call.return_data[32] + _5016
                                            mem[_5020 + 132] = 0
                                            mem[_5020 + 164] = 160
                                            mem[_5020 + 260] = mem[_5020]
                                            idx = 0
                                            s = _5020 + 292
                                            t = _5020 + 32
                                            while idx < mem[_5020]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5020 + 196] = this.address
                                            mem[_5020 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7599 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7743 = mem[_7599]
                                            require mem[_7599] <= test266151307()
                                            require _7599 + mem[_7599] + 31 < _7599 + return_data.size
                                            _7887 = mem[_7599 + mem[_7599]]
                                            if mem[_7599 + mem[_7599]] > test266151307():
                                                revert with 0, 65
                                            if _7599 + ceil32(return_data.size) + ceil32(32 * mem[_7599 + mem[_7599]]) + 1 > test266151307() or ceil32(32 * mem[_7599 + mem[_7599]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7599 + ceil32(return_data.size) + ceil32(32 * mem[_7599 + mem[_7599]]) + 1
                                            mem[_7599 + ceil32(return_data.size)] = _7887
                                            require return_data.size >= _7743 + (32 * _7887) + 32
                                            mem[_7599 + ceil32(return_data.size) + 32 len 32 * _7887] = mem[_7599 + _7743 + 32 len 32 * _7887]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7887:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7599 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5016:
                                                revert with 0, 17
                                            mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5020 + 100] = ext_call.return_data[0] + _5016
                                            mem[_5020 + 132] = 0
                                            mem[_5020 + 164] = 160
                                            mem[_5020 + 260] = mem[_5020]
                                            idx = 0
                                            s = _5020 + 292
                                            t = _5020 + 32
                                            while idx < mem[_5020]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5020 + 196] = this.address
                                            mem[_5020 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7600 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7744 = mem[_7600]
                                            require mem[_7600] <= test266151307()
                                            require _7600 + mem[_7600] + 31 < _7600 + return_data.size
                                            _7888 = mem[_7600 + mem[_7600]]
                                            if mem[_7600 + mem[_7600]] > test266151307():
                                                revert with 0, 65
                                            if _7600 + ceil32(return_data.size) + ceil32(32 * mem[_7600 + mem[_7600]]) + 1 > test266151307() or ceil32(32 * mem[_7600 + mem[_7600]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7600 + ceil32(return_data.size) + ceil32(32 * mem[_7600 + mem[_7600]]) + 1
                                            mem[_7600 + ceil32(return_data.size)] = _7888
                                            require return_data.size >= _7744 + (32 * _7888) + 32
                                            mem[_7600 + ceil32(return_data.size) + 32 len 32 * _7888] = mem[_7600 + _7744 + 32 len 32 * _7888]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7888:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7600 + ceil32(return_data.size) + 64]
                    else:
                        if brushAddress == address(ext_call.return_data[0]):
                            if brushAddress != address(ext_call.return_data[0]):
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5016:
                                        revert with 0, 17
                                    mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5020 + 100] = ext_call.return_data[32] + _5016
                                    mem[_5020 + 132] = 0
                                    mem[_5020 + 164] = 160
                                    mem[_5020 + 260] = mem[_5020]
                                    idx = 0
                                    s = _5020 + 292
                                    t = _5020 + 32
                                    while idx < mem[_5020]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5020 + 196] = this.address
                                    mem[_5020 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7601 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7745 = mem[_7601]
                                    require mem[_7601] <= test266151307()
                                    require _7601 + mem[_7601] + 31 < _7601 + return_data.size
                                    _7889 = mem[_7601 + mem[_7601]]
                                    if mem[_7601 + mem[_7601]] > test266151307():
                                        revert with 0, 65
                                    if _7601 + ceil32(return_data.size) + ceil32(32 * mem[_7601 + mem[_7601]]) + 1 > test266151307() or ceil32(32 * mem[_7601 + mem[_7601]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7601 + ceil32(return_data.size) + ceil32(32 * mem[_7601 + mem[_7601]]) + 1
                                    mem[_7601 + ceil32(return_data.size)] = _7889
                                    require return_data.size >= _7745 + (32 * _7889) + 32
                                    mem[_7601 + ceil32(return_data.size) + 32 len 32 * _7889] = mem[_7601 + _7745 + 32 len 32 * _7889]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7889:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7601 + ceil32(return_data.size) + 64]
                                else:
                                    if ext_call.return_data[0] > !_5016:
                                        revert with 0, 17
                                    mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5020 + 100] = ext_call.return_data[0] + _5016
                                    mem[_5020 + 132] = 0
                                    mem[_5020 + 164] = 160
                                    mem[_5020 + 260] = mem[_5020]
                                    idx = 0
                                    s = _5020 + 292
                                    t = _5020 + 32
                                    while idx < mem[_5020]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5020 + 196] = this.address
                                    mem[_5020 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7602 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7746 = mem[_7602]
                                    require mem[_7602] <= test266151307()
                                    require _7602 + mem[_7602] + 31 < _7602 + return_data.size
                                    _7890 = mem[_7602 + mem[_7602]]
                                    if mem[_7602 + mem[_7602]] > test266151307():
                                        revert with 0, 65
                                    if _7602 + ceil32(return_data.size) + ceil32(32 * mem[_7602 + mem[_7602]]) + 1 > test266151307() or ceil32(32 * mem[_7602 + mem[_7602]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7602 + ceil32(return_data.size) + ceil32(32 * mem[_7602 + mem[_7602]]) + 1
                                    mem[_7602 + ceil32(return_data.size)] = _7890
                                    require return_data.size >= _7746 + (32 * _7890) + 32
                                    mem[_7602 + ceil32(return_data.size) + 32 len 32 * _7890] = mem[_7602 + _7746 + 32 len 32 * _7890]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7890:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7602 + ceil32(return_data.size) + 64]
                            else:
                                if brushAddress == address(ext_call.return_data[0]):
                                    if ext_call.return_data[32] > !_5016:
                                        revert with 0, 17
                                    mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_5020 + 100] = ext_call.return_data[32] + _5016
                                    mem[_5020 + 132] = 0
                                    mem[_5020 + 164] = 160
                                    mem[_5020 + 260] = mem[_5020]
                                    idx = 0
                                    s = _5020 + 292
                                    t = _5020 + 32
                                    while idx < mem[_5020]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5020 + 196] = this.address
                                    mem[_5020 + 228] = block.timestamp + 10000
                                    require ext_code.size(routerAddress)
                                    call routerAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _7603 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _7747 = mem[_7603]
                                    require mem[_7603] <= test266151307()
                                    require _7603 + mem[_7603] + 31 < _7603 + return_data.size
                                    _7891 = mem[_7603 + mem[_7603]]
                                    if mem[_7603 + mem[_7603]] > test266151307():
                                        revert with 0, 65
                                    if _7603 + ceil32(return_data.size) + ceil32(32 * mem[_7603 + mem[_7603]]) + 1 > test266151307() or ceil32(32 * mem[_7603 + mem[_7603]]) + 1 < 0:
                                        revert with 0, 65
                                    mem[64] = _7603 + ceil32(return_data.size) + ceil32(32 * mem[_7603 + mem[_7603]]) + 1
                                    mem[_7603 + ceil32(return_data.size)] = _7891
                                    require return_data.size >= _7747 + (32 * _7891) + 32
                                    mem[_7603 + ceil32(return_data.size) + 32 len 32 * _7891] = mem[_7603 + _7747 + 32 len 32 * _7891]
                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                        revert with 0, 17
                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                    if 1 >= _7891:
                                        revert with 0, 50
                                    require ext_code.size(brushAddress)
                                    call brushAddress.burn(uint256 rg1) with:
                                         gas gas_remaining wei
                                        args mem[_7603 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[0] > !_5016:
                                            revert with 0, 17
                                        mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5020 + 100] = ext_call.return_data[0] + _5016
                                        mem[_5020 + 132] = 0
                                        mem[_5020 + 164] = 160
                                        mem[_5020 + 260] = mem[_5020]
                                        idx = 0
                                        s = _5020 + 292
                                        t = _5020 + 32
                                        while idx < mem[_5020]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5020 + 196] = this.address
                                        mem[_5020 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7604 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7748 = mem[_7604]
                                        require mem[_7604] <= test266151307()
                                        require _7604 + mem[_7604] + 31 < _7604 + return_data.size
                                        _7892 = mem[_7604 + mem[_7604]]
                                        if mem[_7604 + mem[_7604]] > test266151307():
                                            revert with 0, 65
                                        if _7604 + ceil32(return_data.size) + ceil32(32 * mem[_7604 + mem[_7604]]) + 1 > test266151307() or ceil32(32 * mem[_7604 + mem[_7604]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7604 + ceil32(return_data.size) + ceil32(32 * mem[_7604 + mem[_7604]]) + 1
                                        mem[_7604 + ceil32(return_data.size)] = _7892
                                        require return_data.size >= _7748 + (32 * _7892) + 32
                                        mem[_7604 + ceil32(return_data.size) + 32 len 32 * _7892] = mem[_7604 + _7748 + 32 len 32 * _7892]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _7892:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7604 + ceil32(return_data.size) + 64]
                                    else:
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5016:
                                                revert with 0, 17
                                            mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5020 + 100] = ext_call.return_data[32] + _5016
                                            mem[_5020 + 132] = 0
                                            mem[_5020 + 164] = 160
                                            mem[_5020 + 260] = mem[_5020]
                                            idx = 0
                                            s = _5020 + 292
                                            t = _5020 + 32
                                            while idx < mem[_5020]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5020 + 196] = this.address
                                            mem[_5020 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7605 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7749 = mem[_7605]
                                            require mem[_7605] <= test266151307()
                                            require _7605 + mem[_7605] + 31 < _7605 + return_data.size
                                            _7893 = mem[_7605 + mem[_7605]]
                                            if mem[_7605 + mem[_7605]] > test266151307():
                                                revert with 0, 65
                                            if _7605 + ceil32(return_data.size) + ceil32(32 * mem[_7605 + mem[_7605]]) + 1 > test266151307() or ceil32(32 * mem[_7605 + mem[_7605]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7605 + ceil32(return_data.size) + ceil32(32 * mem[_7605 + mem[_7605]]) + 1
                                            mem[_7605 + ceil32(return_data.size)] = _7893
                                            require return_data.size >= _7749 + (32 * _7893) + 32
                                            mem[_7605 + ceil32(return_data.size) + 32 len 32 * _7893] = mem[_7605 + _7749 + 32 len 32 * _7893]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7893:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7605 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5016:
                                                revert with 0, 17
                                            mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5020 + 100] = ext_call.return_data[0] + _5016
                                            mem[_5020 + 132] = 0
                                            mem[_5020 + 164] = 160
                                            mem[_5020 + 260] = mem[_5020]
                                            idx = 0
                                            s = _5020 + 292
                                            t = _5020 + 32
                                            while idx < mem[_5020]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5020 + 196] = this.address
                                            mem[_5020 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7606 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7750 = mem[_7606]
                                            require mem[_7606] <= test266151307()
                                            require _7606 + mem[_7606] + 31 < _7606 + return_data.size
                                            _7894 = mem[_7606 + mem[_7606]]
                                            if mem[_7606 + mem[_7606]] > test266151307():
                                                revert with 0, 65
                                            if _7606 + ceil32(return_data.size) + ceil32(32 * mem[_7606 + mem[_7606]]) + 1 > test266151307() or ceil32(32 * mem[_7606 + mem[_7606]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7606 + ceil32(return_data.size) + ceil32(32 * mem[_7606 + mem[_7606]]) + 1
                                            mem[_7606 + ceil32(return_data.size)] = _7894
                                            require return_data.size >= _7750 + (32 * _7894) + 32
                                            mem[_7606 + ceil32(return_data.size) + 32 len 32 * _7894] = mem[_7606 + _7750 + 32 len 32 * _7894]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7894:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7606 + ceil32(return_data.size) + 64]
                        else:
                            if brushAddress == address(ext_call.return_data[0]):
                                if brushAddress != address(ext_call.return_data[0]):
                                    if wftmAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5016:
                                            revert with 0, 17
                                        mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5020 + 100] = ext_call.return_data[32] + _5016
                                        mem[_5020 + 132] = 0
                                        mem[_5020 + 164] = 160
                                        mem[_5020 + 260] = mem[_5020]
                                        idx = 0
                                        s = _5020 + 292
                                        t = _5020 + 32
                                        while idx < mem[_5020]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5020 + 196] = this.address
                                        mem[_5020 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7607 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7751 = mem[_7607]
                                        require mem[_7607] <= test266151307()
                                        require _7607 + mem[_7607] + 31 < _7607 + return_data.size
                                        _7895 = mem[_7607 + mem[_7607]]
                                        if mem[_7607 + mem[_7607]] > test266151307():
                                            revert with 0, 65
                                        if _7607 + ceil32(return_data.size) + ceil32(32 * mem[_7607 + mem[_7607]]) + 1 > test266151307() or ceil32(32 * mem[_7607 + mem[_7607]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7607 + ceil32(return_data.size) + ceil32(32 * mem[_7607 + mem[_7607]]) + 1
                                        mem[_7607 + ceil32(return_data.size)] = _7895
                                        require return_data.size >= _7751 + (32 * _7895) + 32
                                        mem[_7607 + ceil32(return_data.size) + 32 len 32 * _7895] = mem[_7607 + _7751 + 32 len 32 * _7895]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _7895:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7607 + ceil32(return_data.size) + 64]
                                    else:
                                        if ext_call.return_data[0] > !_5016:
                                            revert with 0, 17
                                        mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5020 + 100] = ext_call.return_data[0] + _5016
                                        mem[_5020 + 132] = 0
                                        mem[_5020 + 164] = 160
                                        mem[_5020 + 260] = mem[_5020]
                                        idx = 0
                                        s = _5020 + 292
                                        t = _5020 + 32
                                        while idx < mem[_5020]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5020 + 196] = this.address
                                        mem[_5020 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7608 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7752 = mem[_7608]
                                        require mem[_7608] <= test266151307()
                                        require _7608 + mem[_7608] + 31 < _7608 + return_data.size
                                        _7896 = mem[_7608 + mem[_7608]]
                                        if mem[_7608 + mem[_7608]] > test266151307():
                                            revert with 0, 65
                                        if _7608 + ceil32(return_data.size) + ceil32(32 * mem[_7608 + mem[_7608]]) + 1 > test266151307() or ceil32(32 * mem[_7608 + mem[_7608]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7608 + ceil32(return_data.size) + ceil32(32 * mem[_7608 + mem[_7608]]) + 1
                                        mem[_7608 + ceil32(return_data.size)] = _7896
                                        require return_data.size >= _7752 + (32 * _7896) + 32
                                        mem[_7608 + ceil32(return_data.size) + 32 len 32 * _7896] = mem[_7608 + _7752 + 32 len 32 * _7896]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _7896:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7608 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress == address(ext_call.return_data[0]):
                                        if ext_call.return_data[32] > !_5016:
                                            revert with 0, 17
                                        mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_5020 + 100] = ext_call.return_data[32] + _5016
                                        mem[_5020 + 132] = 0
                                        mem[_5020 + 164] = 160
                                        mem[_5020 + 260] = mem[_5020]
                                        idx = 0
                                        s = _5020 + 292
                                        t = _5020 + 32
                                        while idx < mem[_5020]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_5020 + 196] = this.address
                                        mem[_5020 + 228] = block.timestamp + 10000
                                        require ext_code.size(routerAddress)
                                        call routerAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _7609 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _7753 = mem[_7609]
                                        require mem[_7609] <= test266151307()
                                        require _7609 + mem[_7609] + 31 < _7609 + return_data.size
                                        _7897 = mem[_7609 + mem[_7609]]
                                        if mem[_7609 + mem[_7609]] > test266151307():
                                            revert with 0, 65
                                        if _7609 + ceil32(return_data.size) + ceil32(32 * mem[_7609 + mem[_7609]]) + 1 > test266151307() or ceil32(32 * mem[_7609 + mem[_7609]]) + 1 < 0:
                                            revert with 0, 65
                                        mem[64] = _7609 + ceil32(return_data.size) + ceil32(32 * mem[_7609 + mem[_7609]]) + 1
                                        mem[_7609 + ceil32(return_data.size)] = _7897
                                        require return_data.size >= _7753 + (32 * _7897) + 32
                                        mem[_7609 + ceil32(return_data.size) + 32 len 32 * _7897] = mem[_7609 + _7753 + 32 len 32 * _7897]
                                        if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                            revert with 0, 17
                                        maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                        if 1 >= _7897:
                                            revert with 0, 50
                                        require ext_code.size(brushAddress)
                                        call brushAddress.burn(uint256 rg1) with:
                                             gas gas_remaining wei
                                            args mem[_7609 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[0] > !_5016:
                                                revert with 0, 17
                                            mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5020 + 100] = ext_call.return_data[0] + _5016
                                            mem[_5020 + 132] = 0
                                            mem[_5020 + 164] = 160
                                            mem[_5020 + 260] = mem[_5020]
                                            idx = 0
                                            s = _5020 + 292
                                            t = _5020 + 32
                                            while idx < mem[_5020]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5020 + 196] = this.address
                                            mem[_5020 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7610 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7754 = mem[_7610]
                                            require mem[_7610] <= test266151307()
                                            require _7610 + mem[_7610] + 31 < _7610 + return_data.size
                                            _7898 = mem[_7610 + mem[_7610]]
                                            if mem[_7610 + mem[_7610]] > test266151307():
                                                revert with 0, 65
                                            if _7610 + ceil32(return_data.size) + ceil32(32 * mem[_7610 + mem[_7610]]) + 1 > test266151307() or ceil32(32 * mem[_7610 + mem[_7610]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7610 + ceil32(return_data.size) + ceil32(32 * mem[_7610 + mem[_7610]]) + 1
                                            mem[_7610 + ceil32(return_data.size)] = _7898
                                            require return_data.size >= _7754 + (32 * _7898) + 32
                                            mem[_7610 + ceil32(return_data.size) + 32 len 32 * _7898] = mem[_7610 + _7754 + 32 len 32 * _7898]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7898:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7610 + ceil32(return_data.size) + 64]
                                        else:
                                            if wftmAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[32] > !_5016:
                                                    revert with 0, 17
                                                mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5020 + 100] = ext_call.return_data[32] + _5016
                                                mem[_5020 + 132] = 0
                                                mem[_5020 + 164] = 160
                                                mem[_5020 + 260] = mem[_5020]
                                                idx = 0
                                                s = _5020 + 292
                                                t = _5020 + 32
                                                while idx < mem[_5020]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5020 + 196] = this.address
                                                mem[_5020 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7611 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7755 = mem[_7611]
                                                require mem[_7611] <= test266151307()
                                                require _7611 + mem[_7611] + 31 < _7611 + return_data.size
                                                _7899 = mem[_7611 + mem[_7611]]
                                                if mem[_7611 + mem[_7611]] > test266151307():
                                                    revert with 0, 65
                                                if _7611 + ceil32(return_data.size) + ceil32(32 * mem[_7611 + mem[_7611]]) + 1 > test266151307() or ceil32(32 * mem[_7611 + mem[_7611]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7611 + ceil32(return_data.size) + ceil32(32 * mem[_7611 + mem[_7611]]) + 1
                                                mem[_7611 + ceil32(return_data.size)] = _7899
                                                require return_data.size >= _7755 + (32 * _7899) + 32
                                                mem[_7611 + ceil32(return_data.size) + 32 len 32 * _7899] = mem[_7611 + _7755 + 32 len 32 * _7899]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _7899:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7611 + ceil32(return_data.size) + 64]
                                            else:
                                                if ext_call.return_data[0] > !_5016:
                                                    revert with 0, 17
                                                mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5020 + 100] = ext_call.return_data[0] + _5016
                                                mem[_5020 + 132] = 0
                                                mem[_5020 + 164] = 160
                                                mem[_5020 + 260] = mem[_5020]
                                                idx = 0
                                                s = _5020 + 292
                                                t = _5020 + 32
                                                while idx < mem[_5020]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5020 + 196] = this.address
                                                mem[_5020 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7612 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7756 = mem[_7612]
                                                require mem[_7612] <= test266151307()
                                                require _7612 + mem[_7612] + 31 < _7612 + return_data.size
                                                _7900 = mem[_7612 + mem[_7612]]
                                                if mem[_7612 + mem[_7612]] > test266151307():
                                                    revert with 0, 65
                                                if _7612 + ceil32(return_data.size) + ceil32(32 * mem[_7612 + mem[_7612]]) + 1 > test266151307() or ceil32(32 * mem[_7612 + mem[_7612]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7612 + ceil32(return_data.size) + ceil32(32 * mem[_7612 + mem[_7612]]) + 1
                                                mem[_7612 + ceil32(return_data.size)] = _7900
                                                require return_data.size >= _7756 + (32 * _7900) + 32
                                                mem[_7612 + ceil32(return_data.size) + 32 len 32 * _7900] = mem[_7612 + _7756 + 32 len 32 * _7900]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _7900:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7612 + ceil32(return_data.size) + 64]
                            else:
                                if wftmAddress == address(ext_call.return_data[0]):
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5016:
                                                revert with 0, 17
                                            mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5020 + 100] = ext_call.return_data[32] + _5016
                                            mem[_5020 + 132] = 0
                                            mem[_5020 + 164] = 160
                                            mem[_5020 + 260] = mem[_5020]
                                            idx = 0
                                            s = _5020 + 292
                                            t = _5020 + 32
                                            while idx < mem[_5020]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5020 + 196] = this.address
                                            mem[_5020 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7613 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7757 = mem[_7613]
                                            require mem[_7613] <= test266151307()
                                            require _7613 + mem[_7613] + 31 < _7613 + return_data.size
                                            _7901 = mem[_7613 + mem[_7613]]
                                            if mem[_7613 + mem[_7613]] > test266151307():
                                                revert with 0, 65
                                            if _7613 + ceil32(return_data.size) + ceil32(32 * mem[_7613 + mem[_7613]]) + 1 > test266151307() or ceil32(32 * mem[_7613 + mem[_7613]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7613 + ceil32(return_data.size) + ceil32(32 * mem[_7613 + mem[_7613]]) + 1
                                            mem[_7613 + ceil32(return_data.size)] = _7901
                                            require return_data.size >= _7757 + (32 * _7901) + 32
                                            mem[_7613 + ceil32(return_data.size) + 32 len 32 * _7901] = mem[_7613 + _7757 + 32 len 32 * _7901]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7901:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7613 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5016:
                                                revert with 0, 17
                                            mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5020 + 100] = ext_call.return_data[0] + _5016
                                            mem[_5020 + 132] = 0
                                            mem[_5020 + 164] = 160
                                            mem[_5020 + 260] = mem[_5020]
                                            idx = 0
                                            s = _5020 + 292
                                            t = _5020 + 32
                                            while idx < mem[_5020]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5020 + 196] = this.address
                                            mem[_5020 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7614 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7758 = mem[_7614]
                                            require mem[_7614] <= test266151307()
                                            require _7614 + mem[_7614] + 31 < _7614 + return_data.size
                                            _7902 = mem[_7614 + mem[_7614]]
                                            if mem[_7614 + mem[_7614]] > test266151307():
                                                revert with 0, 65
                                            if _7614 + ceil32(return_data.size) + ceil32(32 * mem[_7614 + mem[_7614]]) + 1 > test266151307() or ceil32(32 * mem[_7614 + mem[_7614]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7614 + ceil32(return_data.size) + ceil32(32 * mem[_7614 + mem[_7614]]) + 1
                                            mem[_7614 + ceil32(return_data.size)] = _7902
                                            require return_data.size >= _7758 + (32 * _7902) + 32
                                            mem[_7614 + ceil32(return_data.size) + 32 len 32 * _7902] = mem[_7614 + _7758 + 32 len 32 * _7902]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7902:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7614 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5016:
                                                revert with 0, 17
                                            mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5020 + 100] = ext_call.return_data[32] + _5016
                                            mem[_5020 + 132] = 0
                                            mem[_5020 + 164] = 160
                                            mem[_5020 + 260] = mem[_5020]
                                            idx = 0
                                            s = _5020 + 292
                                            t = _5020 + 32
                                            while idx < mem[_5020]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5020 + 196] = this.address
                                            mem[_5020 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7615 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7759 = mem[_7615]
                                            require mem[_7615] <= test266151307()
                                            require _7615 + mem[_7615] + 31 < _7615 + return_data.size
                                            _7903 = mem[_7615 + mem[_7615]]
                                            if mem[_7615 + mem[_7615]] > test266151307():
                                                revert with 0, 65
                                            if _7615 + ceil32(return_data.size) + ceil32(32 * mem[_7615 + mem[_7615]]) + 1 > test266151307() or ceil32(32 * mem[_7615 + mem[_7615]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7615 + ceil32(return_data.size) + ceil32(32 * mem[_7615 + mem[_7615]]) + 1
                                            mem[_7615 + ceil32(return_data.size)] = _7903
                                            require return_data.size >= _7759 + (32 * _7903) + 32
                                            mem[_7615 + ceil32(return_data.size) + 32 len 32 * _7903] = mem[_7615 + _7759 + 32 len 32 * _7903]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7903:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7615 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5016:
                                                    revert with 0, 17
                                                mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5020 + 100] = ext_call.return_data[0] + _5016
                                                mem[_5020 + 132] = 0
                                                mem[_5020 + 164] = 160
                                                mem[_5020 + 260] = mem[_5020]
                                                idx = 0
                                                s = _5020 + 292
                                                t = _5020 + 32
                                                while idx < mem[_5020]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5020 + 196] = this.address
                                                mem[_5020 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7616 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7760 = mem[_7616]
                                                require mem[_7616] <= test266151307()
                                                require _7616 + mem[_7616] + 31 < _7616 + return_data.size
                                                _7904 = mem[_7616 + mem[_7616]]
                                                if mem[_7616 + mem[_7616]] > test266151307():
                                                    revert with 0, 65
                                                if _7616 + ceil32(return_data.size) + ceil32(32 * mem[_7616 + mem[_7616]]) + 1 > test266151307() or ceil32(32 * mem[_7616 + mem[_7616]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7616 + ceil32(return_data.size) + ceil32(32 * mem[_7616 + mem[_7616]]) + 1
                                                mem[_7616 + ceil32(return_data.size)] = _7904
                                                require return_data.size >= _7760 + (32 * _7904) + 32
                                                mem[_7616 + ceil32(return_data.size) + 32 len 32 * _7904] = mem[_7616 + _7760 + 32 len 32 * _7904]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _7904:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7616 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5016:
                                                        revert with 0, 17
                                                    mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5020 + 100] = ext_call.return_data[32] + _5016
                                                    mem[_5020 + 132] = 0
                                                    mem[_5020 + 164] = 160
                                                    mem[_5020 + 260] = mem[_5020]
                                                    idx = 0
                                                    s = _5020 + 292
                                                    t = _5020 + 32
                                                    while idx < mem[_5020]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5020 + 196] = this.address
                                                    mem[_5020 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7617 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7761 = mem[_7617]
                                                    require mem[_7617] <= test266151307()
                                                    require _7617 + mem[_7617] + 31 < _7617 + return_data.size
                                                    _7905 = mem[_7617 + mem[_7617]]
                                                    if mem[_7617 + mem[_7617]] > test266151307():
                                                        revert with 0, 65
                                                    if _7617 + ceil32(return_data.size) + ceil32(32 * mem[_7617 + mem[_7617]]) + 1 > test266151307() or ceil32(32 * mem[_7617 + mem[_7617]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7617 + ceil32(return_data.size) + ceil32(32 * mem[_7617 + mem[_7617]]) + 1
                                                    mem[_7617 + ceil32(return_data.size)] = _7905
                                                    require return_data.size >= _7761 + (32 * _7905) + 32
                                                    mem[_7617 + ceil32(return_data.size) + 32 len 32 * _7905] = mem[_7617 + _7761 + 32 len 32 * _7905]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _7905:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7617 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5016:
                                                        revert with 0, 17
                                                    mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5020 + 100] = ext_call.return_data[0] + _5016
                                                    mem[_5020 + 132] = 0
                                                    mem[_5020 + 164] = 160
                                                    mem[_5020 + 260] = mem[_5020]
                                                    idx = 0
                                                    s = _5020 + 292
                                                    t = _5020 + 32
                                                    while idx < mem[_5020]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5020 + 196] = this.address
                                                    mem[_5020 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7618 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7762 = mem[_7618]
                                                    require mem[_7618] <= test266151307()
                                                    require _7618 + mem[_7618] + 31 < _7618 + return_data.size
                                                    _7906 = mem[_7618 + mem[_7618]]
                                                    if mem[_7618 + mem[_7618]] > test266151307():
                                                        revert with 0, 65
                                                    if _7618 + ceil32(return_data.size) + ceil32(32 * mem[_7618 + mem[_7618]]) + 1 > test266151307() or ceil32(32 * mem[_7618 + mem[_7618]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7618 + ceil32(return_data.size) + ceil32(32 * mem[_7618 + mem[_7618]]) + 1
                                                    mem[_7618 + ceil32(return_data.size)] = _7906
                                                    require return_data.size >= _7762 + (32 * _7906) + 32
                                                    mem[_7618 + ceil32(return_data.size) + 32 len 32 * _7906] = mem[_7618 + _7762 + 32 len 32 * _7906]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _7906:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7618 + ceil32(return_data.size) + 64]
                                else:
                                    if brushAddress != address(ext_call.return_data[0]):
                                        if wftmAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5016:
                                                revert with 0, 17
                                            mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5020 + 100] = ext_call.return_data[32] + _5016
                                            mem[_5020 + 132] = 0
                                            mem[_5020 + 164] = 160
                                            mem[_5020 + 260] = mem[_5020]
                                            idx = 0
                                            s = _5020 + 292
                                            t = _5020 + 32
                                            while idx < mem[_5020]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5020 + 196] = this.address
                                            mem[_5020 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7619 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7763 = mem[_7619]
                                            require mem[_7619] <= test266151307()
                                            require _7619 + mem[_7619] + 31 < _7619 + return_data.size
                                            _7907 = mem[_7619 + mem[_7619]]
                                            if mem[_7619 + mem[_7619]] > test266151307():
                                                revert with 0, 65
                                            if _7619 + ceil32(return_data.size) + ceil32(32 * mem[_7619 + mem[_7619]]) + 1 > test266151307() or ceil32(32 * mem[_7619 + mem[_7619]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7619 + ceil32(return_data.size) + ceil32(32 * mem[_7619 + mem[_7619]]) + 1
                                            mem[_7619 + ceil32(return_data.size)] = _7907
                                            require return_data.size >= _7763 + (32 * _7907) + 32
                                            mem[_7619 + ceil32(return_data.size) + 32 len 32 * _7907] = mem[_7619 + _7763 + 32 len 32 * _7907]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7907:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7619 + ceil32(return_data.size) + 64]
                                        else:
                                            if ext_call.return_data[0] > !_5016:
                                                revert with 0, 17
                                            mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5020 + 100] = ext_call.return_data[0] + _5016
                                            mem[_5020 + 132] = 0
                                            mem[_5020 + 164] = 160
                                            mem[_5020 + 260] = mem[_5020]
                                            idx = 0
                                            s = _5020 + 292
                                            t = _5020 + 32
                                            while idx < mem[_5020]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5020 + 196] = this.address
                                            mem[_5020 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7620 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7764 = mem[_7620]
                                            require mem[_7620] <= test266151307()
                                            require _7620 + mem[_7620] + 31 < _7620 + return_data.size
                                            _7908 = mem[_7620 + mem[_7620]]
                                            if mem[_7620 + mem[_7620]] > test266151307():
                                                revert with 0, 65
                                            if _7620 + ceil32(return_data.size) + ceil32(32 * mem[_7620 + mem[_7620]]) + 1 > test266151307() or ceil32(32 * mem[_7620 + mem[_7620]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7620 + ceil32(return_data.size) + ceil32(32 * mem[_7620 + mem[_7620]]) + 1
                                            mem[_7620 + ceil32(return_data.size)] = _7908
                                            require return_data.size >= _7764 + (32 * _7908) + 32
                                            mem[_7620 + ceil32(return_data.size) + 32 len 32 * _7908] = mem[_7620 + _7764 + 32 len 32 * _7908]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7908:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7620 + ceil32(return_data.size) + 64]
                                    else:
                                        if brushAddress == address(ext_call.return_data[0]):
                                            if ext_call.return_data[32] > !_5016:
                                                revert with 0, 17
                                            mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                            mem[_5020 + 100] = ext_call.return_data[32] + _5016
                                            mem[_5020 + 132] = 0
                                            mem[_5020 + 164] = 160
                                            mem[_5020 + 260] = mem[_5020]
                                            idx = 0
                                            s = _5020 + 292
                                            t = _5020 + 32
                                            while idx < mem[_5020]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_5020 + 196] = this.address
                                            mem[_5020 + 228] = block.timestamp + 10000
                                            require ext_code.size(routerAddress)
                                            call routerAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _7621 = mem[64]
                                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            _7765 = mem[_7621]
                                            require mem[_7621] <= test266151307()
                                            require _7621 + mem[_7621] + 31 < _7621 + return_data.size
                                            _7909 = mem[_7621 + mem[_7621]]
                                            if mem[_7621 + mem[_7621]] > test266151307():
                                                revert with 0, 65
                                            if _7621 + ceil32(return_data.size) + ceil32(32 * mem[_7621 + mem[_7621]]) + 1 > test266151307() or ceil32(32 * mem[_7621 + mem[_7621]]) + 1 < 0:
                                                revert with 0, 65
                                            mem[64] = _7621 + ceil32(return_data.size) + ceil32(32 * mem[_7621 + mem[_7621]]) + 1
                                            mem[_7621 + ceil32(return_data.size)] = _7909
                                            require return_data.size >= _7765 + (32 * _7909) + 32
                                            mem[_7621 + ceil32(return_data.size) + 32 len 32 * _7909] = mem[_7621 + _7765 + 32 len 32 * _7909]
                                            if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                revert with 0, 17
                                            maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                            if 1 >= _7909:
                                                revert with 0, 50
                                            require ext_code.size(brushAddress)
                                            call brushAddress.burn(uint256 rg1) with:
                                                 gas gas_remaining wei
                                                args mem[_7621 + ceil32(return_data.size) + 64]
                                        else:
                                            if brushAddress == address(ext_call.return_data[0]):
                                                if ext_call.return_data[0] > !_5016:
                                                    revert with 0, 17
                                                mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                mem[_5020 + 100] = ext_call.return_data[0] + _5016
                                                mem[_5020 + 132] = 0
                                                mem[_5020 + 164] = 160
                                                mem[_5020 + 260] = mem[_5020]
                                                idx = 0
                                                s = _5020 + 292
                                                t = _5020 + 32
                                                while idx < mem[_5020]:
                                                    mem[s] = mem[t + 12 len 20]
                                                    idx = idx + 1
                                                    s = s + 32
                                                    t = t + 32
                                                    continue 
                                                mem[_5020 + 196] = this.address
                                                mem[_5020 + 228] = block.timestamp + 10000
                                                require ext_code.size(routerAddress)
                                                call routerAddress.mem[mem[64] len 4] with:
                                                     gas gas_remaining wei
                                                    args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _7622 = mem[64]
                                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                _7766 = mem[_7622]
                                                require mem[_7622] <= test266151307()
                                                require _7622 + mem[_7622] + 31 < _7622 + return_data.size
                                                _7910 = mem[_7622 + mem[_7622]]
                                                if mem[_7622 + mem[_7622]] > test266151307():
                                                    revert with 0, 65
                                                if _7622 + ceil32(return_data.size) + ceil32(32 * mem[_7622 + mem[_7622]]) + 1 > test266151307() or ceil32(32 * mem[_7622 + mem[_7622]]) + 1 < 0:
                                                    revert with 0, 65
                                                mem[64] = _7622 + ceil32(return_data.size) + ceil32(32 * mem[_7622 + mem[_7622]]) + 1
                                                mem[_7622 + ceil32(return_data.size)] = _7910
                                                require return_data.size >= _7766 + (32 * _7910) + 32
                                                mem[_7622 + ceil32(return_data.size) + 32 len 32 * _7910] = mem[_7622 + _7766 + 32 len 32 * _7910]
                                                if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                    revert with 0, 17
                                                maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                if 1 >= _7910:
                                                    revert with 0, 50
                                                require ext_code.size(brushAddress)
                                                call brushAddress.burn(uint256 rg1) with:
                                                     gas gas_remaining wei
                                                    args mem[_7622 + ceil32(return_data.size) + 64]
                                            else:
                                                if wftmAddress == address(ext_call.return_data[0]):
                                                    if ext_call.return_data[32] > !_5016:
                                                        revert with 0, 17
                                                    mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5020 + 100] = ext_call.return_data[32] + _5016
                                                    mem[_5020 + 132] = 0
                                                    mem[_5020 + 164] = 160
                                                    mem[_5020 + 260] = mem[_5020]
                                                    idx = 0
                                                    s = _5020 + 292
                                                    t = _5020 + 32
                                                    while idx < mem[_5020]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5020 + 196] = this.address
                                                    mem[_5020 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7623 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7767 = mem[_7623]
                                                    require mem[_7623] <= test266151307()
                                                    require _7623 + mem[_7623] + 31 < _7623 + return_data.size
                                                    _7911 = mem[_7623 + mem[_7623]]
                                                    if mem[_7623 + mem[_7623]] > test266151307():
                                                        revert with 0, 65
                                                    if _7623 + ceil32(return_data.size) + ceil32(32 * mem[_7623 + mem[_7623]]) + 1 > test266151307() or ceil32(32 * mem[_7623 + mem[_7623]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7623 + ceil32(return_data.size) + ceil32(32 * mem[_7623 + mem[_7623]]) + 1
                                                    mem[_7623 + ceil32(return_data.size)] = _7911
                                                    require return_data.size >= _7767 + (32 * _7911) + 32
                                                    mem[_7623 + ceil32(return_data.size) + 32 len 32 * _7911] = mem[_7623 + _7767 + 32 len 32 * _7911]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _7911:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7623 + ceil32(return_data.size) + 64]
                                                else:
                                                    if ext_call.return_data[0] > !_5016:
                                                        revert with 0, 17
                                                    mem[_5020 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                                    mem[_5020 + 100] = ext_call.return_data[0] + _5016
                                                    mem[_5020 + 132] = 0
                                                    mem[_5020 + 164] = 160
                                                    mem[_5020 + 260] = mem[_5020]
                                                    idx = 0
                                                    s = _5020 + 292
                                                    t = _5020 + 32
                                                    while idx < mem[_5020]:
                                                        mem[s] = mem[t + 12 len 20]
                                                        idx = idx + 1
                                                        s = s + 32
                                                        t = t + 32
                                                        continue 
                                                    mem[_5020 + 196] = this.address
                                                    mem[_5020 + 228] = block.timestamp + 10000
                                                    require ext_code.size(routerAddress)
                                                    call routerAddress.mem[mem[64] len 4] with:
                                                         gas gas_remaining wei
                                                        args mem[mem[64] + 4 len _5020 + (32 * mem[_5020]) + -mem[64] + 288]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _7624 = mem[64]
                                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    _7768 = mem[_7624]
                                                    require mem[_7624] <= test266151307()
                                                    require _7624 + mem[_7624] + 31 < _7624 + return_data.size
                                                    _7912 = mem[_7624 + mem[_7624]]
                                                    if mem[_7624 + mem[_7624]] > test266151307():
                                                        revert with 0, 65
                                                    if _7624 + ceil32(return_data.size) + ceil32(32 * mem[_7624 + mem[_7624]]) + 1 > test266151307() or ceil32(32 * mem[_7624 + mem[_7624]]) + 1 < 0:
                                                        revert with 0, 65
                                                    mem[64] = _7624 + ceil32(return_data.size) + ceil32(32 * mem[_7624 + mem[_7624]]) + 1
                                                    mem[_7624 + ceil32(return_data.size)] = _7912
                                                    require return_data.size >= _7768 + (32 * _7912) + 32
                                                    mem[_7624 + ceil32(return_data.size) + 32 len 32 * _7912] = mem[_7624 + _7768 + 32 len 32 * _7912]
                                                    if maxBurnAndBuyBackAmounts[address(arg1)] < maxBurnAndBuyBackAmounts[address(arg1)]:
                                                        revert with 0, 17
                                                    maxBurnAndBuyBackAmounts[address(arg1)] = 0
                                                    if 1 >= _7912:
                                                        revert with 0, 50
                                                    require ext_code.size(brushAddress)
                                                    call brushAddress.burn(uint256 rg1) with:
                                                         gas gas_remaining wei
                                                        args mem[_7624 + ceil32(return_data.size) + 64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}



}
