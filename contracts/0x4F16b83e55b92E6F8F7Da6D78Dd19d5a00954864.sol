contract main {




// =====================  Runtime code  =====================


#
#  - transferFrom(address arg1, address arg2, uint256 arg3)
#  - initialize()
#
array of uint256 stor1;
array of uint256 stor99;
array of uint256 name;
array of uint256 symbol;
uint8 decimals;
address owner;
array of struct transactions;
uint256 stor202;
mapping of uint256 stor203;
mapping of uint256 stor204;
mapping of uint256 allowance;
mapping of uint8 stor206;
array of address stor207;
uint256 totalSupply;
uint256 stor209;
uint256 totalFees;
uint256 _tFeePercent;
uint256 _tFeeTimestamp;
address _rebaserAddress;
uint256 _limitTimestamp;
array of struct stor46472157311649131651317580928243384587355742660275723744700495089454914805032;
array of address stor78124409783719932406374152597529114957380397136489353056513409383928196874025;

function name() payable {
    return name[0 len name.length]
}

function _limitTimestamp() payable {
    return _limitTimestamp
}

function totalFees() payable {
    return totalFees
}

function totalSupply() payable {
    return totalSupply
}

function _tFeePercent() payable {
    return _tFeePercent
}

function decimals() payable {
    return decimals
}

function _rebaser() payable {
    return _rebaserAddress
}

function owner() payable {
    return owner
}

function transactionsSize() payable {
    return transactions.length
}

function symbol() payable {
    return symbol[0 len symbol.length]
}

function transactions(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < transactions.length
    mem[128] = stor[sha3((2 * arg1) + ('name', 'transactions', 201) + 1)].field_0
    idx = 128
    s = 0
    while stor[(2 * arg1) + ('name', 'transactions', 201) + 1].length + 96 > idx:
        mem[idx + 32] = stor[s + sha3((2 * arg1) + ('name', 'transactions', 201) + 1)].field_256
        idx = idx + 32
        s = s + 1
        continue 
    return bool(uint8(transactions[arg1].field_0)), 
           address(transactions[arg1].field_0),
           Array(len=stor[(2 * arg1) + ('name', 'transactions', 201) + 1].length, data=mem[128 len stor[(2 * arg1) + ('name', 'transactions', 201) + 1].length])
}

function _tFeeTimestamp() payable {
    return _tFeeTimestamp
}

function isExcluded(address arg1) payable {
    require calldata.size - 4 >= 32
    return bool(stor206[address(arg1)])
}

function allowance(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    return allowance[address(arg1)][address(arg2)]
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function setRebaser(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    _rebaserAddress = arg1
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0x734f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function setTransactionEnabled(uint256 arg1, bool arg2) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    if arg1 >= transactions.length:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    40,
                    0x73696e646578206d75737420626520696e2072616e6765206f662073746f726564207478206c6973,
                    mem[204 len 24]
    uint8(transactions[arg1].field_0) = uint8(arg2)
}

function setTransferFeePercent(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    if block.timestamp < _tFeeTimestamp + (12 * 3600):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    44,
                    0x655472616e7366657220666565206368616e6765732074696d656c6f636b656420666f7220313220686f7572,
                    mem[208 len 20]
    _tFeePercent = arg1
    _tFeeTimestamp = block.timestamp
}

function addTransaction(address arg1, bytes arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 <= 4294967296
    require arg2 + 36 <= calldata.size
    require arg2.length <= 4294967296 and arg2 + arg2.length + 36 <= calldata.size
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    transactions.length++
    uint8(stor66BE[stor201.length].field_0) = 1
    address(stor66BE[stor201.length].field_8) = arg1
    Mask(88, 0, stor66BE[stor201.length].field_168) = 0
    stor[sha3((2 * stor201.length) + 0x66be4f155c5ef2ebd3772b228f2f00681e4ed5826cdb3b1943cc11ad15ad1d29)][] = Array(len=arg2.length, data=arg2[all])
}

function includeAccount(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    if not stor206[address(arg1)]:
        revert with 0, 'Account is already excluded'
    idx = 0
    while idx < stor207.length:
        mem[0] = 207
        if stor207[idx] != arg1:
            idx = idx + 1
            continue 
        require stor207.length - 1 < stor207.length
        require idx < stor207.length
        stor207[idx] = stor207[stor207.length]
        stor204[address(arg1)] = 0
        stor206[address(arg1)] = 0
        require stor207.length
        stor207[stor207.length] = 0
        stor207.length--
}

function approve(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    36,
                    0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573,
                    mem[200 len 28]
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    34,
                    0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573,
                    mem[198 len 30]
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function decreaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if arg2 > allowance[address(msg.sender)][address(arg1)]:
        revert with 0, 
                    32,
                    37,
                    0x6e45524332303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572,
                    mem[165 len 27],
                    mem[219 len 5]
    if not msg.sender:
        revert with 0, 32, 36, 0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573, mem[296 len 28]
    if not arg1:
        revert with 0, 32, 34, 0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573, mem[294 len 30]
    allowance[address(msg.sender)][address(arg1)] -= arg2
    emit Approval((allowance[address(msg.sender)][address(arg1)] - arg2), msg.sender, arg1);
    return 1
}

function increaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if arg2 + allowance[address(msg.sender)][address(arg1)] < allowance[address(msg.sender)][address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    36,
                    0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573,
                    mem[200 len 28]
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    34,
                    0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573,
                    mem[198 len 30]
    allowance[address(msg.sender)][address(arg1)] += arg2
    emit Approval((arg2 + allowance[address(msg.sender)][address(arg1)]), msg.sender, arg1);
    return 1
}

function removeTransaction(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    if arg1 >= transactions.length:
        revert with 0, 'index out of bounds'
    if arg1 < transactions.length - 1:
        require transactions.length - 1 < transactions.length
        require arg1 < transactions.length
        uint8(transactions[arg1].field_0) = uint8(bool(uint8(transactions[transactions.length - 1].field_0)))
        uint8(transactions[arg1].field_0) = uint8(bool(uint8(transactions[transactions.length - 1].field_0)))
        Mask(248, 0, transactions[arg1].field_8) = address(transactions[transactions.length - 1].field_8)
        Mask(88, 0, transactions[arg1].field_168) = Mask(88, 168, bool(uint8(transactions[transactions.length - 1].field_0))) >> 168
        if 31 >= stor[(2 * transactions.length - 1) + ('name', 'transactions', 201) + 1].length:
            transactions[arg1].field_256 = transactions[transactions.length - 1].field_256
            idx = 0
            while stor[('name', 'transactions', 201) + (2 * arg1) + 1].length + 31 / 32 > idx:
                stor[idx + sha3(('name', 'transactions', 201) + (2 * arg1) + 1)].field_0 = 0
                idx = idx + 1
                continue 
        else:
            transactions[arg1].field_256 = Mask(255, 1, transactions[transactions.length - 1].field_256 and (256 * not bool(transactions[transactions.length - 1].field_256)) - 1) + 1
            if not Mask(255, 1, transactions[transactions.length - 1].field_256 and (256 * not bool(transactions[transactions.length - 1].field_256)) - 1):
                idx = 0
                while stor[('name', 'transactions', 201) + (2 * arg1) + 1].length + 31 / 32 > idx:
                    stor[idx + sha3(('name', 'transactions', 201) + (2 * arg1) + 1)].field_0 = 0
                    idx = idx + 1
                    continue 
            else:
                s = 0
                idx = 0
                while stor[(2 * transactions.length - 1) + ('name', 'transactions', 201) + 1].length + 31 / 32 > idx:
                    stor[s + sha3(('name', 'transactions', 201) + (2 * arg1) + 1)].field_0 = stor[idx + sha3((2 * transactions.length - 1) + ('name', 'transactions', 201) + 1)].field_0
                    s = s + 1
                    idx = idx + 1
                    continue 
                idx = stor[(2 * transactions.length - 1) + ('name', 'transactions', 201) + 1].length + 31 / 32
                while stor[('name', 'transactions', 201) + (2 * arg1) + 1].length + 31 / 32 > idx:
                    stor[idx + sha3(('name', 'transactions', 201) + (2 * arg1) + 1)].field_0 = 0
                    idx = idx + 1
                    continue 
    require transactions.length
    Mask(168, 0, transactions[transactions.length - 1].field_0) = 0
    transactions[transactions.length - 1].field_256 = 0
    if 31 < stor[(2 * transactions.length - 1) + ('name', 'transactions', 201) + 1].length:
        idx = 0
        while stor[(2 * transactions.length - 1) + ('name', 'transactions', 201) + 1].length + 31 / 32 > idx:
            stor[idx + sha3((2 * transactions.length - 1) + ('name', 'transactions', 201) + 1)].field_0 = 0
            idx = idx + 1
            continue 
    transactions.length--
}

function tokenFromRefraction(uint256 arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if arg1 > stor209:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    42,
                    0x64416d6f756e74206d757374206265206c657373207468616e20746f74616c2072656672616374696f6e,
                    mem[206 len 22]
    idx = 0
    s = totalSupply
    t = stor209
    while idx < stor207.length:
        mem[0] = stor207[idx]
        mem[32] = 203
        if stor203[stor207[idx]] > t:
            _156 = mem[64]
            mem[64] = mem[64] + 64
            mem[_156] = 26
            mem[_156 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero'
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _156 + 32]
                    idx = idx + 32
                    continue 
            else:
                _198 = mem[64]
                mem[64] = mem[64] + 64
                mem[_198] = 26
                mem[_198 + 32] = 'SafeMath: division by zero'
                if stor209 / totalSupply:
                    return (arg1 / stor209 / totalSupply)
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero'
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _198 + 32]
                    idx = idx + 32
                    continue 
            revert with 0, 'SafeMath: division by zero'
        require idx < stor207.length
        mem[0] = stor207[idx]
        mem[32] = 204
        if stor204[stor207[idx]] > s:
            _166 = mem[64]
            mem[64] = mem[64] + 64
            mem[_166] = 26
            mem[_166 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero'
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _166 + 32]
                    idx = idx + 32
                    continue 
            else:
                _220 = mem[64]
                mem[64] = mem[64] + 64
                mem[_220] = 26
                mem[_220 + 32] = 'SafeMath: division by zero'
                if stor209 / totalSupply:
                    return (arg1 / stor209 / totalSupply)
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero'
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _220 + 32]
                    idx = idx + 32
                    continue 
            revert with 0, 'SafeMath: division by zero'
        require idx < stor207.length
        mem[0] = stor207[idx]
        mem[32] = 203
        _161 = mem[64]
        mem[64] = mem[64] + 64
        mem[_161] = 30
        mem[_161 + 32] = 'SafeMath: subtraction overflow'
        if stor203[stor207[idx]] > t:
            _168 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _168 + 68] = mem[idx + _161 + 32]
                idx = idx + 32
                continue 
            mem[_168 + 68] = mem[_168 + 70 len 30]
            revert with memory
              from mem[64]
               len _168 + -mem[64] + 100
        require idx < stor207.length
        mem[0] = stor207[idx]
        mem[32] = 204
        _200 = mem[64]
        mem[64] = mem[64] + 64
        mem[_200] = 30
        mem[_200 + 32] = 'SafeMath: subtraction overflow'
        if stor204[stor207[idx]] <= s:
            idx = idx + 1
            s = s - stor204[stor207[idx]]
            t = t - stor203[stor207[idx]]
            continue 
        _217 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _217 + 68] = mem[idx + _200 + 32]
            idx = idx + 32
            continue 
        mem[_217 + 68] = mem[_217 + 70 len 30]
        revert with memory
          from mem[64]
           len _217 + -mem[64] + 100
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero'
    if t >= stor209 / totalSupply:
        if not s:
            revert with 0, 'SafeMath: division by zero'
        if not t / s:
            revert with 0, 'SafeMath: division by zero'
        return (arg1 / t / s)
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero'
    if not stor209 / totalSupply:
        revert with 0, 'SafeMath: division by zero'
    return (arg1 / stor209 / totalSupply)
}

function balanceOf(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if stor206[address(arg1)]:
        return stor204[address(arg1)]
    mem[0] = arg1
    mem[32] = 203
    if stor203[address(arg1)] > stor209:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    42,
                    0x64416d6f756e74206d757374206265206c657373207468616e20746f74616c2072656672616374696f6e,
                    mem[206 len 22]
    idx = 0
    s = totalSupply
    t = stor209
    while idx < stor207.length:
        mem[0] = stor207[idx]
        mem[32] = 203
        if stor203[stor207[idx]] > t:
            _161 = mem[64]
            mem[64] = mem[64] + 64
            mem[_161] = 26
            mem[_161 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero'
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _161 + 32]
                    idx = idx + 32
                    continue 
            else:
                _203 = mem[64]
                mem[64] = mem[64] + 64
                mem[_203] = 26
                mem[_203 + 32] = 'SafeMath: division by zero'
                if stor209 / totalSupply:
                    return (stor203[address(arg1)] / stor209 / totalSupply)
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero'
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _203 + 32]
                    idx = idx + 32
                    continue 
            revert with 0, 'SafeMath: division by zero'
        require idx < stor207.length
        mem[0] = stor207[idx]
        mem[32] = 204
        if stor204[stor207[idx]] > s:
            _171 = mem[64]
            mem[64] = mem[64] + 64
            mem[_171] = 26
            mem[_171 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero'
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _171 + 32]
                    idx = idx + 32
                    continue 
            else:
                _225 = mem[64]
                mem[64] = mem[64] + 64
                mem[_225] = 26
                mem[_225 + 32] = 'SafeMath: division by zero'
                if stor209 / totalSupply:
                    return (stor203[address(arg1)] / stor209 / totalSupply)
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero'
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _225 + 32]
                    idx = idx + 32
                    continue 
            revert with 0, 'SafeMath: division by zero'
        require idx < stor207.length
        mem[0] = stor207[idx]
        mem[32] = 203
        _166 = mem[64]
        mem[64] = mem[64] + 64
        mem[_166] = 30
        mem[_166 + 32] = 'SafeMath: subtraction overflow'
        if stor203[stor207[idx]] > t:
            _173 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _173 + 68] = mem[idx + _166 + 32]
                idx = idx + 32
                continue 
            mem[_173 + 68] = mem[_173 + 70 len 30]
            revert with memory
              from mem[64]
               len _173 + -mem[64] + 100
        require idx < stor207.length
        mem[0] = stor207[idx]
        mem[32] = 204
        _205 = mem[64]
        mem[64] = mem[64] + 64
        mem[_205] = 30
        mem[_205 + 32] = 'SafeMath: subtraction overflow'
        if stor204[stor207[idx]] <= s:
            idx = idx + 1
            s = s - stor204[stor207[idx]]
            t = t - stor203[stor207[idx]]
            continue 
        _222 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _222 + 68] = mem[idx + _205 + 32]
            idx = idx + 32
            continue 
        mem[_222 + 68] = mem[_222 + 70 len 30]
        revert with memory
          from mem[64]
           len _222 + -mem[64] + 100
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero'
    if t >= stor209 / totalSupply:
        if not s:
            revert with 0, 'SafeMath: division by zero'
        if not t / s:
            revert with 0, 'SafeMath: division by zero'
        return (stor203[address(arg1)] / t / s)
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero'
    if not stor209 / totalSupply:
        revert with 0, 'SafeMath: division by zero'
    return (stor203[address(arg1)] / stor209 / totalSupply)
}

function excludeAccount(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'sOwnable: caller is not the owne'
    if stor206[address(arg1)]:
        revert with 0, 'Account is already excluded'
    if stor203[address(arg1)]:
        mem[0] = arg1
        mem[32] = 203
        if stor203[address(arg1)] > stor209:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        42,
                        0x64416d6f756e74206d757374206265206c657373207468616e20746f74616c2072656672616374696f6e,
                        mem[206 len 22]
        idx = 0
        s = totalSupply
        t = stor209
        while idx < stor207.length:
            mem[0] = stor207[idx]
            mem[32] = 203
            if stor203[stor207[idx]] > t:
                _166 = mem[64]
                mem[64] = mem[64] + 64
                mem[_166] = 26
                mem[_166 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _166 + 32]
                        idx = idx + 32
                        continue 
                else:
                    _208 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_208] = 26
                    mem[_208 + 32] = 'SafeMath: division by zero'
                    if stor209 / totalSupply:
                        stor204[address(arg1)] = stor203[address(arg1)] / stor209 / totalSupply
                        stor206[address(arg1)] = 1
                        stor207.length++
                        storACB8[stor207.length] = arg1
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _208 + 32]
                        idx = idx + 32
                        continue 
                revert with 0, 'SafeMath: division by zero'
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 204
            if stor204[stor207[idx]] > s:
                _176 = mem[64]
                mem[64] = mem[64] + 64
                mem[_176] = 26
                mem[_176 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _176 + 32]
                        idx = idx + 32
                        continue 
                else:
                    _230 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_230] = 26
                    mem[_230 + 32] = 'SafeMath: division by zero'
                    if stor209 / totalSupply:
                        stor204[address(arg1)] = stor203[address(arg1)] / stor209 / totalSupply
                        stor206[address(arg1)] = 1
                        stor207.length++
                        storACB8[stor207.length] = arg1
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _230 + 32]
                        idx = idx + 32
                        continue 
                revert with 0, 'SafeMath: division by zero'
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 203
            _171 = mem[64]
            mem[64] = mem[64] + 64
            mem[_171] = 30
            mem[_171 + 32] = 'SafeMath: subtraction overflow'
            if stor203[stor207[idx]] > t:
                _178 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _178 + 68] = mem[idx + _171 + 32]
                    idx = idx + 32
                    continue 
                mem[_178 + 68] = mem[_178 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _178 + -mem[64] + 100
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 204
            _210 = mem[64]
            mem[64] = mem[64] + 64
            mem[_210] = 30
            mem[_210 + 32] = 'SafeMath: subtraction overflow'
            if stor204[stor207[idx]] <= s:
                idx = idx + 1
                s = s - stor204[stor207[idx]]
                t = t - stor203[stor207[idx]]
                continue 
            _227 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _227 + 68] = mem[idx + _210 + 32]
                idx = idx + 32
                continue 
            mem[_227 + 68] = mem[_227 + 70 len 30]
            revert with memory
              from mem[64]
               len _227 + -mem[64] + 100
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero'
        if t >= stor209 / totalSupply:
            if not s:
                revert with 0, 'SafeMath: division by zero'
            if not t / s:
                revert with 0, 'SafeMath: division by zero'
            stor204[address(arg1)] = stor203[address(arg1)] / t / s
        else:
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero'
            if not stor209 / totalSupply:
                revert with 0, 'SafeMath: division by zero'
            stor204[address(arg1)] = stor203[address(arg1)] / stor209 / totalSupply
    stor206[address(arg1)] = 1
    stor207.length++
    storACB8[stor207.length] = arg1
}

function refractionFromToken(uint256 arg1, bool arg2) payable {
    require calldata.size - 4 >= 64
    if arg1 > totalSupply:
        revert with 0, 'Amount must be less than supply'
    if arg2:
        if not arg1:
            mem[96] = 26
            mem[128] = 'SafeMath: division by zero'
            mem[64] = 224
            mem[160] = 30
            mem[192] = 'SafeMath: subtraction overflow'
            if 0 > arg1:
                revert with 0, 'SafeMath: subtraction overflow'
            idx = 0
            s = totalSupply
            t = stor209
            while idx < stor207.length:
                mem[0] = stor207[idx]
                mem[32] = 203
                if stor203[stor207[idx]] > t:
                    _878 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_878] = 26
                    mem[_878 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _878 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if not arg1:
                        return 0
                    if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _1211 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1211] = 30
                    mem[_1211 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor209 / totalSupply * arg1:
                        return (stor209 / totalSupply * arg1)
                    _1239 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1239 + 68] = mem[idx + _1211 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1239 + 68] = mem[_1239 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1239 + -mem[64] + 100
                require idx < stor207.length
                mem[0] = stor207[idx]
                mem[32] = 204
                if stor204[stor207[idx]] > s:
                    _912 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_912] = 26
                    mem[_912 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _912 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if not arg1:
                        return 0
                    if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _1242 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1242] = 30
                    mem[_1242 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor209 / totalSupply * arg1:
                        return (stor209 / totalSupply * arg1)
                    _1298 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1298 + 68] = mem[idx + _1242 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1298 + 68] = mem[_1298 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1298 + -mem[64] + 100
                require idx < stor207.length
                mem[0] = stor207[idx]
                mem[32] = 203
                _896 = mem[64]
                mem[64] = mem[64] + 64
                mem[_896] = 30
                mem[_896 + 32] = 'SafeMath: subtraction overflow'
                if stor203[stor207[idx]] > t:
                    _928 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _928 + 68] = mem[idx + _896 + 32]
                        idx = idx + 32
                        continue 
                    mem[_928 + 68] = mem[_928 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _928 + -mem[64] + 100
                require idx < stor207.length
                mem[0] = stor207[idx]
                mem[32] = 204
                _1049 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1049] = 30
                mem[_1049 + 32] = 'SafeMath: subtraction overflow'
                if stor204[stor207[idx]] <= s:
                    idx = idx + 1
                    s = s - stor204[stor207[idx]]
                    t = t - stor203[stor207[idx]]
                    continue 
                _1103 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1103 + 68] = mem[idx + _1049 + 32]
                    idx = idx + 32
                    continue 
                mem[_1103 + 68] = mem[_1103 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1103 + -mem[64] + 100
            _820 = mem[64]
            mem[64] = mem[64] + 64
            mem[_820] = 26
            mem[_820 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero'
            if t >= stor209 / totalSupply:
                _946 = mem[64]
                mem[64] = mem[64] + 64
                mem[_946] = 26
                mem[_946 + 32] = 'SafeMath: division by zero'
                if not s:
                    revert with 0, 'SafeMath: division by zero'
                if not arg1:
                    return 0
                if t / s * arg1 / arg1 != t / s:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if 0 > t / s * arg1:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (t / s * arg1)
            _947 = mem[64]
            mem[64] = mem[64] + 64
            mem[_947] = 26
            mem[_947 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                return 0
            if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if 0 > stor209 / totalSupply * arg1:
                revert with 0, 'SafeMath: subtraction overflow'
            return (stor209 / totalSupply * arg1)
        if _tFeePercent * arg1 / arg1 != _tFeePercent:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if _tFeePercent * arg1 / 10000 > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        idx = 0
        s = totalSupply
        t = stor209
        while idx < stor207.length:
            mem[0] = stor207[idx]
            mem[32] = 203
            if stor203[stor207[idx]] > t:
                _873 = mem[64]
                mem[64] = mem[64] + 64
                mem[_873] = 26
                mem[_873 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _873 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                if not arg1:
                    if not _tFeePercent * arg1 / 10000:
                        return 0
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _1208 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1208] = 30
                    mem[_1208 + 32] = 'SafeMath: subtraction overflow'
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 <= 0:
                        return (-1 * stor209 / totalSupply * _tFeePercent * arg1 / 10000)
                    _1234 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1234 + 68] = mem[idx + _1208 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1234 + 68] = mem[_1234 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1234 + -mem[64] + 100
                if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not _tFeePercent * arg1 / 10000:
                    _1207 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1207] = 30
                    mem[_1207 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor209 / totalSupply * arg1:
                        return (stor209 / totalSupply * arg1)
                    _1231 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1231 + 68] = mem[idx + _1207 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1231 + 68] = mem[_1231 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1231 + -mem[64] + 100
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1217 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1217] = 30
                mem[_1217 + 32] = 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 <= stor209 / totalSupply * arg1:
                    return ((stor209 / totalSupply * arg1) - (stor209 / totalSupply * _tFeePercent * arg1 / 10000))
                _1265 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1265 + 68] = mem[idx + _1217 + 32]
                    idx = idx + 32
                    continue 
                mem[_1265 + 68] = mem[_1265 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1265 + -mem[64] + 100
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 204
            if stor204[stor207[idx]] > s:
                _907 = mem[64]
                mem[64] = mem[64] + 64
                mem[_907] = 26
                mem[_907 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _907 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                if not arg1:
                    if not _tFeePercent * arg1 / 10000:
                        return 0
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _1238 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1238] = 30
                    mem[_1238 + 32] = 'SafeMath: subtraction overflow'
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 <= 0:
                        return (-1 * stor209 / totalSupply * _tFeePercent * arg1 / 10000)
                    _1292 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1292 + 68] = mem[idx + _1238 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1292 + 68] = mem[_1292 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1292 + -mem[64] + 100
                if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not _tFeePercent * arg1 / 10000:
                    _1237 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1237] = 30
                    mem[_1237 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor209 / totalSupply * arg1:
                        return (stor209 / totalSupply * arg1)
                    _1289 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1289 + 68] = mem[idx + _1237 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1289 + 68] = mem[_1289 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1289 + -mem[64] + 100
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1268 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1268] = 30
                mem[_1268 + 32] = 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 <= stor209 / totalSupply * arg1:
                    return ((stor209 / totalSupply * arg1) - (stor209 / totalSupply * _tFeePercent * arg1 / 10000))
                _1326 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1326 + 68] = mem[idx + _1268 + 32]
                    idx = idx + 32
                    continue 
                mem[_1326 + 68] = mem[_1326 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1326 + -mem[64] + 100
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 203
            _893 = mem[64]
            mem[64] = mem[64] + 64
            mem[_893] = 30
            mem[_893 + 32] = 'SafeMath: subtraction overflow'
            if stor203[stor207[idx]] > t:
                _924 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _924 + 68] = mem[idx + _893 + 32]
                    idx = idx + 32
                    continue 
                mem[_924 + 68] = mem[_924 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _924 + -mem[64] + 100
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 204
            _1042 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1042] = 30
            mem[_1042 + 32] = 'SafeMath: subtraction overflow'
            if stor204[stor207[idx]] <= s:
                idx = idx + 1
                s = s - stor204[stor207[idx]]
                t = t - stor203[stor207[idx]]
                continue 
            _1095 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _1095 + 68] = mem[idx + _1042 + 32]
                idx = idx + 32
                continue 
            mem[_1095 + 68] = mem[_1095 + 70 len 30]
            revert with memory
              from mem[64]
               len _1095 + -mem[64] + 100
        _815 = mem[64]
        mem[64] = mem[64] + 64
        mem[_815] = 26
        mem[_815 + 32] = 'SafeMath: division by zero'
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero'
        if t >= stor209 / totalSupply:
            _939 = mem[64]
            mem[64] = mem[64] + 64
            mem[_939] = 26
            mem[_939 + 32] = 'SafeMath: division by zero'
            if not s:
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                if not _tFeePercent * arg1 / 10000:
                    return 0
                if t / s * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != t / s:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if t / s * _tFeePercent * arg1 / 10000 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (-1 * t / s * _tFeePercent * arg1 / 10000)
            if t / s * arg1 / arg1 != t / s:
                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not _tFeePercent * arg1 / 10000:
                if 0 > t / s * arg1:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (t / s * arg1)
            if t / s * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != t / s:
                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if t / s * _tFeePercent * arg1 / 10000 > t / s * arg1:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((t / s * arg1) - (t / s * _tFeePercent * arg1 / 10000))
        _940 = mem[64]
        mem[64] = mem[64] + 64
        mem[_940] = 26
        mem[_940 + 32] = 'SafeMath: division by zero'
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero'
        if not arg1:
            if not _tFeePercent * arg1 / 10000:
                return 0
            if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if stor209 / totalSupply * _tFeePercent * arg1 / 10000 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return (-1 * stor209 / totalSupply * _tFeePercent * arg1 / 10000)
        if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if not _tFeePercent * arg1 / 10000:
            if 0 > stor209 / totalSupply * arg1:
                revert with 0, 'SafeMath: subtraction overflow'
            return (stor209 / totalSupply * arg1)
        if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if stor209 / totalSupply * _tFeePercent * arg1 / 10000 > stor209 / totalSupply * arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((stor209 / totalSupply * arg1) - (stor209 / totalSupply * _tFeePercent * arg1 / 10000))
    if not arg1:
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 0 > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        idx = 0
        s = totalSupply
        t = stor209
        while idx < stor207.length:
            mem[0] = stor207[idx]
            mem[32] = 203
            if stor203[stor207[idx]] > t:
                _888 = mem[64]
                mem[64] = mem[64] + 64
                mem[_888] = 26
                mem[_888 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _888 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                if not arg1:
                    return 0
                if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1216 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1216] = 30
                mem[_1216 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= stor209 / totalSupply * arg1:
                    return (stor209 / totalSupply * arg1)
                _1255 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1255 + 68] = mem[idx + _1216 + 32]
                    idx = idx + 32
                    continue 
                mem[_1255 + 68] = mem[_1255 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1255 + -mem[64] + 100
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 204
            if stor204[stor207[idx]] > s:
                _922 = mem[64]
                mem[64] = mem[64] + 64
                mem[_922] = 26
                mem[_922 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _922 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                if not arg1:
                    return 0
                if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1258 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1258] = 30
                mem[_1258 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= stor209 / totalSupply * arg1:
                    return (stor209 / totalSupply * arg1)
                _1316 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1316 + 68] = mem[idx + _1258 + 32]
                    idx = idx + 32
                    continue 
                mem[_1316 + 68] = mem[_1316 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1316 + -mem[64] + 100
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 203
            _902 = mem[64]
            mem[64] = mem[64] + 64
            mem[_902] = 30
            mem[_902 + 32] = 'SafeMath: subtraction overflow'
            if stor203[stor207[idx]] > t:
                _936 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _936 + 68] = mem[idx + _902 + 32]
                    idx = idx + 32
                    continue 
                mem[_936 + 68] = mem[_936 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _936 + -mem[64] + 100
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 204
            _1063 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1063] = 30
            mem[_1063 + 32] = 'SafeMath: subtraction overflow'
            if stor204[stor207[idx]] <= s:
                idx = idx + 1
                s = s - stor204[stor207[idx]]
                t = t - stor203[stor207[idx]]
                continue 
            _1119 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _1119 + 68] = mem[idx + _1063 + 32]
                idx = idx + 32
                continue 
            mem[_1119 + 68] = mem[_1119 + 70 len 30]
            revert with memory
              from mem[64]
               len _1119 + -mem[64] + 100
        _830 = mem[64]
        mem[64] = mem[64] + 64
        mem[_830] = 26
        mem[_830 + 32] = 'SafeMath: division by zero'
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero'
        if t >= stor209 / totalSupply:
            _960 = mem[64]
            mem[64] = mem[64] + 64
            mem[_960] = 26
            mem[_960 + 32] = 'SafeMath: division by zero'
            if not s:
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                return 0
            if t / s * arg1 / arg1 != t / s:
                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if 0 > t / s * arg1:
                revert with 0, 'SafeMath: subtraction overflow'
            return (t / s * arg1)
        _961 = mem[64]
        mem[64] = mem[64] + 64
        mem[_961] = 26
        mem[_961 + 32] = 'SafeMath: division by zero'
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero'
        if not arg1:
            return 0
        if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if 0 > stor209 / totalSupply * arg1:
            revert with 0, 'SafeMath: subtraction overflow'
    else:
        if _tFeePercent * arg1 / arg1 != _tFeePercent:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if _tFeePercent * arg1 / 10000 > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        idx = 0
        s = totalSupply
        t = stor209
        while idx < stor207.length:
            mem[0] = stor207[idx]
            mem[32] = 203
            if stor203[stor207[idx]] > t:
                _883 = mem[64]
                mem[64] = mem[64] + 64
                mem[_883] = 26
                mem[_883 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _883 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                if not arg1:
                    if not _tFeePercent * arg1 / 10000:
                        return 0
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _1213 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1213] = 30
                    mem[_1213 + 32] = 'SafeMath: subtraction overflow'
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 <= 0:
                        return 0
                    _1250 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1250 + 68] = mem[idx + _1213 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1250 + 68] = mem[_1250 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1250 + -mem[64] + 100
                if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not _tFeePercent * arg1 / 10000:
                    _1212 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1212] = 30
                    mem[_1212 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor209 / totalSupply * arg1:
                        return (stor209 / totalSupply * arg1)
                    _1247 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1247 + 68] = mem[idx + _1212 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1247 + 68] = mem[_1247 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1247 + -mem[64] + 100
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1222 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1222] = 30
                mem[_1222 + 32] = 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 <= stor209 / totalSupply * arg1:
                    return (stor209 / totalSupply * arg1)
                _1277 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1277 + 68] = mem[idx + _1222 + 32]
                    idx = idx + 32
                    continue 
                mem[_1277 + 68] = mem[_1277 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1277 + -mem[64] + 100
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 204
            if stor204[stor207[idx]] > s:
                _917 = mem[64]
                mem[64] = mem[64] + 64
                mem[_917] = 26
                mem[_917 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _917 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                if not arg1:
                    if not _tFeePercent * arg1 / 10000:
                        return 0
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _1254 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1254] = 30
                    mem[_1254 + 32] = 'SafeMath: subtraction overflow'
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 <= 0:
                        return 0
                    _1310 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1310 + 68] = mem[idx + _1254 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1310 + 68] = mem[_1310 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1310 + -mem[64] + 100
                if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not _tFeePercent * arg1 / 10000:
                    _1253 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1253] = 30
                    mem[_1253 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor209 / totalSupply * arg1:
                        return (stor209 / totalSupply * arg1)
                    _1307 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1307 + 68] = mem[idx + _1253 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1307 + 68] = mem[_1307 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1307 + -mem[64] + 100
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1280 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1280] = 30
                mem[_1280 + 32] = 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 <= stor209 / totalSupply * arg1:
                    return (stor209 / totalSupply * arg1)
                _1338 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1338 + 68] = mem[idx + _1280 + 32]
                    idx = idx + 32
                    continue 
                mem[_1338 + 68] = mem[_1338 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1338 + -mem[64] + 100
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 203
            _899 = mem[64]
            mem[64] = mem[64] + 64
            mem[_899] = 30
            mem[_899 + 32] = 'SafeMath: subtraction overflow'
            if stor203[stor207[idx]] > t:
                _932 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _932 + 68] = mem[idx + _899 + 32]
                    idx = idx + 32
                    continue 
                mem[_932 + 68] = mem[_932 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _932 + -mem[64] + 100
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 204
            _1056 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1056] = 30
            mem[_1056 + 32] = 'SafeMath: subtraction overflow'
            if stor204[stor207[idx]] <= s:
                idx = idx + 1
                s = s - stor204[stor207[idx]]
                t = t - stor203[stor207[idx]]
                continue 
            _1111 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _1111 + 68] = mem[idx + _1056 + 32]
                idx = idx + 32
                continue 
            mem[_1111 + 68] = mem[_1111 + 70 len 30]
            revert with memory
              from mem[64]
               len _1111 + -mem[64] + 100
        _825 = mem[64]
        mem[64] = mem[64] + 64
        mem[_825] = 26
        mem[_825 + 32] = 'SafeMath: division by zero'
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero'
        if t >= stor209 / totalSupply:
            _953 = mem[64]
            mem[64] = mem[64] + 64
            mem[_953] = 26
            mem[_953 + 32] = 'SafeMath: division by zero'
            if not s:
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                if _tFeePercent * arg1 / 10000:
                    if t / s * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != t / s:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if t / s * _tFeePercent * arg1 / 10000 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    else:
                        return 0
                else:
                    return 0
            if t / s * arg1 / arg1 != t / s:
                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not _tFeePercent * arg1 / 10000:
                if 0 > t / s * arg1:
                    revert with 0, 'SafeMath: subtraction overflow'
            else:
                if t / s * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != t / s:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if t / s * _tFeePercent * arg1 / 10000 > t / s * arg1:
                    revert with 0, 'SafeMath: subtraction overflow'
            return (t / s * arg1)
        _954 = mem[64]
        mem[64] = mem[64] + 64
        mem[_954] = 26
        mem[_954 + 32] = 'SafeMath: division by zero'
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero'
        if not arg1:
            if _tFeePercent * arg1 / 10000:
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                else:
                    return 0
            else:
                return 0
        if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if not _tFeePercent * arg1 / 10000:
            if 0 > stor209 / totalSupply * arg1:
                revert with 0, 'SafeMath: subtraction overflow'
        else:
            if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if stor209 / totalSupply * _tFeePercent * arg1 / 10000 > stor209 / totalSupply * arg1:
                revert with 0, 'SafeMath: subtraction overflow'
    return (stor209 / totalSupply * arg1)
}

function refract(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    mem[0] = msg.sender
    mem[32] = 206
    if stor206[address(msg.sender)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    44,
                    0x734578636c75646564206164647265737365732063616e6e6f742063616c6c20746869732066756e6374696f,
                    mem[208 len 20]
    if not arg1:
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 0 > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        idx = 0
        s = totalSupply
        t = stor209
        while idx < stor207.length:
            mem[0] = stor207[idx]
            mem[32] = 203
            if stor203[stor207[idx]] > t:
                _877 = mem[64]
                mem[64] = mem[64] + 64
                mem[_877] = 26
                mem[_877 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _877 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                if not arg1:
                    _1037 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1037] = 30
                    mem[_1037 + 32] = 'SafeMath: subtraction overflow'
                    mem[0] = msg.sender
                    mem[32] = 203
                    _1137 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1137] = 30
                    mem[_1137 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor203[address(msg.sender)]:
                        _1176 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1176 + 68] = mem[idx + _1137 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1176 + 68] = mem[_1176 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1176 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 203
                    _1273 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1273] = 30
                    mem[_1273 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor209:
                        if arg1 + totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _1347 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1347 + 68] = mem[idx + _1273 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1347 + 68] = mem[_1347 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1347 + -mem[64] + 100
                if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1042 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1042] = 30
                mem[_1042 + 32] = 'SafeMath: subtraction overflow'
                if 0 > stor209 / totalSupply * arg1:
                    _1060 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1060 + 68] = mem[idx + _1042 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1060 + 68] = mem[_1060 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1060 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 203
                _1155 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1155] = 30
                mem[_1155 + 32] = 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * arg1 > stor203[address(msg.sender)]:
                    _1210 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1210 + 68] = mem[idx + _1155 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1210 + 68] = mem[_1210 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1210 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 203
                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg1
                _1307 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1307] = 30
                mem[_1307 + 32] = 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * arg1 <= stor209:
                    stor209 += -1 * stor209 / totalSupply * arg1
                    if arg1 + totalFees < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _1385 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1385 + 68] = mem[idx + _1307 + 32]
                    idx = idx + 32
                    continue 
                mem[_1385 + 68] = mem[_1385 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1385 + -mem[64] + 100
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 204
            if stor204[stor207[idx]] <= s:
                require idx < stor207.length
                mem[0] = stor207[idx]
                mem[32] = 203
                _885 = mem[64]
                mem[64] = mem[64] + 64
                mem[_885] = 30
                mem[_885 + 32] = 'SafeMath: subtraction overflow'
                if stor203[stor207[idx]] > t:
                    _901 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _901 + 68] = mem[idx + _885 + 32]
                        idx = idx + 32
                        continue 
                    mem[_901 + 68] = mem[_901 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _901 + -mem[64] + 100
                require idx < stor207.length
                mem[0] = stor207[idx]
                mem[32] = 204
                _964 = mem[64]
                mem[64] = mem[64] + 64
                mem[_964] = 30
                mem[_964 + 32] = 'SafeMath: subtraction overflow'
                if stor204[stor207[idx]] <= s:
                    idx = idx + 1
                    s = s - stor204[stor207[idx]]
                    t = t - stor203[stor207[idx]]
                    continue 
                _992 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _992 + 68] = mem[idx + _964 + 32]
                    idx = idx + 32
                    continue 
                mem[_992 + 68] = mem[_992 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _992 + -mem[64] + 100
            _895 = mem[64]
            mem[64] = mem[64] + 64
            mem[_895] = 26
            mem[_895 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero'
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _895 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                _1047 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1047] = 30
                mem[_1047 + 32] = 'SafeMath: subtraction overflow'
                mem[0] = msg.sender
                mem[32] = 203
                _1181 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1181] = 30
                mem[_1181 + 32] = 'SafeMath: subtraction overflow'
                if 0 > stor203[address(msg.sender)]:
                    _1245 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1245 + 68] = mem[idx + _1181 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1245 + 68] = mem[_1245 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1245 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 203
                _1352 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1352] = 30
                mem[_1352 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= stor209:
                    if arg1 + totalFees < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _1430 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1430 + 68] = mem[idx + _1352 + 32]
                    idx = idx + 32
                    continue 
                mem[_1430 + 68] = mem[_1430 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1430 + -mem[64] + 100
            if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _1063 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1063] = 30
            mem[_1063 + 32] = 'SafeMath: subtraction overflow'
            if 0 > stor209 / totalSupply * arg1:
                _1091 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1091 + 68] = mem[idx + _1063 + 32]
                    idx = idx + 32
                    continue 
                mem[_1091 + 68] = mem[_1091 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1091 + -mem[64] + 100
            mem[0] = msg.sender
            mem[32] = 203
            _1213 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1213] = 30
            mem[_1213 + 32] = 'SafeMath: subtraction overflow'
            if stor209 / totalSupply * arg1 > stor203[address(msg.sender)]:
                _1276 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1276 + 68] = mem[idx + _1213 + 32]
                    idx = idx + 32
                    continue 
                mem[_1276 + 68] = mem[_1276 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1276 + -mem[64] + 100
            mem[0] = msg.sender
            mem[32] = 203
            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg1
            _1388 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1388] = 30
            mem[_1388 + 32] = 'SafeMath: subtraction overflow'
            if stor209 / totalSupply * arg1 <= stor209:
                stor209 += -1 * stor209 / totalSupply * arg1
                if arg1 + totalFees < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                totalFees += arg1
            _1473 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _1473 + 68] = mem[idx + _1388 + 32]
                idx = idx + 32
                continue 
            mem[_1473 + 68] = mem[_1473 + 70 len 30]
            revert with memory
              from mem[64]
               len _1473 + -mem[64] + 100
        _847 = mem[64]
        mem[64] = mem[64] + 64
        mem[_847] = 26
        mem[_847 + 32] = 'SafeMath: division by zero'
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero'
        if t >= stor209 / totalSupply:
            _911 = mem[64]
            mem[64] = mem[64] + 64
            mem[_911] = 26
            mem[_911 + 32] = 'SafeMath: division by zero'
            if not s:
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                if 0 > stor203[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor209:
                    revert with 0, 'SafeMath: subtraction overflow'
            else:
                if t / s * arg1 / arg1 != t / s:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if 0 > t / s * arg1:
                    revert with 0, 'SafeMath: subtraction overflow'
                if t / s * arg1 > stor203[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor203[address(msg.sender)] += -1 * t / s * arg1
                if t / s * arg1 > stor209:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor209 += -1 * t / s * arg1
        else:
            _912 = mem[64]
            mem[64] = mem[64] + 64
            mem[_912] = 26
            mem[_912 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                if 0 > stor203[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor209:
                    revert with 0, 'SafeMath: subtraction overflow'
            else:
                if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if 0 > stor209 / totalSupply * arg1:
                    revert with 0, 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * arg1 > stor203[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg1
                if stor209 / totalSupply * arg1 > stor209:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor209 += -1 * stor209 / totalSupply * arg1
    else:
        if _tFeePercent * arg1 / arg1 != _tFeePercent:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if _tFeePercent * arg1 / 10000 > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        idx = 0
        s = totalSupply
        t = stor209
        while idx < stor207.length:
            mem[0] = stor207[idx]
            mem[32] = 203
            if stor203[stor207[idx]] > t:
                _872 = mem[64]
                mem[64] = mem[64] + 64
                mem[_872] = 26
                mem[_872 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _872 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                if not arg1:
                    if not _tFeePercent * arg1 / 10000:
                        _1036 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1036] = 30
                        mem[_1036 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = msg.sender
                        mem[32] = 203
                        _1126 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1126] = 30
                        mem[_1126 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor203[address(msg.sender)]:
                            _1164 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1164 + 68] = mem[idx + _1126 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1164 + 68] = mem[_1164 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _1164 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 203
                        _1260 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1260] = 30
                        mem[_1260 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor209:
                            if arg1 + totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += arg1
                        _1330 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1330 + 68] = mem[idx + _1260 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1330 + 68] = mem[_1330 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1330 + -mem[64] + 100
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _1039 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1039] = 30
                    mem[_1039 + 32] = 'SafeMath: subtraction overflow'
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 > 0:
                        _1055 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1055 + 68] = mem[idx + _1039 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1055 + 68] = mem[_1055 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1055 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 203
                    _1148 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1148] = 30
                    mem[_1148 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor203[address(msg.sender)]:
                        _1197 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1197 + 68] = mem[idx + _1148 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1197 + 68] = mem[_1197 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1197 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 203
                    _1292 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1292] = 30
                    mem[_1292 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor209:
                        if arg1 + totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _1369 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1369 + 68] = mem[idx + _1292 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1369 + 68] = mem[_1369 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1369 + -mem[64] + 100
                if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not _tFeePercent * arg1 / 10000:
                    _1038 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1038] = 30
                    mem[_1038 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor209 / totalSupply * arg1:
                        _1052 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1052 + 68] = mem[idx + _1038 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1052 + 68] = mem[_1052 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1052 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 203
                    _1147 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1147] = 30
                    mem[_1147 + 32] = 'SafeMath: subtraction overflow'
                    if stor209 / totalSupply * arg1 > stor203[address(msg.sender)]:
                        _1194 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1194 + 68] = mem[idx + _1147 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1194 + 68] = mem[_1194 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1194 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 203
                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg1
                    _1289 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1289] = 30
                    mem[_1289 + 32] = 'SafeMath: subtraction overflow'
                    if stor209 / totalSupply * arg1 <= stor209:
                        stor209 += -1 * stor209 / totalSupply * arg1
                        if arg1 + totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _1366 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1366 + 68] = mem[idx + _1289 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1366 + 68] = mem[_1366 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1366 + -mem[64] + 100
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1043 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1043] = 30
                mem[_1043 + 32] = 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 > stor209 / totalSupply * arg1:
                    _1070 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1070 + 68] = mem[idx + _1043 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1070 + 68] = mem[_1070 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1070 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 203
                _1163 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1163] = 30
                mem[_1163 + 32] = 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * arg1 > stor203[address(msg.sender)]:
                    _1228 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1228 + 68] = mem[idx + _1163 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1228 + 68] = mem[_1228 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1228 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 203
                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg1
                _1325 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1325] = 30
                mem[_1325 + 32] = 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * arg1 <= stor209:
                    stor209 += -1 * stor209 / totalSupply * arg1
                    if arg1 + totalFees < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _1406 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1406 + 68] = mem[idx + _1325 + 32]
                    idx = idx + 32
                    continue 
                mem[_1406 + 68] = mem[_1406 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1406 + -mem[64] + 100
            require idx < stor207.length
            mem[0] = stor207[idx]
            mem[32] = 204
            if stor204[stor207[idx]] <= s:
                require idx < stor207.length
                mem[0] = stor207[idx]
                mem[32] = 203
                _882 = mem[64]
                mem[64] = mem[64] + 64
                mem[_882] = 30
                mem[_882 + 32] = 'SafeMath: subtraction overflow'
                if stor203[stor207[idx]] > t:
                    _897 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _897 + 68] = mem[idx + _882 + 32]
                        idx = idx + 32
                        continue 
                    mem[_897 + 68] = mem[_897 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _897 + -mem[64] + 100
                require idx < stor207.length
                mem[0] = stor207[idx]
                mem[32] = 204
                _957 = mem[64]
                mem[64] = mem[64] + 64
                mem[_957] = 30
                mem[_957 + 32] = 'SafeMath: subtraction overflow'
                if stor204[stor207[idx]] <= s:
                    idx = idx + 1
                    s = s - stor204[stor207[idx]]
                    t = t - stor203[stor207[idx]]
                    continue 
                _984 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _984 + 68] = mem[idx + _957 + 32]
                    idx = idx + 32
                    continue 
                mem[_984 + 68] = mem[_984 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _984 + -mem[64] + 100
            _890 = mem[64]
            mem[64] = mem[64] + 64
            mem[_890] = 26
            mem[_890 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                mem[mem[64] + 68] = 'SafeMath: division by zero'
                idx = 32
                while idx < 26:
                    mem[idx + mem[64] + 68] = mem[idx + _890 + 32]
                    idx = idx + 32
                    continue 
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                if not _tFeePercent * arg1 / 10000:
                    _1046 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1046] = 30
                    mem[_1046 + 32] = 'SafeMath: subtraction overflow'
                    mem[0] = msg.sender
                    mem[32] = 203
                    _1173 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1173] = 30
                    mem[_1173 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor203[address(msg.sender)]:
                        _1234 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1234 + 68] = mem[idx + _1173 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1234 + 68] = mem[_1234 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1234 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 203
                    _1337 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1337] = 30
                    mem[_1337 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor209:
                        if arg1 + totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _1415 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1415 + 68] = mem[idx + _1337 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1415 + 68] = mem[_1415 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1415 + -mem[64] + 100
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1059 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1059] = 30
                mem[_1059 + 32] = 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * _tFeePercent * arg1 / 10000 > 0:
                    _1085 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1085 + 68] = mem[idx + _1059 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1085 + 68] = mem[_1085 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1085 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 203
                _1203 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1203] = 30
                mem[_1203 + 32] = 'SafeMath: subtraction overflow'
                if 0 > stor203[address(msg.sender)]:
                    _1266 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1266 + 68] = mem[idx + _1203 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1266 + 68] = mem[_1266 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1266 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 203
                _1377 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1377] = 30
                mem[_1377 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= stor209:
                    if arg1 + totalFees < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _1459 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1459 + 68] = mem[idx + _1377 + 32]
                    idx = idx + 32
                    continue 
                mem[_1459 + 68] = mem[_1459 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1459 + -mem[64] + 100
            if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not _tFeePercent * arg1 / 10000:
                _1058 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1058] = 30
                mem[_1058 + 32] = 'SafeMath: subtraction overflow'
                if 0 > stor209 / totalSupply * arg1:
                    _1082 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1082 + 68] = mem[idx + _1058 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1082 + 68] = mem[_1082 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1082 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 203
                _1202 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1202] = 30
                mem[_1202 + 32] = 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * arg1 > stor203[address(msg.sender)]:
                    _1263 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1263 + 68] = mem[idx + _1202 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1263 + 68] = mem[_1263 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1263 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 203
                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg1
                _1374 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1374] = 30
                mem[_1374 + 32] = 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * arg1 <= stor209:
                    stor209 += -1 * stor209 / totalSupply * arg1
                    if arg1 + totalFees < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _1456 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1456 + 68] = mem[idx + _1374 + 32]
                    idx = idx + 32
                    continue 
                mem[_1456 + 68] = mem[_1456 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1456 + -mem[64] + 100
            if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _1073 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1073] = 30
            mem[_1073 + 32] = 'SafeMath: subtraction overflow'
            if stor209 / totalSupply * _tFeePercent * arg1 / 10000 > stor209 / totalSupply * arg1:
                _1102 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1102 + 68] = mem[idx + _1073 + 32]
                    idx = idx + 32
                    continue 
                mem[_1102 + 68] = mem[_1102 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1102 + -mem[64] + 100
            mem[0] = msg.sender
            mem[32] = 203
            _1233 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1233] = 30
            mem[_1233 + 32] = 'SafeMath: subtraction overflow'
            if stor209 / totalSupply * arg1 > stor203[address(msg.sender)]:
                _1296 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1296 + 68] = mem[idx + _1233 + 32]
                    idx = idx + 32
                    continue 
                mem[_1296 + 68] = mem[_1296 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1296 + -mem[64] + 100
            mem[0] = msg.sender
            mem[32] = 203
            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg1
            _1410 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1410] = 30
            mem[_1410 + 32] = 'SafeMath: subtraction overflow'
            if stor209 / totalSupply * arg1 <= stor209:
                stor209 += -1 * stor209 / totalSupply * arg1
                if arg1 + totalFees < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                totalFees += arg1
            _1500 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _1500 + 68] = mem[idx + _1410 + 32]
                idx = idx + 32
                continue 
            mem[_1500 + 68] = mem[_1500 + 70 len 30]
            revert with memory
              from mem[64]
               len _1500 + -mem[64] + 100
        _842 = mem[64]
        mem[64] = mem[64] + 64
        mem[_842] = 26
        mem[_842 + 32] = 'SafeMath: division by zero'
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero'
        if t >= stor209 / totalSupply:
            _904 = mem[64]
            mem[64] = mem[64] + 64
            mem[_904] = 26
            mem[_904 + 32] = 'SafeMath: division by zero'
            if not s:
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                if _tFeePercent * arg1 / 10000:
                    if t / s * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != t / s:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if t / s * _tFeePercent * arg1 / 10000 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor203[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor209:
                    revert with 0, 'SafeMath: subtraction overflow'
            else:
                if t / s * arg1 / arg1 != t / s:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not _tFeePercent * arg1 / 10000:
                    if 0 > t / s * arg1:
                        revert with 0, 'SafeMath: subtraction overflow'
                else:
                    if t / s * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != t / s:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if t / s * _tFeePercent * arg1 / 10000 > t / s * arg1:
                        revert with 0, 'SafeMath: subtraction overflow'
                if t / s * arg1 > stor203[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor203[address(msg.sender)] += -1 * t / s * arg1
                if t / s * arg1 > stor209:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor209 += -1 * t / s * arg1
        else:
            _905 = mem[64]
            mem[64] = mem[64] + 64
            mem[_905] = 26
            mem[_905 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero'
            if not arg1:
                if _tFeePercent * arg1 / 10000:
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor203[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor209:
                    revert with 0, 'SafeMath: subtraction overflow'
            else:
                if stor209 / totalSupply * arg1 / arg1 != stor209 / totalSupply:
                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not _tFeePercent * arg1 / 10000:
                    if 0 > stor209 / totalSupply * arg1:
                        revert with 0, 'SafeMath: subtraction overflow'
                else:
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 / _tFeePercent * arg1 / 10000 != stor209 / totalSupply:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if stor209 / totalSupply * _tFeePercent * arg1 / 10000 > stor209 / totalSupply * arg1:
                        revert with 0, 'SafeMath: subtraction overflow'
                if stor209 / totalSupply * arg1 > stor203[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg1
                if stor209 / totalSupply * arg1 > stor209:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor209 += -1 * stor209 / totalSupply * arg1
    if arg1 + totalFees < totalFees:
        revert with 0, 'SafeMath: addition overflow'
    totalFees += arg1
}

function rebase(int256 arg1) payable {
    require calldata.size - 4 >= 32
    if msg.sender == owner:
        if stor202 + 1 < stor202:
            revert with 0, 'SafeMath: addition overflow'
        stor202++
        if not arg1:
            emit LogRebase(totalSupply, stor202);
        else:
            if arg1 >= 0:
                if not arg1:
                    mem[64] = 160
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero'
                    if arg1 >= 0:
                        if (0 / totalSupply) + 10^9 < 10^9:
                            revert with 0, 'SafeMath: addition overflow'
                        if arg1 >= 0:
                            if arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2878 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2878] = 26
                                        mem[_2878 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3006 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3006] = 26
                                        mem[_3006 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4273 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4273] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4273 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4273 + 32
                                t = sha3(mem[0])
                                while _4273 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4273 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4273 + 36 len mem[_4273] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5879 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5879 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5879 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5879 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2882 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2882] = 26
                                        mem[_2882 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3010 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3010] = 26
                                        mem[_3010 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4276 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4276] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4276 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4276 + 32
                                t = sha3(mem[0])
                                while _4276 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4276 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4276 + 36 len mem[_4276] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5880 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5880 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5880 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5880 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                    else:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 / totalSupply > 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg1 >= 0:
                            if arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2886 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2886] = 26
                                        mem[_2886 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3014 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3014] = 26
                                        mem[_3014 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4279 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4279] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4279 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4279 + 32
                                t = sha3(mem[0])
                                while _4279 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4279 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4279 + 36 len mem[_4279] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5881 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5881 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5881 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5881 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 288
                            mem[224] = 30
                            mem[256] = 'SafeMath: subtraction overflow'
                            if arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2890 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2890] = 26
                                        mem[_2890 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3018 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3018] = 26
                                        mem[_3018 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4282 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4282] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4282 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4282 + 32
                                t = sha3(mem[0])
                                while _4282 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4282 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4282 + 36 len mem[_4282] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5882 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5882 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5882 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5882 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                else:
                    if 10^9 * arg1 / arg1 != 10^9:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    mem[64] = 160
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero'
                    if arg1 >= 0:
                        if (10^9 * arg1 / totalSupply) + 10^9 < 10^9:
                            revert with 0, 'SafeMath: addition overflow'
                        if arg1 >= 0:
                            if arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2862 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2862] = 26
                                        mem[_2862 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2990 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2990] = 26
                                        mem[_2990 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4261 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4261] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4261 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4261 + 32
                                t = sha3(mem[0])
                                while _4261 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4261 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4261 + 36 len mem[_4261] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5875 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5875 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5875 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5875 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2866 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2866] = 26
                                        mem[_2866 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2994 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2994] = 26
                                        mem[_2994 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4264 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4264] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4264 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4264 + 32
                                t = sha3(mem[0])
                                while _4264 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4264 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4264 + 36 len mem[_4264] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5876 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5876 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5876 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5876 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                    else:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 10^9 * arg1 / totalSupply > 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg1 >= 0:
                            if arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2870 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2870] = 26
                                        mem[_2870 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2998 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2998] = 26
                                        mem[_2998 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4267 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4267] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4267 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4267 + 32
                                t = sha3(mem[0])
                                while _4267 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4267 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4267 + 36 len mem[_4267] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5877 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5877 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5877 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5877 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 288
                            mem[224] = 30
                            mem[256] = 'SafeMath: subtraction overflow'
                            if arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2874 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2874] = 26
                                        mem[_2874 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3002 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3002] = 26
                                        mem[_3002 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4270 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4270] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4270 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4270 + 32
                                t = sha3(mem[0])
                                while _4270 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4270 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4270 + 36 len mem[_4270] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5878 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5878 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5878 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5878 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
            else:
                if -arg1 < 0:
                    revert with 0, 'SafeCast: value must be positive'
                if not -arg1:
                    mem[64] = 160
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero'
                    if arg1 >= 0:
                        if (0 / totalSupply) + 10^9 < 10^9:
                            revert with 0, 'SafeMath: addition overflow'
                        if arg1 >= 0:
                            if -arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2846 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2846] = 26
                                        mem[_2846 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2974 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2974] = 26
                                        mem[_2974 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4249 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4249] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4249 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4249 + 32
                                t = sha3(mem[0])
                                while _4249 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4249 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4249 + 36 len mem[_4249] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5871 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5871 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5871 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5871 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if -arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2850 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2850] = 26
                                        mem[_2850 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2978 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2978] = 26
                                        mem[_2978 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4252 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4252] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4252 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4252 + 32
                                t = sha3(mem[0])
                                while _4252 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4252 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4252 + 36 len mem[_4252] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5872 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5872 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5872 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5872 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                    else:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 / totalSupply > 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg1 >= 0:
                            if -arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2854 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2854] = 26
                                        mem[_2854 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2982 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2982] = 26
                                        mem[_2982 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4255 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4255] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4255 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4255 + 32
                                t = sha3(mem[0])
                                while _4255 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4255 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4255 + 36 len mem[_4255] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5873 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5873 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5873 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5873 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 288
                            mem[224] = 30
                            mem[256] = 'SafeMath: subtraction overflow'
                            if -arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2858 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2858] = 26
                                        mem[_2858 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2986 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2986] = 26
                                        mem[_2986 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4258 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4258] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4258 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4258 + 32
                                t = sha3(mem[0])
                                while _4258 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4258 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4258 + 36 len mem[_4258] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5874 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5874 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5874 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5874 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                else:
                    if -1 * 10^9 * arg1 / -arg1 != 10^9:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    mem[64] = 160
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero'
                    if arg1 >= 0:
                        if (-1 * 10^9 * arg1 / totalSupply) + 10^9 < 10^9:
                            revert with 0, 'SafeMath: addition overflow'
                        if arg1 >= 0:
                            if -arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2830 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2830] = 26
                                        mem[_2830 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (-1 * 10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2958 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2958] = 26
                                        mem[_2958 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4237 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4237] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4237 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4237 + 32
                                t = sha3(mem[0])
                                while _4237 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4237 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4237 + 36 len mem[_4237] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5867 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5867 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5867 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5867 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if -arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2834 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2834] = 26
                                        mem[_2834 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (-1 * 10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2962 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2962] = 26
                                        mem[_2962 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4240 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4240] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4240 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4240 + 32
                                t = sha3(mem[0])
                                while _4240 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4240 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4240 + 36 len mem[_4240] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5868 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5868 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5868 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5868 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                    else:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if -1 * 10^9 * arg1 / totalSupply > 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg1 >= 0:
                            if -arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2838 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2838] = 26
                                        mem[_2838 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(-1 * 10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2966 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2966] = 26
                                        mem[_2966 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4243 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4243] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4243 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4243 + 32
                                t = sha3(mem[0])
                                while _4243 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4243 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4243 + 36 len mem[_4243] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5869 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5869 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5869 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5869 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 288
                            mem[224] = 30
                            mem[256] = 'SafeMath: subtraction overflow'
                            if -arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2842 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2842] = 26
                                        mem[_2842 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(-1 * 10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _2970 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2970] = 26
                                        mem[_2970 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4246 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4246] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4246 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4246 + 32
                                t = sha3(mem[0])
                                while _4246 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4246 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4246 + 36 len mem[_4246] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5870 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5870 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5870 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5870 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
    else:
        if _rebaserAddress != msg.sender:
            revert with 0, 'Sender not authorized'
        if stor202 + 1 < stor202:
            revert with 0, 'SafeMath: addition overflow'
        stor202++
        if not arg1:
            emit LogRebase(totalSupply, stor202);
        else:
            if arg1 >= 0:
                if not arg1:
                    mem[64] = 160
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero'
                    if arg1 >= 0:
                        if (0 / totalSupply) + 10^9 < 10^9:
                            revert with 0, 'SafeMath: addition overflow'
                        if arg1 >= 0:
                            if arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2942 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2942] = 26
                                        mem[_2942 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3070 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3070] = 26
                                        mem[_3070 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4321 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4321] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4321 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4321 + 32
                                t = sha3(mem[0])
                                while _4321 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4321 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4321 + 36 len mem[_4321] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5895 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5895 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5895 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5895 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2946 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2946] = 26
                                        mem[_2946 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3074 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3074] = 26
                                        mem[_3074 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4324 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4324] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4324 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4324 + 32
                                t = sha3(mem[0])
                                while _4324 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4324 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4324 + 36 len mem[_4324] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5896 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5896 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5896 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5896 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                    else:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 / totalSupply > 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg1 >= 0:
                            if arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2950 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2950] = 26
                                        mem[_2950 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3078 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3078] = 26
                                        mem[_3078 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4327 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4327] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4327 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4327 + 32
                                t = sha3(mem[0])
                                while _4327 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4327 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4327 + 36 len mem[_4327] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5897 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5897 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5897 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5897 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 288
                            mem[224] = 30
                            mem[256] = 'SafeMath: subtraction overflow'
                            if arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2954 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2954] = 26
                                        mem[_2954 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3082 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3082] = 26
                                        mem[_3082 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4330 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4330] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4330 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4330 + 32
                                t = sha3(mem[0])
                                while _4330 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4330 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4330 + 36 len mem[_4330] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5898 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5898 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5898 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5898 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                else:
                    if 10^9 * arg1 / arg1 != 10^9:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    mem[64] = 160
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero'
                    if arg1 >= 0:
                        if (10^9 * arg1 / totalSupply) + 10^9 < 10^9:
                            revert with 0, 'SafeMath: addition overflow'
                        if arg1 >= 0:
                            if arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2926 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2926] = 26
                                        mem[_2926 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3054 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3054] = 26
                                        mem[_3054 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4309 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4309] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4309 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4309 + 32
                                t = sha3(mem[0])
                                while _4309 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4309 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4309 + 36 len mem[_4309] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5891 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5891 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5891 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5891 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2930 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2930] = 26
                                        mem[_2930 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3058 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3058] = 26
                                        mem[_3058 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4312 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4312] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4312 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4312 + 32
                                t = sha3(mem[0])
                                while _4312 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4312 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4312 + 36 len mem[_4312] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5892 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5892 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5892 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5892 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                    else:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 10^9 * arg1 / totalSupply > 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg1 >= 0:
                            if arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2934 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2934] = 26
                                        mem[_2934 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3062 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3062] = 26
                                        mem[_3062 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4315 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4315] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4315 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4315 + 32
                                t = sha3(mem[0])
                                while _4315 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4315 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4315 + 36 len mem[_4315] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5893 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5893 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5893 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5893 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 288
                            mem[224] = 30
                            mem[256] = 'SafeMath: subtraction overflow'
                            if arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2938 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2938] = 26
                                        mem[_2938 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3066 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3066] = 26
                                        mem[_3066 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4318 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4318] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4318 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4318 + 32
                                t = sha3(mem[0])
                                while _4318 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4318 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4318 + 36 len mem[_4318] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5894 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5894 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5894 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5894 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
            else:
                if -arg1 < 0:
                    revert with 0, 'SafeCast: value must be positive'
                if not -arg1:
                    mem[64] = 160
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero'
                    if arg1 >= 0:
                        if (0 / totalSupply) + 10^9 < 10^9:
                            revert with 0, 'SafeMath: addition overflow'
                        if arg1 >= 0:
                            if -arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2910 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2910] = 26
                                        mem[_2910 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3038 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3038] = 26
                                        mem[_3038 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4297 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4297] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4297 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4297 + 32
                                t = sha3(mem[0])
                                while _4297 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4297 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4297 + 36 len mem[_4297] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5887 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5887 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5887 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5887 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if -arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2914 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2914] = 26
                                        mem[_2914 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3042 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3042] = 26
                                        mem[_3042 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4300 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4300] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4300 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4300 + 32
                                t = sha3(mem[0])
                                while _4300 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4300 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4300 + 36 len mem[_4300] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5888 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5888 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5888 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5888 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                    else:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 / totalSupply > 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg1 >= 0:
                            if -arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2918 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2918] = 26
                                        mem[_2918 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3046 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3046] = 26
                                        mem[_3046 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4303 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4303] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4303 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4303 + 32
                                t = sha3(mem[0])
                                while _4303 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4303 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4303 + 36 len mem[_4303] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5889 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5889 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5889 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5889 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 288
                            mem[224] = 30
                            mem[256] = 'SafeMath: subtraction overflow'
                            if -arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2922 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2922] = 26
                                        mem[_2922 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(0 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3050 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3050] = 26
                                        mem[_3050 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (0 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4306 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4306] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4306 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4306 + 32
                                t = sha3(mem[0])
                                while _4306 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4306 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4306 + 36 len mem[_4306] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5890 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5890 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5890 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5890 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                else:
                    if -1 * 10^9 * arg1 / -arg1 != 10^9:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    mem[64] = 160
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero'
                    if arg1 >= 0:
                        if (-1 * 10^9 * arg1 / totalSupply) + 10^9 < 10^9:
                            revert with 0, 'SafeMath: addition overflow'
                        if arg1 >= 0:
                            if -arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2894 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2894] = 26
                                        mem[_2894 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (-1 * 10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3022 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3022] = 26
                                        mem[_3022 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4285 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4285] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4285 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4285 + 32
                                t = sha3(mem[0])
                                while _4285 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4285 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4285 + 36 len mem[_4285] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5883 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5883 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5883 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5883 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if -arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2898 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2898] = 26
                                        mem[_2898 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) + (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != (-1 * 10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3026 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3026] = 26
                                        mem[_3026 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) + (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4288 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4288] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4288 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4288 + 32
                                t = sha3(mem[0])
                                while _4288 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4288 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4288 + 36 len mem[_4288] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5884 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5884 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5884 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5884 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                    else:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if -1 * 10^9 * arg1 / totalSupply > 10^9:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg1 >= 0:
                            if -arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply -= arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2902 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2902] = 26
                                        mem[_2902 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(-1 * 10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3030 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3030] = 26
                                        mem[_3030 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4291 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4291] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4291 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4291 + 32
                                t = sha3(mem[0])
                                while _4291 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4291 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4291 + 36 len mem[_4291] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5885 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5885 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5885 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5885 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
                        else:
                            mem[64] = 288
                            mem[224] = 30
                            mem[256] = 'SafeMath: subtraction overflow'
                            if -arg1 > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply += arg1
                            idx = 0
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] > 0:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if not stor204[stor207[idx]]:
                                        _2906 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_2906] = 26
                                        mem[_2906 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = 0
                                    else:
                                        if (10^9 * stor204[stor207[idx]]) - (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / stor204[stor207[idx]] != -(-1 * 10^9 * arg1 / totalSupply) + 10^9:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _3034 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_3034] = 26
                                        mem[_3034 + 32] = 'SafeMath: division by zero'
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        stor204[stor207[idx]] = (10^9 * stor204[stor207[idx]]) - (-1 * 10^9 * arg1 / totalSupply * stor204[stor207[idx]]) / 10^9
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = totalSupply
                            emit LogRebase(totalSupply, stor202);
                            idx = 0
                            while idx < transactions.length:
                                mem[0] = 201
                                if not uint8(transactions[idx].field_0):
                                    idx = idx + 1
                                    continue 
                                _4294 = mem[64]
                                mem[64] = mem[64] + ceil32(stor[(2 * idx) + ('name', 'transactions', 201) + 1].length) + 32
                                mem[_4294] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[_4294 + 32] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = _4294 + 32
                                t = sha3(mem[0])
                                while _4294 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length > s:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                call address(transactions[idx].field_8).mem[_4294 + 32 len 4] with:
                                     gas gas_remaining - 34710 wei
                                    args mem[_4294 + 36 len mem[_4294] - 4]
                                if ext_call.success:
                                    idx = idx + 1
                                    continue 
                                _5886 = mem[64]
                                mem[mem[64]] = idx
                                mem[mem[64] + 32] = 64
                                mem[mem[64] + 64] = stor[(2 * idx) + ('name', 'transactions', 201) + 1].length
                                mem[0] = (2 * idx) + sha3(201) + 1
                                mem[mem[64] + 96] = stor[sha3((2 * idx) + ('name', 'transactions', 201) + 1)].field_0
                                s = mem[64] + 96
                                t = sha3(mem[0])
                                while _5886 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + 96 > s + 32:
                                    mem[s + 32] = stor1[t]
                                    s = s + 32
                                    t = t + 1
                                    continue 
                                emit TransactionFailed(address rg1, uint256 rg2, bytes rg3):
                                                       mem[mem[64] len _5886 + stor[(2 * idx) + ('name', 'transactions', 201) + 1].length + (s + -_5886 + -stor[(2 * idx) + ('name', 'transactions', 201) + 1].length - 64 % 32) + -mem[64] + 96],
                                                       address(transactions[idx].field_8),
                                revert with 0, 'Transaction Failed'
    return totalSupply
}

function transfer(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    37,
                    0x7345524332303a207472616e736665722066726f6d20746865207a65726f20616464726573,
                    mem[201 len 27]
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    35,
                    0xfe45524332303a207472616e7366657220746f20746865207a65726f20616464726573,
                    mem[199 len 29]
    if arg2 <= 0:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    41,
                    0x725472616e7366657220616d6f756e74206d7573742062652067726561746572207468616e207a6572,
                    mem[205 len 23]
    if not stor206[address(msg.sender)]:
        if stor206[address(msg.sender)]:
            if stor206[address(msg.sender)]:
                mem[0] = msg.sender
                mem[32] = 206
                if not stor206[address(msg.sender)]:
                    if not arg2:
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = totalSupply
                        t = stor209
                        while idx < stor207.length:
                            mem[0] = stor207[idx]
                            mem[32] = 203
                            if stor203[stor207[idx]] > t:
                                _32634 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32634] = 26
                                mem[_32634 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _32634 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    _37698 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37698] = 30
                                    mem[_37698 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _39714 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39714] = 30
                                    mem[_39714 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _41099 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _41099 + 68] = mem[idx + _39714 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41099 + 68] = mem[_41099 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41099 + -mem[64] + 100
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = stor203[arg1]
                                    _48074 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_48074] = 30
                                    mem[_48074 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _50539 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _50539 + 68] = mem[idx + _48074 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_50539 + 68] = mem[_50539 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _50539 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _37807 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_37807] = 30
                                mem[_37807 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _38077 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _38077 + 68] = mem[idx + _37807 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_38077 + 68] = mem[_38077 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _38077 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _40574 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_40574] = 30
                                mem[_40574 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _41767 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _41767 + 68] = mem[idx + _40574 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_41767 + 68] = mem[_41767 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _41767 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                _49363 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_49363] = 30
                                mem[_49363 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _51633 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _51633 + 68] = mem[idx + _49363 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_51633 + 68] = mem[_51633 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _51633 + -mem[64] + 100
                            require idx < stor207.length
                            mem[0] = stor207[idx]
                            mem[32] = 204
                            if stor204[stor207[idx]] <= s:
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                _32942 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32942] = 30
                                mem[_32942 + 32] = 'SafeMath: subtraction overflow'
                                if stor203[stor207[idx]] > t:
                                    _33438 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _33438 + 68] = mem[idx + _32942 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33438 + 68] = mem[_33438 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33438 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                _35241 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35241] = 30
                                mem[_35241 + 32] = 'SafeMath: subtraction overflow'
                                if stor204[stor207[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor204[stor207[idx]]
                                    t = t - stor203[stor207[idx]]
                                    continue 
                                _36049 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _36049 + 68] = mem[idx + _35241 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36049 + 68] = mem[_36049 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _36049 + -mem[64] + 100
                            _33132 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33132] = 26
                            mem[_33132 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _33132 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                _37938 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_37938] = 30
                                mem[_37938 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 203
                                _41104 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_41104] = 30
                                mem[_41104 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor203[address(msg.sender)]:
                                    _42668 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _42668 + 68] = mem[idx + _41104 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_42668 + 68] = mem[_42668 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _42668 + -mem[64] + 100
                                if stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = stor203[arg1]
                                _50542 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_50542] = 30
                                mem[_50542 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _52468 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _52468 + 68] = mem[idx + _50542 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_52468 + 68] = mem[_52468 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _52468 + -mem[64] + 100
                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _38080 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_38080] = 30
                            mem[_38080 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor209 / totalSupply * arg2:
                                _38820 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _38820 + 68] = mem[idx + _38080 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_38820 + 68] = mem[_38820 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _38820 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 203
                            _41770 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_41770] = 30
                            mem[_41770 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                _43684 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _43684 + 68] = mem[idx + _41770 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_43684 + 68] = mem[_43684 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _43684 + -mem[64] + 100
                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                            _51636 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_51636] = 30
                            mem[_51636 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor209:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _53119 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _53119 + 68] = mem[idx + _51636 + 32]
                                idx = idx + 32
                                continue 
                            mem[_53119 + 68] = mem[_53119 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _53119 + -mem[64] + 100
                        _31764 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31764] = 26
                        mem[_31764 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero'
                        if t >= stor209 / totalSupply:
                            _33688 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33688] = 26
                            mem[_33688 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if 0 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] = stor203[arg1]
                            else:
                                if t / s * arg2 / arg2 != t / s:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > t / s * arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if t / s * arg2 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                        else:
                            _33689 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33689] = 26
                            mem[_33689 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if 0 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] = stor203[arg1]
                            else:
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > stor209 / totalSupply * arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                        if 0 > stor209:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if _tFeePercent * arg2 / arg2 != _tFeePercent:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if _tFeePercent * arg2 / 10000 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = totalSupply
                        t = stor209
                        while idx < stor207.length:
                            mem[0] = stor207[idx]
                            mem[32] = 203
                            if stor203[stor207[idx]] > t:
                                _32629 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32629] = 26
                                mem[_32629 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _32629 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        _37697 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37697] = 30
                                        mem[_37697 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _39703 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39703] = 30
                                        mem[_39703 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _41087 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _41087 + 68] = mem[idx + _39703 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41087 + 68] = mem[_41087 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41087 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _48054 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48054] = 30
                                        mem[_48054 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _50526 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _50526 + 68] = mem[idx + _48054 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50526 + 68] = mem[_50526 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50526 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _37804 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37804] = 30
                                    mem[_37804 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                        _38072 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38072 + 68] = mem[idx + _37804 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38072 + 68] = mem[_38072 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38072 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _40567 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_40567] = 30
                                    mem[_40567 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _41754 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _41754 + 68] = mem[idx + _40567 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41754 + 68] = mem[_41754 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41754 + -mem[64] + 100
                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _49347 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_49347] = 30
                                    mem[_49347 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _51626 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _51626 + 68] = mem[idx + _49347 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_51626 + 68] = mem[_51626 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _51626 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    _37803 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37803] = 30
                                    mem[_37803 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _38069 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38069 + 68] = mem[idx + _37803 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38069 + 68] = mem[_38069 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38069 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _40566 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_40566] = 30
                                    mem[_40566 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _41751 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _41751 + 68] = mem[idx + _40566 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41751 + 68] = mem[_41751 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41751 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _49346 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_49346] = 30
                                    mem[_49346 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _51623 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _51623 + 68] = mem[idx + _49346 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_51623 + 68] = mem[_51623 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _51623 + -mem[64] + 100
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _37934 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_37934] = 30
                                mem[_37934 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                    _38503 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _38503 + 68] = mem[idx + _37934 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_38503 + 68] = mem[_38503 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _38503 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _41086 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_41086] = 30
                                mem[_41086 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _42649 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _42649 + 68] = mem[idx + _41086 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_42649 + 68] = mem[_42649 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _42649 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                _50525 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_50525] = 30
                                mem[_50525 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                    return 1
                                _52457 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _52457 + 68] = mem[idx + _50525 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_52457 + 68] = mem[_52457 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _52457 + -mem[64] + 100
                            require idx < stor207.length
                            mem[0] = stor207[idx]
                            mem[32] = 204
                            if stor204[stor207[idx]] <= s:
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                _32939 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32939] = 30
                                mem[_32939 + 32] = 'SafeMath: subtraction overflow'
                                if stor203[stor207[idx]] > t:
                                    _33434 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _33434 + 68] = mem[idx + _32939 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33434 + 68] = mem[_33434 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33434 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                _35234 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35234] = 30
                                mem[_35234 + 32] = 'SafeMath: subtraction overflow'
                                if stor204[stor207[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor204[stor207[idx]]
                                    t = t - stor203[stor207[idx]]
                                    continue 
                                _36041 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _36041 + 68] = mem[idx + _35234 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36041 + 68] = mem[_36041 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _36041 + -mem[64] + 100
                            _33127 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33127] = 26
                            mem[_33127 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _33127 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if not _tFeePercent * arg2 / 10000:
                                    _37937 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37937] = 30
                                    mem[_37937 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41096 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41096] = 30
                                    mem[_41096 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _42656 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _42656 + 68] = mem[idx + _41096 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42656 + 68] = mem[_42656 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42656 + -mem[64] + 100
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = stor203[arg1]
                                    _50530 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50530] = 30
                                    mem[_50530 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _52462 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _52462 + 68] = mem[idx + _50530 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52462 + 68] = mem[_52462 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52462 + -mem[64] + 100
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _38076 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38076] = 30
                                mem[_38076 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                    _38814 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _38814 + 68] = mem[idx + _38076 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_38814 + 68] = mem[_38814 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _38814 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _41760 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_41760] = 30
                                mem[_41760 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor203[address(msg.sender)]:
                                    _43674 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _43674 + 68] = mem[idx + _41760 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_43674 + 68] = mem[_43674 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _43674 + -mem[64] + 100
                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                _51630 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_51630] = 30
                                mem[_51630 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                    return 1
                                _53111 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _53111 + 68] = mem[idx + _51630 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_53111 + 68] = mem[_53111 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _53111 + -mem[64] + 100
                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not _tFeePercent * arg2 / 10000:
                                _38075 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38075] = 30
                                mem[_38075 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _38811 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _38811 + 68] = mem[idx + _38075 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_38811 + 68] = mem[_38811 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _38811 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _41759 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_41759] = 30
                                mem[_41759 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _43671 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _43671 + 68] = mem[idx + _41759 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_43671 + 68] = mem[_43671 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _43671 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                _51629 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_51629] = 30
                                mem[_51629 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                    return 1
                                _53108 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _53108 + 68] = mem[idx + _51629 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_53108 + 68] = mem[_53108 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _53108 + -mem[64] + 100
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _38506 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_38506] = 30
                            mem[_38506 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                _39323 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _39323 + 68] = mem[idx + _38506 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_39323 + 68] = mem[_39323 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _39323 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 203
                            _42655 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_42655] = 30
                            mem[_42655 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                _44587 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _44587 + 68] = mem[idx + _42655 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_44587 + 68] = mem[_44587 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _44587 + -mem[64] + 100
                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                            _52461 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_52461] = 30
                            mem[_52461 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                return 1
                            _53922 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _53922 + 68] = mem[idx + _52461 + 32]
                                idx = idx + 32
                                continue 
                            mem[_53922 + 68] = mem[_53922 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _53922 + -mem[64] + 100
                        _31759 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31759] = 26
                        mem[_31759 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero'
                        if t >= stor209 / totalSupply:
                            _33681 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33681] = 26
                            mem[_33681 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if not _tFeePercent * arg2 / 10000:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if t / s * _tFeePercent * arg2 / 10000 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                            else:
                                if t / s * arg2 / arg2 != t / s:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    if 0 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                        else:
                            _33682 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33682] = 26
                            mem[_33682 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if not _tFeePercent * arg2 / 10000:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                            else:
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    if 0 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += _tFeePercent * arg2 / 10000
                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                else:
                    mem[0] = arg1
                    mem[32] = 206
                    if not stor206[address(arg1)]:
                        if not arg2:
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _32644 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32644] = 26
                                    mem[_32644 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _32644 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _37702 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37702] = 30
                                        mem[_37702 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _39745 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39745] = 30
                                        mem[_39745 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _41122 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _41122 + 68] = mem[idx + _39745 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41122 + 68] = mem[_41122 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41122 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _48116 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48116] = 30
                                        mem[_48116 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _50575 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _50575 + 68] = mem[idx + _48116 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50575 + 68] = mem[_50575 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50575 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _37812 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37812] = 30
                                    mem[_37812 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _38093 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38093 + 68] = mem[idx + _37812 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38093 + 68] = mem[_38093 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38093 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _40594 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_40594] = 30
                                    mem[_40594 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _41799 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _41799 + 68] = mem[idx + _40594 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41799 + 68] = mem[_41799 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41799 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _49402 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_49402] = 30
                                    mem[_49402 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _51657 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _51657 + 68] = mem[idx + _49402 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_51657 + 68] = mem[_51657 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _51657 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _32948 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32948] = 30
                                    mem[_32948 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _33446 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _33446 + 68] = mem[idx + _32948 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33446 + 68] = mem[_33446 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33446 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _35255 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35255] = 30
                                    mem[_35255 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _36065 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _36065 + 68] = mem[idx + _35255 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36065 + 68] = mem[_36065 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _36065 + -mem[64] + 100
                                _33142 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33142] = 26
                                mem[_33142 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _33142 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    _37943 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37943] = 30
                                    mem[_37943 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41127 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41127] = 30
                                    mem[_41127 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _42704 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _42704 + 68] = mem[idx + _41127 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42704 + 68] = mem[_42704 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42704 + -mem[64] + 100
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = stor203[arg1]
                                    _50578 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50578] = 30
                                    mem[_50578 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _52486 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _52486 + 68] = mem[idx + _50578 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52486 + 68] = mem[_52486 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52486 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _38096 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38096] = 30
                                mem[_38096 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _38838 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _38838 + 68] = mem[idx + _38096 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_38838 + 68] = mem[_38838 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _38838 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _41802 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_41802] = 30
                                mem[_41802 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _43716 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _43716 + 68] = mem[idx + _41802 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_43716 + 68] = mem[_43716 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _43716 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                _51660 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_51660] = 30
                                mem[_51660 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _53141 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _53141 + 68] = mem[idx + _51660 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_53141 + 68] = mem[_53141 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _53141 + -mem[64] + 100
                            _31774 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31774] = 26
                            mem[_31774 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _33702 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33702] = 26
                                mem[_33702 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                            else:
                                _33703 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33703] = 26
                                mem[_33703 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                            if 0 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if _tFeePercent * arg2 / 10000 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _32639 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32639] = 26
                                    mem[_32639 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _32639 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            _37701 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37701] = 30
                                            mem[_37701 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _39734 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39734] = 30
                                            mem[_39734 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _41110 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _41110 + 68] = mem[idx + _39734 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41110 + 68] = mem[_41110 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41110 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _48096 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48096] = 30
                                            mem[_48096 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _50562 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _50562 + 68] = mem[idx + _48096 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50562 + 68] = mem[_50562 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50562 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _37809 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37809] = 30
                                        mem[_37809 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            _38088 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38088 + 68] = mem[idx + _37809 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38088 + 68] = mem[_38088 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38088 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _40587 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40587] = 30
                                        mem[_40587 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _41786 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _41786 + 68] = mem[idx + _40587 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41786 + 68] = mem[_41786 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41786 + -mem[64] + 100
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _49386 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_49386] = 30
                                        mem[_49386 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _51650 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _51650 + 68] = mem[idx + _49386 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_51650 + 68] = mem[_51650 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _51650 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        _37808 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37808] = 30
                                        mem[_37808 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _38085 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38085 + 68] = mem[idx + _37808 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38085 + 68] = mem[_38085 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38085 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _40586 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40586] = 30
                                        mem[_40586 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _41783 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _41783 + 68] = mem[idx + _40586 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41783 + 68] = mem[_41783 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41783 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _49385 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_49385] = 30
                                        mem[_49385 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _51647 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _51647 + 68] = mem[idx + _49385 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_51647 + 68] = mem[_51647 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _51647 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _37939 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37939] = 30
                                    mem[_37939 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        _38515 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38515 + 68] = mem[idx + _37939 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38515 + 68] = mem[_38515 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38515 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41109 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41109] = 30
                                    mem[_41109 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _42685 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _42685 + 68] = mem[idx + _41109 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42685 + 68] = mem[_42685 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42685 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _50561 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50561] = 30
                                    mem[_50561 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _52475 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _52475 + 68] = mem[idx + _50561 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52475 + 68] = mem[_52475 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52475 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _32945 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32945] = 30
                                    mem[_32945 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _33442 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _33442 + 68] = mem[idx + _32945 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33442 + 68] = mem[_33442 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33442 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _35248 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35248] = 30
                                    mem[_35248 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _36057 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _36057 + 68] = mem[idx + _35248 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36057 + 68] = mem[_36057 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _36057 + -mem[64] + 100
                                _33137 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33137] = 26
                                mem[_33137 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _33137 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        _37942 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37942] = 30
                                        mem[_37942 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41119 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41119] = 30
                                        mem[_41119 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _42692 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42692 + 68] = mem[idx + _41119 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42692 + 68] = mem[_42692 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42692 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _50566 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50566] = 30
                                        mem[_50566 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _52480 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52480 + 68] = mem[idx + _50566 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52480 + 68] = mem[_52480 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52480 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38092 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38092] = 30
                                    mem[_38092 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                        _38832 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38832 + 68] = mem[idx + _38092 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38832 + 68] = mem[_38832 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38832 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41792 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41792] = 30
                                    mem[_41792 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _43706 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43706 + 68] = mem[idx + _41792 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43706 + 68] = mem[_43706 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43706 + -mem[64] + 100
                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _51654 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_51654] = 30
                                    mem[_51654 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _53133 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53133 + 68] = mem[idx + _51654 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53133 + 68] = mem[_53133 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53133 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    _38091 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38091] = 30
                                    mem[_38091 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _38829 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38829 + 68] = mem[idx + _38091 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38829 + 68] = mem[_38829 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38829 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41791 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41791] = 30
                                    mem[_41791 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _43703 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43703 + 68] = mem[idx + _41791 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43703 + 68] = mem[_43703 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43703 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _51653 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_51653] = 30
                                    mem[_51653 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _53130 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53130 + 68] = mem[idx + _51653 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53130 + 68] = mem[_53130 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53130 + -mem[64] + 100
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _38518 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38518] = 30
                                mem[_38518 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                    _39337 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _39337 + 68] = mem[idx + _38518 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39337 + 68] = mem[_39337 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39337 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _42691 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_42691] = 30
                                mem[_42691 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _44625 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _44625 + 68] = mem[idx + _42691 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_44625 + 68] = mem[_44625 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _44625 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                _52479 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_52479] = 30
                                mem[_52479 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                    return 1
                                _53954 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _53954 + 68] = mem[idx + _52479 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_53954 + 68] = mem[_53954 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _53954 + -mem[64] + 100
                            _31769 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31769] = 26
                            mem[_31769 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _33695 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33695] = 26
                                mem[_33695 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if t / s * _tFeePercent * arg2 / 10000 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                            else:
                                _33696 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33696] = 26
                                mem[_33696 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += _tFeePercent * arg2 / 10000
                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                    else:
                        if not arg2:
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _32654 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32654] = 26
                                    mem[_32654 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _32654 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _37704 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37704] = 30
                                        mem[_37704 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _39765 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39765] = 30
                                        mem[_39765 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _41138 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _41138 + 68] = mem[idx + _39765 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41138 + 68] = mem[_41138 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41138 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _43735 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43735] = 30
                                        mem[_43735 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _45761 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45761 + 68] = mem[idx + _43735 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45761 + 68] = mem[_45761 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45761 + -mem[64] + 100
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        _55941 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_55941] = 30
                                        mem[_55941 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _57549 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _57549 + 68] = mem[idx + _55941 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_57549 + 68] = mem[_57549 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _57549 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _37814 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37814] = 30
                                    mem[_37814 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _38101 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38101 + 68] = mem[idx + _37814 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38101 + 68] = mem[_38101 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38101 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 204
                                    _40602 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_40602] = 30
                                    mem[_40602 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        _41819 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _41819 + 68] = mem[idx + _40602 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41819 + 68] = mem[_41819 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41819 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    stor204[address(msg.sender)] -= arg2
                                    mem[32] = 203
                                    _44664 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_44664] = 30
                                    mem[_44664 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _47020 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _47020 + 68] = mem[idx + _44664 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_47020 + 68] = mem[_47020 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _47020 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] += stor209 / totalSupply * arg2
                                    _56737 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_56737] = 30
                                    mem[_56737 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _58481 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _58481 + 68] = mem[idx + _56737 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_58481 + 68] = mem[_58481 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _58481 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _32954 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32954] = 30
                                    mem[_32954 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _33454 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _33454 + 68] = mem[idx + _32954 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33454 + 68] = mem[_33454 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33454 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _35269 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35269] = 30
                                    mem[_35269 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _36081 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _36081 + 68] = mem[idx + _35269 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36081 + 68] = mem[_36081 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _36081 + -mem[64] + 100
                                _33152 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33152] = 26
                                mem[_33152 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _33152 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    _37945 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37945] = 30
                                    mem[_37945 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 204
                                    _41143 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41143] = 30
                                    mem[_41143 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        _42728 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _42728 + 68] = mem[idx + _41143 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42728 + 68] = mem[_42728 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42728 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    stor204[address(msg.sender)] -= arg2
                                    mem[32] = 203
                                    _45767 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_45767] = 30
                                    mem[_45767 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _48156 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _48156 + 68] = mem[idx + _45767 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_48156 + 68] = mem[_48156 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _48156 + -mem[64] + 100
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    _57552 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_57552] = 30
                                    mem[_57552 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _59214 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _59214 + 68] = mem[idx + _57552 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_59214 + 68] = mem[_59214 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _59214 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _38104 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38104] = 30
                                mem[_38104 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _38850 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _38850 + 68] = mem[idx + _38104 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_38850 + 68] = mem[_38850 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _38850 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 204
                                _41822 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_41822] = 30
                                mem[_41822 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 > stor204[address(msg.sender)]:
                                    _43738 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _43738 + 68] = mem[idx + _41822 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_43738 + 68] = mem[_43738 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _43738 + -mem[64] + 100
                                mem[0] = msg.sender
                                stor204[address(msg.sender)] -= arg2
                                mem[32] = 203
                                _47023 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_47023] = 30
                                mem[_47023 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _49433 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _49433 + 68] = mem[idx + _47023 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_49433 + 68] = mem[_49433 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _49433 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] += arg2
                                if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] += stor209 / totalSupply * arg2
                                _58484 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_58484] = 30
                                mem[_58484 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _59792 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _59792 + 68] = mem[idx + _58484 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_59792 + 68] = mem[_59792 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _59792 + -mem[64] + 100
                            _31784 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31784] = 26
                            mem[_31784 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _33716 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33716] = 26
                                mem[_33716 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if arg2 > stor204[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor204[address(msg.sender)] -= arg2
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor204[address(msg.sender)] -= arg2
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] += t / s * arg2
                            else:
                                _33717 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33717] = 26
                                mem[_33717 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if arg2 > stor204[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor204[address(msg.sender)] -= arg2
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor204[address(msg.sender)] -= arg2
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] += stor209 / totalSupply * arg2
                        else:
                            if 0 / arg2:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _32649 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32649] = 26
                                    mem[_32649 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _32649 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _37703 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37703] = 30
                                        mem[_37703 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _39755 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39755] = 30
                                        mem[_39755 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _41130 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _41130 + 68] = mem[idx + _39755 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41130 + 68] = mem[_41130 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41130 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _43724 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43724] = 30
                                        mem[_43724 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _45745 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45745 + 68] = mem[idx + _43724 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45745 + 68] = mem[_45745 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45745 + -mem[64] + 100
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        _55933 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_55933] = 30
                                        mem[_55933 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _57539 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _57539 + 68] = mem[idx + _55933 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_57539 + 68] = mem[_57539 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _57539 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _37813 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37813] = 30
                                    mem[_37813 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _38097 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38097 + 68] = mem[idx + _37813 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38097 + 68] = mem[_38097 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38097 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 204
                                    _40598 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_40598] = 30
                                    mem[_40598 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        _41809 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _41809 + 68] = mem[idx + _40598 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41809 + 68] = mem[_41809 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41809 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    stor204[address(msg.sender)] -= arg2
                                    mem[32] = 203
                                    _44651 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_44651] = 30
                                    mem[_44651 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _47007 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _47007 + 68] = mem[idx + _44651 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_47007 + 68] = mem[_47007 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _47007 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] += stor209 / totalSupply * arg2
                                    _56731 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_56731] = 30
                                    mem[_56731 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _58475 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _58475 + 68] = mem[idx + _56731 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_58475 + 68] = mem[_58475 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _58475 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _32951 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32951] = 30
                                    mem[_32951 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _33450 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _33450 + 68] = mem[idx + _32951 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33450 + 68] = mem[_33450 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33450 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _35262 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35262] = 30
                                    mem[_35262 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _36073 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _36073 + 68] = mem[idx + _35262 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36073 + 68] = mem[_36073 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _36073 + -mem[64] + 100
                                _33147 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33147] = 26
                                mem[_33147 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _33147 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    _37944 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37944] = 30
                                    mem[_37944 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 204
                                    _41135 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41135] = 30
                                    mem[_41135 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        _42716 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _42716 + 68] = mem[idx + _41135 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42716 + 68] = mem[_42716 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42716 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    stor204[address(msg.sender)] -= arg2
                                    mem[32] = 203
                                    _45751 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_45751] = 30
                                    mem[_45751 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _48137 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _48137 + 68] = mem[idx + _45751 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_48137 + 68] = mem[_48137 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _48137 + -mem[64] + 100
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    _57542 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_57542] = 30
                                    mem[_57542 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _59208 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _59208 + 68] = mem[idx + _57542 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_59208 + 68] = mem[_59208 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _59208 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _38100 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38100] = 30
                                mem[_38100 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _38844 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _38844 + 68] = mem[idx + _38100 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_38844 + 68] = mem[_38844 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _38844 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 204
                                _41812 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_41812] = 30
                                mem[_41812 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 > stor204[address(msg.sender)]:
                                    _43727 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _43727 + 68] = mem[idx + _41812 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_43727 + 68] = mem[_43727 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _43727 + -mem[64] + 100
                                mem[0] = msg.sender
                                stor204[address(msg.sender)] -= arg2
                                mem[32] = 203
                                _47010 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_47010] = 30
                                mem[_47010 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _49417 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _49417 + 68] = mem[idx + _47010 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_49417 + 68] = mem[_49417 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _49417 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] += arg2
                                if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] += stor209 / totalSupply * arg2
                                _58478 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_58478] = 30
                                mem[_58478 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _59784 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _59784 + 68] = mem[idx + _58478 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_59784 + 68] = mem[_59784 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _59784 + -mem[64] + 100
                            _31779 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31779] = 26
                            mem[_31779 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _33709 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33709] = 26
                                mem[_33709 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if arg2 > stor204[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor204[address(msg.sender)] -= arg2
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor204[address(msg.sender)] -= arg2
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] += t / s * arg2
                            else:
                                _33710 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33710] = 26
                                mem[_33710 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if arg2 > stor204[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor204[address(msg.sender)] -= arg2
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor204[address(msg.sender)] -= arg2
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] += stor209 / totalSupply * arg2
                        if 0 > stor209:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
            else:
                mem[0] = arg1
                mem[32] = 206
                if not stor206[address(arg1)]:
                    if not arg2:
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = totalSupply
                        t = stor209
                        while idx < stor207.length:
                            mem[0] = stor207[idx]
                            mem[32] = 203
                            if stor203[stor207[idx]] > t:
                                _32694 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32694] = 26
                                mem[_32694 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _32694 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    _37718 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37718] = 30
                                    mem[_37718 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _39878 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_39878] = 30
                                    mem[_39878 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _41223 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _41223 + 68] = mem[idx + _39878 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41223 + 68] = mem[_41223 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41223 + -mem[64] + 100
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = stor203[arg1]
                                    _48318 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_48318] = 30
                                    mem[_48318 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _50747 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _50747 + 68] = mem[idx + _48318 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_50747 + 68] = mem[_50747 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _50747 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _37831 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_37831] = 30
                                mem[_37831 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _38157 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _38157 + 68] = mem[idx + _37831 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_38157 + 68] = mem[_38157 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _38157 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _40670 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_40670] = 30
                                mem[_40670 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _41935 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _41935 + 68] = mem[idx + _40670 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_41935 + 68] = mem[_41935 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _41935 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                _49583 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_49583] = 30
                                mem[_49583 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _51793 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _51793 + 68] = mem[idx + _49583 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_51793 + 68] = mem[_51793 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _51793 + -mem[64] + 100
                            require idx < stor207.length
                            mem[0] = stor207[idx]
                            mem[32] = 204
                            if stor204[stor207[idx]] <= s:
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                _32978 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32978] = 30
                                mem[_32978 + 32] = 'SafeMath: subtraction overflow'
                                if stor203[stor207[idx]] > t:
                                    _33486 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _33486 + 68] = mem[idx + _32978 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33486 + 68] = mem[_33486 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33486 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                _35325 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35325] = 30
                                mem[_35325 + 32] = 'SafeMath: subtraction overflow'
                                if stor204[stor207[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor204[stor207[idx]]
                                    t = t - stor203[stor207[idx]]
                                    continue 
                                _36145 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _36145 + 68] = mem[idx + _35325 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36145 + 68] = mem[_36145 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _36145 + -mem[64] + 100
                            _33192 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33192] = 26
                            mem[_33192 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _33192 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                _37962 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_37962] = 30
                                mem[_37962 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 203
                                _41228 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_41228] = 30
                                mem[_41228 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor203[address(msg.sender)]:
                                    _42860 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _42860 + 68] = mem[idx + _41228 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_42860 + 68] = mem[_42860 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _42860 + -mem[64] + 100
                                if stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = stor203[arg1]
                                _50750 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_50750] = 30
                                mem[_50750 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _52592 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _52592 + 68] = mem[idx + _50750 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_52592 + 68] = mem[_52592 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _52592 + -mem[64] + 100
                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _38160 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_38160] = 30
                            mem[_38160 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor209 / totalSupply * arg2:
                                _38916 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _38916 + 68] = mem[idx + _38160 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_38916 + 68] = mem[_38916 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _38916 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 203
                            _41938 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_41938] = 30
                            mem[_41938 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                _43856 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _43856 + 68] = mem[idx + _41938 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_43856 + 68] = mem[_43856 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _43856 + -mem[64] + 100
                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                            _51796 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_51796] = 30
                            mem[_51796 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor209:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _53275 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _53275 + 68] = mem[idx + _51796 + 32]
                                idx = idx + 32
                                continue 
                            mem[_53275 + 68] = mem[_53275 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _53275 + -mem[64] + 100
                        _31824 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31824] = 26
                        mem[_31824 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero'
                        if t >= stor209 / totalSupply:
                            _33772 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33772] = 26
                            mem[_33772 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if 0 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] = stor203[arg1]
                            else:
                                if t / s * arg2 / arg2 != t / s:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > t / s * arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if t / s * arg2 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                        else:
                            _33773 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33773] = 26
                            mem[_33773 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if 0 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] = stor203[arg1]
                            else:
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > stor209 / totalSupply * arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                        if 0 > stor209:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if _tFeePercent * arg2 / arg2 != _tFeePercent:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if _tFeePercent * arg2 / 10000 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = totalSupply
                        t = stor209
                        while idx < stor207.length:
                            mem[0] = stor207[idx]
                            mem[32] = 203
                            if stor203[stor207[idx]] > t:
                                _32689 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32689] = 26
                                mem[_32689 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _32689 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        _37717 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37717] = 30
                                        mem[_37717 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _39867 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39867] = 30
                                        mem[_39867 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _41211 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _41211 + 68] = mem[idx + _39867 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41211 + 68] = mem[_41211 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41211 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _48298 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48298] = 30
                                        mem[_48298 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _50734 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _50734 + 68] = mem[idx + _48298 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50734 + 68] = mem[_50734 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50734 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _37828 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37828] = 30
                                    mem[_37828 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                        _38152 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38152 + 68] = mem[idx + _37828 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38152 + 68] = mem[_38152 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38152 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _40663 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_40663] = 30
                                    mem[_40663 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _41922 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _41922 + 68] = mem[idx + _40663 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41922 + 68] = mem[_41922 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41922 + -mem[64] + 100
                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _49567 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_49567] = 30
                                    mem[_49567 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _51786 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _51786 + 68] = mem[idx + _49567 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_51786 + 68] = mem[_51786 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _51786 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    _37827 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37827] = 30
                                    mem[_37827 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _38149 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38149 + 68] = mem[idx + _37827 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38149 + 68] = mem[_38149 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38149 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _40662 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_40662] = 30
                                    mem[_40662 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _41919 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _41919 + 68] = mem[idx + _40662 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41919 + 68] = mem[_41919 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41919 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _49566 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_49566] = 30
                                    mem[_49566 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _51783 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _51783 + 68] = mem[idx + _49566 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_51783 + 68] = mem[_51783 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _51783 + -mem[64] + 100
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _37958 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_37958] = 30
                                mem[_37958 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                    _38559 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _38559 + 68] = mem[idx + _37958 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_38559 + 68] = mem[_38559 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _38559 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _41210 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_41210] = 30
                                mem[_41210 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _42841 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _42841 + 68] = mem[idx + _41210 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_42841 + 68] = mem[_42841 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _42841 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                _50733 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_50733] = 30
                                mem[_50733 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                    return 1
                                _52581 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _52581 + 68] = mem[idx + _50733 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_52581 + 68] = mem[_52581 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _52581 + -mem[64] + 100
                            require idx < stor207.length
                            mem[0] = stor207[idx]
                            mem[32] = 204
                            if stor204[stor207[idx]] <= s:
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                _32975 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32975] = 30
                                mem[_32975 + 32] = 'SafeMath: subtraction overflow'
                                if stor203[stor207[idx]] > t:
                                    _33482 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _33482 + 68] = mem[idx + _32975 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33482 + 68] = mem[_33482 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33482 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                _35318 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35318] = 30
                                mem[_35318 + 32] = 'SafeMath: subtraction overflow'
                                if stor204[stor207[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor204[stor207[idx]]
                                    t = t - stor203[stor207[idx]]
                                    continue 
                                _36137 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _36137 + 68] = mem[idx + _35318 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36137 + 68] = mem[_36137 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _36137 + -mem[64] + 100
                            _33187 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33187] = 26
                            mem[_33187 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _33187 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if not _tFeePercent * arg2 / 10000:
                                    _37961 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37961] = 30
                                    mem[_37961 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41220 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41220] = 30
                                    mem[_41220 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _42848 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _42848 + 68] = mem[idx + _41220 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42848 + 68] = mem[_42848 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42848 + -mem[64] + 100
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = stor203[arg1]
                                    _50738 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50738] = 30
                                    mem[_50738 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _52586 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _52586 + 68] = mem[idx + _50738 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52586 + 68] = mem[_52586 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52586 + -mem[64] + 100
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _38156 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38156] = 30
                                mem[_38156 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                    _38910 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _38910 + 68] = mem[idx + _38156 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_38910 + 68] = mem[_38910 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _38910 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _41928 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_41928] = 30
                                mem[_41928 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor203[address(msg.sender)]:
                                    _43846 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _43846 + 68] = mem[idx + _41928 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_43846 + 68] = mem[_43846 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _43846 + -mem[64] + 100
                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                _51790 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_51790] = 30
                                mem[_51790 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                    return 1
                                _53267 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _53267 + 68] = mem[idx + _51790 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_53267 + 68] = mem[_53267 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _53267 + -mem[64] + 100
                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not _tFeePercent * arg2 / 10000:
                                _38155 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38155] = 30
                                mem[_38155 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _38907 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _38907 + 68] = mem[idx + _38155 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_38907 + 68] = mem[_38907 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _38907 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _41927 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_41927] = 30
                                mem[_41927 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _43843 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _43843 + 68] = mem[idx + _41927 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_43843 + 68] = mem[_43843 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _43843 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                _51789 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_51789] = 30
                                mem[_51789 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                    return 1
                                _53264 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _53264 + 68] = mem[idx + _51789 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_53264 + 68] = mem[_53264 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _53264 + -mem[64] + 100
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _38562 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_38562] = 30
                            mem[_38562 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                _39391 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _39391 + 68] = mem[idx + _38562 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_39391 + 68] = mem[_39391 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _39391 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 203
                            _42847 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_42847] = 30
                            mem[_42847 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                _44791 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _44791 + 68] = mem[idx + _42847 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_44791 + 68] = mem[_44791 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _44791 + -mem[64] + 100
                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                            _52585 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_52585] = 30
                            mem[_52585 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                return 1
                            _54110 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _54110 + 68] = mem[idx + _52585 + 32]
                                idx = idx + 32
                                continue 
                            mem[_54110 + 68] = mem[_54110 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _54110 + -mem[64] + 100
                        _31819 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31819] = 26
                        mem[_31819 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero'
                        if t >= stor209 / totalSupply:
                            _33765 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33765] = 26
                            mem[_33765 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if not _tFeePercent * arg2 / 10000:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if t / s * _tFeePercent * arg2 / 10000 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                            else:
                                if t / s * arg2 / arg2 != t / s:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    if 0 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                        else:
                            _33766 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33766] = 26
                            mem[_33766 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if not _tFeePercent * arg2 / 10000:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                            else:
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    if 0 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += _tFeePercent * arg2 / 10000
                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                else:
                    mem[0] = msg.sender
                    mem[32] = 206
                    if not stor206[address(msg.sender)]:
                        if not arg2:
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _32664 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32664] = 26
                                    mem[_32664 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _32664 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _37708 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37708] = 30
                                        mem[_37708 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _39796 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39796] = 30
                                        mem[_39796 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _41161 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _41161 + 68] = mem[idx + _39796 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41161 + 68] = mem[_41161 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41161 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _48196 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48196] = 30
                                        mem[_48196 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _50643 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _50643 + 68] = mem[idx + _48196 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50643 + 68] = mem[_50643 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50643 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _37819 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37819] = 30
                                    mem[_37819 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _38117 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38117 + 68] = mem[idx + _37819 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38117 + 68] = mem[_38117 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38117 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _40622 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_40622] = 30
                                    mem[_40622 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _41851 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _41851 + 68] = mem[idx + _40622 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41851 + 68] = mem[_41851 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41851 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _49473 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_49473] = 30
                                    mem[_49473 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _51713 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _51713 + 68] = mem[idx + _49473 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_51713 + 68] = mem[_51713 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _51713 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _32960 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32960] = 30
                                    mem[_32960 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _33462 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _33462 + 68] = mem[idx + _32960 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33462 + 68] = mem[_33462 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33462 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _35283 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35283] = 30
                                    mem[_35283 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _36097 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _36097 + 68] = mem[idx + _35283 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36097 + 68] = mem[_36097 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _36097 + -mem[64] + 100
                                _33162 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33162] = 26
                                mem[_33162 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _33162 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    _37950 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37950] = 30
                                    mem[_37950 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41166 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41166] = 30
                                    mem[_41166 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _42764 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _42764 + 68] = mem[idx + _41166 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42764 + 68] = mem[_42764 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42764 + -mem[64] + 100
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = stor203[arg1]
                                    _50646 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50646] = 30
                                    mem[_50646 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _52530 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _52530 + 68] = mem[idx + _50646 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52530 + 68] = mem[_52530 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52530 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _38120 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38120] = 30
                                mem[_38120 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _38868 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _38868 + 68] = mem[idx + _38120 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_38868 + 68] = mem[_38868 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _38868 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _41854 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_41854] = 30
                                mem[_41854 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _43770 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _43770 + 68] = mem[idx + _41854 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_43770 + 68] = mem[_43770 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _43770 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                _51716 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_51716] = 30
                                mem[_51716 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _53197 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _53197 + 68] = mem[idx + _51716 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_53197 + 68] = mem[_53197 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _53197 + -mem[64] + 100
                            _31794 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31794] = 26
                            mem[_31794 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _33730 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33730] = 26
                                mem[_33730 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                            else:
                                _33731 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33731] = 26
                                mem[_33731 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                            if 0 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if _tFeePercent * arg2 / 10000 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _32659 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32659] = 26
                                    mem[_32659 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _32659 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            _37707 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37707] = 30
                                            mem[_37707 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _39785 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39785] = 30
                                            mem[_39785 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _41149 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _41149 + 68] = mem[idx + _39785 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41149 + 68] = mem[_41149 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41149 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _48176 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48176] = 30
                                            mem[_48176 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _50630 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _50630 + 68] = mem[idx + _48176 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50630 + 68] = mem[_50630 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50630 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _37816 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37816] = 30
                                        mem[_37816 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            _38112 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38112 + 68] = mem[idx + _37816 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38112 + 68] = mem[_38112 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38112 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _40615 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40615] = 30
                                        mem[_40615 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _41838 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _41838 + 68] = mem[idx + _40615 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41838 + 68] = mem[_41838 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41838 + -mem[64] + 100
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _49457 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_49457] = 30
                                        mem[_49457 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _51706 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _51706 + 68] = mem[idx + _49457 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_51706 + 68] = mem[_51706 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _51706 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        _37815 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37815] = 30
                                        mem[_37815 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _38109 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38109 + 68] = mem[idx + _37815 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38109 + 68] = mem[_38109 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38109 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _40614 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40614] = 30
                                        mem[_40614 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _41835 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _41835 + 68] = mem[idx + _40614 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41835 + 68] = mem[_41835 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41835 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _49456 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_49456] = 30
                                        mem[_49456 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _51703 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _51703 + 68] = mem[idx + _49456 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_51703 + 68] = mem[_51703 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _51703 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _37946 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37946] = 30
                                    mem[_37946 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        _38531 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38531 + 68] = mem[idx + _37946 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38531 + 68] = mem[_38531 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38531 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41148 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41148] = 30
                                    mem[_41148 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _42745 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _42745 + 68] = mem[idx + _41148 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42745 + 68] = mem[_42745 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42745 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _50629 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50629] = 30
                                    mem[_50629 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _52519 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _52519 + 68] = mem[idx + _50629 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52519 + 68] = mem[_52519 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52519 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _32957 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32957] = 30
                                    mem[_32957 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _33458 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _33458 + 68] = mem[idx + _32957 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33458 + 68] = mem[_33458 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33458 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _35276 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35276] = 30
                                    mem[_35276 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _36089 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _36089 + 68] = mem[idx + _35276 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36089 + 68] = mem[_36089 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _36089 + -mem[64] + 100
                                _33157 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33157] = 26
                                mem[_33157 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _33157 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        _37949 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37949] = 30
                                        mem[_37949 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41158 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41158] = 30
                                        mem[_41158 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _42752 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42752 + 68] = mem[idx + _41158 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42752 + 68] = mem[_42752 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42752 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _50634 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50634] = 30
                                        mem[_50634 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _52524 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52524 + 68] = mem[idx + _50634 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52524 + 68] = mem[_52524 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52524 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38116 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38116] = 30
                                    mem[_38116 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                        _38862 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38862 + 68] = mem[idx + _38116 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38862 + 68] = mem[_38862 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38862 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41844 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41844] = 30
                                    mem[_41844 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _43760 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43760 + 68] = mem[idx + _41844 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43760 + 68] = mem[_43760 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43760 + -mem[64] + 100
                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _51710 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_51710] = 30
                                    mem[_51710 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _53189 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53189 + 68] = mem[idx + _51710 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53189 + 68] = mem[_53189 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53189 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    _38115 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38115] = 30
                                    mem[_38115 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _38859 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38859 + 68] = mem[idx + _38115 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38859 + 68] = mem[_38859 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38859 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41843 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41843] = 30
                                    mem[_41843 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _43757 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43757 + 68] = mem[idx + _41843 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43757 + 68] = mem[_43757 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43757 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _51709 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_51709] = 30
                                    mem[_51709 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _53186 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53186 + 68] = mem[idx + _51709 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53186 + 68] = mem[_53186 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53186 + -mem[64] + 100
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _38534 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38534] = 30
                                mem[_38534 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                    _39357 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _39357 + 68] = mem[idx + _38534 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39357 + 68] = mem[_39357 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39357 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _42751 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_42751] = 30
                                mem[_42751 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _44689 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _44689 + 68] = mem[idx + _42751 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_44689 + 68] = mem[_44689 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _44689 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                _52523 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_52523] = 30
                                mem[_52523 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                    return 1
                                _54016 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _54016 + 68] = mem[idx + _52523 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_54016 + 68] = mem[_54016 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _54016 + -mem[64] + 100
                            _31789 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31789] = 26
                            mem[_31789 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _33723 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33723] = 26
                                mem[_33723 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if t / s * _tFeePercent * arg2 / 10000 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                            else:
                                _33724 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33724] = 26
                                mem[_33724 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += _tFeePercent * arg2 / 10000
                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                    else:
                        mem[0] = arg1
                        mem[32] = 206
                        if not stor206[address(arg1)]:
                            if not arg2:
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _32674 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32674] = 26
                                        mem[_32674 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _32674 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _37712 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37712] = 30
                                            mem[_37712 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _39827 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39827] = 30
                                            mem[_39827 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _41184 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _41184 + 68] = mem[idx + _39827 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41184 + 68] = mem[_41184 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41184 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _48238 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48238] = 30
                                            mem[_48238 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _50679 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _50679 + 68] = mem[idx + _48238 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50679 + 68] = mem[_50679 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50679 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _37824 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37824] = 30
                                        mem[_37824 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _38133 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38133 + 68] = mem[idx + _37824 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38133 + 68] = mem[_38133 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38133 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _40642 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40642] = 30
                                        mem[_40642 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _41883 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _41883 + 68] = mem[idx + _40642 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41883 + 68] = mem[_41883 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41883 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _49512 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_49512] = 30
                                        mem[_49512 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _51737 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _51737 + 68] = mem[idx + _49512 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_51737 + 68] = mem[_51737 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _51737 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _32966 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32966] = 30
                                        mem[_32966 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _33470 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _33470 + 68] = mem[idx + _32966 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33470 + 68] = mem[_33470 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33470 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _35297 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35297] = 30
                                        mem[_35297 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _36113 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _36113 + 68] = mem[idx + _35297 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36113 + 68] = mem[_36113 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36113 + -mem[64] + 100
                                    _33172 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33172] = 26
                                    mem[_33172 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _33172 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _37955 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37955] = 30
                                        mem[_37955 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41189 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41189] = 30
                                        mem[_41189 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _42800 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42800 + 68] = mem[idx + _41189 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42800 + 68] = mem[_42800 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42800 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _50682 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50682] = 30
                                        mem[_50682 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _52548 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52548 + 68] = mem[idx + _50682 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52548 + 68] = mem[_52548 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52548 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38136 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38136] = 30
                                    mem[_38136 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _38886 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38886 + 68] = mem[idx + _38136 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38886 + 68] = mem[_38886 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38886 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41886 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41886] = 30
                                    mem[_41886 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _43802 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43802 + 68] = mem[idx + _41886 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43802 + 68] = mem[_43802 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43802 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _51740 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_51740] = 30
                                    mem[_51740 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _53219 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53219 + 68] = mem[idx + _51740 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53219 + 68] = mem[_53219 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53219 + -mem[64] + 100
                                _31804 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31804] = 26
                                mem[_31804 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _33744 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33744] = 26
                                    mem[_33744 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                else:
                                    _33745 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33745] = 26
                                    mem[_33745 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if _tFeePercent * arg2 / 10000 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _32669 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32669] = 26
                                        mem[_32669 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _32669 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                _37711 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37711] = 30
                                                mem[_37711 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _39816 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39816] = 30
                                                mem[_39816 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _41172 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _41172 + 68] = mem[idx + _39816 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_41172 + 68] = mem[_41172 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _41172 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _48218 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_48218] = 30
                                                mem[_48218 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                    return 1
                                                _50666 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _50666 + 68] = mem[idx + _48218 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_50666 + 68] = mem[_50666 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _50666 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _37821 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37821] = 30
                                            mem[_37821 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                _38128 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38128 + 68] = mem[idx + _37821 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38128 + 68] = mem[_38128 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38128 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _40635 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40635] = 30
                                            mem[_40635 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _41870 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _41870 + 68] = mem[idx + _40635 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41870 + 68] = mem[_41870 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41870 + -mem[64] + 100
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _49496 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_49496] = 30
                                            mem[_49496 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _51730 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _51730 + 68] = mem[idx + _49496 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_51730 + 68] = mem[_51730 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _51730 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            _37820 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37820] = 30
                                            mem[_37820 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _38125 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38125 + 68] = mem[idx + _37820 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38125 + 68] = mem[_38125 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38125 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _40634 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40634] = 30
                                            mem[_40634 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _41867 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _41867 + 68] = mem[idx + _40634 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41867 + 68] = mem[_41867 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41867 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _49495 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_49495] = 30
                                            mem[_49495 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _51727 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _51727 + 68] = mem[idx + _49495 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_51727 + 68] = mem[_51727 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _51727 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _37951 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37951] = 30
                                        mem[_37951 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            _38543 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38543 + 68] = mem[idx + _37951 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38543 + 68] = mem[_38543 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38543 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41171 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41171] = 30
                                        mem[_41171 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _42781 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42781 + 68] = mem[idx + _41171 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42781 + 68] = mem[_42781 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42781 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _50665 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50665] = 30
                                        mem[_50665 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _52537 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52537 + 68] = mem[idx + _50665 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52537 + 68] = mem[_52537 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52537 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _32963 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32963] = 30
                                        mem[_32963 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _33466 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _33466 + 68] = mem[idx + _32963 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33466 + 68] = mem[_33466 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33466 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _35290 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35290] = 30
                                        mem[_35290 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _36105 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _36105 + 68] = mem[idx + _35290 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36105 + 68] = mem[_36105 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36105 + -mem[64] + 100
                                    _33167 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33167] = 26
                                    mem[_33167 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _33167 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            _37954 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37954] = 30
                                            mem[_37954 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41181 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41181] = 30
                                            mem[_41181 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _42788 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42788 + 68] = mem[idx + _41181 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42788 + 68] = mem[_42788 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42788 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _50670 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50670] = 30
                                            mem[_50670 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _52542 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52542 + 68] = mem[idx + _50670 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52542 + 68] = mem[_52542 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52542 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38132 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38132] = 30
                                        mem[_38132 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            _38880 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38880 + 68] = mem[idx + _38132 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38880 + 68] = mem[_38880 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38880 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41876 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41876] = 30
                                        mem[_41876 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _43792 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43792 + 68] = mem[idx + _41876 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43792 + 68] = mem[_43792 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43792 + -mem[64] + 100
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _51734 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51734] = 30
                                        mem[_51734 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _53211 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53211 + 68] = mem[idx + _51734 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53211 + 68] = mem[_53211 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53211 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        _38131 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38131] = 30
                                        mem[_38131 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _38877 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38877 + 68] = mem[idx + _38131 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38877 + 68] = mem[_38877 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38877 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41875 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41875] = 30
                                        mem[_41875 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _43789 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43789 + 68] = mem[idx + _41875 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43789 + 68] = mem[_43789 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43789 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _51733 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51733] = 30
                                        mem[_51733 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _53208 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53208 + 68] = mem[idx + _51733 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53208 + 68] = mem[_53208 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53208 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38546 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38546] = 30
                                    mem[_38546 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        _39371 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39371 + 68] = mem[idx + _38546 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39371 + 68] = mem[_39371 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39371 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42787 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42787] = 30
                                    mem[_42787 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _44727 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44727 + 68] = mem[idx + _42787 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44727 + 68] = mem[_44727 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44727 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _52541 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52541] = 30
                                    mem[_52541 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _54048 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54048 + 68] = mem[idx + _52541 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54048 + 68] = mem[_54048 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54048 + -mem[64] + 100
                                _31799 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31799] = 26
                                mem[_31799 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _33737 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33737] = 26
                                    mem[_33737 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                else:
                                    _33738 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33738] = 26
                                    mem[_33738 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                        else:
                            if not arg2:
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _32684 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32684] = 26
                                        mem[_32684 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _32684 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _37714 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37714] = 30
                                            mem[_37714 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _39847 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39847] = 30
                                            mem[_39847 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _41200 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _41200 + 68] = mem[idx + _39847 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41200 + 68] = mem[_41200 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41200 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _43821 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43821] = 30
                                            mem[_43821 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _45881 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _45881 + 68] = mem[idx + _43821 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45881 + 68] = mem[_45881 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45881 + -mem[64] + 100
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            _56017 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_56017] = 30
                                            mem[_56017 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _57639 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _57639 + 68] = mem[idx + _56017 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_57639 + 68] = mem[_57639 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _57639 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _37826 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37826] = 30
                                        mem[_37826 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _38141 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38141 + 68] = mem[idx + _37826 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38141 + 68] = mem[_38141 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38141 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _40650 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40650] = 30
                                        mem[_40650 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _41903 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _41903 + 68] = mem[idx + _40650 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41903 + 68] = mem[_41903 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41903 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _44766 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_44766] = 30
                                        mem[_44766 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _47124 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _47124 + 68] = mem[idx + _44766 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_47124 + 68] = mem[_47124 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _47124 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                                        _56811 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_56811] = 30
                                        mem[_56811 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _58549 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _58549 + 68] = mem[idx + _56811 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_58549 + 68] = mem[_58549 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _58549 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _32972 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32972] = 30
                                        mem[_32972 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _33478 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _33478 + 68] = mem[idx + _32972 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33478 + 68] = mem[_33478 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33478 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _35311 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35311] = 30
                                        mem[_35311 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _36129 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _36129 + 68] = mem[idx + _35311 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36129 + 68] = mem[_36129 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36129 + -mem[64] + 100
                                    _33182 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33182] = 26
                                    mem[_33182 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _33182 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _37957 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37957] = 30
                                        mem[_37957 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _41205 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41205] = 30
                                        mem[_41205 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _42824 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42824 + 68] = mem[idx + _41205 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42824 + 68] = mem[_42824 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42824 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _45887 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_45887] = 30
                                        mem[_45887 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _48278 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _48278 + 68] = mem[idx + _45887 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48278 + 68] = mem[_48278 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48278 + -mem[64] + 100
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        _57642 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_57642] = 30
                                        mem[_57642 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _59266 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _59266 + 68] = mem[idx + _57642 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_59266 + 68] = mem[_59266 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _59266 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38144 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38144] = 30
                                    mem[_38144 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _38898 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38898 + 68] = mem[idx + _38144 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38898 + 68] = mem[_38898 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38898 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 204
                                    _41906 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41906] = 30
                                    mem[_41906 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        _43824 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43824 + 68] = mem[idx + _41906 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43824 + 68] = mem[_43824 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43824 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    stor204[address(msg.sender)] -= arg2
                                    mem[32] = 203
                                    _47127 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_47127] = 30
                                    mem[_47127 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _49543 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _49543 + 68] = mem[idx + _47127 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_49543 + 68] = mem[_49543 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _49543 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] += stor209 / totalSupply * arg2
                                    _58552 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_58552] = 30
                                    mem[_58552 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _59844 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _59844 + 68] = mem[idx + _58552 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_59844 + 68] = mem[_59844 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _59844 + -mem[64] + 100
                                _31814 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31814] = 26
                                mem[_31814 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _33758 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33758] = 26
                                    mem[_33758 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] += t / s * arg2
                                else:
                                    _33759 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33759] = 26
                                    mem[_33759 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                            else:
                                if 0 / arg2:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _32679 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32679] = 26
                                        mem[_32679 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _32679 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _37713 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37713] = 30
                                            mem[_37713 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _39837 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39837] = 30
                                            mem[_39837 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _41192 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _41192 + 68] = mem[idx + _39837 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41192 + 68] = mem[_41192 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41192 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _43810 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43810] = 30
                                            mem[_43810 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _45865 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _45865 + 68] = mem[idx + _43810 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45865 + 68] = mem[_45865 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45865 + -mem[64] + 100
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            _56009 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_56009] = 30
                                            mem[_56009 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _57629 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _57629 + 68] = mem[idx + _56009 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_57629 + 68] = mem[_57629 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _57629 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _37825 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37825] = 30
                                        mem[_37825 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _38137 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38137 + 68] = mem[idx + _37825 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38137 + 68] = mem[_38137 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38137 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _40646 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40646] = 30
                                        mem[_40646 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _41893 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _41893 + 68] = mem[idx + _40646 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41893 + 68] = mem[_41893 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41893 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _44753 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_44753] = 30
                                        mem[_44753 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _47111 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _47111 + 68] = mem[idx + _44753 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_47111 + 68] = mem[_47111 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _47111 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                                        _56805 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_56805] = 30
                                        mem[_56805 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _58543 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _58543 + 68] = mem[idx + _56805 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_58543 + 68] = mem[_58543 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _58543 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _32969 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32969] = 30
                                        mem[_32969 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _33474 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _33474 + 68] = mem[idx + _32969 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33474 + 68] = mem[_33474 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33474 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _35304 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35304] = 30
                                        mem[_35304 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _36121 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _36121 + 68] = mem[idx + _35304 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36121 + 68] = mem[_36121 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36121 + -mem[64] + 100
                                    _33177 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33177] = 26
                                    mem[_33177 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _33177 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _37956 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37956] = 30
                                        mem[_37956 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _41197 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41197] = 30
                                        mem[_41197 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _42812 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42812 + 68] = mem[idx + _41197 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42812 + 68] = mem[_42812 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42812 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _45871 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_45871] = 30
                                        mem[_45871 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _48259 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _48259 + 68] = mem[idx + _45871 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48259 + 68] = mem[_48259 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48259 + -mem[64] + 100
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        _57632 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_57632] = 30
                                        mem[_57632 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _59260 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _59260 + 68] = mem[idx + _57632 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_59260 + 68] = mem[_59260 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _59260 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38140 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38140] = 30
                                    mem[_38140 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _38892 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38892 + 68] = mem[idx + _38140 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38892 + 68] = mem[_38892 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38892 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 204
                                    _41896 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41896] = 30
                                    mem[_41896 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        _43813 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43813 + 68] = mem[idx + _41896 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43813 + 68] = mem[_43813 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43813 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    stor204[address(msg.sender)] -= arg2
                                    mem[32] = 203
                                    _47114 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_47114] = 30
                                    mem[_47114 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _49527 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _49527 + 68] = mem[idx + _47114 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_49527 + 68] = mem[_49527 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _49527 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] += stor209 / totalSupply * arg2
                                    _58546 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_58546] = 30
                                    mem[_58546 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _59836 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _59836 + 68] = mem[idx + _58546 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_59836 + 68] = mem[_59836 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _59836 + -mem[64] + 100
                                _31809 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31809] = 26
                                mem[_31809 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _33751 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33751] = 26
                                    mem[_33751 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] += t / s * arg2
                                else:
                                    _33752 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33752] = 26
                                    mem[_33752 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                            if 0 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
        else:
            mem[0] = arg1
            mem[32] = 206
            if stor206[address(arg1)]:
                if not arg2:
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if 0 > arg2:
                        revert with 0, 'SafeMath: subtraction overflow'
                    idx = 0
                    s = totalSupply
                    t = stor209
                    while idx < stor207.length:
                        mem[0] = stor207[idx]
                        mem[32] = 203
                        if stor203[stor207[idx]] > t:
                            _32774 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32774] = 26
                            mem[_32774 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _32774 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                _37746 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_37746] = 30
                                mem[_37746 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 203
                                _40104 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_40104] = 30
                                mem[_40104 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor203[address(msg.sender)]:
                                    _41393 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _41393 + 68] = mem[idx + _40104 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_41393 + 68] = mem[_41393 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _41393 + -mem[64] + 100
                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] += arg2
                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                _52006 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_52006] = 30
                                mem[_52006 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _53478 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _53478 + 68] = mem[idx + _52006 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_53478 + 68] = mem[_53478 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _53478 + -mem[64] + 100
                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _37865 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_37865] = 30
                            mem[_37865 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor209 / totalSupply * arg2:
                                _38269 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _38269 + 68] = mem[idx + _37865 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_38269 + 68] = mem[_38269 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _38269 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 203
                            _40806 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_40806] = 30
                            mem[_40806 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                _42167 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _42167 + 68] = mem[idx + _40806 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_42167 + 68] = mem[_42167 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _42167 + -mem[64] + 100
                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor204[address(arg1)] += arg2
                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                            _52755 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_52755] = 30
                            mem[_52755 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor209:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _54364 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _54364 + 68] = mem[idx + _52755 + 32]
                                idx = idx + 32
                                continue 
                            mem[_54364 + 68] = mem[_54364 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _54364 + -mem[64] + 100
                        require idx < stor207.length
                        mem[0] = stor207[idx]
                        mem[32] = 204
                        if stor204[stor207[idx]] <= s:
                            require idx < stor207.length
                            mem[0] = stor207[idx]
                            mem[32] = 203
                            _33026 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33026] = 30
                            mem[_33026 + 32] = 'SafeMath: subtraction overflow'
                            if stor203[stor207[idx]] > t:
                                _33550 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _33550 + 68] = mem[idx + _33026 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_33550 + 68] = mem[_33550 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _33550 + -mem[64] + 100
                            require idx < stor207.length
                            mem[0] = stor207[idx]
                            mem[32] = 204
                            _35437 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35437] = 30
                            mem[_35437 + 32] = 'SafeMath: subtraction overflow'
                            if stor204[stor207[idx]] <= s:
                                idx = idx + 1
                                s = s - stor204[stor207[idx]]
                                t = t - stor203[stor207[idx]]
                                continue 
                            _36273 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _36273 + 68] = mem[idx + _35437 + 32]
                                idx = idx + 32
                                continue 
                            mem[_36273 + 68] = mem[_36273 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _36273 + -mem[64] + 100
                        _33272 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33272] = 26
                        mem[_33272 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _33272 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not arg2:
                            _37996 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_37996] = 30
                            mem[_37996 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 203
                            _41398 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_41398] = 30
                            mem[_41398 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor203[address(msg.sender)]:
                                _43124 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _43124 + 68] = mem[idx + _41398 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_43124 + 68] = mem[_43124 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _43124 + -mem[64] + 100
                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor204[address(arg1)] += arg2
                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            _53481 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_53481] = 30
                            mem[_53481 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor209:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _55348 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _55348 + 68] = mem[idx + _53481 + 32]
                                idx = idx + 32
                                continue 
                            mem[_55348 + 68] = mem[_55348 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _55348 + -mem[64] + 100
                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _38272 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_38272] = 30
                        mem[_38272 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor209 / totalSupply * arg2:
                            _39048 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _39048 + 68] = mem[idx + _38272 + 32]
                                idx = idx + 32
                                continue 
                            mem[_39048 + 68] = mem[_39048 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _39048 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 203
                        _42170 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_42170] = 30
                        mem[_42170 + 32] = 'SafeMath: subtraction overflow'
                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                            _44092 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _44092 + 68] = mem[idx + _42170 + 32]
                                idx = idx + 32
                                continue 
                            mem[_44092 + 68] = mem[_44092 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _44092 + -mem[64] + 100
                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor204[address(arg1)] += arg2
                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 203
                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                        _54367 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_54367] = 30
                        mem[_54367 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor209:
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                            return 1
                        _56252 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _56252 + 68] = mem[idx + _54367 + 32]
                            idx = idx + 32
                            continue 
                        mem[_56252 + 68] = mem[_56252 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _56252 + -mem[64] + 100
                    _31904 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31904] = 26
                    mem[_31904 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero'
                    if t >= stor209 / totalSupply:
                        _33884 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33884] = 26
                        mem[_33884 + 32] = 'SafeMath: division by zero'
                        if not s:
                            revert with 0, 'SafeMath: division by zero'
                        if not arg2:
                            if 0 > stor203[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor204[address(arg1)] += arg2
                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if t / s * arg2 / arg2 != t / s:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if 0 > t / s * arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if t / s * arg2 > stor203[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor203[address(msg.sender)] += -1 * t / s * arg2
                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor204[address(arg1)] += arg2
                            if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor203[address(arg1)] += t / s * arg2
                    else:
                        _33885 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33885] = 26
                        mem[_33885 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero'
                        if not arg2:
                            if 0 > stor203[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor204[address(arg1)] += arg2
                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if 0 > stor209 / totalSupply * arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor204[address(arg1)] += arg2
                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                    if 0 > stor209:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if totalFees < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    emit Transfer(arg2, msg.sender, arg1);
                else:
                    if _tFeePercent * arg2 / arg2 != _tFeePercent:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if _tFeePercent * arg2 / 10000 > arg2:
                        revert with 0, 'SafeMath: subtraction overflow'
                    idx = 0
                    s = totalSupply
                    t = stor209
                    while idx < stor207.length:
                        mem[0] = stor207[idx]
                        mem[32] = 203
                        if stor203[stor207[idx]] > t:
                            _32769 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32769] = 26
                            mem[_32769 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _32769 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if not _tFeePercent * arg2 / 10000:
                                    _37745 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37745] = 30
                                    mem[_37745 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _40093 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_40093] = 30
                                    mem[_40093 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _41381 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _41381 + 68] = mem[idx + _40093 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41381 + 68] = mem[_41381 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41381 + -mem[64] + 100
                                    if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                    if stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    _51996 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_51996] = 30
                                    mem[_51996 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _53467 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53467 + 68] = mem[idx + _51996 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53467 + 68] = mem[_53467 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53467 + -mem[64] + 100
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _37862 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_37862] = 30
                                mem[_37862 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                    _38264 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _38264 + 68] = mem[idx + _37862 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_38264 + 68] = mem[_38264 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _38264 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _40799 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_40799] = 30
                                mem[_40799 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor203[address(msg.sender)]:
                                    _42154 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _42154 + 68] = mem[idx + _40799 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_42154 + 68] = mem[_42154 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _42154 + -mem[64] + 100
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                _52746 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_52746] = 30
                                mem[_52746 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                    return 1
                                _54357 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _54357 + 68] = mem[idx + _52746 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_54357 + 68] = mem[_54357 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _54357 + -mem[64] + 100
                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not _tFeePercent * arg2 / 10000:
                                _37861 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_37861] = 30
                                mem[_37861 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _38261 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _38261 + 68] = mem[idx + _37861 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_38261 + 68] = mem[_38261 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _38261 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _40798 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_40798] = 30
                                mem[_40798 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _42151 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _42151 + 68] = mem[idx + _40798 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_42151 + 68] = mem[_42151 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _42151 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] += stor209 / totalSupply * arg2
                                _52745 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_52745] = 30
                                mem[_52745 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                    return 1
                                _54354 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _54354 + 68] = mem[idx + _52745 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_54354 + 68] = mem[_54354 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _54354 + -mem[64] + 100
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _37992 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_37992] = 30
                            mem[_37992 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                _38639 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _38639 + 68] = mem[idx + _37992 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_38639 + 68] = mem[_38639 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _38639 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 203
                            _41380 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_41380] = 30
                            mem[_41380 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                _43105 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _43105 + 68] = mem[idx + _41380 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_43105 + 68] = mem[_43105 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _43105 + -mem[64] + 100
                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                            if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)]
                            _53466 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_53466] = 30
                            mem[_53466 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                return 1
                            _55337 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _55337 + 68] = mem[idx + _53466 + 32]
                                idx = idx + 32
                                continue 
                            mem[_55337 + 68] = mem[_55337 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _55337 + -mem[64] + 100
                        require idx < stor207.length
                        mem[0] = stor207[idx]
                        mem[32] = 204
                        if stor204[stor207[idx]] <= s:
                            require idx < stor207.length
                            mem[0] = stor207[idx]
                            mem[32] = 203
                            _33023 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33023] = 30
                            mem[_33023 + 32] = 'SafeMath: subtraction overflow'
                            if stor203[stor207[idx]] > t:
                                _33546 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _33546 + 68] = mem[idx + _33023 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_33546 + 68] = mem[_33546 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _33546 + -mem[64] + 100
                            require idx < stor207.length
                            mem[0] = stor207[idx]
                            mem[32] = 204
                            _35430 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_35430] = 30
                            mem[_35430 + 32] = 'SafeMath: subtraction overflow'
                            if stor204[stor207[idx]] <= s:
                                idx = idx + 1
                                s = s - stor204[stor207[idx]]
                                t = t - stor203[stor207[idx]]
                                continue 
                            _36265 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _36265 + 68] = mem[idx + _35430 + 32]
                                idx = idx + 32
                                continue 
                            mem[_36265 + 68] = mem[_36265 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _36265 + -mem[64] + 100
                        _33267 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33267] = 26
                        mem[_33267 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _33267 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not arg2:
                            if not _tFeePercent * arg2 / 10000:
                                _37995 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_37995] = 30
                                mem[_37995 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 203
                                _41390 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_41390] = 30
                                mem[_41390 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor203[address(msg.sender)]:
                                    _43112 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _43112 + 68] = mem[idx + _41390 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_43112 + 68] = mem[_43112 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _43112 + -mem[64] + 100
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                _53471 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_53471] = 30
                                mem[_53471 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                    return 1
                                _55342 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _55342 + 68] = mem[idx + _53471 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_55342 + 68] = mem[_55342 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _55342 + -mem[64] + 100
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _38268 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_38268] = 30
                            mem[_38268 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                _39042 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _39042 + 68] = mem[idx + _38268 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_39042 + 68] = mem[_39042 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _39042 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 203
                            _42160 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_42160] = 30
                            mem[_42160 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor203[address(msg.sender)]:
                                _44082 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _44082 + 68] = mem[idx + _42160 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_44082 + 68] = mem[_44082 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _44082 + -mem[64] + 100
                            if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                            _54361 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_54361] = 30
                            mem[_54361 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                return 1
                            _56244 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _56244 + 68] = mem[idx + _54361 + 32]
                                idx = idx + 32
                                continue 
                            mem[_56244 + 68] = mem[_56244 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _56244 + -mem[64] + 100
                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not _tFeePercent * arg2 / 10000:
                            _38267 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_38267] = 30
                            mem[_38267 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor209 / totalSupply * arg2:
                                _39039 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _39039 + 68] = mem[idx + _38267 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_39039 + 68] = mem[_39039 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _39039 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 203
                            _42159 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_42159] = 30
                            mem[_42159 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                _44079 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _44079 + 68] = mem[idx + _42159 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_44079 + 68] = mem[_44079 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _44079 + -mem[64] + 100
                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                            if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                            _54360 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_54360] = 30
                            mem[_54360 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor209:
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                return 1
                            _56241 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _56241 + 68] = mem[idx + _54360 + 32]
                                idx = idx + 32
                                continue 
                            mem[_56241 + 68] = mem[_56241 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _56241 + -mem[64] + 100
                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _38642 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_38642] = 30
                        mem[_38642 + 32] = 'SafeMath: subtraction overflow'
                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                            _39487 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _39487 + 68] = mem[idx + _38642 + 32]
                                idx = idx + 32
                                continue 
                            mem[_39487 + 68] = mem[_39487 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _39487 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 203
                        _43111 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_43111] = 30
                        mem[_43111 + 32] = 'SafeMath: subtraction overflow'
                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                            _45071 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _45071 + 68] = mem[idx + _43111 + 32]
                                idx = idx + 32
                                continue 
                            mem[_45071 + 68] = mem[_45071 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _45071 + -mem[64] + 100
                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                        if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 203
                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)]
                        _55341 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_55341] = 30
                        mem[_55341 + 32] = 'SafeMath: subtraction overflow'
                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += _tFeePercent * arg2 / 10000
                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                            return 1
                        _57039 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _57039 + 68] = mem[idx + _55341 + 32]
                            idx = idx + 32
                            continue 
                        mem[_57039 + 68] = mem[_57039 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _57039 + -mem[64] + 100
                    _31899 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31899] = 26
                    mem[_31899 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero'
                    if t >= stor209 / totalSupply:
                        _33877 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33877] = 26
                        mem[_33877 + 32] = 'SafeMath: division by zero'
                        if not s:
                            revert with 0, 'SafeMath: division by zero'
                        if not arg2:
                            if not _tFeePercent * arg2 / 10000:
                                if 0 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if t / s * _tFeePercent * arg2 / 10000 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 0 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] += -1 * t / s * _tFeePercent * arg2 / 10000
                                if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                        else:
                            if t / s * arg2 / arg2 != t / s:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not _tFeePercent * arg2 / 10000:
                                if 0 > t / s * arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if t / s * arg2 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] += t / s * arg2
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if t / s * arg2 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[address(arg1)]
                                if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                    else:
                        _33878 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33878] = 26
                        mem[_33878 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero'
                        if not arg2:
                            if not _tFeePercent * arg2 / 10000:
                                if 0 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 0 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                        else:
                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not _tFeePercent * arg2 / 10000:
                                if 0 > stor209 / totalSupply * arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] += stor209 / totalSupply * arg2
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)]
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += _tFeePercent * arg2 / 10000
                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
            else:
                if stor206[address(msg.sender)]:
                    mem[0] = msg.sender
                    mem[32] = 206
                    if not stor206[address(msg.sender)]:
                        if not arg2:
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _32704 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32704] = 26
                                    mem[_32704 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _32704 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _37722 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37722] = 30
                                        mem[_37722 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _39909 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_39909] = 30
                                        mem[_39909 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _41246 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _41246 + 68] = mem[idx + _39909 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41246 + 68] = mem[_41246 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41246 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _48360 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48360] = 30
                                        mem[_48360 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _50783 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _50783 + 68] = mem[idx + _48360 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50783 + 68] = mem[_50783 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50783 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _37836 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37836] = 30
                                    mem[_37836 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _38173 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38173 + 68] = mem[idx + _37836 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38173 + 68] = mem[_38173 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38173 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _40690 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_40690] = 30
                                    mem[_40690 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _41967 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _41967 + 68] = mem[idx + _40690 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41967 + 68] = mem[_41967 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41967 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _49622 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_49622] = 30
                                    mem[_49622 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _51817 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _51817 + 68] = mem[idx + _49622 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_51817 + 68] = mem[_51817 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _51817 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _32984 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32984] = 30
                                    mem[_32984 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _33494 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _33494 + 68] = mem[idx + _32984 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33494 + 68] = mem[_33494 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33494 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _35339 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35339] = 30
                                    mem[_35339 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _36161 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _36161 + 68] = mem[idx + _35339 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36161 + 68] = mem[_36161 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _36161 + -mem[64] + 100
                                _33202 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33202] = 26
                                mem[_33202 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _33202 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    _37967 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37967] = 30
                                    mem[_37967 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41251 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41251] = 30
                                    mem[_41251 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _42896 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _42896 + 68] = mem[idx + _41251 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42896 + 68] = mem[_42896 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42896 + -mem[64] + 100
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = stor203[arg1]
                                    _50786 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50786] = 30
                                    mem[_50786 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _52610 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _52610 + 68] = mem[idx + _50786 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52610 + 68] = mem[_52610 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52610 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _38176 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38176] = 30
                                mem[_38176 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _38934 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _38934 + 68] = mem[idx + _38176 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_38934 + 68] = mem[_38934 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _38934 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _41970 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_41970] = 30
                                mem[_41970 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _43888 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _43888 + 68] = mem[idx + _41970 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_43888 + 68] = mem[_43888 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _43888 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                _51820 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_51820] = 30
                                mem[_51820 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _53297 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _53297 + 68] = mem[idx + _51820 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_53297 + 68] = mem[_53297 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _53297 + -mem[64] + 100
                            _31834 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31834] = 26
                            mem[_31834 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _33786 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33786] = 26
                                mem[_33786 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                            else:
                                _33787 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33787] = 26
                                mem[_33787 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                            if 0 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if _tFeePercent * arg2 / 10000 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _32699 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32699] = 26
                                    mem[_32699 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _32699 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            _37721 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37721] = 30
                                            mem[_37721 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _39898 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39898] = 30
                                            mem[_39898 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _41234 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _41234 + 68] = mem[idx + _39898 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41234 + 68] = mem[_41234 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41234 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _48340 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48340] = 30
                                            mem[_48340 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _50770 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _50770 + 68] = mem[idx + _48340 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50770 + 68] = mem[_50770 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50770 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _37833 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37833] = 30
                                        mem[_37833 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            _38168 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38168 + 68] = mem[idx + _37833 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38168 + 68] = mem[_38168 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38168 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _40683 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40683] = 30
                                        mem[_40683 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _41954 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _41954 + 68] = mem[idx + _40683 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41954 + 68] = mem[_41954 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41954 + -mem[64] + 100
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _49606 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_49606] = 30
                                        mem[_49606 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _51810 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _51810 + 68] = mem[idx + _49606 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_51810 + 68] = mem[_51810 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _51810 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        _37832 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37832] = 30
                                        mem[_37832 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _38165 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38165 + 68] = mem[idx + _37832 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38165 + 68] = mem[_38165 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38165 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _40682 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40682] = 30
                                        mem[_40682 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _41951 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _41951 + 68] = mem[idx + _40682 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41951 + 68] = mem[_41951 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41951 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _49605 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_49605] = 30
                                        mem[_49605 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _51807 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _51807 + 68] = mem[idx + _49605 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_51807 + 68] = mem[_51807 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _51807 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _37963 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37963] = 30
                                    mem[_37963 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        _38571 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38571 + 68] = mem[idx + _37963 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38571 + 68] = mem[_38571 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38571 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41233 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41233] = 30
                                    mem[_41233 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _42877 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _42877 + 68] = mem[idx + _41233 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42877 + 68] = mem[_42877 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42877 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _50769 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50769] = 30
                                    mem[_50769 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _52599 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _52599 + 68] = mem[idx + _50769 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52599 + 68] = mem[_52599 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52599 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _32981 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32981] = 30
                                    mem[_32981 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _33490 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _33490 + 68] = mem[idx + _32981 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33490 + 68] = mem[_33490 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33490 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _35332 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35332] = 30
                                    mem[_35332 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _36153 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _36153 + 68] = mem[idx + _35332 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36153 + 68] = mem[_36153 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _36153 + -mem[64] + 100
                                _33197 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33197] = 26
                                mem[_33197 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _33197 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        _37966 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37966] = 30
                                        mem[_37966 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41243 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41243] = 30
                                        mem[_41243 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _42884 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42884 + 68] = mem[idx + _41243 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42884 + 68] = mem[_42884 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42884 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _50774 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50774] = 30
                                        mem[_50774 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _52604 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52604 + 68] = mem[idx + _50774 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52604 + 68] = mem[_52604 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52604 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38172 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38172] = 30
                                    mem[_38172 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                        _38928 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38928 + 68] = mem[idx + _38172 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38928 + 68] = mem[_38928 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38928 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41960 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41960] = 30
                                    mem[_41960 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _43878 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43878 + 68] = mem[idx + _41960 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43878 + 68] = mem[_43878 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43878 + -mem[64] + 100
                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _51814 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_51814] = 30
                                    mem[_51814 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _53289 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53289 + 68] = mem[idx + _51814 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53289 + 68] = mem[_53289 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53289 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    _38171 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38171] = 30
                                    mem[_38171 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _38925 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38925 + 68] = mem[idx + _38171 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38925 + 68] = mem[_38925 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38925 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41959 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41959] = 30
                                    mem[_41959 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _43875 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43875 + 68] = mem[idx + _41959 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43875 + 68] = mem[_43875 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43875 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _51813 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_51813] = 30
                                    mem[_51813 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _53286 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53286 + 68] = mem[idx + _51813 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53286 + 68] = mem[_53286 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53286 + -mem[64] + 100
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _38574 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38574] = 30
                                mem[_38574 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                    _39405 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _39405 + 68] = mem[idx + _38574 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39405 + 68] = mem[_39405 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39405 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _42883 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_42883] = 30
                                mem[_42883 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _44829 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _44829 + 68] = mem[idx + _42883 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_44829 + 68] = mem[_44829 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _44829 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                _52603 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_52603] = 30
                                mem[_52603 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                    return 1
                                _54142 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _54142 + 68] = mem[idx + _52603 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_54142 + 68] = mem[_54142 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _54142 + -mem[64] + 100
                            _31829 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31829] = 26
                            mem[_31829 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _33779 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33779] = 26
                                mem[_33779 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if t / s * _tFeePercent * arg2 / 10000 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                            else:
                                _33780 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33780] = 26
                                mem[_33780 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += _tFeePercent * arg2 / 10000
                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                    else:
                        mem[0] = arg1
                        mem[32] = 206
                        if not stor206[address(arg1)]:
                            if not arg2:
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _32714 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32714] = 26
                                        mem[_32714 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _32714 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _37726 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37726] = 30
                                            mem[_37726 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _39940 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39940] = 30
                                            mem[_39940 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _41269 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _41269 + 68] = mem[idx + _39940 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41269 + 68] = mem[_41269 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41269 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _48402 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48402] = 30
                                            mem[_48402 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _50819 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _50819 + 68] = mem[idx + _48402 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50819 + 68] = mem[_50819 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50819 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _37841 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37841] = 30
                                        mem[_37841 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _38189 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38189 + 68] = mem[idx + _37841 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38189 + 68] = mem[_38189 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38189 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _40710 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40710] = 30
                                        mem[_40710 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _41999 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _41999 + 68] = mem[idx + _40710 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41999 + 68] = mem[_41999 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41999 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _49661 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_49661] = 30
                                        mem[_49661 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _51841 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _51841 + 68] = mem[idx + _49661 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_51841 + 68] = mem[_51841 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _51841 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _32990 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32990] = 30
                                        mem[_32990 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _33502 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _33502 + 68] = mem[idx + _32990 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33502 + 68] = mem[_33502 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33502 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _35353 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35353] = 30
                                        mem[_35353 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _36177 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _36177 + 68] = mem[idx + _35353 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36177 + 68] = mem[_36177 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36177 + -mem[64] + 100
                                    _33212 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33212] = 26
                                    mem[_33212 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _33212 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _37972 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37972] = 30
                                        mem[_37972 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41274 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41274] = 30
                                        mem[_41274 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _42932 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42932 + 68] = mem[idx + _41274 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42932 + 68] = mem[_42932 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42932 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _50822 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50822] = 30
                                        mem[_50822 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _52628 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52628 + 68] = mem[idx + _50822 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52628 + 68] = mem[_52628 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52628 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38192 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38192] = 30
                                    mem[_38192 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _38952 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38952 + 68] = mem[idx + _38192 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38952 + 68] = mem[_38952 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38952 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42002 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42002] = 30
                                    mem[_42002 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _43920 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43920 + 68] = mem[idx + _42002 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43920 + 68] = mem[_43920 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43920 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _51844 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_51844] = 30
                                    mem[_51844 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _53319 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53319 + 68] = mem[idx + _51844 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53319 + 68] = mem[_53319 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53319 + -mem[64] + 100
                                _31844 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31844] = 26
                                mem[_31844 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _33800 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33800] = 26
                                    mem[_33800 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                else:
                                    _33801 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33801] = 26
                                    mem[_33801 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if _tFeePercent * arg2 / 10000 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _32709 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32709] = 26
                                        mem[_32709 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _32709 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                _37725 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37725] = 30
                                                mem[_37725 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _39929 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39929] = 30
                                                mem[_39929 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _41257 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _41257 + 68] = mem[idx + _39929 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_41257 + 68] = mem[_41257 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _41257 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _48382 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_48382] = 30
                                                mem[_48382 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                    return 1
                                                _50806 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _50806 + 68] = mem[idx + _48382 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_50806 + 68] = mem[_50806 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _50806 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _37838 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37838] = 30
                                            mem[_37838 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                _38184 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38184 + 68] = mem[idx + _37838 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38184 + 68] = mem[_38184 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38184 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _40703 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40703] = 30
                                            mem[_40703 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _41986 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _41986 + 68] = mem[idx + _40703 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41986 + 68] = mem[_41986 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41986 + -mem[64] + 100
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _49645 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_49645] = 30
                                            mem[_49645 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _51834 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _51834 + 68] = mem[idx + _49645 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_51834 + 68] = mem[_51834 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _51834 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            _37837 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37837] = 30
                                            mem[_37837 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _38181 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38181 + 68] = mem[idx + _37837 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38181 + 68] = mem[_38181 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38181 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _40702 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40702] = 30
                                            mem[_40702 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _41983 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _41983 + 68] = mem[idx + _40702 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41983 + 68] = mem[_41983 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41983 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _49644 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_49644] = 30
                                            mem[_49644 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _51831 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _51831 + 68] = mem[idx + _49644 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_51831 + 68] = mem[_51831 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _51831 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _37968 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37968] = 30
                                        mem[_37968 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            _38583 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38583 + 68] = mem[idx + _37968 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38583 + 68] = mem[_38583 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38583 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41256 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41256] = 30
                                        mem[_41256 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _42913 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42913 + 68] = mem[idx + _41256 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42913 + 68] = mem[_42913 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42913 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _50805 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50805] = 30
                                        mem[_50805 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _52617 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52617 + 68] = mem[idx + _50805 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52617 + 68] = mem[_52617 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52617 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _32987 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32987] = 30
                                        mem[_32987 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _33498 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _33498 + 68] = mem[idx + _32987 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33498 + 68] = mem[_33498 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33498 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _35346 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35346] = 30
                                        mem[_35346 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _36169 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _36169 + 68] = mem[idx + _35346 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36169 + 68] = mem[_36169 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36169 + -mem[64] + 100
                                    _33207 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33207] = 26
                                    mem[_33207 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _33207 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            _37971 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37971] = 30
                                            mem[_37971 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41266 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41266] = 30
                                            mem[_41266 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _42920 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42920 + 68] = mem[idx + _41266 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42920 + 68] = mem[_42920 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42920 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _50810 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50810] = 30
                                            mem[_50810 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _52622 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52622 + 68] = mem[idx + _50810 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52622 + 68] = mem[_52622 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52622 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38188 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38188] = 30
                                        mem[_38188 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            _38946 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38946 + 68] = mem[idx + _38188 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38946 + 68] = mem[_38946 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38946 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41992 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41992] = 30
                                        mem[_41992 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _43910 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43910 + 68] = mem[idx + _41992 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43910 + 68] = mem[_43910 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43910 + -mem[64] + 100
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _51838 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51838] = 30
                                        mem[_51838 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _53311 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53311 + 68] = mem[idx + _51838 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53311 + 68] = mem[_53311 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53311 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        _38187 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38187] = 30
                                        mem[_38187 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _38943 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38943 + 68] = mem[idx + _38187 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38943 + 68] = mem[_38943 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38943 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41991 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41991] = 30
                                        mem[_41991 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _43907 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43907 + 68] = mem[idx + _41991 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43907 + 68] = mem[_43907 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43907 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _51837 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51837] = 30
                                        mem[_51837 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _53308 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53308 + 68] = mem[idx + _51837 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53308 + 68] = mem[_53308 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53308 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38586 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38586] = 30
                                    mem[_38586 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        _39419 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39419 + 68] = mem[idx + _38586 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39419 + 68] = mem[_39419 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39419 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42919 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42919] = 30
                                    mem[_42919 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _44867 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44867 + 68] = mem[idx + _42919 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44867 + 68] = mem[_44867 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44867 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _52621 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52621] = 30
                                    mem[_52621 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _54174 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54174 + 68] = mem[idx + _52621 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54174 + 68] = mem[_54174 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54174 + -mem[64] + 100
                                _31839 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31839] = 26
                                mem[_31839 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _33793 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33793] = 26
                                    mem[_33793 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                else:
                                    _33794 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33794] = 26
                                    mem[_33794 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                        else:
                            if not arg2:
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _32724 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32724] = 26
                                        mem[_32724 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _32724 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _37728 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37728] = 30
                                            mem[_37728 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _39960 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39960] = 30
                                            mem[_39960 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _41285 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _41285 + 68] = mem[idx + _39960 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41285 + 68] = mem[_41285 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41285 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _43939 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43939] = 30
                                            mem[_43939 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _46045 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _46045 + 68] = mem[idx + _43939 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_46045 + 68] = mem[_46045 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _46045 + -mem[64] + 100
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            _56123 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_56123] = 30
                                            mem[_56123 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _57764 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _57764 + 68] = mem[idx + _56123 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_57764 + 68] = mem[_57764 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _57764 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _37843 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37843] = 30
                                        mem[_37843 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _38197 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38197 + 68] = mem[idx + _37843 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38197 + 68] = mem[_38197 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38197 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _40718 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40718] = 30
                                        mem[_40718 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _42019 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42019 + 68] = mem[idx + _40718 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42019 + 68] = mem[_42019 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42019 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _44906 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_44906] = 30
                                        mem[_44906 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _47267 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _47267 + 68] = mem[idx + _44906 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_47267 + 68] = mem[_47267 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _47267 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                                        _56916 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_56916] = 30
                                        mem[_56916 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _58645 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _58645 + 68] = mem[idx + _56916 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_58645 + 68] = mem[_58645 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _58645 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _32996 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32996] = 30
                                        mem[_32996 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _33510 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _33510 + 68] = mem[idx + _32996 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33510 + 68] = mem[_33510 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33510 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _35367 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35367] = 30
                                        mem[_35367 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _36193 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _36193 + 68] = mem[idx + _35367 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36193 + 68] = mem[_36193 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36193 + -mem[64] + 100
                                    _33222 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33222] = 26
                                    mem[_33222 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _33222 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _37974 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37974] = 30
                                        mem[_37974 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _41290 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41290] = 30
                                        mem[_41290 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _42956 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42956 + 68] = mem[idx + _41290 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42956 + 68] = mem[_42956 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42956 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _46051 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_46051] = 30
                                        mem[_46051 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _48442 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _48442 + 68] = mem[idx + _46051 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48442 + 68] = mem[_48442 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48442 + -mem[64] + 100
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        _57767 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_57767] = 30
                                        mem[_57767 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _59334 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _59334 + 68] = mem[idx + _57767 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_59334 + 68] = mem[_59334 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _59334 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38200 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38200] = 30
                                    mem[_38200 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _38964 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38964 + 68] = mem[idx + _38200 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38964 + 68] = mem[_38964 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38964 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 204
                                    _42022 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42022] = 30
                                    mem[_42022 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        _43942 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43942 + 68] = mem[idx + _42022 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43942 + 68] = mem[_43942 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43942 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    stor204[address(msg.sender)] -= arg2
                                    mem[32] = 203
                                    _47270 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_47270] = 30
                                    mem[_47270 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _49692 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _49692 + 68] = mem[idx + _47270 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_49692 + 68] = mem[_49692 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _49692 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] += stor209 / totalSupply * arg2
                                    _58648 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_58648] = 30
                                    mem[_58648 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _59912 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _59912 + 68] = mem[idx + _58648 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_59912 + 68] = mem[_59912 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _59912 + -mem[64] + 100
                                _31854 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31854] = 26
                                mem[_31854 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _33814 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33814] = 26
                                    mem[_33814 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] += t / s * arg2
                                else:
                                    _33815 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33815] = 26
                                    mem[_33815 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                            else:
                                if 0 / arg2:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _32719 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32719] = 26
                                        mem[_32719 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _32719 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _37727 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37727] = 30
                                            mem[_37727 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _39950 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39950] = 30
                                            mem[_39950 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _41277 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _41277 + 68] = mem[idx + _39950 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41277 + 68] = mem[_41277 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41277 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _43928 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43928] = 30
                                            mem[_43928 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _46029 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _46029 + 68] = mem[idx + _43928 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_46029 + 68] = mem[_46029 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _46029 + -mem[64] + 100
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            _56115 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_56115] = 30
                                            mem[_56115 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _57754 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _57754 + 68] = mem[idx + _56115 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_57754 + 68] = mem[_57754 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _57754 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _37842 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37842] = 30
                                        mem[_37842 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _38193 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38193 + 68] = mem[idx + _37842 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38193 + 68] = mem[_38193 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38193 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _40714 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40714] = 30
                                        mem[_40714 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _42009 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42009 + 68] = mem[idx + _40714 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42009 + 68] = mem[_42009 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42009 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _44893 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_44893] = 30
                                        mem[_44893 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _47254 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _47254 + 68] = mem[idx + _44893 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_47254 + 68] = mem[_47254 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _47254 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                                        _56910 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_56910] = 30
                                        mem[_56910 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _58639 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _58639 + 68] = mem[idx + _56910 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_58639 + 68] = mem[_58639 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _58639 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _32993 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32993] = 30
                                        mem[_32993 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _33506 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _33506 + 68] = mem[idx + _32993 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33506 + 68] = mem[_33506 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33506 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _35360 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35360] = 30
                                        mem[_35360 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _36185 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _36185 + 68] = mem[idx + _35360 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36185 + 68] = mem[_36185 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36185 + -mem[64] + 100
                                    _33217 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33217] = 26
                                    mem[_33217 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _33217 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _37973 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37973] = 30
                                        mem[_37973 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _41282 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41282] = 30
                                        mem[_41282 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _42944 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42944 + 68] = mem[idx + _41282 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42944 + 68] = mem[_42944 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42944 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _46035 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_46035] = 30
                                        mem[_46035 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _48423 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _48423 + 68] = mem[idx + _46035 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48423 + 68] = mem[_48423 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48423 + -mem[64] + 100
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        _57757 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_57757] = 30
                                        mem[_57757 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _59328 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _59328 + 68] = mem[idx + _57757 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_59328 + 68] = mem[_59328 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _59328 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38196 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38196] = 30
                                    mem[_38196 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _38958 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38958 + 68] = mem[idx + _38196 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38958 + 68] = mem[_38958 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38958 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 204
                                    _42012 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42012] = 30
                                    mem[_42012 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        _43931 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43931 + 68] = mem[idx + _42012 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43931 + 68] = mem[_43931 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43931 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    stor204[address(msg.sender)] -= arg2
                                    mem[32] = 203
                                    _47257 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_47257] = 30
                                    mem[_47257 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _49676 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _49676 + 68] = mem[idx + _47257 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_49676 + 68] = mem[_49676 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _49676 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] += stor209 / totalSupply * arg2
                                    _58642 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_58642] = 30
                                    mem[_58642 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _59904 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _59904 + 68] = mem[idx + _58642 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_59904 + 68] = mem[_59904 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _59904 + -mem[64] + 100
                                _31849 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31849] = 26
                                mem[_31849 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _33807 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33807] = 26
                                    mem[_33807 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] += t / s * arg2
                                else:
                                    _33808 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33808] = 26
                                    mem[_33808 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                            if 0 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                else:
                    mem[0] = arg1
                    mem[32] = 206
                    if not stor206[address(arg1)]:
                        if not arg2:
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _32764 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32764] = 26
                                    mem[_32764 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _32764 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _37742 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37742] = 30
                                        mem[_37742 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _40073 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40073] = 30
                                        mem[_40073 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _41370 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _41370 + 68] = mem[idx + _40073 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41370 + 68] = mem[_41370 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41370 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _48604 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48604] = 30
                                        mem[_48604 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _50991 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _50991 + 68] = mem[idx + _48604 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_50991 + 68] = mem[_50991 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _50991 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _37860 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37860] = 30
                                    mem[_37860 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _38253 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38253 + 68] = mem[idx + _37860 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38253 + 68] = mem[_38253 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38253 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _40786 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_40786] = 30
                                    mem[_40786 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _42135 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _42135 + 68] = mem[idx + _40786 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42135 + 68] = mem[_42135 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42135 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _49842 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_49842] = 30
                                    mem[_49842 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _51977 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _51977 + 68] = mem[idx + _49842 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_51977 + 68] = mem[_51977 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _51977 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _33020 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33020] = 30
                                    mem[_33020 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _33542 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _33542 + 68] = mem[idx + _33020 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33542 + 68] = mem[_33542 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33542 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _35423 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35423] = 30
                                    mem[_35423 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _36257 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _36257 + 68] = mem[idx + _35423 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36257 + 68] = mem[_36257 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _36257 + -mem[64] + 100
                                _33262 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33262] = 26
                                mem[_33262 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _33262 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    _37991 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37991] = 30
                                    mem[_37991 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41375 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41375] = 30
                                    mem[_41375 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _43088 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43088 + 68] = mem[idx + _41375 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43088 + 68] = mem[_43088 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43088 + -mem[64] + 100
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = stor203[arg1]
                                    _50994 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50994] = 30
                                    mem[_50994 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _52734 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _52734 + 68] = mem[idx + _50994 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52734 + 68] = mem[_52734 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52734 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _38256 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38256] = 30
                                mem[_38256 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _39030 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _39030 + 68] = mem[idx + _38256 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39030 + 68] = mem[_39030 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39030 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _42138 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_42138] = 30
                                mem[_42138 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _44060 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _44060 + 68] = mem[idx + _42138 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_44060 + 68] = mem[_44060 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _44060 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                _51980 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_51980] = 30
                                mem[_51980 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _53453 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _53453 + 68] = mem[idx + _51980 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_53453 + 68] = mem[_53453 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _53453 + -mem[64] + 100
                            _31894 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31894] = 26
                            mem[_31894 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _33870 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33870] = 26
                                mem[_33870 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                            else:
                                _33871 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33871] = 26
                                mem[_33871 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                            if 0 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if _tFeePercent * arg2 / 10000 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _32759 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32759] = 26
                                    mem[_32759 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _32759 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            _37741 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37741] = 30
                                            mem[_37741 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _40062 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40062] = 30
                                            mem[_40062 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _41358 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _41358 + 68] = mem[idx + _40062 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41358 + 68] = mem[_41358 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41358 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _48584 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48584] = 30
                                            mem[_48584 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _50978 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _50978 + 68] = mem[idx + _48584 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50978 + 68] = mem[_50978 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50978 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _37857 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37857] = 30
                                        mem[_37857 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            _38248 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38248 + 68] = mem[idx + _37857 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38248 + 68] = mem[_38248 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38248 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _40779 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40779] = 30
                                        mem[_40779 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _42122 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42122 + 68] = mem[idx + _40779 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42122 + 68] = mem[_42122 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42122 + -mem[64] + 100
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _49826 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_49826] = 30
                                        mem[_49826 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _51970 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _51970 + 68] = mem[idx + _49826 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_51970 + 68] = mem[_51970 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _51970 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        _37856 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37856] = 30
                                        mem[_37856 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _38245 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38245 + 68] = mem[idx + _37856 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38245 + 68] = mem[_38245 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38245 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _40778 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40778] = 30
                                        mem[_40778 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _42119 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42119 + 68] = mem[idx + _40778 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42119 + 68] = mem[_42119 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42119 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _49825 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_49825] = 30
                                        mem[_49825 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _51967 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _51967 + 68] = mem[idx + _49825 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_51967 + 68] = mem[_51967 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _51967 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _37987 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37987] = 30
                                    mem[_37987 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        _38627 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38627 + 68] = mem[idx + _37987 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38627 + 68] = mem[_38627 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38627 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41357 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41357] = 30
                                    mem[_41357 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _43069 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43069 + 68] = mem[idx + _41357 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43069 + 68] = mem[_43069 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43069 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _50977 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50977] = 30
                                    mem[_50977 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _52723 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _52723 + 68] = mem[idx + _50977 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52723 + 68] = mem[_52723 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52723 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _33017 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33017] = 30
                                    mem[_33017 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _33538 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _33538 + 68] = mem[idx + _33017 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33538 + 68] = mem[_33538 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33538 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _35416 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35416] = 30
                                    mem[_35416 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _36249 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _36249 + 68] = mem[idx + _35416 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36249 + 68] = mem[_36249 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _36249 + -mem[64] + 100
                                _33257 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33257] = 26
                                mem[_33257 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _33257 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        _37990 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37990] = 30
                                        mem[_37990 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41367 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41367] = 30
                                        mem[_41367 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _43076 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43076 + 68] = mem[idx + _41367 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43076 + 68] = mem[_43076 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43076 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _50982 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50982] = 30
                                        mem[_50982 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _52728 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52728 + 68] = mem[idx + _50982 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52728 + 68] = mem[_52728 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52728 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38252 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38252] = 30
                                    mem[_38252 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                        _39024 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39024 + 68] = mem[idx + _38252 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39024 + 68] = mem[_39024 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39024 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42128 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42128] = 30
                                    mem[_42128 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _44050 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44050 + 68] = mem[idx + _42128 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44050 + 68] = mem[_44050 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44050 + -mem[64] + 100
                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _51974 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_51974] = 30
                                    mem[_51974 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _53445 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53445 + 68] = mem[idx + _51974 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53445 + 68] = mem[_53445 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53445 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    _38251 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38251] = 30
                                    mem[_38251 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _39021 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39021 + 68] = mem[idx + _38251 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39021 + 68] = mem[_39021 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39021 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42127 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42127] = 30
                                    mem[_42127 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _44047 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44047 + 68] = mem[idx + _42127 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44047 + 68] = mem[_44047 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44047 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _51973 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_51973] = 30
                                    mem[_51973 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _53442 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53442 + 68] = mem[idx + _51973 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53442 + 68] = mem[_53442 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53442 + -mem[64] + 100
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _38630 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38630] = 30
                                mem[_38630 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                    _39473 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _39473 + 68] = mem[idx + _38630 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39473 + 68] = mem[_39473 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39473 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _43075 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_43075] = 30
                                mem[_43075 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _45033 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _45033 + 68] = mem[idx + _43075 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_45033 + 68] = mem[_45033 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _45033 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                _52727 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_52727] = 30
                                mem[_52727 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                    return 1
                                _54330 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _54330 + 68] = mem[idx + _52727 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_54330 + 68] = mem[_54330 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _54330 + -mem[64] + 100
                            _31889 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31889] = 26
                            mem[_31889 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _33863 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33863] = 26
                                mem[_33863 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if t / s * _tFeePercent * arg2 / 10000 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                            else:
                                _33864 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33864] = 26
                                mem[_33864 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += _tFeePercent * arg2 / 10000
                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                    else:
                        mem[0] = msg.sender
                        mem[32] = 206
                        if not stor206[address(msg.sender)]:
                            if not arg2:
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _32734 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32734] = 26
                                        mem[_32734 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _32734 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _37732 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37732] = 30
                                            mem[_37732 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _39991 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_39991] = 30
                                            mem[_39991 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _41308 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _41308 + 68] = mem[idx + _39991 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41308 + 68] = mem[_41308 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41308 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _48482 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48482] = 30
                                            mem[_48482 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _50887 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _50887 + 68] = mem[idx + _48482 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50887 + 68] = mem[_50887 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50887 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _37848 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37848] = 30
                                        mem[_37848 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _38213 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38213 + 68] = mem[idx + _37848 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38213 + 68] = mem[_38213 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38213 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _40738 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40738] = 30
                                        mem[_40738 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _42051 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42051 + 68] = mem[idx + _40738 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42051 + 68] = mem[_42051 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42051 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _49732 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_49732] = 30
                                        mem[_49732 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _51897 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _51897 + 68] = mem[idx + _49732 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_51897 + 68] = mem[_51897 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _51897 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _33002 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33002] = 30
                                        mem[_33002 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _33518 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _33518 + 68] = mem[idx + _33002 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33518 + 68] = mem[_33518 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33518 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _35381 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35381] = 30
                                        mem[_35381 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _36209 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _36209 + 68] = mem[idx + _35381 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36209 + 68] = mem[_36209 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36209 + -mem[64] + 100
                                    _33232 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33232] = 26
                                    mem[_33232 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _33232 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _37979 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37979] = 30
                                        mem[_37979 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41313 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41313] = 30
                                        mem[_41313 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _42992 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42992 + 68] = mem[idx + _41313 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42992 + 68] = mem[_42992 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42992 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _50890 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50890] = 30
                                        mem[_50890 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _52672 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52672 + 68] = mem[idx + _50890 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52672 + 68] = mem[_52672 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52672 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38216 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38216] = 30
                                    mem[_38216 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _38982 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38982 + 68] = mem[idx + _38216 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38982 + 68] = mem[_38982 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38982 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42054 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42054] = 30
                                    mem[_42054 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _43974 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43974 + 68] = mem[idx + _42054 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43974 + 68] = mem[_43974 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43974 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _51900 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_51900] = 30
                                    mem[_51900 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _53375 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53375 + 68] = mem[idx + _51900 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53375 + 68] = mem[_53375 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53375 + -mem[64] + 100
                                _31864 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31864] = 26
                                mem[_31864 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _33828 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33828] = 26
                                    mem[_33828 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                else:
                                    _33829 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33829] = 26
                                    mem[_33829 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if _tFeePercent * arg2 / 10000 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _32729 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32729] = 26
                                        mem[_32729 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _32729 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                _37731 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37731] = 30
                                                mem[_37731 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _39980 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_39980] = 30
                                                mem[_39980 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _41296 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _41296 + 68] = mem[idx + _39980 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_41296 + 68] = mem[_41296 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _41296 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _48462 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_48462] = 30
                                                mem[_48462 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                    return 1
                                                _50874 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _50874 + 68] = mem[idx + _48462 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_50874 + 68] = mem[_50874 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _50874 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _37845 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37845] = 30
                                            mem[_37845 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                _38208 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38208 + 68] = mem[idx + _37845 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38208 + 68] = mem[_38208 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38208 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _40731 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40731] = 30
                                            mem[_40731 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _42038 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42038 + 68] = mem[idx + _40731 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42038 + 68] = mem[_42038 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42038 + -mem[64] + 100
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _49716 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_49716] = 30
                                            mem[_49716 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _51890 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _51890 + 68] = mem[idx + _49716 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_51890 + 68] = mem[_51890 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _51890 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            _37844 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37844] = 30
                                            mem[_37844 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _38205 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38205 + 68] = mem[idx + _37844 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38205 + 68] = mem[_38205 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38205 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _40730 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40730] = 30
                                            mem[_40730 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _42035 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42035 + 68] = mem[idx + _40730 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42035 + 68] = mem[_42035 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42035 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _49715 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_49715] = 30
                                            mem[_49715 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _51887 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _51887 + 68] = mem[idx + _49715 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_51887 + 68] = mem[_51887 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _51887 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _37975 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37975] = 30
                                        mem[_37975 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            _38599 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38599 + 68] = mem[idx + _37975 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38599 + 68] = mem[_38599 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38599 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41295 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41295] = 30
                                        mem[_41295 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _42973 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42973 + 68] = mem[idx + _41295 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42973 + 68] = mem[_42973 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42973 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _50873 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50873] = 30
                                        mem[_50873 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _52661 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52661 + 68] = mem[idx + _50873 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52661 + 68] = mem[_52661 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52661 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _32999 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32999] = 30
                                        mem[_32999 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _33514 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _33514 + 68] = mem[idx + _32999 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33514 + 68] = mem[_33514 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33514 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _35374 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35374] = 30
                                        mem[_35374 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _36201 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _36201 + 68] = mem[idx + _35374 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36201 + 68] = mem[_36201 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36201 + -mem[64] + 100
                                    _33227 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33227] = 26
                                    mem[_33227 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _33227 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            _37978 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37978] = 30
                                            mem[_37978 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41305 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41305] = 30
                                            mem[_41305 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _42980 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42980 + 68] = mem[idx + _41305 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42980 + 68] = mem[_42980 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42980 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _50878 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50878] = 30
                                            mem[_50878 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _52666 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52666 + 68] = mem[idx + _50878 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52666 + 68] = mem[_52666 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52666 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38212 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38212] = 30
                                        mem[_38212 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            _38976 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38976 + 68] = mem[idx + _38212 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38976 + 68] = mem[_38976 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38976 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42044 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42044] = 30
                                        mem[_42044 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _43964 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43964 + 68] = mem[idx + _42044 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43964 + 68] = mem[_43964 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43964 + -mem[64] + 100
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _51894 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51894] = 30
                                        mem[_51894 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _53367 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53367 + 68] = mem[idx + _51894 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53367 + 68] = mem[_53367 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53367 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        _38211 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38211] = 30
                                        mem[_38211 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _38973 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38973 + 68] = mem[idx + _38211 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38973 + 68] = mem[_38973 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38973 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42043 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42043] = 30
                                        mem[_42043 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _43961 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43961 + 68] = mem[idx + _42043 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43961 + 68] = mem[_43961 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43961 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _51893 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51893] = 30
                                        mem[_51893 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _53364 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53364 + 68] = mem[idx + _51893 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53364 + 68] = mem[_53364 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53364 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38602 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38602] = 30
                                    mem[_38602 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        _39439 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39439 + 68] = mem[idx + _38602 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39439 + 68] = mem[_39439 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39439 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42979 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42979] = 30
                                    mem[_42979 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _44931 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44931 + 68] = mem[idx + _42979 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44931 + 68] = mem[_44931 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44931 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _52665 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52665] = 30
                                    mem[_52665 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _54236 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54236 + 68] = mem[idx + _52665 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54236 + 68] = mem[_54236 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54236 + -mem[64] + 100
                                _31859 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31859] = 26
                                mem[_31859 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _33821 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33821] = 26
                                    mem[_33821 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                else:
                                    _33822 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33822] = 26
                                    mem[_33822 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                        else:
                            mem[0] = arg1
                            mem[32] = 206
                            if not stor206[address(arg1)]:
                                if not arg2:
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero'
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _32744 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32744] = 26
                                            mem[_32744 + 32] = 'SafeMath: division by zero'
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _32744 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                _37736 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37736] = 30
                                                mem[_37736 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _40022 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40022] = 30
                                                mem[_40022 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _41331 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _41331 + 68] = mem[idx + _40022 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_41331 + 68] = mem[_41331 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _41331 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _48524 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_48524] = 30
                                                mem[_48524 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    return 1
                                                _50923 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _50923 + 68] = mem[idx + _48524 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_50923 + 68] = mem[_50923 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _50923 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _37853 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37853] = 30
                                            mem[_37853 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _38229 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38229 + 68] = mem[idx + _37853 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38229 + 68] = mem[_38229 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38229 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _40758 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40758] = 30
                                            mem[_40758 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _42083 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42083 + 68] = mem[idx + _40758 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42083 + 68] = mem[_42083 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42083 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _49771 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_49771] = 30
                                            mem[_49771 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _51921 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _51921 + 68] = mem[idx + _49771 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_51921 + 68] = mem[_51921 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _51921 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _33008 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33008] = 30
                                            mem[_33008 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _33526 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _33526 + 68] = mem[idx + _33008 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_33526 + 68] = mem[_33526 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _33526 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _35395 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35395] = 30
                                            mem[_35395 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _36225 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _36225 + 68] = mem[idx + _35395 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36225 + 68] = mem[_36225 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36225 + -mem[64] + 100
                                        _33242 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33242] = 26
                                        mem[_33242 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _33242 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _37984 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37984] = 30
                                            mem[_37984 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41336 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41336] = 30
                                            mem[_41336 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _43028 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43028 + 68] = mem[idx + _41336 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43028 + 68] = mem[_43028 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43028 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _50926 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50926] = 30
                                            mem[_50926 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _52690 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52690 + 68] = mem[idx + _50926 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52690 + 68] = mem[_52690 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52690 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38232 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38232] = 30
                                        mem[_38232 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39000 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39000 + 68] = mem[idx + _38232 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39000 + 68] = mem[_39000 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39000 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42086 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42086] = 30
                                        mem[_42086 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _44006 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44006 + 68] = mem[idx + _42086 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44006 + 68] = mem[_44006 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44006 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _51924 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51924] = 30
                                        mem[_51924 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _53397 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53397 + 68] = mem[idx + _51924 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53397 + 68] = mem[_53397 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53397 + -mem[64] + 100
                                    _31874 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31874] = 26
                                    mem[_31874 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _33842 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33842] = 26
                                        mem[_33842 + 32] = 'SafeMath: division by zero'
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                    else:
                                        _33843 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33843] = 26
                                        mem[_33843 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero'
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if _tFeePercent * arg2 / 10000 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _32739 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32739] = 26
                                            mem[_32739 + 32] = 'SafeMath: division by zero'
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _32739 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                if not _tFeePercent * arg2 / 10000:
                                                    _37735 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_37735] = 30
                                                    mem[_37735 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 203
                                                    _40011 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_40011] = 30
                                                    mem[_40011 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor203[address(msg.sender)]:
                                                        _41319 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _41319 + 68] = mem[idx + _40011 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_41319 + 68] = mem[_41319 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _41319 + -mem[64] + 100
                                                    if stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 203
                                                    stor203[address(arg1)] = stor203[arg1]
                                                    _48504 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_48504] = 30
                                                    mem[_48504 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor209:
                                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += _tFeePercent * arg2 / 10000
                                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                        return 1
                                                    _50910 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _50910 + 68] = mem[idx + _48504 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_50910 + 68] = mem[_50910 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _50910 + -mem[64] + 100
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _37850 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37850] = 30
                                                mem[_37850 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                    _38224 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _38224 + 68] = mem[idx + _37850 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_38224 + 68] = mem[_38224 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _38224 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _40751 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40751] = 30
                                                mem[_40751 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _42070 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _42070 + 68] = mem[idx + _40751 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42070 + 68] = mem[_42070 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42070 + -mem[64] + 100
                                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                _49755 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_49755] = 30
                                                mem[_49755 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                    return 1
                                                _51914 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _51914 + 68] = mem[idx + _49755 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_51914 + 68] = mem[_51914 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _51914 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not _tFeePercent * arg2 / 10000:
                                                _37849 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37849] = 30
                                                mem[_37849 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor209 / totalSupply * arg2:
                                                    _38221 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _38221 + 68] = mem[idx + _37849 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_38221 + 68] = mem[_38221 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _38221 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _40750 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40750] = 30
                                                mem[_40750 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    _42067 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _42067 + 68] = mem[idx + _40750 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42067 + 68] = mem[_42067 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42067 + -mem[64] + 100
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                                _49754 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_49754] = 30
                                                mem[_49754 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                    return 1
                                                _51911 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _51911 + 68] = mem[idx + _49754 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_51911 + 68] = mem[_51911 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _51911 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _37980 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37980] = 30
                                            mem[_37980 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                _38611 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38611 + 68] = mem[idx + _37980 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38611 + 68] = mem[_38611 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38611 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41318 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41318] = 30
                                            mem[_41318 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _43009 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43009 + 68] = mem[idx + _41318 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43009 + 68] = mem[_43009 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43009 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _50909 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50909] = 30
                                            mem[_50909 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _52679 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52679 + 68] = mem[idx + _50909 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52679 + 68] = mem[_52679 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52679 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _33005 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33005] = 30
                                            mem[_33005 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _33522 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _33522 + 68] = mem[idx + _33005 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_33522 + 68] = mem[_33522 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _33522 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _35388 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35388] = 30
                                            mem[_35388 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _36217 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _36217 + 68] = mem[idx + _35388 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36217 + 68] = mem[_36217 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36217 + -mem[64] + 100
                                        _33237 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33237] = 26
                                        mem[_33237 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _33237 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                _37983 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37983] = 30
                                                mem[_37983 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _41328 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41328] = 30
                                                mem[_41328 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _43016 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _43016 + 68] = mem[idx + _41328 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_43016 + 68] = mem[_43016 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _43016 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _50914 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_50914] = 30
                                                mem[_50914 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                    return 1
                                                _52684 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _52684 + 68] = mem[idx + _50914 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_52684 + 68] = mem[_52684 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _52684 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _38228 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38228] = 30
                                            mem[_38228 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                _38994 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38994 + 68] = mem[idx + _38228 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38994 + 68] = mem[_38994 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38994 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42076 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42076] = 30
                                            mem[_42076 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _43996 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43996 + 68] = mem[idx + _42076 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43996 + 68] = mem[_43996 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43996 + -mem[64] + 100
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _51918 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51918] = 30
                                            mem[_51918 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _53389 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53389 + 68] = mem[idx + _51918 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53389 + 68] = mem[_53389 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53389 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            _38227 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38227] = 30
                                            mem[_38227 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _38991 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38991 + 68] = mem[idx + _38227 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38991 + 68] = mem[_38991 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38991 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42075 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42075] = 30
                                            mem[_42075 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _43993 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43993 + 68] = mem[idx + _42075 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43993 + 68] = mem[_43993 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43993 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _51917 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51917] = 30
                                            mem[_51917 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _53386 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53386 + 68] = mem[idx + _51917 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53386 + 68] = mem[_53386 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53386 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38614 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38614] = 30
                                        mem[_38614 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            _39453 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39453 + 68] = mem[idx + _38614 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39453 + 68] = mem[_39453 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39453 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _43015 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43015] = 30
                                        mem[_43015 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _44969 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44969 + 68] = mem[idx + _43015 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44969 + 68] = mem[_44969 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44969 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _52683 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52683] = 30
                                        mem[_52683 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _54268 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54268 + 68] = mem[idx + _52683 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54268 + 68] = mem[_54268 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54268 + -mem[64] + 100
                                    _31869 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31869] = 26
                                    mem[_31869 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _33835 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33835] = 26
                                        mem[_33835 + 32] = 'SafeMath: division by zero'
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if t / s * _tFeePercent * arg2 / 10000 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > t / s * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if t / s * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                                if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if t / s * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                                if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                    else:
                                        _33836 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33836] = 26
                                        mem[_33836 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > stor209 / totalSupply * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                            else:
                                if not arg2:
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero'
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _32754 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32754] = 26
                                            mem[_32754 + 32] = 'SafeMath: division by zero'
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _32754 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                _37738 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37738] = 30
                                                mem[_37738 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 204
                                                _40042 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40042] = 30
                                                mem[_40042 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    _41347 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _41347 + 68] = mem[idx + _40042 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_41347 + 68] = mem[_41347 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _41347 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                stor204[address(msg.sender)] -= arg2
                                                mem[32] = 203
                                                _44025 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_44025] = 30
                                                mem[_44025 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _46165 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _46165 + 68] = mem[idx + _44025 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_46165 + 68] = mem[_46165 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _46165 + -mem[64] + 100
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                _56199 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_56199] = 30
                                                mem[_56199 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    return 1
                                                _57854 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _57854 + 68] = mem[idx + _56199 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_57854 + 68] = mem[_57854 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _57854 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _37855 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37855] = 30
                                            mem[_37855 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _38237 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38237 + 68] = mem[idx + _37855 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38237 + 68] = mem[_38237 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38237 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _40766 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40766] = 30
                                            mem[_40766 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _42103 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42103 + 68] = mem[idx + _40766 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42103 + 68] = mem[_42103 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42103 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _45008 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45008] = 30
                                            mem[_45008 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _47371 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _47371 + 68] = mem[idx + _45008 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_47371 + 68] = mem[_47371 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _47371 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                            _56990 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_56990] = 30
                                            mem[_56990 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _58713 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _58713 + 68] = mem[idx + _56990 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_58713 + 68] = mem[_58713 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _58713 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _33014 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33014] = 30
                                            mem[_33014 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _33534 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _33534 + 68] = mem[idx + _33014 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_33534 + 68] = mem[_33534 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _33534 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _35409 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35409] = 30
                                            mem[_35409 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _36241 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _36241 + 68] = mem[idx + _35409 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36241 + 68] = mem[_36241 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36241 + -mem[64] + 100
                                        _33252 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33252] = 26
                                        mem[_33252 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _33252 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _37986 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37986] = 30
                                            mem[_37986 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _41352 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41352] = 30
                                            mem[_41352 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _43052 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43052 + 68] = mem[idx + _41352 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43052 + 68] = mem[_43052 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43052 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _46171 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_46171] = 30
                                            mem[_46171 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _48564 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _48564 + 68] = mem[idx + _46171 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_48564 + 68] = mem[_48564 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _48564 + -mem[64] + 100
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            _57857 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_57857] = 30
                                            mem[_57857 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _59386 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _59386 + 68] = mem[idx + _57857 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_59386 + 68] = mem[_59386 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _59386 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38240 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38240] = 30
                                        mem[_38240 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39012 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39012 + 68] = mem[idx + _38240 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39012 + 68] = mem[_39012 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39012 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _42106 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42106] = 30
                                        mem[_42106 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _44028 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44028 + 68] = mem[idx + _42106 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44028 + 68] = mem[_44028 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44028 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _47374 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_47374] = 30
                                        mem[_47374 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _49802 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _49802 + 68] = mem[idx + _47374 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_49802 + 68] = mem[_49802 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _49802 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                                        _58716 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_58716] = 30
                                        mem[_58716 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _59964 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _59964 + 68] = mem[idx + _58716 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_59964 + 68] = mem[_59964 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _59964 + -mem[64] + 100
                                    _31884 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31884] = 26
                                    mem[_31884 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _33856 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33856] = 26
                                        mem[_33856 + 32] = 'SafeMath: division by zero'
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] += t / s * arg2
                                    else:
                                        _33857 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33857] = 26
                                        mem[_33857 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                else:
                                    if 0 / arg2:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero'
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _32749 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32749] = 26
                                            mem[_32749 + 32] = 'SafeMath: division by zero'
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _32749 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                _37737 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37737] = 30
                                                mem[_37737 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 204
                                                _40032 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40032] = 30
                                                mem[_40032 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    _41339 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _41339 + 68] = mem[idx + _40032 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_41339 + 68] = mem[_41339 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _41339 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                stor204[address(msg.sender)] -= arg2
                                                mem[32] = 203
                                                _44014 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_44014] = 30
                                                mem[_44014 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _46149 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _46149 + 68] = mem[idx + _44014 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_46149 + 68] = mem[_46149 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _46149 + -mem[64] + 100
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                _56191 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_56191] = 30
                                                mem[_56191 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    return 1
                                                _57844 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _57844 + 68] = mem[idx + _56191 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_57844 + 68] = mem[_57844 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _57844 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _37854 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37854] = 30
                                            mem[_37854 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _38233 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38233 + 68] = mem[idx + _37854 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38233 + 68] = mem[_38233 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38233 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _40762 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40762] = 30
                                            mem[_40762 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _42093 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42093 + 68] = mem[idx + _40762 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42093 + 68] = mem[_42093 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42093 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _44995 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_44995] = 30
                                            mem[_44995 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _47358 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _47358 + 68] = mem[idx + _44995 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_47358 + 68] = mem[_47358 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _47358 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                            _56984 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_56984] = 30
                                            mem[_56984 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _58707 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _58707 + 68] = mem[idx + _56984 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_58707 + 68] = mem[_58707 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _58707 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _33011 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33011] = 30
                                            mem[_33011 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _33530 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _33530 + 68] = mem[idx + _33011 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_33530 + 68] = mem[_33530 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _33530 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _35402 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35402] = 30
                                            mem[_35402 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _36233 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _36233 + 68] = mem[idx + _35402 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36233 + 68] = mem[_36233 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36233 + -mem[64] + 100
                                        _33247 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33247] = 26
                                        mem[_33247 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _33247 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _37985 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37985] = 30
                                            mem[_37985 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _41344 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41344] = 30
                                            mem[_41344 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _43040 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43040 + 68] = mem[idx + _41344 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43040 + 68] = mem[_43040 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43040 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _46155 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_46155] = 30
                                            mem[_46155 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _48545 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _48545 + 68] = mem[idx + _46155 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_48545 + 68] = mem[_48545 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _48545 + -mem[64] + 100
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            _57847 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_57847] = 30
                                            mem[_57847 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _59380 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _59380 + 68] = mem[idx + _57847 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_59380 + 68] = mem[_59380 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _59380 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38236 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38236] = 30
                                        mem[_38236 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39006 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39006 + 68] = mem[idx + _38236 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39006 + 68] = mem[_39006 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39006 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _42096 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42096] = 30
                                        mem[_42096 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _44017 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44017 + 68] = mem[idx + _42096 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44017 + 68] = mem[_44017 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44017 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _47361 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_47361] = 30
                                        mem[_47361 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _49786 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _49786 + 68] = mem[idx + _47361 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_49786 + 68] = mem[_49786 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _49786 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                                        _58710 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_58710] = 30
                                        mem[_58710 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _59956 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _59956 + 68] = mem[idx + _58710 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_59956 + 68] = mem[_59956 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _59956 + -mem[64] + 100
                                    _31879 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31879] = 26
                                    mem[_31879 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _33849 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33849] = 26
                                        mem[_33849 + 32] = 'SafeMath: division by zero'
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] += t / s * arg2
                                    else:
                                        _33850 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33850] = 26
                                        mem[_33850 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
    else:
        mem[0] = arg1
        mem[32] = 206
        if not stor206[address(arg1)]:
            if not arg2:
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                mem[64] = 224
                mem[160] = 30
                mem[192] = 'SafeMath: subtraction overflow'
                if 0 > arg2:
                    revert with 0, 'SafeMath: subtraction overflow'
                idx = 0
                s = totalSupply
                t = stor209
                while idx < stor207.length:
                    mem[0] = stor207[idx]
                    mem[32] = 203
                    if stor203[stor207[idx]] > t:
                        _32934 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32934] = 26
                        mem[_32934 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _32934 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not arg2:
                            _37802 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_37802] = 30
                            mem[_37802 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 204
                            _40556 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_40556] = 30
                            mem[_40556 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor204[address(msg.sender)]:
                                _41733 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _41733 + 68] = mem[idx + _40556 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_41733 + 68] = mem[_41733 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _41733 + -mem[64] + 100
                            mem[0] = msg.sender
                            stor204[address(msg.sender)] -= arg2
                            mem[32] = 203
                            _44563 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_44563] = 30
                            mem[_44563 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor203[address(msg.sender)]:
                                _46914 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _46914 + 68] = mem[idx + _44563 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_46914 + 68] = mem[_46914 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _46914 + -mem[64] + 100
                            if stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] = stor203[arg1]
                            _53901 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_53901] = 30
                            mem[_53901 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor209:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _55865 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _55865 + 68] = mem[idx + _53901 + 32]
                                idx = idx + 32
                                continue 
                            mem[_55865 + 68] = mem[_55865 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _55865 + -mem[64] + 100
                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _37933 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_37933] = 30
                        mem[_37933 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor209 / totalSupply * arg2:
                            _38493 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _38493 + 68] = mem[idx + _37933 + 32]
                                idx = idx + 32
                                continue 
                            mem[_38493 + 68] = mem[_38493 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _38493 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 204
                        _41078 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_41078] = 30
                        mem[_41078 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor204[address(msg.sender)]:
                            _42631 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _42631 + 68] = mem[idx + _41078 + 32]
                                idx = idx + 32
                                continue 
                            mem[_42631 + 68] = mem[_42631 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _42631 + -mem[64] + 100
                        mem[0] = msg.sender
                        stor204[address(msg.sender)] -= arg2
                        mem[32] = 203
                        _45643 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_45643] = 30
                        mem[_45643 + 32] = 'SafeMath: subtraction overflow'
                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                            _48030 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _48030 + 68] = mem[idx + _45643 + 32]
                                idx = idx + 32
                                continue 
                            mem[_48030 + 68] = mem[_48030 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _48030 + -mem[64] + 100
                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 203
                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                        _54867 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_54867] = 30
                        mem[_54867 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor209:
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                            return 1
                        _56661 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _56661 + 68] = mem[idx + _54867 + 32]
                            idx = idx + 32
                            continue 
                        mem[_56661 + 68] = mem[_56661 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _56661 + -mem[64] + 100
                    require idx < stor207.length
                    mem[0] = stor207[idx]
                    mem[32] = 204
                    if stor204[stor207[idx]] <= s:
                        require idx < stor207.length
                        mem[0] = stor207[idx]
                        mem[32] = 203
                        _33122 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33122] = 30
                        mem[_33122 + 32] = 'SafeMath: subtraction overflow'
                        if stor203[stor207[idx]] > t:
                            _33678 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _33678 + 68] = mem[idx + _33122 + 32]
                                idx = idx + 32
                                continue 
                            mem[_33678 + 68] = mem[_33678 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _33678 + -mem[64] + 100
                        require idx < stor207.length
                        mem[0] = stor207[idx]
                        mem[32] = 204
                        _35661 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35661] = 30
                        mem[_35661 + 32] = 'SafeMath: subtraction overflow'
                        if stor204[stor207[idx]] <= s:
                            idx = idx + 1
                            s = s - stor204[stor207[idx]]
                            t = t - stor203[stor207[idx]]
                            continue 
                        _36529 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _36529 + 68] = mem[idx + _35661 + 32]
                            idx = idx + 32
                            continue 
                        mem[_36529 + 68] = mem[_36529 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _36529 + -mem[64] + 100
                    _33432 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_33432] = 26
                    mem[_33432 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _33432 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if not arg2:
                        _38064 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_38064] = 30
                        mem[_38064 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = msg.sender
                        mem[32] = 204
                        _41738 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_41738] = 30
                        mem[_41738 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor204[address(msg.sender)]:
                            _43652 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _43652 + 68] = mem[idx + _41738 + 32]
                                idx = idx + 32
                                continue 
                            mem[_43652 + 68] = mem[_43652 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _43652 + -mem[64] + 100
                        mem[0] = msg.sender
                        stor204[address(msg.sender)] -= arg2
                        mem[32] = 203
                        _46920 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_46920] = 30
                        mem[_46920 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor203[address(msg.sender)]:
                            _49323 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _49323 + 68] = mem[idx + _46920 + 32]
                                idx = idx + 32
                                continue 
                            mem[_49323 + 68] = mem[_49323 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _49323 + -mem[64] + 100
                        if stor203[arg1] < stor203[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 203
                        stor203[address(arg1)] = stor203[arg1]
                        _55868 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_55868] = 30
                        mem[_55868 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor209:
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                            return 1
                        _57460 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _57460 + 68] = mem[idx + _55868 + 32]
                            idx = idx + 32
                            continue 
                        mem[_57460 + 68] = mem[_57460 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _57460 + -mem[64] + 100
                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _38496 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_38496] = 30
                    mem[_38496 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor209 / totalSupply * arg2:
                        _39312 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _39312 + 68] = mem[idx + _38496 + 32]
                            idx = idx + 32
                            continue 
                        mem[_39312 + 68] = mem[_39312 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _39312 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 204
                    _42634 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_42634] = 30
                    mem[_42634 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 > stor204[address(msg.sender)]:
                        _44566 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _44566 + 68] = mem[idx + _42634 + 32]
                            idx = idx + 32
                            continue 
                        mem[_44566 + 68] = mem[_44566 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _44566 + -mem[64] + 100
                    mem[0] = msg.sender
                    stor204[address(msg.sender)] -= arg2
                    mem[32] = 203
                    _48033 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_48033] = 30
                    mem[_48033 + 32] = 'SafeMath: subtraction overflow'
                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                        _50504 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _50504 + 68] = mem[idx + _48033 + 32]
                            idx = idx + 32
                            continue 
                        mem[_50504 + 68] = mem[_50504 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _50504 + -mem[64] + 100
                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg1
                    mem[32] = 203
                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                    _56664 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_56664] = 30
                    mem[_56664 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor209:
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                        return 1
                    _58414 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _58414 + 68] = mem[idx + _56664 + 32]
                        idx = idx + 32
                        continue 
                    mem[_58414 + 68] = mem[_58414 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _58414 + -mem[64] + 100
                _32064 = mem[64]
                mem[64] = mem[64] + 64
                mem[_32064] = 26
                mem[_32064 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero'
                if t >= stor209 / totalSupply:
                    _34108 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_34108] = 26
                    mem[_34108 + 32] = 'SafeMath: division by zero'
                    if not s:
                        revert with 0, 'SafeMath: division by zero'
                    if not arg2:
                        if arg2 > stor204[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor204[address(msg.sender)] -= arg2
                        if 0 > stor203[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if stor203[arg1] < stor203[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor203[address(arg1)] = stor203[arg1]
                    else:
                        if t / s * arg2 / arg2 != t / s:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if 0 > t / s * arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 > stor204[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor204[address(msg.sender)] -= arg2
                        if t / s * arg2 > stor203[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor203[address(msg.sender)] += -1 * t / s * arg2
                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                else:
                    _34109 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_34109] = 26
                    mem[_34109 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero'
                    if not arg2:
                        if arg2 > stor204[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor204[address(msg.sender)] -= arg2
                        if 0 > stor203[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if stor203[arg1] < stor203[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor203[address(arg1)] = stor203[arg1]
                    else:
                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if 0 > stor209 / totalSupply * arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 > stor204[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor204[address(msg.sender)] -= arg2
                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                if 0 > stor209:
                    revert with 0, 'SafeMath: subtraction overflow'
                if totalFees < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                emit Transfer(arg2, msg.sender, arg1);
            else:
                if _tFeePercent * arg2 / arg2 != _tFeePercent:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                mem[64] = 224
                mem[160] = 30
                mem[192] = 'SafeMath: subtraction overflow'
                if _tFeePercent * arg2 / 10000 > arg2:
                    revert with 0, 'SafeMath: subtraction overflow'
                idx = 0
                s = totalSupply
                t = stor209
                while idx < stor207.length:
                    mem[0] = stor207[idx]
                    mem[32] = 203
                    if stor203[stor207[idx]] > t:
                        _32929 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32929] = 26
                        mem[_32929 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _32929 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        if not arg2:
                            if not _tFeePercent * arg2 / 10000:
                                _37801 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_37801] = 30
                                mem[_37801 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 204
                                _40545 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_40545] = 30
                                mem[_40545 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 > stor204[address(msg.sender)]:
                                    _41721 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _41721 + 68] = mem[idx + _40545 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_41721 + 68] = mem[_41721 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _41721 + -mem[64] + 100
                                mem[0] = msg.sender
                                stor204[address(msg.sender)] -= arg2
                                mem[32] = 203
                                _44549 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_44549] = 30
                                mem[_44549 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor203[address(msg.sender)]:
                                    _46895 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _46895 + 68] = mem[idx + _44549 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_46895 + 68] = mem[_46895 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _46895 + -mem[64] + 100
                                if stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = stor203[arg1]
                                _53881 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_53881] = 30
                                mem[_53881 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                    return 1
                                _55852 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _55852 + 68] = mem[idx + _53881 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_55852 + 68] = mem[_55852 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _55852 + -mem[64] + 100
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _37930 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_37930] = 30
                            mem[_37930 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                _38488 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _38488 + 68] = mem[idx + _37930 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_38488 + 68] = mem[_38488 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _38488 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 204
                            _41071 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_41071] = 30
                            mem[_41071 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor204[address(msg.sender)]:
                                _42618 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _42618 + 68] = mem[idx + _41071 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_42618 + 68] = mem[_42618 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _42618 + -mem[64] + 100
                            mem[0] = msg.sender
                            stor204[address(msg.sender)] -= arg2
                            mem[32] = 203
                            _45627 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_45627] = 30
                            mem[_45627 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor203[address(msg.sender)]:
                                _48011 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _48011 + 68] = mem[idx + _45627 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_48011 + 68] = mem[_48011 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _48011 + -mem[64] + 100
                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                            _54851 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_54851] = 30
                            mem[_54851 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                return 1
                            _56654 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _56654 + 68] = mem[idx + _54851 + 32]
                                idx = idx + 32
                                continue 
                            mem[_56654 + 68] = mem[_56654 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _56654 + -mem[64] + 100
                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not _tFeePercent * arg2 / 10000:
                            _37929 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_37929] = 30
                            mem[_37929 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor209 / totalSupply * arg2:
                                _38485 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _38485 + 68] = mem[idx + _37929 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_38485 + 68] = mem[_38485 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _38485 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 204
                            _41070 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_41070] = 30
                            mem[_41070 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor204[address(msg.sender)]:
                                _42615 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _42615 + 68] = mem[idx + _41070 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_42615 + 68] = mem[_42615 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _42615 + -mem[64] + 100
                            mem[0] = msg.sender
                            stor204[address(msg.sender)] -= arg2
                            mem[32] = 203
                            _45624 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_45624] = 30
                            mem[_45624 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                _48008 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _48008 + 68] = mem[idx + _45624 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_48008 + 68] = mem[_48008 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _48008 + -mem[64] + 100
                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                            _54850 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_54850] = 30
                            mem[_54850 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor209:
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                return 1
                            _56651 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _56651 + 68] = mem[idx + _54850 + 32]
                                idx = idx + 32
                                continue 
                            mem[_56651 + 68] = mem[_56651 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _56651 + -mem[64] + 100
                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _38060 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_38060] = 30
                        mem[_38060 + 32] = 'SafeMath: subtraction overflow'
                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                            _38799 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _38799 + 68] = mem[idx + _38060 + 32]
                                idx = idx + 32
                                continue 
                            mem[_38799 + 68] = mem[_38799 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _38799 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 204
                        _41720 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_41720] = 30
                        mem[_41720 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor204[address(msg.sender)]:
                            _43633 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _43633 + 68] = mem[idx + _41720 + 32]
                                idx = idx + 32
                                continue 
                            mem[_43633 + 68] = mem[_43633 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _43633 + -mem[64] + 100
                        mem[0] = msg.sender
                        stor204[address(msg.sender)] -= arg2
                        mem[32] = 203
                        _46890 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_46890] = 30
                        mem[_46890 + 32] = 'SafeMath: subtraction overflow'
                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                            _49293 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _49293 + 68] = mem[idx + _46890 + 32]
                                idx = idx + 32
                                continue 
                            mem[_49293 + 68] = mem[_49293 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _49293 + -mem[64] + 100
                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 203
                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                        _55851 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_55851] = 30
                        mem[_55851 + 32] = 'SafeMath: subtraction overflow'
                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += _tFeePercent * arg2 / 10000
                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                            return 1
                        _57449 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _57449 + 68] = mem[idx + _55851 + 32]
                            idx = idx + 32
                            continue 
                        mem[_57449 + 68] = mem[_57449 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _57449 + -mem[64] + 100
                    require idx < stor207.length
                    mem[0] = stor207[idx]
                    mem[32] = 204
                    if stor204[stor207[idx]] <= s:
                        require idx < stor207.length
                        mem[0] = stor207[idx]
                        mem[32] = 203
                        _33119 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_33119] = 30
                        mem[_33119 + 32] = 'SafeMath: subtraction overflow'
                        if stor203[stor207[idx]] > t:
                            _33674 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _33674 + 68] = mem[idx + _33119 + 32]
                                idx = idx + 32
                                continue 
                            mem[_33674 + 68] = mem[_33674 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _33674 + -mem[64] + 100
                        require idx < stor207.length
                        mem[0] = stor207[idx]
                        mem[32] = 204
                        _35654 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35654] = 30
                        mem[_35654 + 32] = 'SafeMath: subtraction overflow'
                        if stor204[stor207[idx]] <= s:
                            idx = idx + 1
                            s = s - stor204[stor207[idx]]
                            t = t - stor203[stor207[idx]]
                            continue 
                        _36521 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _36521 + 68] = mem[idx + _35654 + 32]
                            idx = idx + 32
                            continue 
                        mem[_36521 + 68] = mem[_36521 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _36521 + -mem[64] + 100
                    _33427 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_33427] = 26
                    mem[_33427 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _33427 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if not arg2:
                        if not _tFeePercent * arg2 / 10000:
                            _38063 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_38063] = 30
                            mem[_38063 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 204
                            _41730 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_41730] = 30
                            mem[_41730 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor204[address(msg.sender)]:
                                _43640 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _43640 + 68] = mem[idx + _41730 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_43640 + 68] = mem[_43640 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _43640 + -mem[64] + 100
                            mem[0] = msg.sender
                            stor204[address(msg.sender)] -= arg2
                            mem[32] = 203
                            _46904 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_46904] = 30
                            mem[_46904 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor203[address(msg.sender)]:
                                _49304 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _49304 + 68] = mem[idx + _46904 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_49304 + 68] = mem[_49304 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _49304 + -mem[64] + 100
                            if stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] = stor203[arg1]
                            _55856 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_55856] = 30
                            mem[_55856 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor209:
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                return 1
                            _57454 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _57454 + 68] = mem[idx + _55856 + 32]
                                idx = idx + 32
                                continue 
                            mem[_57454 + 68] = mem[_57454 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _57454 + -mem[64] + 100
                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _38492 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_38492] = 30
                        mem[_38492 + 32] = 'SafeMath: subtraction overflow'
                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                            _39306 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _39306 + 68] = mem[idx + _38492 + 32]
                                idx = idx + 32
                                continue 
                            mem[_39306 + 68] = mem[_39306 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _39306 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 204
                        _42624 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_42624] = 30
                        mem[_42624 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor204[address(msg.sender)]:
                            _44555 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _44555 + 68] = mem[idx + _42624 + 32]
                                idx = idx + 32
                                continue 
                            mem[_44555 + 68] = mem[_44555 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _44555 + -mem[64] + 100
                        mem[0] = msg.sender
                        stor204[address(msg.sender)] -= arg2
                        mem[32] = 203
                        _48020 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_48020] = 30
                        mem[_48020 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor203[address(msg.sender)]:
                            _50488 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _50488 + 68] = mem[idx + _48020 + 32]
                                idx = idx + 32
                                continue 
                            mem[_50488 + 68] = mem[_50488 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _50488 + -mem[64] + 100
                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 203
                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                        _56658 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_56658] = 30
                        mem[_56658 + 32] = 'SafeMath: subtraction overflow'
                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += _tFeePercent * arg2 / 10000
                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                            return 1
                        _58406 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _58406 + 68] = mem[idx + _56658 + 32]
                            idx = idx + 32
                            continue 
                        mem[_58406 + 68] = mem[_58406 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _58406 + -mem[64] + 100
                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not _tFeePercent * arg2 / 10000:
                        _38491 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_38491] = 30
                        mem[_38491 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor209 / totalSupply * arg2:
                            _39303 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _39303 + 68] = mem[idx + _38491 + 32]
                                idx = idx + 32
                                continue 
                            mem[_39303 + 68] = mem[_39303 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _39303 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 204
                        _42623 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_42623] = 30
                        mem[_42623 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor204[address(msg.sender)]:
                            _44552 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _44552 + 68] = mem[idx + _42623 + 32]
                                idx = idx + 32
                                continue 
                            mem[_44552 + 68] = mem[_44552 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _44552 + -mem[64] + 100
                        mem[0] = msg.sender
                        stor204[address(msg.sender)] -= arg2
                        mem[32] = 203
                        _48017 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_48017] = 30
                        mem[_48017 + 32] = 'SafeMath: subtraction overflow'
                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                            _50485 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _50485 + 68] = mem[idx + _48017 + 32]
                                idx = idx + 32
                                continue 
                            mem[_50485 + 68] = mem[_50485 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _50485 + -mem[64] + 100
                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 203
                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                        _56657 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_56657] = 30
                        mem[_56657 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor209:
                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += _tFeePercent * arg2 / 10000
                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                            return 1
                        _58403 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _58403 + 68] = mem[idx + _56657 + 32]
                            idx = idx + 32
                            continue 
                        mem[_58403 + 68] = mem[_58403 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _58403 + -mem[64] + 100
                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _38802 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_38802] = 30
                    mem[_38802 + 32] = 'SafeMath: subtraction overflow'
                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                        _39679 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _39679 + 68] = mem[idx + _38802 + 32]
                            idx = idx + 32
                            continue 
                        mem[_39679 + 68] = mem[_39679 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _39679 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 204
                    _43639 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_43639] = 30
                    mem[_43639 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 > stor204[address(msg.sender)]:
                        _45631 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _45631 + 68] = mem[idx + _43639 + 32]
                            idx = idx + 32
                            continue 
                        mem[_45631 + 68] = mem[_45631 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _45631 + -mem[64] + 100
                    mem[0] = msg.sender
                    stor204[address(msg.sender)] -= arg2
                    mem[32] = 203
                    _49299 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_49299] = 30
                    mem[_49299 + 32] = 'SafeMath: subtraction overflow'
                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                        _51591 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _51591 + 68] = mem[idx + _49299 + 32]
                            idx = idx + 32
                            continue 
                        mem[_51591 + 68] = mem[_51591 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _51591 + -mem[64] + 100
                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg1
                    mem[32] = 203
                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                    _57453 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_57453] = 30
                    mem[_57453 + 32] = 'SafeMath: subtraction overflow'
                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += _tFeePercent * arg2 / 10000
                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                        return 1
                    _59149 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _59149 + 68] = mem[idx + _57453 + 32]
                        idx = idx + 32
                        continue 
                    mem[_59149 + 68] = mem[_59149 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _59149 + -mem[64] + 100
                _32059 = mem[64]
                mem[64] = mem[64] + 64
                mem[_32059] = 26
                mem[_32059 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero'
                if t >= stor209 / totalSupply:
                    _34101 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_34101] = 26
                    mem[_34101 + 32] = 'SafeMath: division by zero'
                    if not s:
                        revert with 0, 'SafeMath: division by zero'
                    if not arg2:
                        if not _tFeePercent * arg2 / 10000:
                            if arg2 > stor204[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor204[address(msg.sender)] -= arg2
                            if 0 > stor203[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor203[address(arg1)] = stor203[arg1]
                            if 0 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                        else:
                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if t / s * _tFeePercent * arg2 / 10000 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 > stor204[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor204[address(msg.sender)] -= arg2
                            if 0 > stor203[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                    else:
                        if t / s * arg2 / arg2 != t / s:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not _tFeePercent * arg2 / 10000:
                            if 0 > t / s * arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 > stor204[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor204[address(msg.sender)] -= arg2
                            if t / s * arg2 > stor203[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor203[address(msg.sender)] += -1 * t / s * arg2
                            if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                            if 0 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                        else:
                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 > stor204[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor204[address(msg.sender)] -= arg2
                            if t / s * arg2 > stor203[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor203[address(msg.sender)] += -1 * t / s * arg2
                            if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                else:
                    _34102 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_34102] = 26
                    mem[_34102 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero'
                    if not arg2:
                        if not _tFeePercent * arg2 / 10000:
                            if arg2 > stor204[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor204[address(msg.sender)] -= arg2
                            if 0 > stor203[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor203[address(arg1)] = stor203[arg1]
                            if 0 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                        else:
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 > stor204[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor204[address(msg.sender)] -= arg2
                            if 0 > stor203[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                    else:
                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not _tFeePercent * arg2 / 10000:
                            if 0 > stor209 / totalSupply * arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 > stor204[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor204[address(msg.sender)] -= arg2
                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                            if 0 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                        else:
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 > stor204[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor204[address(msg.sender)] -= arg2
                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                totalFees += _tFeePercent * arg2 / 10000
                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
        else:
            if stor206[address(msg.sender)]:
                if stor206[address(msg.sender)]:
                    mem[0] = msg.sender
                    mem[32] = 206
                    if not stor206[address(msg.sender)]:
                        if not arg2:
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _32784 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32784] = 26
                                    mem[_32784 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _32784 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _37750 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37750] = 30
                                        mem[_37750 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _40135 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40135] = 30
                                        mem[_40135 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _41416 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _41416 + 68] = mem[idx + _40135 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41416 + 68] = mem[_41416 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41416 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _48693 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48693] = 30
                                        mem[_48693 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _51068 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _51068 + 68] = mem[idx + _48693 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_51068 + 68] = mem[_51068 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _51068 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _37870 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37870] = 30
                                    mem[_37870 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _38285 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38285 + 68] = mem[idx + _37870 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38285 + 68] = mem[_38285 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38285 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _40826 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_40826] = 30
                                    mem[_40826 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _42199 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _42199 + 68] = mem[idx + _40826 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42199 + 68] = mem[_42199 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42199 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _49928 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_49928] = 30
                                    mem[_49928 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _52030 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _52030 + 68] = mem[idx + _49928 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52030 + 68] = mem[_52030 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52030 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _33032 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33032] = 30
                                    mem[_33032 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _33558 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _33558 + 68] = mem[idx + _33032 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33558 + 68] = mem[_33558 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33558 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _35451 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35451] = 30
                                    mem[_35451 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _36289 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _36289 + 68] = mem[idx + _35451 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36289 + 68] = mem[_36289 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _36289 + -mem[64] + 100
                                _33282 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33282] = 26
                                mem[_33282 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _33282 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    _38001 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38001] = 30
                                    mem[_38001 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41421 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41421] = 30
                                    mem[_41421 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _43160 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43160 + 68] = mem[idx + _41421 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43160 + 68] = mem[_43160 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43160 + -mem[64] + 100
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = stor203[arg1]
                                    _51071 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_51071] = 30
                                    mem[_51071 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _52772 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _52772 + 68] = mem[idx + _51071 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52772 + 68] = mem[_52772 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52772 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _38288 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38288] = 30
                                mem[_38288 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _39066 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _39066 + 68] = mem[idx + _38288 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39066 + 68] = mem[_39066 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39066 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _42202 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_42202] = 30
                                mem[_42202 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _44124 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _44124 + 68] = mem[idx + _42202 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_44124 + 68] = mem[_44124 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _44124 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                _52033 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_52033] = 30
                                mem[_52033 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _53501 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _53501 + 68] = mem[idx + _52033 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_53501 + 68] = mem[_53501 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _53501 + -mem[64] + 100
                            _31914 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31914] = 26
                            mem[_31914 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _33898 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33898] = 26
                                mem[_33898 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                            else:
                                _33899 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33899] = 26
                                mem[_33899 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                            if 0 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if _tFeePercent * arg2 / 10000 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _32779 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32779] = 26
                                    mem[_32779 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _32779 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            _37749 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37749] = 30
                                            mem[_37749 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _40124 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40124] = 30
                                            mem[_40124 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _41404 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _41404 + 68] = mem[idx + _40124 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41404 + 68] = mem[_41404 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41404 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _48673 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48673] = 30
                                            mem[_48673 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _51055 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _51055 + 68] = mem[idx + _48673 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_51055 + 68] = mem[_51055 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _51055 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _37867 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37867] = 30
                                        mem[_37867 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            _38280 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38280 + 68] = mem[idx + _37867 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38280 + 68] = mem[_38280 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38280 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _40819 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40819] = 30
                                        mem[_40819 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _42186 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42186 + 68] = mem[idx + _40819 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42186 + 68] = mem[_42186 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42186 + -mem[64] + 100
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _49912 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_49912] = 30
                                        mem[_49912 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _52023 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52023 + 68] = mem[idx + _49912 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52023 + 68] = mem[_52023 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52023 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        _37866 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37866] = 30
                                        mem[_37866 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _38277 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38277 + 68] = mem[idx + _37866 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38277 + 68] = mem[_38277 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38277 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _40818 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40818] = 30
                                        mem[_40818 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _42183 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42183 + 68] = mem[idx + _40818 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42183 + 68] = mem[_42183 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42183 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _49911 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_49911] = 30
                                        mem[_49911 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _52020 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52020 + 68] = mem[idx + _49911 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52020 + 68] = mem[_52020 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52020 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _37997 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37997] = 30
                                    mem[_37997 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        _38651 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38651 + 68] = mem[idx + _37997 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38651 + 68] = mem[_38651 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38651 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41403 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41403] = 30
                                    mem[_41403 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _43141 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43141 + 68] = mem[idx + _41403 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43141 + 68] = mem[_43141 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43141 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _51054 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_51054] = 30
                                    mem[_51054 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _52761 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _52761 + 68] = mem[idx + _51054 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52761 + 68] = mem[_52761 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52761 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _33029 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33029] = 30
                                    mem[_33029 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _33554 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _33554 + 68] = mem[idx + _33029 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33554 + 68] = mem[_33554 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33554 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _35444 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35444] = 30
                                    mem[_35444 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _36281 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _36281 + 68] = mem[idx + _35444 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36281 + 68] = mem[_36281 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _36281 + -mem[64] + 100
                                _33277 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33277] = 26
                                mem[_33277 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _33277 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        _38000 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38000] = 30
                                        mem[_38000 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41413 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41413] = 30
                                        mem[_41413 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _43148 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43148 + 68] = mem[idx + _41413 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43148 + 68] = mem[_43148 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43148 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _51059 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51059] = 30
                                        mem[_51059 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _52766 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52766 + 68] = mem[idx + _51059 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52766 + 68] = mem[_52766 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52766 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38284 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38284] = 30
                                    mem[_38284 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                        _39060 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39060 + 68] = mem[idx + _38284 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39060 + 68] = mem[_39060 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39060 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42192 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42192] = 30
                                    mem[_42192 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _44114 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44114 + 68] = mem[idx + _42192 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44114 + 68] = mem[_44114 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44114 + -mem[64] + 100
                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _52027 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52027] = 30
                                    mem[_52027 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _53493 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53493 + 68] = mem[idx + _52027 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53493 + 68] = mem[_53493 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53493 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    _38283 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38283] = 30
                                    mem[_38283 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _39057 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39057 + 68] = mem[idx + _38283 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39057 + 68] = mem[_39057 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39057 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42191 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42191] = 30
                                    mem[_42191 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _44111 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44111 + 68] = mem[idx + _42191 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44111 + 68] = mem[_44111 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44111 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _52026 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52026] = 30
                                    mem[_52026 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _53490 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53490 + 68] = mem[idx + _52026 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53490 + 68] = mem[_53490 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53490 + -mem[64] + 100
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _38654 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38654] = 30
                                mem[_38654 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                    _39501 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _39501 + 68] = mem[idx + _38654 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39501 + 68] = mem[_39501 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39501 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _43147 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_43147] = 30
                                mem[_43147 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _45109 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _45109 + 68] = mem[idx + _43147 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_45109 + 68] = mem[_45109 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _45109 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                _52765 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_52765] = 30
                                mem[_52765 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                    return 1
                                _54384 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _54384 + 68] = mem[idx + _52765 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_54384 + 68] = mem[_54384 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _54384 + -mem[64] + 100
                            _31909 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31909] = 26
                            mem[_31909 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _33891 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33891] = 26
                                mem[_33891 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if t / s * _tFeePercent * arg2 / 10000 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                            else:
                                _33892 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33892] = 26
                                mem[_33892 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += _tFeePercent * arg2 / 10000
                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                    else:
                        mem[0] = arg1
                        mem[32] = 206
                        if not stor206[address(arg1)]:
                            if not arg2:
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _32794 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32794] = 26
                                        mem[_32794 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _32794 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _37754 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37754] = 30
                                            mem[_37754 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _40166 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40166] = 30
                                            mem[_40166 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _41439 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _41439 + 68] = mem[idx + _40166 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41439 + 68] = mem[_41439 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41439 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _48735 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48735] = 30
                                            mem[_48735 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _51104 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _51104 + 68] = mem[idx + _48735 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_51104 + 68] = mem[_51104 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _51104 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _37875 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37875] = 30
                                        mem[_37875 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _38301 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38301 + 68] = mem[idx + _37875 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38301 + 68] = mem[_38301 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38301 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _40846 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40846] = 30
                                        mem[_40846 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _42231 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42231 + 68] = mem[idx + _40846 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42231 + 68] = mem[_42231 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42231 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _49967 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_49967] = 30
                                        mem[_49967 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _52054 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52054 + 68] = mem[idx + _49967 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52054 + 68] = mem[_52054 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52054 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _33038 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33038] = 30
                                        mem[_33038 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _33566 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _33566 + 68] = mem[idx + _33038 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33566 + 68] = mem[_33566 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33566 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _35465 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35465] = 30
                                        mem[_35465 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _36305 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _36305 + 68] = mem[idx + _35465 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36305 + 68] = mem[_36305 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36305 + -mem[64] + 100
                                    _33292 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33292] = 26
                                    mem[_33292 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _33292 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _38006 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38006] = 30
                                        mem[_38006 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41444 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41444] = 30
                                        mem[_41444 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _43196 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43196 + 68] = mem[idx + _41444 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43196 + 68] = mem[_43196 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43196 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _51107 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51107] = 30
                                        mem[_51107 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _52790 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52790 + 68] = mem[idx + _51107 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52790 + 68] = mem[_52790 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52790 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38304 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38304] = 30
                                    mem[_38304 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _39084 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39084 + 68] = mem[idx + _38304 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39084 + 68] = mem[_39084 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39084 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42234 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42234] = 30
                                    mem[_42234 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _44156 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44156 + 68] = mem[idx + _42234 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44156 + 68] = mem[_44156 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44156 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _52057 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52057] = 30
                                    mem[_52057 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _53523 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53523 + 68] = mem[idx + _52057 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53523 + 68] = mem[_53523 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53523 + -mem[64] + 100
                                _31924 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31924] = 26
                                mem[_31924 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _33912 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33912] = 26
                                    mem[_33912 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                else:
                                    _33913 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33913] = 26
                                    mem[_33913 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if _tFeePercent * arg2 / 10000 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _32789 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32789] = 26
                                        mem[_32789 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _32789 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                _37753 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37753] = 30
                                                mem[_37753 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _40155 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40155] = 30
                                                mem[_40155 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _41427 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _41427 + 68] = mem[idx + _40155 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_41427 + 68] = mem[_41427 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _41427 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _48715 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_48715] = 30
                                                mem[_48715 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                    return 1
                                                _51091 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _51091 + 68] = mem[idx + _48715 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_51091 + 68] = mem[_51091 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _51091 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _37872 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37872] = 30
                                            mem[_37872 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                _38296 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38296 + 68] = mem[idx + _37872 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38296 + 68] = mem[_38296 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38296 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _40839 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40839] = 30
                                            mem[_40839 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _42218 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42218 + 68] = mem[idx + _40839 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42218 + 68] = mem[_42218 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42218 + -mem[64] + 100
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _49951 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_49951] = 30
                                            mem[_49951 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _52047 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52047 + 68] = mem[idx + _49951 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52047 + 68] = mem[_52047 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52047 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            _37871 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37871] = 30
                                            mem[_37871 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _38293 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38293 + 68] = mem[idx + _37871 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38293 + 68] = mem[_38293 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38293 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _40838 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40838] = 30
                                            mem[_40838 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _42215 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42215 + 68] = mem[idx + _40838 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42215 + 68] = mem[_42215 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42215 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _49950 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_49950] = 30
                                            mem[_49950 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _52044 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52044 + 68] = mem[idx + _49950 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52044 + 68] = mem[_52044 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52044 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38002 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38002] = 30
                                        mem[_38002 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            _38663 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38663 + 68] = mem[idx + _38002 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38663 + 68] = mem[_38663 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38663 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41426 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41426] = 30
                                        mem[_41426 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _43177 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43177 + 68] = mem[idx + _41426 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43177 + 68] = mem[_43177 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43177 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _51090 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51090] = 30
                                        mem[_51090 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _52779 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52779 + 68] = mem[idx + _51090 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52779 + 68] = mem[_52779 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52779 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _33035 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33035] = 30
                                        mem[_33035 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _33562 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _33562 + 68] = mem[idx + _33035 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33562 + 68] = mem[_33562 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33562 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _35458 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35458] = 30
                                        mem[_35458 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _36297 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _36297 + 68] = mem[idx + _35458 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36297 + 68] = mem[_36297 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36297 + -mem[64] + 100
                                    _33287 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33287] = 26
                                    mem[_33287 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _33287 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            _38005 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38005] = 30
                                            mem[_38005 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41436 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41436] = 30
                                            mem[_41436 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _43184 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43184 + 68] = mem[idx + _41436 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43184 + 68] = mem[_43184 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43184 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _51095 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51095] = 30
                                            mem[_51095 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _52784 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52784 + 68] = mem[idx + _51095 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52784 + 68] = mem[_52784 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52784 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38300 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38300] = 30
                                        mem[_38300 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            _39078 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39078 + 68] = mem[idx + _38300 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39078 + 68] = mem[_39078 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39078 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42224 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42224] = 30
                                        mem[_42224 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _44146 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44146 + 68] = mem[idx + _42224 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44146 + 68] = mem[_44146 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44146 + -mem[64] + 100
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _52051 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52051] = 30
                                        mem[_52051 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _53515 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53515 + 68] = mem[idx + _52051 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53515 + 68] = mem[_53515 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53515 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        _38299 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38299] = 30
                                        mem[_38299 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39075 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39075 + 68] = mem[idx + _38299 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39075 + 68] = mem[_39075 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39075 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42223 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42223] = 30
                                        mem[_42223 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _44143 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44143 + 68] = mem[idx + _42223 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44143 + 68] = mem[_44143 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44143 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _52050 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52050] = 30
                                        mem[_52050 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _53512 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53512 + 68] = mem[idx + _52050 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53512 + 68] = mem[_53512 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53512 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38666 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38666] = 30
                                    mem[_38666 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        _39515 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39515 + 68] = mem[idx + _38666 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39515 + 68] = mem[_39515 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39515 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _43183 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43183] = 30
                                    mem[_43183 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _45147 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45147 + 68] = mem[idx + _43183 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45147 + 68] = mem[_45147 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45147 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _52783 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52783] = 30
                                    mem[_52783 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _54416 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54416 + 68] = mem[idx + _52783 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54416 + 68] = mem[_54416 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54416 + -mem[64] + 100
                                _31919 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31919] = 26
                                mem[_31919 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _33905 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33905] = 26
                                    mem[_33905 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                else:
                                    _33906 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33906] = 26
                                    mem[_33906 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                        else:
                            if not arg2:
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _32804 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32804] = 26
                                        mem[_32804 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _32804 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _37756 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37756] = 30
                                            mem[_37756 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _40186 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40186] = 30
                                            mem[_40186 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _41455 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _41455 + 68] = mem[idx + _40186 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41455 + 68] = mem[_41455 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41455 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _44175 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_44175] = 30
                                            mem[_44175 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _46375 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _46375 + 68] = mem[idx + _44175 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_46375 + 68] = mem[_46375 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _46375 + -mem[64] + 100
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            _56327 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_56327] = 30
                                            mem[_56327 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _58015 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _58015 + 68] = mem[idx + _56327 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_58015 + 68] = mem[_58015 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _58015 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _37877 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37877] = 30
                                        mem[_37877 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _38309 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38309 + 68] = mem[idx + _37877 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38309 + 68] = mem[_38309 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38309 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _40854 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40854] = 30
                                        mem[_40854 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _42251 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42251 + 68] = mem[idx + _40854 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42251 + 68] = mem[_42251 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42251 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _45186 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_45186] = 30
                                        mem[_45186 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _47556 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _47556 + 68] = mem[idx + _45186 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_47556 + 68] = mem[_47556 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _47556 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                                        _57127 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_57127] = 30
                                        mem[_57127 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _58839 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _58839 + 68] = mem[idx + _57127 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_58839 + 68] = mem[_58839 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _58839 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _33044 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33044] = 30
                                        mem[_33044 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _33574 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _33574 + 68] = mem[idx + _33044 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33574 + 68] = mem[_33574 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33574 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _35479 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35479] = 30
                                        mem[_35479 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _36321 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _36321 + 68] = mem[idx + _35479 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36321 + 68] = mem[_36321 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36321 + -mem[64] + 100
                                    _33302 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33302] = 26
                                    mem[_33302 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _33302 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _38008 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38008] = 30
                                        mem[_38008 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _41460 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41460] = 30
                                        mem[_41460 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _43220 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43220 + 68] = mem[idx + _41460 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43220 + 68] = mem[_43220 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43220 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _46381 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_46381] = 30
                                        mem[_46381 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _48775 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _48775 + 68] = mem[idx + _46381 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48775 + 68] = mem[_48775 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48775 + -mem[64] + 100
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        _58018 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_58018] = 30
                                        mem[_58018 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _59485 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _59485 + 68] = mem[idx + _58018 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_59485 + 68] = mem[_59485 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _59485 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38312 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38312] = 30
                                    mem[_38312 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _39096 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39096 + 68] = mem[idx + _38312 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39096 + 68] = mem[_39096 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39096 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 204
                                    _42254 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42254] = 30
                                    mem[_42254 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        _44178 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44178 + 68] = mem[idx + _42254 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44178 + 68] = mem[_44178 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44178 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    stor204[address(msg.sender)] -= arg2
                                    mem[32] = 203
                                    _47559 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_47559] = 30
                                    mem[_47559 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _49998 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _49998 + 68] = mem[idx + _47559 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_49998 + 68] = mem[_49998 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _49998 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] += stor209 / totalSupply * arg2
                                    _58842 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_58842] = 30
                                    mem[_58842 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _60067 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _60067 + 68] = mem[idx + _58842 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_60067 + 68] = mem[_60067 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _60067 + -mem[64] + 100
                                _31934 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31934] = 26
                                mem[_31934 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _33926 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33926] = 26
                                    mem[_33926 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] += t / s * arg2
                                else:
                                    _33927 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33927] = 26
                                    mem[_33927 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                            else:
                                if 0 / arg2:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _32799 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32799] = 26
                                        mem[_32799 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _32799 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _37755 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37755] = 30
                                            mem[_37755 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _40176 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40176] = 30
                                            mem[_40176 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _41447 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _41447 + 68] = mem[idx + _40176 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41447 + 68] = mem[_41447 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41447 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _44164 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_44164] = 30
                                            mem[_44164 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _46359 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _46359 + 68] = mem[idx + _44164 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_46359 + 68] = mem[_46359 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _46359 + -mem[64] + 100
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            _56319 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_56319] = 30
                                            mem[_56319 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _58005 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _58005 + 68] = mem[idx + _56319 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_58005 + 68] = mem[_58005 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _58005 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _37876 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37876] = 30
                                        mem[_37876 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _38305 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38305 + 68] = mem[idx + _37876 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38305 + 68] = mem[_38305 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38305 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _40850 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40850] = 30
                                        mem[_40850 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _42241 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42241 + 68] = mem[idx + _40850 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42241 + 68] = mem[_42241 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42241 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _45173 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_45173] = 30
                                        mem[_45173 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _47543 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _47543 + 68] = mem[idx + _45173 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_47543 + 68] = mem[_47543 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _47543 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                                        _57121 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_57121] = 30
                                        mem[_57121 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _58833 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _58833 + 68] = mem[idx + _57121 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_58833 + 68] = mem[_58833 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _58833 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _33041 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33041] = 30
                                        mem[_33041 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _33570 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _33570 + 68] = mem[idx + _33041 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33570 + 68] = mem[_33570 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33570 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _35472 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35472] = 30
                                        mem[_35472 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _36313 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _36313 + 68] = mem[idx + _35472 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36313 + 68] = mem[_36313 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36313 + -mem[64] + 100
                                    _33297 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33297] = 26
                                    mem[_33297 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _33297 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _38007 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38007] = 30
                                        mem[_38007 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _41452 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41452] = 30
                                        mem[_41452 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _43208 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43208 + 68] = mem[idx + _41452 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43208 + 68] = mem[_43208 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43208 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _46365 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_46365] = 30
                                        mem[_46365 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _48756 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _48756 + 68] = mem[idx + _46365 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_48756 + 68] = mem[_48756 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _48756 + -mem[64] + 100
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        _58008 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_58008] = 30
                                        mem[_58008 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _59479 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _59479 + 68] = mem[idx + _58008 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_59479 + 68] = mem[_59479 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _59479 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38308 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38308] = 30
                                    mem[_38308 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _39090 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39090 + 68] = mem[idx + _38308 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39090 + 68] = mem[_39090 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39090 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 204
                                    _42244 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42244] = 30
                                    mem[_42244 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 > stor204[address(msg.sender)]:
                                        _44167 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44167 + 68] = mem[idx + _42244 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44167 + 68] = mem[_44167 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44167 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    stor204[address(msg.sender)] -= arg2
                                    mem[32] = 203
                                    _47546 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_47546] = 30
                                    mem[_47546 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _49982 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _49982 + 68] = mem[idx + _47546 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_49982 + 68] = mem[_49982 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _49982 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] += stor209 / totalSupply * arg2
                                    _58836 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_58836] = 30
                                    mem[_58836 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _60059 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _60059 + 68] = mem[idx + _58836 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_60059 + 68] = mem[_60059 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _60059 + -mem[64] + 100
                                _31929 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31929] = 26
                                mem[_31929 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _33919 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33919] = 26
                                    mem[_33919 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] += t / s * arg2
                                else:
                                    _33920 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33920] = 26
                                    mem[_33920 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor204[address(msg.sender)] -= arg2
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                            if 0 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                else:
                    mem[0] = arg1
                    mem[32] = 206
                    if not stor206[address(arg1)]:
                        if not arg2:
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _32844 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32844] = 26
                                    mem[_32844 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _32844 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _37770 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37770] = 30
                                        mem[_37770 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _40299 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40299] = 30
                                        mem[_40299 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _41540 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _41540 + 68] = mem[idx + _40299 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41540 + 68] = mem[_41540 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41540 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _48937 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_48937] = 30
                                        mem[_48937 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _51276 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _51276 + 68] = mem[idx + _48937 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_51276 + 68] = mem[_51276 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _51276 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _37894 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37894] = 30
                                    mem[_37894 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _38365 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38365 + 68] = mem[idx + _37894 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38365 + 68] = mem[_38365 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38365 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _40922 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_40922] = 30
                                    mem[_40922 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _42367 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _42367 + 68] = mem[idx + _40922 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42367 + 68] = mem[_42367 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42367 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _50148 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_50148] = 30
                                    mem[_50148 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _52190 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _52190 + 68] = mem[idx + _50148 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52190 + 68] = mem[_52190 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52190 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _33068 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33068] = 30
                                    mem[_33068 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _33606 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _33606 + 68] = mem[idx + _33068 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33606 + 68] = mem[_33606 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33606 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _35535 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35535] = 30
                                    mem[_35535 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _36385 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _36385 + 68] = mem[idx + _35535 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36385 + 68] = mem[_36385 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _36385 + -mem[64] + 100
                                _33342 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33342] = 26
                                mem[_33342 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _33342 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    _38025 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38025] = 30
                                    mem[_38025 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41545 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41545] = 30
                                    mem[_41545 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _43352 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43352 + 68] = mem[idx + _41545 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43352 + 68] = mem[_43352 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43352 + -mem[64] + 100
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = stor203[arg1]
                                    _51279 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_51279] = 30
                                    mem[_51279 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _52896 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _52896 + 68] = mem[idx + _51279 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52896 + 68] = mem[_52896 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52896 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _38368 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38368] = 30
                                mem[_38368 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _39162 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _39162 + 68] = mem[idx + _38368 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39162 + 68] = mem[_39162 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39162 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _42370 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_42370] = 30
                                mem[_42370 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _44296 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _44296 + 68] = mem[idx + _42370 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_44296 + 68] = mem[_44296 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _44296 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                _52193 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_52193] = 30
                                mem[_52193 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _53657 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _53657 + 68] = mem[idx + _52193 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_53657 + 68] = mem[_53657 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _53657 + -mem[64] + 100
                            _31974 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31974] = 26
                            mem[_31974 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _33982 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33982] = 26
                                mem[_33982 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                            else:
                                _33983 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33983] = 26
                                mem[_33983 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = stor203[arg1]
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                            if 0 > stor209:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            mem[96] = 26
                            mem[128] = 'SafeMath: division by zero'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if _tFeePercent * arg2 / 10000 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = totalSupply
                            t = stor209
                            while idx < stor207.length:
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                if stor203[stor207[idx]] > t:
                                    _32839 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32839] = 26
                                    mem[_32839 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _32839 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            _37769 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37769] = 30
                                            mem[_37769 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _40288 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40288] = 30
                                            mem[_40288 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _41528 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _41528 + 68] = mem[idx + _40288 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41528 + 68] = mem[_41528 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41528 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _48917 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48917] = 30
                                            mem[_48917 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _51263 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _51263 + 68] = mem[idx + _48917 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_51263 + 68] = mem[_51263 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _51263 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _37891 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37891] = 30
                                        mem[_37891 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            _38360 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38360 + 68] = mem[idx + _37891 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38360 + 68] = mem[_38360 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38360 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _40915 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40915] = 30
                                        mem[_40915 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _42354 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42354 + 68] = mem[idx + _40915 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42354 + 68] = mem[_42354 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42354 + -mem[64] + 100
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _50132 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50132] = 30
                                        mem[_50132 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _52183 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52183 + 68] = mem[idx + _50132 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52183 + 68] = mem[_52183 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52183 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        _37890 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37890] = 30
                                        mem[_37890 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _38357 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38357 + 68] = mem[idx + _37890 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38357 + 68] = mem[_38357 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38357 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _40914 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40914] = 30
                                        mem[_40914 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _42351 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42351 + 68] = mem[idx + _40914 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42351 + 68] = mem[_42351 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42351 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _50131 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50131] = 30
                                        mem[_50131 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _52180 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52180 + 68] = mem[idx + _50131 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52180 + 68] = mem[_52180 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52180 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38021 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38021] = 30
                                    mem[_38021 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        _38707 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38707 + 68] = mem[idx + _38021 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38707 + 68] = mem[_38707 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38707 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41527 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41527] = 30
                                    mem[_41527 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _43333 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43333 + 68] = mem[idx + _41527 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43333 + 68] = mem[_43333 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43333 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _51262 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_51262] = 30
                                    mem[_51262 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _52885 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _52885 + 68] = mem[idx + _51262 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_52885 + 68] = mem[_52885 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _52885 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                if stor204[stor207[idx]] <= s:
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    _33065 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33065] = 30
                                    mem[_33065 + 32] = 'SafeMath: subtraction overflow'
                                    if stor203[stor207[idx]] > t:
                                        _33602 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _33602 + 68] = mem[idx + _33065 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_33602 + 68] = mem[_33602 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _33602 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    _35528 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_35528] = 30
                                    mem[_35528 + 32] = 'SafeMath: subtraction overflow'
                                    if stor204[stor207[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor204[stor207[idx]]
                                        t = t - stor203[stor207[idx]]
                                        continue 
                                    _36377 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _36377 + 68] = mem[idx + _35528 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_36377 + 68] = mem[_36377 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _36377 + -mem[64] + 100
                                _33337 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33337] = 26
                                mem[_33337 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _33337 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        _38024 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38024] = 30
                                        mem[_38024 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41537 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41537] = 30
                                        mem[_41537 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _43340 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43340 + 68] = mem[idx + _41537 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43340 + 68] = mem[_43340 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43340 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _51267 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51267] = 30
                                        mem[_51267 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _52890 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52890 + 68] = mem[idx + _51267 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52890 + 68] = mem[_52890 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52890 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38364 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38364] = 30
                                    mem[_38364 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                        _39156 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39156 + 68] = mem[idx + _38364 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39156 + 68] = mem[_39156 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39156 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42360 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42360] = 30
                                    mem[_42360 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _44286 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44286 + 68] = mem[idx + _42360 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44286 + 68] = mem[_44286 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44286 + -mem[64] + 100
                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _52187 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52187] = 30
                                    mem[_52187 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _53649 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53649 + 68] = mem[idx + _52187 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53649 + 68] = mem[_53649 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53649 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    _38363 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38363] = 30
                                    mem[_38363 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _39153 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39153 + 68] = mem[idx + _38363 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39153 + 68] = mem[_39153 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39153 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42359 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42359] = 30
                                    mem[_42359 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _44283 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44283 + 68] = mem[idx + _42359 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44283 + 68] = mem[_44283 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44283 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _52186 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52186] = 30
                                    mem[_52186 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _53646 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53646 + 68] = mem[idx + _52186 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53646 + 68] = mem[_53646 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53646 + -mem[64] + 100
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _38710 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38710] = 30
                                mem[_38710 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                    _39569 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _39569 + 68] = mem[idx + _38710 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39569 + 68] = mem[_39569 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39569 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _43339 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_43339] = 30
                                mem[_43339 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _45313 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _45313 + 68] = mem[idx + _43339 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_45313 + 68] = mem[_45313 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _45313 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                _52889 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_52889] = 30
                                mem[_52889 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                    return 1
                                _54572 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _54572 + 68] = mem[idx + _52889 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_54572 + 68] = mem[_54572 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _54572 + -mem[64] + 100
                            _31969 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31969] = 26
                            mem[_31969 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if t >= stor209 / totalSupply:
                                _33975 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33975] = 26
                                mem[_33975 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if t / s * _tFeePercent * arg2 / 10000 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                else:
                                    if t / s * arg2 / arg2 != t / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                            else:
                                _33976 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33976] = 26
                                mem[_33976 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                else:
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += _tFeePercent * arg2 / 10000
                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                    else:
                        mem[0] = msg.sender
                        mem[32] = 206
                        if not stor206[address(msg.sender)]:
                            if not arg2:
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _32814 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32814] = 26
                                        mem[_32814 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _32814 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _37760 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37760] = 30
                                            mem[_37760 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _40217 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40217] = 30
                                            mem[_40217 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _41478 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _41478 + 68] = mem[idx + _40217 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41478 + 68] = mem[_41478 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41478 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _48815 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48815] = 30
                                            mem[_48815 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _51172 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _51172 + 68] = mem[idx + _48815 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_51172 + 68] = mem[_51172 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _51172 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _37882 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37882] = 30
                                        mem[_37882 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _38325 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38325 + 68] = mem[idx + _37882 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38325 + 68] = mem[_38325 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38325 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _40874 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40874] = 30
                                        mem[_40874 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _42283 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42283 + 68] = mem[idx + _40874 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42283 + 68] = mem[_42283 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42283 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _50038 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50038] = 30
                                        mem[_50038 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _52110 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52110 + 68] = mem[idx + _50038 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52110 + 68] = mem[_52110 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52110 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _33050 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33050] = 30
                                        mem[_33050 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _33582 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _33582 + 68] = mem[idx + _33050 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33582 + 68] = mem[_33582 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33582 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _35493 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35493] = 30
                                        mem[_35493 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _36337 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _36337 + 68] = mem[idx + _35493 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36337 + 68] = mem[_36337 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36337 + -mem[64] + 100
                                    _33312 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33312] = 26
                                    mem[_33312 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _33312 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _38013 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38013] = 30
                                        mem[_38013 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41483 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41483] = 30
                                        mem[_41483 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _43256 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43256 + 68] = mem[idx + _41483 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43256 + 68] = mem[_43256 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43256 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _51175 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51175] = 30
                                        mem[_51175 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _52834 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52834 + 68] = mem[idx + _51175 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52834 + 68] = mem[_52834 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52834 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38328 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38328] = 30
                                    mem[_38328 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _39114 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39114 + 68] = mem[idx + _38328 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39114 + 68] = mem[_39114 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39114 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42286 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42286] = 30
                                    mem[_42286 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _44210 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44210 + 68] = mem[idx + _42286 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44210 + 68] = mem[_44210 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44210 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _52113 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52113] = 30
                                    mem[_52113 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _53579 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53579 + 68] = mem[idx + _52113 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53579 + 68] = mem[_53579 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53579 + -mem[64] + 100
                                _31944 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31944] = 26
                                mem[_31944 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _33940 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33940] = 26
                                    mem[_33940 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                else:
                                    _33941 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33941] = 26
                                    mem[_33941 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if _tFeePercent * arg2 / 10000 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _32809 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32809] = 26
                                        mem[_32809 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _32809 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                _37759 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37759] = 30
                                                mem[_37759 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _40206 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40206] = 30
                                                mem[_40206 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _41466 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _41466 + 68] = mem[idx + _40206 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_41466 + 68] = mem[_41466 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _41466 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _48795 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_48795] = 30
                                                mem[_48795 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                    return 1
                                                _51159 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _51159 + 68] = mem[idx + _48795 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_51159 + 68] = mem[_51159 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _51159 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _37879 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37879] = 30
                                            mem[_37879 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                _38320 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38320 + 68] = mem[idx + _37879 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38320 + 68] = mem[_38320 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38320 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _40867 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40867] = 30
                                            mem[_40867 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _42270 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42270 + 68] = mem[idx + _40867 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42270 + 68] = mem[_42270 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42270 + -mem[64] + 100
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _50022 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50022] = 30
                                            mem[_50022 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _52103 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52103 + 68] = mem[idx + _50022 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52103 + 68] = mem[_52103 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52103 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            _37878 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37878] = 30
                                            mem[_37878 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _38317 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38317 + 68] = mem[idx + _37878 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38317 + 68] = mem[_38317 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38317 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _40866 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40866] = 30
                                            mem[_40866 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _42267 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42267 + 68] = mem[idx + _40866 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42267 + 68] = mem[_42267 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42267 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _50021 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50021] = 30
                                            mem[_50021 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _52100 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52100 + 68] = mem[idx + _50021 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52100 + 68] = mem[_52100 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52100 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38009 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38009] = 30
                                        mem[_38009 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            _38679 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38679 + 68] = mem[idx + _38009 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38679 + 68] = mem[_38679 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38679 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41465 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41465] = 30
                                        mem[_41465 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _43237 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43237 + 68] = mem[idx + _41465 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43237 + 68] = mem[_43237 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43237 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _51158 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51158] = 30
                                        mem[_51158 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _52823 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52823 + 68] = mem[idx + _51158 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52823 + 68] = mem[_52823 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52823 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _33047 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33047] = 30
                                        mem[_33047 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _33578 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _33578 + 68] = mem[idx + _33047 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33578 + 68] = mem[_33578 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33578 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _35486 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35486] = 30
                                        mem[_35486 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _36329 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _36329 + 68] = mem[idx + _35486 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36329 + 68] = mem[_36329 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36329 + -mem[64] + 100
                                    _33307 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33307] = 26
                                    mem[_33307 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _33307 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            _38012 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38012] = 30
                                            mem[_38012 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41475 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41475] = 30
                                            mem[_41475 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _43244 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43244 + 68] = mem[idx + _41475 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43244 + 68] = mem[_43244 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43244 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _51163 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51163] = 30
                                            mem[_51163 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _52828 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52828 + 68] = mem[idx + _51163 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52828 + 68] = mem[_52828 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52828 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38324 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38324] = 30
                                        mem[_38324 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            _39108 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39108 + 68] = mem[idx + _38324 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39108 + 68] = mem[_39108 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39108 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42276 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42276] = 30
                                        mem[_42276 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _44200 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44200 + 68] = mem[idx + _42276 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44200 + 68] = mem[_44200 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44200 + -mem[64] + 100
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _52107 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52107] = 30
                                        mem[_52107 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _53571 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53571 + 68] = mem[idx + _52107 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53571 + 68] = mem[_53571 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53571 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        _38323 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38323] = 30
                                        mem[_38323 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39105 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39105 + 68] = mem[idx + _38323 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39105 + 68] = mem[_39105 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39105 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42275 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42275] = 30
                                        mem[_42275 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _44197 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44197 + 68] = mem[idx + _42275 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44197 + 68] = mem[_44197 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44197 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _52106 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52106] = 30
                                        mem[_52106 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _53568 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53568 + 68] = mem[idx + _52106 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53568 + 68] = mem[_53568 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53568 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38682 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38682] = 30
                                    mem[_38682 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        _39535 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39535 + 68] = mem[idx + _38682 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39535 + 68] = mem[_39535 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39535 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _43243 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43243] = 30
                                    mem[_43243 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _45211 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45211 + 68] = mem[idx + _43243 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45211 + 68] = mem[_45211 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45211 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _52827 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52827] = 30
                                    mem[_52827 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _54478 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54478 + 68] = mem[idx + _52827 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54478 + 68] = mem[_54478 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54478 + -mem[64] + 100
                                _31939 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31939] = 26
                                mem[_31939 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _33933 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33933] = 26
                                    mem[_33933 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                else:
                                    _33934 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33934] = 26
                                    mem[_33934 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                        else:
                            mem[0] = arg1
                            mem[32] = 206
                            if not stor206[address(arg1)]:
                                if not arg2:
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero'
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _32824 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32824] = 26
                                            mem[_32824 + 32] = 'SafeMath: division by zero'
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _32824 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                _37764 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37764] = 30
                                                mem[_37764 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _40248 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40248] = 30
                                                mem[_40248 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _41501 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _41501 + 68] = mem[idx + _40248 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_41501 + 68] = mem[_41501 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _41501 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _48857 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_48857] = 30
                                                mem[_48857 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    return 1
                                                _51208 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _51208 + 68] = mem[idx + _48857 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_51208 + 68] = mem[_51208 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _51208 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _37887 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37887] = 30
                                            mem[_37887 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _38341 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38341 + 68] = mem[idx + _37887 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38341 + 68] = mem[_38341 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38341 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _40894 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40894] = 30
                                            mem[_40894 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _42315 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42315 + 68] = mem[idx + _40894 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42315 + 68] = mem[_42315 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42315 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _50077 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50077] = 30
                                            mem[_50077 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _52134 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52134 + 68] = mem[idx + _50077 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52134 + 68] = mem[_52134 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52134 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _33056 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33056] = 30
                                            mem[_33056 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _33590 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _33590 + 68] = mem[idx + _33056 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_33590 + 68] = mem[_33590 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _33590 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _35507 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35507] = 30
                                            mem[_35507 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _36353 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _36353 + 68] = mem[idx + _35507 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36353 + 68] = mem[_36353 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36353 + -mem[64] + 100
                                        _33322 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33322] = 26
                                        mem[_33322 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _33322 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _38018 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38018] = 30
                                            mem[_38018 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41506 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41506] = 30
                                            mem[_41506 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _43292 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43292 + 68] = mem[idx + _41506 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43292 + 68] = mem[_43292 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43292 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _51211 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51211] = 30
                                            mem[_51211 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _52852 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52852 + 68] = mem[idx + _51211 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52852 + 68] = mem[_52852 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52852 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38344 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38344] = 30
                                        mem[_38344 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39132 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39132 + 68] = mem[idx + _38344 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39132 + 68] = mem[_39132 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39132 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42318 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42318] = 30
                                        mem[_42318 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _44242 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44242 + 68] = mem[idx + _42318 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44242 + 68] = mem[_44242 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44242 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _52137 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52137] = 30
                                        mem[_52137 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _53601 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53601 + 68] = mem[idx + _52137 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53601 + 68] = mem[_53601 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53601 + -mem[64] + 100
                                    _31954 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31954] = 26
                                    mem[_31954 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _33954 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33954] = 26
                                        mem[_33954 + 32] = 'SafeMath: division by zero'
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                    else:
                                        _33955 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33955] = 26
                                        mem[_33955 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero'
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if _tFeePercent * arg2 / 10000 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _32819 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32819] = 26
                                            mem[_32819 + 32] = 'SafeMath: division by zero'
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _32819 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                if not _tFeePercent * arg2 / 10000:
                                                    _37763 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_37763] = 30
                                                    mem[_37763 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 203
                                                    _40237 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_40237] = 30
                                                    mem[_40237 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor203[address(msg.sender)]:
                                                        _41489 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _41489 + 68] = mem[idx + _40237 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_41489 + 68] = mem[_41489 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _41489 + -mem[64] + 100
                                                    if stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 203
                                                    stor203[address(arg1)] = stor203[arg1]
                                                    _48837 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_48837] = 30
                                                    mem[_48837 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor209:
                                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += _tFeePercent * arg2 / 10000
                                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                        return 1
                                                    _51195 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _51195 + 68] = mem[idx + _48837 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_51195 + 68] = mem[_51195 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _51195 + -mem[64] + 100
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _37884 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37884] = 30
                                                mem[_37884 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                    _38336 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _38336 + 68] = mem[idx + _37884 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_38336 + 68] = mem[_38336 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _38336 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _40887 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40887] = 30
                                                mem[_40887 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _42302 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _42302 + 68] = mem[idx + _40887 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42302 + 68] = mem[_42302 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42302 + -mem[64] + 100
                                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                _50061 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_50061] = 30
                                                mem[_50061 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                    return 1
                                                _52127 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _52127 + 68] = mem[idx + _50061 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_52127 + 68] = mem[_52127 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _52127 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not _tFeePercent * arg2 / 10000:
                                                _37883 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37883] = 30
                                                mem[_37883 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor209 / totalSupply * arg2:
                                                    _38333 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _38333 + 68] = mem[idx + _37883 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_38333 + 68] = mem[_38333 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _38333 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _40886 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40886] = 30
                                                mem[_40886 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    _42299 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _42299 + 68] = mem[idx + _40886 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42299 + 68] = mem[_42299 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42299 + -mem[64] + 100
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                                _50060 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_50060] = 30
                                                mem[_50060 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                    return 1
                                                _52124 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _52124 + 68] = mem[idx + _50060 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_52124 + 68] = mem[_52124 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _52124 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _38014 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38014] = 30
                                            mem[_38014 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                _38691 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38691 + 68] = mem[idx + _38014 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38691 + 68] = mem[_38691 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38691 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41488 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41488] = 30
                                            mem[_41488 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _43273 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43273 + 68] = mem[idx + _41488 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43273 + 68] = mem[_43273 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43273 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _51194 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51194] = 30
                                            mem[_51194 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _52841 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52841 + 68] = mem[idx + _51194 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52841 + 68] = mem[_52841 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52841 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _33053 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33053] = 30
                                            mem[_33053 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _33586 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _33586 + 68] = mem[idx + _33053 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_33586 + 68] = mem[_33586 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _33586 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _35500 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35500] = 30
                                            mem[_35500 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _36345 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _36345 + 68] = mem[idx + _35500 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36345 + 68] = mem[_36345 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36345 + -mem[64] + 100
                                        _33317 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33317] = 26
                                        mem[_33317 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _33317 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                _38017 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38017] = 30
                                                mem[_38017 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _41498 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41498] = 30
                                                mem[_41498 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _43280 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _43280 + 68] = mem[idx + _41498 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_43280 + 68] = mem[_43280 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _43280 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _51199 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_51199] = 30
                                                mem[_51199 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                    return 1
                                                _52846 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _52846 + 68] = mem[idx + _51199 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_52846 + 68] = mem[_52846 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _52846 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _38340 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38340] = 30
                                            mem[_38340 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                _39126 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39126 + 68] = mem[idx + _38340 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39126 + 68] = mem[_39126 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39126 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42308 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42308] = 30
                                            mem[_42308 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _44232 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44232 + 68] = mem[idx + _42308 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44232 + 68] = mem[_44232 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44232 + -mem[64] + 100
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _52131 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_52131] = 30
                                            mem[_52131 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _53593 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53593 + 68] = mem[idx + _52131 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53593 + 68] = mem[_53593 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53593 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            _38339 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38339] = 30
                                            mem[_38339 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _39123 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39123 + 68] = mem[idx + _38339 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39123 + 68] = mem[_39123 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39123 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42307 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42307] = 30
                                            mem[_42307 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _44229 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44229 + 68] = mem[idx + _42307 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44229 + 68] = mem[_44229 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44229 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _52130 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_52130] = 30
                                            mem[_52130 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _53590 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53590 + 68] = mem[idx + _52130 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53590 + 68] = mem[_53590 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53590 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38694 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38694] = 30
                                        mem[_38694 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            _39549 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39549 + 68] = mem[idx + _38694 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39549 + 68] = mem[_39549 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39549 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _43279 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43279] = 30
                                        mem[_43279 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _45249 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45249 + 68] = mem[idx + _43279 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45249 + 68] = mem[_45249 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45249 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _52845 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52845] = 30
                                        mem[_52845 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _54510 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54510 + 68] = mem[idx + _52845 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54510 + 68] = mem[_54510 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54510 + -mem[64] + 100
                                    _31949 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31949] = 26
                                    mem[_31949 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _33947 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33947] = 26
                                        mem[_33947 + 32] = 'SafeMath: division by zero'
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if t / s * _tFeePercent * arg2 / 10000 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > t / s * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if t / s * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                                if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if t / s * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                                if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                    else:
                                        _33948 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33948] = 26
                                        mem[_33948 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > stor209 / totalSupply * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                            else:
                                if not arg2:
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero'
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _32834 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32834] = 26
                                            mem[_32834 + 32] = 'SafeMath: division by zero'
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _32834 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                _37766 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37766] = 30
                                                mem[_37766 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 204
                                                _40268 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40268] = 30
                                                mem[_40268 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    _41517 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _41517 + 68] = mem[idx + _40268 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_41517 + 68] = mem[_41517 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _41517 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                stor204[address(msg.sender)] -= arg2
                                                mem[32] = 203
                                                _44261 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_44261] = 30
                                                mem[_44261 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _46495 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _46495 + 68] = mem[idx + _44261 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_46495 + 68] = mem[_46495 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _46495 + -mem[64] + 100
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                _56403 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_56403] = 30
                                                mem[_56403 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    return 1
                                                _58105 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _58105 + 68] = mem[idx + _56403 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_58105 + 68] = mem[_58105 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _58105 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _37889 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37889] = 30
                                            mem[_37889 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _38349 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38349 + 68] = mem[idx + _37889 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38349 + 68] = mem[_38349 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38349 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _40902 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40902] = 30
                                            mem[_40902 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _42335 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42335 + 68] = mem[idx + _40902 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42335 + 68] = mem[_42335 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42335 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _45288 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45288] = 30
                                            mem[_45288 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _47660 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _47660 + 68] = mem[idx + _45288 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_47660 + 68] = mem[_47660 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _47660 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                            _57201 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_57201] = 30
                                            mem[_57201 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _58907 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _58907 + 68] = mem[idx + _57201 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_58907 + 68] = mem[_58907 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _58907 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _33062 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33062] = 30
                                            mem[_33062 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _33598 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _33598 + 68] = mem[idx + _33062 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_33598 + 68] = mem[_33598 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _33598 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _35521 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35521] = 30
                                            mem[_35521 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _36369 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _36369 + 68] = mem[idx + _35521 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36369 + 68] = mem[_36369 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36369 + -mem[64] + 100
                                        _33332 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33332] = 26
                                        mem[_33332 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _33332 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _38020 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38020] = 30
                                            mem[_38020 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _41522 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41522] = 30
                                            mem[_41522 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _43316 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43316 + 68] = mem[idx + _41522 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43316 + 68] = mem[_43316 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43316 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _46501 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_46501] = 30
                                            mem[_46501 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _48897 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _48897 + 68] = mem[idx + _46501 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_48897 + 68] = mem[_48897 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _48897 + -mem[64] + 100
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            _58108 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_58108] = 30
                                            mem[_58108 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _59537 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _59537 + 68] = mem[idx + _58108 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_59537 + 68] = mem[_59537 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _59537 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38352 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38352] = 30
                                        mem[_38352 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39144 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39144 + 68] = mem[idx + _38352 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39144 + 68] = mem[_39144 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39144 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _42338 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42338] = 30
                                        mem[_42338 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _44264 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44264 + 68] = mem[idx + _42338 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44264 + 68] = mem[_44264 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44264 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _47663 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_47663] = 30
                                        mem[_47663 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _50108 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _50108 + 68] = mem[idx + _47663 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50108 + 68] = mem[_50108 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50108 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                                        _58910 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_58910] = 30
                                        mem[_58910 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _60119 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _60119 + 68] = mem[idx + _58910 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_60119 + 68] = mem[_60119 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _60119 + -mem[64] + 100
                                    _31964 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31964] = 26
                                    mem[_31964 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _33968 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33968] = 26
                                        mem[_33968 + 32] = 'SafeMath: division by zero'
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] += t / s * arg2
                                    else:
                                        _33969 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33969] = 26
                                        mem[_33969 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                else:
                                    if 0 / arg2:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero'
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _32829 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32829] = 26
                                            mem[_32829 + 32] = 'SafeMath: division by zero'
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _32829 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                _37765 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37765] = 30
                                                mem[_37765 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 204
                                                _40258 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40258] = 30
                                                mem[_40258 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    _41509 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _41509 + 68] = mem[idx + _40258 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_41509 + 68] = mem[_41509 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _41509 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                stor204[address(msg.sender)] -= arg2
                                                mem[32] = 203
                                                _44250 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_44250] = 30
                                                mem[_44250 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _46479 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _46479 + 68] = mem[idx + _44250 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_46479 + 68] = mem[_46479 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _46479 + -mem[64] + 100
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                _56395 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_56395] = 30
                                                mem[_56395 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    return 1
                                                _58095 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _58095 + 68] = mem[idx + _56395 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_58095 + 68] = mem[_58095 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _58095 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _37888 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37888] = 30
                                            mem[_37888 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _38345 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38345 + 68] = mem[idx + _37888 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38345 + 68] = mem[_38345 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38345 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _40898 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40898] = 30
                                            mem[_40898 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _42325 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42325 + 68] = mem[idx + _40898 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42325 + 68] = mem[_42325 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42325 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _45275 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45275] = 30
                                            mem[_45275 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _47647 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _47647 + 68] = mem[idx + _45275 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_47647 + 68] = mem[_47647 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _47647 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                            _57195 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_57195] = 30
                                            mem[_57195 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _58901 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _58901 + 68] = mem[idx + _57195 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_58901 + 68] = mem[_58901 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _58901 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _33059 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33059] = 30
                                            mem[_33059 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _33594 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _33594 + 68] = mem[idx + _33059 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_33594 + 68] = mem[_33594 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _33594 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _35514 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35514] = 30
                                            mem[_35514 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _36361 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _36361 + 68] = mem[idx + _35514 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36361 + 68] = mem[_36361 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36361 + -mem[64] + 100
                                        _33327 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33327] = 26
                                        mem[_33327 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _33327 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _38019 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38019] = 30
                                            mem[_38019 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _41514 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41514] = 30
                                            mem[_41514 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _43304 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43304 + 68] = mem[idx + _41514 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43304 + 68] = mem[_43304 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43304 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _46485 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_46485] = 30
                                            mem[_46485 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _48878 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _48878 + 68] = mem[idx + _46485 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_48878 + 68] = mem[_48878 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _48878 + -mem[64] + 100
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            _58098 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_58098] = 30
                                            mem[_58098 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _59531 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _59531 + 68] = mem[idx + _58098 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_59531 + 68] = mem[_59531 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _59531 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38348 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38348] = 30
                                        mem[_38348 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39138 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39138 + 68] = mem[idx + _38348 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39138 + 68] = mem[_39138 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39138 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _42328 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42328] = 30
                                        mem[_42328 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _44253 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44253 + 68] = mem[idx + _42328 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44253 + 68] = mem[_44253 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44253 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _47650 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_47650] = 30
                                        mem[_47650 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _50092 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _50092 + 68] = mem[idx + _47650 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50092 + 68] = mem[_50092 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50092 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                                        _58904 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_58904] = 30
                                        mem[_58904 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _60111 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _60111 + 68] = mem[idx + _58904 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_60111 + 68] = mem[_60111 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _60111 + -mem[64] + 100
                                    _31959 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31959] = 26
                                    mem[_31959 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _33961 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33961] = 26
                                        mem[_33961 + 32] = 'SafeMath: division by zero'
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] += t / s * arg2
                                    else:
                                        _33962 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33962] = 26
                                        mem[_33962 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
            else:
                mem[0] = arg1
                mem[32] = 206
                if stor206[address(arg1)]:
                    if not arg2:
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = totalSupply
                        t = stor209
                        while idx < stor207.length:
                            mem[0] = stor207[idx]
                            mem[32] = 203
                            if stor203[stor207[idx]] > t:
                                _32924 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32924] = 26
                                mem[_32924 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _32924 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    _37798 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37798] = 30
                                    mem[_37798 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _40525 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_40525] = 30
                                    mem[_40525 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _41710 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _41710 + 68] = mem[idx + _40525 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_41710 + 68] = mem[_41710 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _41710 + -mem[64] + 100
                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] += arg2
                                    if stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    _52403 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52403] = 30
                                    mem[_52403 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _53860 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53860 + 68] = mem[idx + _52403 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53860 + 68] = mem[_53860 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53860 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _37928 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_37928] = 30
                                mem[_37928 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _38477 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _38477 + 68] = mem[idx + _37928 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_38477 + 68] = mem[_38477 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _38477 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _41058 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_41058] = 30
                                mem[_41058 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _42599 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _42599 + 68] = mem[idx + _41058 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_42599 + 68] = mem[_42599 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _42599 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] += arg2
                                if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] += stor209 / totalSupply * arg2
                                _53059 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_53059] = 30
                                mem[_53059 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _54826 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _54826 + 68] = mem[idx + _53059 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_54826 + 68] = mem[_54826 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _54826 + -mem[64] + 100
                            require idx < stor207.length
                            mem[0] = stor207[idx]
                            mem[32] = 204
                            if stor204[stor207[idx]] <= s:
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                _33116 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33116] = 30
                                mem[_33116 + 32] = 'SafeMath: subtraction overflow'
                                if stor203[stor207[idx]] > t:
                                    _33670 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _33670 + 68] = mem[idx + _33116 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33670 + 68] = mem[_33670 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33670 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                _35647 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35647] = 30
                                mem[_35647 + 32] = 'SafeMath: subtraction overflow'
                                if stor204[stor207[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor204[stor207[idx]]
                                    t = t - stor203[stor207[idx]]
                                    continue 
                                _36513 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _36513 + 68] = mem[idx + _35647 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36513 + 68] = mem[_36513 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _36513 + -mem[64] + 100
                            _33422 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33422] = 26
                            mem[_33422 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _33422 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                _38059 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38059] = 30
                                mem[_38059 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 203
                                _41715 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_41715] = 30
                                mem[_41715 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor203[address(msg.sender)]:
                                    _43616 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _43616 + 68] = mem[idx + _41715 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_43616 + 68] = mem[_43616 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _43616 + -mem[64] + 100
                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] += arg2
                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                _53863 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_53863] = 30
                                mem[_53863 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _55830 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _55830 + 68] = mem[idx + _53863 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_55830 + 68] = mem[_55830 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _55830 + -mem[64] + 100
                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _38480 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_38480] = 30
                            mem[_38480 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor209 / totalSupply * arg2:
                                _39294 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _39294 + 68] = mem[idx + _38480 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_39294 + 68] = mem[_39294 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _39294 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 203
                            _42602 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_42602] = 30
                            mem[_42602 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                _44532 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _44532 + 68] = mem[idx + _42602 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_44532 + 68] = mem[_44532 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _44532 + -mem[64] + 100
                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor204[address(arg1)] += arg2
                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                            _54829 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_54829] = 30
                            mem[_54829 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor209:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _56638 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _56638 + 68] = mem[idx + _54829 + 32]
                                idx = idx + 32
                                continue 
                            mem[_56638 + 68] = mem[_56638 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _56638 + -mem[64] + 100
                        _32054 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32054] = 26
                        mem[_32054 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero'
                        if t >= stor209 / totalSupply:
                            _34094 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34094] = 26
                            mem[_34094 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if 0 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] += arg2
                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if t / s * arg2 / arg2 != t / s:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > t / s * arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if t / s * arg2 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] += arg2
                                if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] += t / s * arg2
                        else:
                            _34095 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34095] = 26
                            mem[_34095 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if 0 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] += arg2
                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > stor209 / totalSupply * arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] += arg2
                                if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor203[address(arg1)] += stor209 / totalSupply * arg2
                        if 0 > stor209:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if _tFeePercent * arg2 / arg2 != _tFeePercent:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if _tFeePercent * arg2 / 10000 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = totalSupply
                        t = stor209
                        while idx < stor207.length:
                            mem[0] = stor207[idx]
                            mem[32] = 203
                            if stor203[stor207[idx]] > t:
                                _32919 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32919] = 26
                                mem[_32919 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _32919 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                if not arg2:
                                    if not _tFeePercent * arg2 / 10000:
                                        _37797 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37797] = 30
                                        mem[_37797 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _40514 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40514] = 30
                                        mem[_40514 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _41698 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _41698 + 68] = mem[idx + _40514 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_41698 + 68] = mem[_41698 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _41698 + -mem[64] + 100
                                        if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                        if stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        _52393 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52393] = 30
                                        mem[_52393 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _53849 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53849 + 68] = mem[idx + _52393 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53849 + 68] = mem[_53849 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53849 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _37925 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37925] = 30
                                    mem[_37925 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                        _38472 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38472 + 68] = mem[idx + _37925 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38472 + 68] = mem[_38472 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38472 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41051 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41051] = 30
                                    mem[_41051 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _42586 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _42586 + 68] = mem[idx + _41051 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42586 + 68] = mem[_42586 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42586 + -mem[64] + 100
                                    if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    _53050 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53050] = 30
                                    mem[_53050 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _54819 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54819 + 68] = mem[idx + _53050 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54819 + 68] = mem[_54819 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54819 + -mem[64] + 100
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    _37924 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_37924] = 30
                                    mem[_37924 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _38469 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _38469 + 68] = mem[idx + _37924 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_38469 + 68] = mem[_38469 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _38469 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41050 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41050] = 30
                                    mem[_41050 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _42583 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _42583 + 68] = mem[idx + _41050 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_42583 + 68] = mem[_42583 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _42583 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                    if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] += stor209 / totalSupply * arg2
                                    _53049 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53049] = 30
                                    mem[_53049 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _54816 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54816 + 68] = mem[idx + _53049 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54816 + 68] = mem[_54816 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54816 + -mem[64] + 100
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _38055 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38055] = 30
                                mem[_38055 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                    _38787 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _38787 + 68] = mem[idx + _38055 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_38787 + 68] = mem[_38787 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _38787 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _41697 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_41697] = 30
                                mem[_41697 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _43597 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _43597 + 68] = mem[idx + _41697 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_43597 + 68] = mem[_43597 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _43597 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)]
                                _53848 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_53848] = 30
                                mem[_53848 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                    return 1
                                _55819 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _55819 + 68] = mem[idx + _53848 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_55819 + 68] = mem[_55819 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _55819 + -mem[64] + 100
                            require idx < stor207.length
                            mem[0] = stor207[idx]
                            mem[32] = 204
                            if stor204[stor207[idx]] <= s:
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 203
                                _33113 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_33113] = 30
                                mem[_33113 + 32] = 'SafeMath: subtraction overflow'
                                if stor203[stor207[idx]] > t:
                                    _33666 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _33666 + 68] = mem[idx + _33113 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_33666 + 68] = mem[_33666 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _33666 + -mem[64] + 100
                                require idx < stor207.length
                                mem[0] = stor207[idx]
                                mem[32] = 204
                                _35640 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_35640] = 30
                                mem[_35640 + 32] = 'SafeMath: subtraction overflow'
                                if stor204[stor207[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor204[stor207[idx]]
                                    t = t - stor203[stor207[idx]]
                                    continue 
                                _36505 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _36505 + 68] = mem[idx + _35640 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_36505 + 68] = mem[_36505 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _36505 + -mem[64] + 100
                            _33417 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_33417] = 26
                            mem[_33417 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _33417 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if not _tFeePercent * arg2 / 10000:
                                    _38058 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38058] = 30
                                    mem[_38058 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _41707 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_41707] = 30
                                    mem[_41707 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        _43604 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _43604 + 68] = mem[idx + _41707 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_43604 + 68] = mem[_43604 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _43604 + -mem[64] + 100
                                    if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                    if stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    _53853 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53853] = 30
                                    mem[_53853 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _55824 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _55824 + 68] = mem[idx + _53853 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_55824 + 68] = mem[_55824 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _55824 + -mem[64] + 100
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _38476 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38476] = 30
                                mem[_38476 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                    _39288 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _39288 + 68] = mem[idx + _38476 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39288 + 68] = mem[_39288 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39288 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _42592 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_42592] = 30
                                mem[_42592 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor203[address(msg.sender)]:
                                    _44522 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _44522 + 68] = mem[idx + _42592 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_44522 + 68] = mem[_44522 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _44522 + -mem[64] + 100
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                _54823 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_54823] = 30
                                mem[_54823 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                    return 1
                                _56630 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _56630 + 68] = mem[idx + _54823 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_56630 + 68] = mem[_56630 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _56630 + -mem[64] + 100
                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not _tFeePercent * arg2 / 10000:
                                _38475 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_38475] = 30
                                mem[_38475 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor209 / totalSupply * arg2:
                                    _39285 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _39285 + 68] = mem[idx + _38475 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_39285 + 68] = mem[_39285 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _39285 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 203
                                _42591 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_42591] = 30
                                mem[_42591 + 32] = 'SafeMath: subtraction overflow'
                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                    _44519 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _44519 + 68] = mem[idx + _42591 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_44519 + 68] = mem[_44519 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _44519 + -mem[64] + 100
                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 203
                                stor203[address(arg1)] += stor209 / totalSupply * arg2
                                _54822 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_54822] = 30
                                mem[_54822 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor209:
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                    return 1
                                _56627 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _56627 + 68] = mem[idx + _54822 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_56627 + 68] = mem[_56627 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _56627 + -mem[64] + 100
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _38790 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_38790] = 30
                            mem[_38790 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                _39665 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _39665 + 68] = mem[idx + _38790 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_39665 + 68] = mem[_39665 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _39665 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 203
                            _43603 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_43603] = 30
                            mem[_43603 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                _45593 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _45593 + 68] = mem[idx + _43603 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_45593 + 68] = mem[_45593 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _45593 + -mem[64] + 100
                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                            if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 203
                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)]
                            _55823 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_55823] = 30
                            mem[_55823 + 32] = 'SafeMath: subtraction overflow'
                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                return 1
                            _57429 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _57429 + 68] = mem[idx + _55823 + 32]
                                idx = idx + 32
                                continue 
                            mem[_57429 + 68] = mem[_57429 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _57429 + -mem[64] + 100
                        _32049 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32049] = 26
                        mem[_32049 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            revert with 0, 'SafeMath: division by zero'
                        if t >= stor209 / totalSupply:
                            _34087 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34087] = 26
                            mem[_34087 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if not _tFeePercent * arg2 / 10000:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                    if stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if t / s * _tFeePercent * arg2 / 10000 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                    if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] += -1 * t / s * _tFeePercent * arg2 / 10000
                                    if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                            else:
                                if t / s * arg2 / arg2 != t / s:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    if 0 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                    if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] += t / s * arg2
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                    if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                    if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[address(arg1)]
                                    if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                        else:
                            _34088 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34088] = 26
                            mem[_34088 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                revert with 0, 'SafeMath: division by zero'
                            if not arg2:
                                if not _tFeePercent * arg2 / 10000:
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                    if stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                            else:
                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not _tFeePercent * arg2 / 10000:
                                    if 0 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                    if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] += stor209 / totalSupply * arg2
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)] < stor204[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor204[address(arg1)] = arg2 - (_tFeePercent * arg2 / 10000) + stor204[address(arg1)]
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)] < stor203[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[address(arg1)]
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += _tFeePercent * arg2 / 10000
                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                else:
                    if stor206[address(msg.sender)]:
                        mem[0] = msg.sender
                        mem[32] = 206
                        if not stor206[address(msg.sender)]:
                            if not arg2:
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _32854 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32854] = 26
                                        mem[_32854 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _32854 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _37774 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37774] = 30
                                            mem[_37774 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _40330 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40330] = 30
                                            mem[_40330 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _41563 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _41563 + 68] = mem[idx + _40330 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41563 + 68] = mem[_41563 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41563 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _48979 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_48979] = 30
                                            mem[_48979 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _51312 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _51312 + 68] = mem[idx + _48979 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_51312 + 68] = mem[_51312 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _51312 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _37899 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37899] = 30
                                        mem[_37899 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _38381 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38381 + 68] = mem[idx + _37899 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38381 + 68] = mem[_38381 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38381 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _40942 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_40942] = 30
                                        mem[_40942 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _42399 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42399 + 68] = mem[idx + _40942 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42399 + 68] = mem[_42399 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42399 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _50187 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50187] = 30
                                        mem[_50187 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _52214 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52214 + 68] = mem[idx + _50187 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52214 + 68] = mem[_52214 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52214 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _33074 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33074] = 30
                                        mem[_33074 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _33614 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _33614 + 68] = mem[idx + _33074 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33614 + 68] = mem[_33614 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33614 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _35549 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35549] = 30
                                        mem[_35549 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _36401 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _36401 + 68] = mem[idx + _35549 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36401 + 68] = mem[_36401 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36401 + -mem[64] + 100
                                    _33352 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33352] = 26
                                    mem[_33352 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _33352 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _38030 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38030] = 30
                                        mem[_38030 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41568 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41568] = 30
                                        mem[_41568 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _43388 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43388 + 68] = mem[idx + _41568 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43388 + 68] = mem[_43388 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43388 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _51315 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51315] = 30
                                        mem[_51315 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _52914 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52914 + 68] = mem[idx + _51315 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52914 + 68] = mem[_52914 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52914 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38384 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38384] = 30
                                    mem[_38384 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _39180 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39180 + 68] = mem[idx + _38384 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39180 + 68] = mem[_39180 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39180 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42402 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42402] = 30
                                    mem[_42402 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _44328 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44328 + 68] = mem[idx + _42402 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44328 + 68] = mem[_44328 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44328 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _52217 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52217] = 30
                                    mem[_52217 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _53679 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53679 + 68] = mem[idx + _52217 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53679 + 68] = mem[_53679 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53679 + -mem[64] + 100
                                _31984 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31984] = 26
                                mem[_31984 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _33996 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33996] = 26
                                    mem[_33996 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                else:
                                    _33997 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33997] = 26
                                    mem[_33997 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if _tFeePercent * arg2 / 10000 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _32849 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32849] = 26
                                        mem[_32849 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _32849 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                _37773 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37773] = 30
                                                mem[_37773 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _40319 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40319] = 30
                                                mem[_40319 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _41551 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _41551 + 68] = mem[idx + _40319 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_41551 + 68] = mem[_41551 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _41551 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _48959 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_48959] = 30
                                                mem[_48959 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                    return 1
                                                _51299 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _51299 + 68] = mem[idx + _48959 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_51299 + 68] = mem[_51299 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _51299 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _37896 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37896] = 30
                                            mem[_37896 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                _38376 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38376 + 68] = mem[idx + _37896 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38376 + 68] = mem[_38376 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38376 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _40935 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40935] = 30
                                            mem[_40935 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _42386 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42386 + 68] = mem[idx + _40935 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42386 + 68] = mem[_42386 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42386 + -mem[64] + 100
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _50171 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50171] = 30
                                            mem[_50171 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _52207 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52207 + 68] = mem[idx + _50171 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52207 + 68] = mem[_52207 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52207 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            _37895 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37895] = 30
                                            mem[_37895 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _38373 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38373 + 68] = mem[idx + _37895 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38373 + 68] = mem[_38373 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38373 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _40934 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40934] = 30
                                            mem[_40934 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _42383 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42383 + 68] = mem[idx + _40934 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42383 + 68] = mem[_42383 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42383 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _50170 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50170] = 30
                                            mem[_50170 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _52204 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52204 + 68] = mem[idx + _50170 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52204 + 68] = mem[_52204 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52204 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38026 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38026] = 30
                                        mem[_38026 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            _38719 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38719 + 68] = mem[idx + _38026 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38719 + 68] = mem[_38719 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38719 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41550 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41550] = 30
                                        mem[_41550 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _43369 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43369 + 68] = mem[idx + _41550 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43369 + 68] = mem[_43369 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43369 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _51298 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51298] = 30
                                        mem[_51298 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _52903 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52903 + 68] = mem[idx + _51298 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52903 + 68] = mem[_52903 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52903 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _33071 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33071] = 30
                                        mem[_33071 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _33610 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _33610 + 68] = mem[idx + _33071 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33610 + 68] = mem[_33610 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33610 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _35542 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35542] = 30
                                        mem[_35542 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _36393 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _36393 + 68] = mem[idx + _35542 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36393 + 68] = mem[_36393 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36393 + -mem[64] + 100
                                    _33347 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33347] = 26
                                    mem[_33347 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _33347 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            _38029 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38029] = 30
                                            mem[_38029 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41560 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41560] = 30
                                            mem[_41560 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _43376 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43376 + 68] = mem[idx + _41560 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43376 + 68] = mem[_43376 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43376 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _51303 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51303] = 30
                                            mem[_51303 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _52908 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52908 + 68] = mem[idx + _51303 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52908 + 68] = mem[_52908 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52908 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38380 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38380] = 30
                                        mem[_38380 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            _39174 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39174 + 68] = mem[idx + _38380 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39174 + 68] = mem[_39174 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39174 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42392 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42392] = 30
                                        mem[_42392 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _44318 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44318 + 68] = mem[idx + _42392 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44318 + 68] = mem[_44318 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44318 + -mem[64] + 100
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _52211 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52211] = 30
                                        mem[_52211 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _53671 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53671 + 68] = mem[idx + _52211 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53671 + 68] = mem[_53671 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53671 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        _38379 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38379] = 30
                                        mem[_38379 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39171 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39171 + 68] = mem[idx + _38379 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39171 + 68] = mem[_39171 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39171 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42391 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42391] = 30
                                        mem[_42391 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _44315 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44315 + 68] = mem[idx + _42391 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44315 + 68] = mem[_44315 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44315 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _52210 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52210] = 30
                                        mem[_52210 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _53668 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53668 + 68] = mem[idx + _52210 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53668 + 68] = mem[_53668 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53668 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38722 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38722] = 30
                                    mem[_38722 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        _39583 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39583 + 68] = mem[idx + _38722 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39583 + 68] = mem[_39583 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39583 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _43375 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43375] = 30
                                    mem[_43375 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _45351 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45351 + 68] = mem[idx + _43375 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45351 + 68] = mem[_45351 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45351 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _52907 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52907] = 30
                                    mem[_52907 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _54604 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54604 + 68] = mem[idx + _52907 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54604 + 68] = mem[_54604 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54604 + -mem[64] + 100
                                _31979 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31979] = 26
                                mem[_31979 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _33989 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33989] = 26
                                    mem[_33989 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                else:
                                    _33990 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33990] = 26
                                    mem[_33990 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                        else:
                            mem[0] = arg1
                            mem[32] = 206
                            if not stor206[address(arg1)]:
                                if not arg2:
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero'
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _32864 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32864] = 26
                                            mem[_32864 + 32] = 'SafeMath: division by zero'
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _32864 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                _37778 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37778] = 30
                                                mem[_37778 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _40361 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40361] = 30
                                                mem[_40361 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _41586 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _41586 + 68] = mem[idx + _40361 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_41586 + 68] = mem[_41586 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _41586 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _49021 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_49021] = 30
                                                mem[_49021 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    return 1
                                                _51348 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _51348 + 68] = mem[idx + _49021 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_51348 + 68] = mem[_51348 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _51348 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _37904 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37904] = 30
                                            mem[_37904 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _38397 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38397 + 68] = mem[idx + _37904 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38397 + 68] = mem[_38397 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38397 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _40962 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40962] = 30
                                            mem[_40962 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _42431 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42431 + 68] = mem[idx + _40962 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42431 + 68] = mem[_42431 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42431 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _50226 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50226] = 30
                                            mem[_50226 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _52238 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52238 + 68] = mem[idx + _50226 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52238 + 68] = mem[_52238 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52238 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _33080 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33080] = 30
                                            mem[_33080 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _33622 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _33622 + 68] = mem[idx + _33080 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_33622 + 68] = mem[_33622 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _33622 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _35563 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35563] = 30
                                            mem[_35563 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _36417 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _36417 + 68] = mem[idx + _35563 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36417 + 68] = mem[_36417 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36417 + -mem[64] + 100
                                        _33362 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33362] = 26
                                        mem[_33362 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _33362 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _38035 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38035] = 30
                                            mem[_38035 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41591 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41591] = 30
                                            mem[_41591 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _43424 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43424 + 68] = mem[idx + _41591 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43424 + 68] = mem[_43424 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43424 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _51351 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51351] = 30
                                            mem[_51351 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _52932 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52932 + 68] = mem[idx + _51351 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52932 + 68] = mem[_52932 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52932 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38400 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38400] = 30
                                        mem[_38400 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39198 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39198 + 68] = mem[idx + _38400 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39198 + 68] = mem[_39198 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39198 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42434 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42434] = 30
                                        mem[_42434 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _44360 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44360 + 68] = mem[idx + _42434 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44360 + 68] = mem[_44360 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44360 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _52241 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52241] = 30
                                        mem[_52241 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _53701 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53701 + 68] = mem[idx + _52241 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53701 + 68] = mem[_53701 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53701 + -mem[64] + 100
                                    _31994 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31994] = 26
                                    mem[_31994 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _34010 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34010] = 26
                                        mem[_34010 + 32] = 'SafeMath: division by zero'
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                    else:
                                        _34011 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34011] = 26
                                        mem[_34011 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero'
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if _tFeePercent * arg2 / 10000 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _32859 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32859] = 26
                                            mem[_32859 + 32] = 'SafeMath: division by zero'
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _32859 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                if not _tFeePercent * arg2 / 10000:
                                                    _37777 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_37777] = 30
                                                    mem[_37777 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 203
                                                    _40350 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_40350] = 30
                                                    mem[_40350 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor203[address(msg.sender)]:
                                                        _41574 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _41574 + 68] = mem[idx + _40350 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_41574 + 68] = mem[_41574 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _41574 + -mem[64] + 100
                                                    if stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 203
                                                    stor203[address(arg1)] = stor203[arg1]
                                                    _49001 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_49001] = 30
                                                    mem[_49001 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor209:
                                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += _tFeePercent * arg2 / 10000
                                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                        return 1
                                                    _51335 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _51335 + 68] = mem[idx + _49001 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_51335 + 68] = mem[_51335 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _51335 + -mem[64] + 100
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _37901 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37901] = 30
                                                mem[_37901 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                    _38392 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _38392 + 68] = mem[idx + _37901 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_38392 + 68] = mem[_38392 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _38392 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _40955 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40955] = 30
                                                mem[_40955 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _42418 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _42418 + 68] = mem[idx + _40955 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42418 + 68] = mem[_42418 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42418 + -mem[64] + 100
                                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                _50210 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_50210] = 30
                                                mem[_50210 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                    return 1
                                                _52231 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _52231 + 68] = mem[idx + _50210 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_52231 + 68] = mem[_52231 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _52231 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not _tFeePercent * arg2 / 10000:
                                                _37900 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37900] = 30
                                                mem[_37900 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor209 / totalSupply * arg2:
                                                    _38389 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _38389 + 68] = mem[idx + _37900 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_38389 + 68] = mem[_38389 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _38389 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _40954 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40954] = 30
                                                mem[_40954 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    _42415 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _42415 + 68] = mem[idx + _40954 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42415 + 68] = mem[_42415 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42415 + -mem[64] + 100
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                                _50209 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_50209] = 30
                                                mem[_50209 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                    return 1
                                                _52228 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _52228 + 68] = mem[idx + _50209 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_52228 + 68] = mem[_52228 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _52228 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _38031 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38031] = 30
                                            mem[_38031 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                _38731 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38731 + 68] = mem[idx + _38031 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38731 + 68] = mem[_38731 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38731 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41573 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41573] = 30
                                            mem[_41573 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _43405 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43405 + 68] = mem[idx + _41573 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43405 + 68] = mem[_43405 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43405 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _51334 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51334] = 30
                                            mem[_51334 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _52921 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52921 + 68] = mem[idx + _51334 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52921 + 68] = mem[_52921 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52921 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _33077 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33077] = 30
                                            mem[_33077 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _33618 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _33618 + 68] = mem[idx + _33077 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_33618 + 68] = mem[_33618 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _33618 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _35556 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35556] = 30
                                            mem[_35556 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _36409 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _36409 + 68] = mem[idx + _35556 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36409 + 68] = mem[_36409 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36409 + -mem[64] + 100
                                        _33357 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33357] = 26
                                        mem[_33357 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _33357 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                _38034 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38034] = 30
                                                mem[_38034 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _41583 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41583] = 30
                                                mem[_41583 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _43412 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _43412 + 68] = mem[idx + _41583 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_43412 + 68] = mem[_43412 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _43412 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _51339 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_51339] = 30
                                                mem[_51339 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                    return 1
                                                _52926 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _52926 + 68] = mem[idx + _51339 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_52926 + 68] = mem[_52926 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _52926 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _38396 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38396] = 30
                                            mem[_38396 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                _39192 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39192 + 68] = mem[idx + _38396 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39192 + 68] = mem[_39192 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39192 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42424 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42424] = 30
                                            mem[_42424 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _44350 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44350 + 68] = mem[idx + _42424 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44350 + 68] = mem[_44350 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44350 + -mem[64] + 100
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _52235 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_52235] = 30
                                            mem[_52235 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _53693 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53693 + 68] = mem[idx + _52235 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53693 + 68] = mem[_53693 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53693 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            _38395 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38395] = 30
                                            mem[_38395 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _39189 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39189 + 68] = mem[idx + _38395 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39189 + 68] = mem[_39189 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39189 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42423 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42423] = 30
                                            mem[_42423 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _44347 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44347 + 68] = mem[idx + _42423 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44347 + 68] = mem[_44347 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44347 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _52234 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_52234] = 30
                                            mem[_52234 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _53690 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53690 + 68] = mem[idx + _52234 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53690 + 68] = mem[_53690 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53690 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38734 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38734] = 30
                                        mem[_38734 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            _39597 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39597 + 68] = mem[idx + _38734 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39597 + 68] = mem[_39597 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39597 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _43411 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43411] = 30
                                        mem[_43411 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _45389 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45389 + 68] = mem[idx + _43411 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45389 + 68] = mem[_45389 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45389 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _52925 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52925] = 30
                                        mem[_52925 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _54636 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54636 + 68] = mem[idx + _52925 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54636 + 68] = mem[_54636 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54636 + -mem[64] + 100
                                    _31989 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31989] = 26
                                    mem[_31989 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _34003 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34003] = 26
                                        mem[_34003 + 32] = 'SafeMath: division by zero'
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if t / s * _tFeePercent * arg2 / 10000 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > t / s * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if t / s * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                                if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if t / s * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                                if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                    else:
                                        _34004 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34004] = 26
                                        mem[_34004 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > stor209 / totalSupply * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                            else:
                                if not arg2:
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero'
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _32874 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32874] = 26
                                            mem[_32874 + 32] = 'SafeMath: division by zero'
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _32874 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                _37780 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37780] = 30
                                                mem[_37780 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 204
                                                _40381 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40381] = 30
                                                mem[_40381 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    _41602 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _41602 + 68] = mem[idx + _40381 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_41602 + 68] = mem[_41602 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _41602 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                stor204[address(msg.sender)] -= arg2
                                                mem[32] = 203
                                                _44379 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_44379] = 30
                                                mem[_44379 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _46659 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _46659 + 68] = mem[idx + _44379 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_46659 + 68] = mem[_46659 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _46659 + -mem[64] + 100
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                _56509 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_56509] = 30
                                                mem[_56509 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    return 1
                                                _58230 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _58230 + 68] = mem[idx + _56509 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_58230 + 68] = mem[_58230 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _58230 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _37906 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37906] = 30
                                            mem[_37906 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _38405 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38405 + 68] = mem[idx + _37906 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38405 + 68] = mem[_38405 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38405 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _40970 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40970] = 30
                                            mem[_40970 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _42451 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42451 + 68] = mem[idx + _40970 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42451 + 68] = mem[_42451 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42451 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _45428 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45428] = 30
                                            mem[_45428 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _47803 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _47803 + 68] = mem[idx + _45428 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_47803 + 68] = mem[_47803 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _47803 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                            _57306 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_57306] = 30
                                            mem[_57306 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _59003 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _59003 + 68] = mem[idx + _57306 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_59003 + 68] = mem[_59003 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _59003 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _33086 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33086] = 30
                                            mem[_33086 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _33630 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _33630 + 68] = mem[idx + _33086 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_33630 + 68] = mem[_33630 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _33630 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _35577 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35577] = 30
                                            mem[_35577 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _36433 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _36433 + 68] = mem[idx + _35577 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36433 + 68] = mem[_36433 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36433 + -mem[64] + 100
                                        _33372 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33372] = 26
                                        mem[_33372 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _33372 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _38037 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38037] = 30
                                            mem[_38037 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _41607 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41607] = 30
                                            mem[_41607 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _43448 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43448 + 68] = mem[idx + _41607 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43448 + 68] = mem[_43448 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43448 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _46665 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_46665] = 30
                                            mem[_46665 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _49061 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _49061 + 68] = mem[idx + _46665 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_49061 + 68] = mem[_49061 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _49061 + -mem[64] + 100
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            _58233 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_58233] = 30
                                            mem[_58233 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _59605 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _59605 + 68] = mem[idx + _58233 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_59605 + 68] = mem[_59605 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _59605 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38408 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38408] = 30
                                        mem[_38408 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39210 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39210 + 68] = mem[idx + _38408 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39210 + 68] = mem[_39210 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39210 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _42454 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42454] = 30
                                        mem[_42454 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _44382 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44382 + 68] = mem[idx + _42454 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44382 + 68] = mem[_44382 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44382 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _47806 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_47806] = 30
                                        mem[_47806 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _50257 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _50257 + 68] = mem[idx + _47806 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50257 + 68] = mem[_50257 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50257 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                                        _59006 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_59006] = 30
                                        mem[_59006 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _60187 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _60187 + 68] = mem[idx + _59006 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_60187 + 68] = mem[_60187 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _60187 + -mem[64] + 100
                                    _32004 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32004] = 26
                                    mem[_32004 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _34024 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34024] = 26
                                        mem[_34024 + 32] = 'SafeMath: division by zero'
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] += t / s * arg2
                                    else:
                                        _34025 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34025] = 26
                                        mem[_34025 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                else:
                                    if 0 / arg2:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero'
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _32869 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32869] = 26
                                            mem[_32869 + 32] = 'SafeMath: division by zero'
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _32869 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                _37779 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37779] = 30
                                                mem[_37779 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 204
                                                _40371 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40371] = 30
                                                mem[_40371 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    _41594 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _41594 + 68] = mem[idx + _40371 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_41594 + 68] = mem[_41594 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _41594 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                stor204[address(msg.sender)] -= arg2
                                                mem[32] = 203
                                                _44368 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_44368] = 30
                                                mem[_44368 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _46643 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _46643 + 68] = mem[idx + _44368 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_46643 + 68] = mem[_46643 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _46643 + -mem[64] + 100
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                _56501 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_56501] = 30
                                                mem[_56501 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    return 1
                                                _58220 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _58220 + 68] = mem[idx + _56501 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_58220 + 68] = mem[_58220 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _58220 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _37905 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37905] = 30
                                            mem[_37905 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _38401 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38401 + 68] = mem[idx + _37905 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38401 + 68] = mem[_38401 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38401 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _40966 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40966] = 30
                                            mem[_40966 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _42441 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42441 + 68] = mem[idx + _40966 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42441 + 68] = mem[_42441 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42441 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _45415 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_45415] = 30
                                            mem[_45415 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _47790 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _47790 + 68] = mem[idx + _45415 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_47790 + 68] = mem[_47790 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _47790 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                            _57300 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_57300] = 30
                                            mem[_57300 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _58997 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _58997 + 68] = mem[idx + _57300 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_58997 + 68] = mem[_58997 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _58997 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _33083 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33083] = 30
                                            mem[_33083 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _33626 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _33626 + 68] = mem[idx + _33083 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_33626 + 68] = mem[_33626 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _33626 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _35570 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35570] = 30
                                            mem[_35570 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _36425 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _36425 + 68] = mem[idx + _35570 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36425 + 68] = mem[_36425 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36425 + -mem[64] + 100
                                        _33367 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33367] = 26
                                        mem[_33367 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _33367 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _38036 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38036] = 30
                                            mem[_38036 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _41599 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41599] = 30
                                            mem[_41599 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _43436 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43436 + 68] = mem[idx + _41599 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43436 + 68] = mem[_43436 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43436 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _46649 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_46649] = 30
                                            mem[_46649 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _49042 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _49042 + 68] = mem[idx + _46649 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_49042 + 68] = mem[_49042 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _49042 + -mem[64] + 100
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            _58223 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_58223] = 30
                                            mem[_58223 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _59599 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _59599 + 68] = mem[idx + _58223 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_59599 + 68] = mem[_59599 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _59599 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38404 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38404] = 30
                                        mem[_38404 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39204 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39204 + 68] = mem[idx + _38404 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39204 + 68] = mem[_39204 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39204 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 204
                                        _42444 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42444] = 30
                                        mem[_42444 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 > stor204[address(msg.sender)]:
                                            _44371 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44371 + 68] = mem[idx + _42444 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44371 + 68] = mem[_44371 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44371 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        stor204[address(msg.sender)] -= arg2
                                        mem[32] = 203
                                        _47793 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_47793] = 30
                                        mem[_47793 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _50241 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _50241 + 68] = mem[idx + _47793 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_50241 + 68] = mem[_50241 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _50241 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor204[address(arg1)] += arg2
                                        if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] += stor209 / totalSupply * arg2
                                        _59000 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_59000] = 30
                                        mem[_59000 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _60179 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _60179 + 68] = mem[idx + _59000 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_60179 + 68] = mem[_60179 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _60179 + -mem[64] + 100
                                    _31999 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_31999] = 26
                                    mem[_31999 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _34017 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34017] = 26
                                        mem[_34017 + 32] = 'SafeMath: division by zero'
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] += t / s * arg2
                                    else:
                                        _34018 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34018] = 26
                                        mem[_34018 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor204[address(msg.sender)] -= arg2
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                    else:
                        mem[0] = arg1
                        mem[32] = 206
                        if not stor206[address(arg1)]:
                            if not arg2:
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _32914 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32914] = 26
                                        mem[_32914 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _32914 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _37794 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37794] = 30
                                            mem[_37794 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _40494 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40494] = 30
                                            mem[_40494 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _41687 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _41687 + 68] = mem[idx + _40494 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_41687 + 68] = mem[_41687 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _41687 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _49223 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_49223] = 30
                                            mem[_49223 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _51520 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _51520 + 68] = mem[idx + _49223 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_51520 + 68] = mem[_51520 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _51520 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _37923 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_37923] = 30
                                        mem[_37923 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _38461 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38461 + 68] = mem[idx + _37923 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38461 + 68] = mem[_38461 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38461 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41038 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41038] = 30
                                        mem[_41038 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _42567 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _42567 + 68] = mem[idx + _41038 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_42567 + 68] = mem[_42567 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _42567 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _50407 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_50407] = 30
                                        mem[_50407 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _52374 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _52374 + 68] = mem[idx + _50407 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_52374 + 68] = mem[_52374 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _52374 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _33110 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33110] = 30
                                        mem[_33110 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _33662 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _33662 + 68] = mem[idx + _33110 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33662 + 68] = mem[_33662 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33662 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _35633 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35633] = 30
                                        mem[_35633 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _36497 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _36497 + 68] = mem[idx + _35633 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36497 + 68] = mem[_36497 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36497 + -mem[64] + 100
                                    _33412 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33412] = 26
                                    mem[_33412 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _33412 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        _38054 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38054] = 30
                                        mem[_38054 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41692 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41692] = 30
                                        mem[_41692 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _43580 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43580 + 68] = mem[idx + _41692 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43580 + 68] = mem[_43580 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43580 + -mem[64] + 100
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = stor203[arg1]
                                        _51523 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51523] = 30
                                        mem[_51523 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _53038 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53038 + 68] = mem[idx + _51523 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53038 + 68] = mem[_53038 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53038 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38464 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38464] = 30
                                    mem[_38464 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor209 / totalSupply * arg2:
                                        _39276 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39276 + 68] = mem[idx + _38464 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39276 + 68] = mem[_39276 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39276 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _42570 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_42570] = 30
                                    mem[_42570 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _44500 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _44500 + 68] = mem[idx + _42570 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_44500 + 68] = mem[_44500 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _44500 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    _52377 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_52377] = 30
                                    mem[_52377 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor209:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _53835 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _53835 + 68] = mem[idx + _52377 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_53835 + 68] = mem[_53835 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _53835 + -mem[64] + 100
                                _32044 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32044] = 26
                                mem[_32044 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _34080 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34080] = 26
                                    mem[_34080 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > t / s * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if t / s * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * t / s * arg2
                                        if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                else:
                                    _34081 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34081] = 26
                                    mem[_34081 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = stor203[arg1]
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > stor209 / totalSupply * arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                if 0 > stor209:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if _tFeePercent * arg2 / 10000 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = totalSupply
                                t = stor209
                                while idx < stor207.length:
                                    mem[0] = stor207[idx]
                                    mem[32] = 203
                                    if stor203[stor207[idx]] > t:
                                        _32909 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32909] = 26
                                        mem[_32909 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _32909 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                _37793 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37793] = 30
                                                mem[_37793 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _40483 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40483] = 30
                                                mem[_40483 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _41675 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _41675 + 68] = mem[idx + _40483 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_41675 + 68] = mem[_41675 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _41675 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _49203 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_49203] = 30
                                                mem[_49203 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                    return 1
                                                _51507 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _51507 + 68] = mem[idx + _49203 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_51507 + 68] = mem[_51507 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _51507 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _37920 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37920] = 30
                                            mem[_37920 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                _38456 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38456 + 68] = mem[idx + _37920 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38456 + 68] = mem[_38456 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38456 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41031 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41031] = 30
                                            mem[_41031 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _42554 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42554 + 68] = mem[idx + _41031 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42554 + 68] = mem[_42554 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42554 + -mem[64] + 100
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _50391 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50391] = 30
                                            mem[_50391 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _52367 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52367 + 68] = mem[idx + _50391 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52367 + 68] = mem[_52367 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52367 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            _37919 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37919] = 30
                                            mem[_37919 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _38453 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38453 + 68] = mem[idx + _37919 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38453 + 68] = mem[_38453 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38453 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41030 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41030] = 30
                                            mem[_41030 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _42551 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42551 + 68] = mem[idx + _41030 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42551 + 68] = mem[_42551 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42551 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _50390 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50390] = 30
                                            mem[_50390 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _52364 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52364 + 68] = mem[idx + _50390 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52364 + 68] = mem[_52364 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52364 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38050 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38050] = 30
                                        mem[_38050 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            _38775 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _38775 + 68] = mem[idx + _38050 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_38775 + 68] = mem[_38775 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _38775 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _41674 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_41674] = 30
                                        mem[_41674 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _43561 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _43561 + 68] = mem[idx + _41674 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_43561 + 68] = mem[_43561 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _43561 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _51506 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_51506] = 30
                                        mem[_51506 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _53027 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53027 + 68] = mem[idx + _51506 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53027 + 68] = mem[_53027 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53027 + -mem[64] + 100
                                    require idx < stor207.length
                                    mem[0] = stor207[idx]
                                    mem[32] = 204
                                    if stor204[stor207[idx]] <= s:
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        _33107 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33107] = 30
                                        mem[_33107 + 32] = 'SafeMath: subtraction overflow'
                                        if stor203[stor207[idx]] > t:
                                            _33658 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _33658 + 68] = mem[idx + _33107 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_33658 + 68] = mem[_33658 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _33658 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        _35626 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_35626] = 30
                                        mem[_35626 + 32] = 'SafeMath: subtraction overflow'
                                        if stor204[stor207[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor204[stor207[idx]]
                                            t = t - stor203[stor207[idx]]
                                            continue 
                                        _36489 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _36489 + 68] = mem[idx + _35626 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_36489 + 68] = mem[_36489 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _36489 + -mem[64] + 100
                                    _33407 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_33407] = 26
                                    mem[_33407 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _33407 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            _38053 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38053] = 30
                                            mem[_38053 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41684 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41684] = 30
                                            mem[_41684 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _43568 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43568 + 68] = mem[idx + _41684 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43568 + 68] = mem[_43568 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43568 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _51511 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51511] = 30
                                            mem[_51511 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _53032 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53032 + 68] = mem[idx + _51511 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53032 + 68] = mem[_53032 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53032 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38460 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38460] = 30
                                        mem[_38460 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                            _39270 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39270 + 68] = mem[idx + _38460 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39270 + 68] = mem[_39270 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39270 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42560 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42560] = 30
                                        mem[_42560 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor203[address(msg.sender)]:
                                            _44490 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44490 + 68] = mem[idx + _42560 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44490 + 68] = mem[_44490 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44490 + -mem[64] + 100
                                        if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _52371 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52371] = 30
                                        mem[_52371 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _53827 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53827 + 68] = mem[idx + _52371 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53827 + 68] = mem[_53827 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53827 + -mem[64] + 100
                                    if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not _tFeePercent * arg2 / 10000:
                                        _38459 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38459] = 30
                                        mem[_38459 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39267 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39267 + 68] = mem[idx + _38459 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39267 + 68] = mem[_39267 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39267 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42559 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42559] = 30
                                        mem[_42559 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _44487 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44487 + 68] = mem[idx + _42559 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44487 + 68] = mem[_44487 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44487 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _52370 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52370] = 30
                                        mem[_52370 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _53824 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53824 + 68] = mem[idx + _52370 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53824 + 68] = mem[_53824 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53824 + -mem[64] + 100
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _38778 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_38778] = 30
                                    mem[_38778 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                        _39651 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _39651 + 68] = mem[idx + _38778 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_39651 + 68] = mem[_39651 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _39651 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 203
                                    _43567 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_43567] = 30
                                    mem[_43567 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                        _45555 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _45555 + 68] = mem[idx + _43567 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_45555 + 68] = mem[_45555 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _45555 + -mem[64] + 100
                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 203
                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                    _53031 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_53031] = 30
                                    mem[_53031 + 32] = 'SafeMath: subtraction overflow'
                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                        return 1
                                    _54792 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _54792 + 68] = mem[idx + _53031 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_54792 + 68] = mem[_54792 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _54792 + -mem[64] + 100
                                _32039 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_32039] = 26
                                mem[_32039 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    revert with 0, 'SafeMath: division by zero'
                                if t >= stor209 / totalSupply:
                                    _34073 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34073] = 26
                                    mem[_34073 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                    else:
                                        if t / s * arg2 / arg2 != t / s:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                else:
                                    _34074 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_34074] = 26
                                    mem[_34074 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if not arg2:
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    else:
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            if 0 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += _tFeePercent * arg2 / 10000
                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                        else:
                            mem[0] = msg.sender
                            mem[32] = 206
                            if not stor206[address(msg.sender)]:
                                if not arg2:
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero'
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _32884 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32884] = 26
                                            mem[_32884 + 32] = 'SafeMath: division by zero'
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _32884 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                _37784 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37784] = 30
                                                mem[_37784 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _40412 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40412] = 30
                                                mem[_40412 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _41625 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _41625 + 68] = mem[idx + _40412 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_41625 + 68] = mem[_41625 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _41625 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _49101 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_49101] = 30
                                                mem[_49101 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    return 1
                                                _51416 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _51416 + 68] = mem[idx + _49101 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_51416 + 68] = mem[_51416 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _51416 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _37911 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_37911] = 30
                                            mem[_37911 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _38421 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38421 + 68] = mem[idx + _37911 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38421 + 68] = mem[_38421 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38421 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _40990 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_40990] = 30
                                            mem[_40990 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _42483 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _42483 + 68] = mem[idx + _40990 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_42483 + 68] = mem[_42483 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _42483 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _50297 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_50297] = 30
                                            mem[_50297 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _52294 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52294 + 68] = mem[idx + _50297 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52294 + 68] = mem[_52294 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52294 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _33092 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33092] = 30
                                            mem[_33092 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _33638 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _33638 + 68] = mem[idx + _33092 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_33638 + 68] = mem[_33638 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _33638 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _35591 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35591] = 30
                                            mem[_35591 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _36449 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _36449 + 68] = mem[idx + _35591 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36449 + 68] = mem[_36449 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36449 + -mem[64] + 100
                                        _33382 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33382] = 26
                                        mem[_33382 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _33382 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            _38042 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38042] = 30
                                            mem[_38042 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41630 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41630] = 30
                                            mem[_41630 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _43484 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43484 + 68] = mem[idx + _41630 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43484 + 68] = mem[_43484 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43484 + -mem[64] + 100
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = stor203[arg1]
                                            _51419 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51419] = 30
                                            mem[_51419 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _52976 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52976 + 68] = mem[idx + _51419 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52976 + 68] = mem[_52976 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52976 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38424 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38424] = 30
                                        mem[_38424 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor209 / totalSupply * arg2:
                                            _39228 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39228 + 68] = mem[idx + _38424 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39228 + 68] = mem[_39228 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39228 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _42486 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_42486] = 30
                                        mem[_42486 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _44414 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _44414 + 68] = mem[idx + _42486 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_44414 + 68] = mem[_44414 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _44414 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        _52297 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52297] = 30
                                        mem[_52297 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor209:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _53757 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _53757 + 68] = mem[idx + _52297 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_53757 + 68] = mem[_53757 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _53757 + -mem[64] + 100
                                    _32014 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32014] = 26
                                    mem[_32014 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _34038 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34038] = 26
                                        mem[_34038 + 32] = 'SafeMath: division by zero'
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > t / s * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if t / s * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * t / s * arg2
                                            if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                    else:
                                        _34039 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34039] = 26
                                        mem[_34039 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if 0 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = stor203[arg1]
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 0 > stor209 / totalSupply * arg2:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                    32,
                                                    33,
                                                    0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[197 len 31]
                                    mem[96] = 26
                                    mem[128] = 'SafeMath: division by zero'
                                    mem[64] = 224
                                    mem[160] = 30
                                    mem[192] = 'SafeMath: subtraction overflow'
                                    if _tFeePercent * arg2 / 10000 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    idx = 0
                                    s = totalSupply
                                    t = stor209
                                    while idx < stor207.length:
                                        mem[0] = stor207[idx]
                                        mem[32] = 203
                                        if stor203[stor207[idx]] > t:
                                            _32879 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_32879] = 26
                                            mem[_32879 + 32] = 'SafeMath: division by zero'
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _32879 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                if not _tFeePercent * arg2 / 10000:
                                                    _37783 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_37783] = 30
                                                    mem[_37783 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 203
                                                    _40401 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_40401] = 30
                                                    mem[_40401 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor203[address(msg.sender)]:
                                                        _41613 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _41613 + 68] = mem[idx + _40401 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_41613 + 68] = mem[_41613 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _41613 + -mem[64] + 100
                                                    if stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 203
                                                    stor203[address(arg1)] = stor203[arg1]
                                                    _49081 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_49081] = 30
                                                    mem[_49081 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor209:
                                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += _tFeePercent * arg2 / 10000
                                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                        return 1
                                                    _51403 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _51403 + 68] = mem[idx + _49081 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_51403 + 68] = mem[_51403 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _51403 + -mem[64] + 100
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _37908 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37908] = 30
                                                mem[_37908 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                    _38416 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _38416 + 68] = mem[idx + _37908 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_38416 + 68] = mem[_38416 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _38416 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _40983 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40983] = 30
                                                mem[_40983 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _42470 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _42470 + 68] = mem[idx + _40983 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42470 + 68] = mem[_42470 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42470 + -mem[64] + 100
                                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                _50281 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_50281] = 30
                                                mem[_50281 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                    return 1
                                                _52287 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _52287 + 68] = mem[idx + _50281 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_52287 + 68] = mem[_52287 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _52287 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not _tFeePercent * arg2 / 10000:
                                                _37907 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37907] = 30
                                                mem[_37907 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor209 / totalSupply * arg2:
                                                    _38413 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _38413 + 68] = mem[idx + _37907 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_38413 + 68] = mem[_38413 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _38413 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _40982 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_40982] = 30
                                                mem[_40982 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    _42467 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _42467 + 68] = mem[idx + _40982 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42467 + 68] = mem[_42467 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42467 + -mem[64] + 100
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                                _50280 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_50280] = 30
                                                mem[_50280 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                    return 1
                                                _52284 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _52284 + 68] = mem[idx + _50280 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_52284 + 68] = mem[_52284 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _52284 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _38038 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38038] = 30
                                            mem[_38038 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                _38747 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _38747 + 68] = mem[idx + _38038 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_38747 + 68] = mem[_38747 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _38747 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _41612 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_41612] = 30
                                            mem[_41612 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _43465 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _43465 + 68] = mem[idx + _41612 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_43465 + 68] = mem[_43465 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _43465 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _51402 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_51402] = 30
                                            mem[_51402 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _52965 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _52965 + 68] = mem[idx + _51402 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_52965 + 68] = mem[_52965 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _52965 + -mem[64] + 100
                                        require idx < stor207.length
                                        mem[0] = stor207[idx]
                                        mem[32] = 204
                                        if stor204[stor207[idx]] <= s:
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            _33089 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33089] = 30
                                            mem[_33089 + 32] = 'SafeMath: subtraction overflow'
                                            if stor203[stor207[idx]] > t:
                                                _33634 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _33634 + 68] = mem[idx + _33089 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_33634 + 68] = mem[_33634 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _33634 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            _35584 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_35584] = 30
                                            mem[_35584 + 32] = 'SafeMath: subtraction overflow'
                                            if stor204[stor207[idx]] <= s:
                                                idx = idx + 1
                                                s = s - stor204[stor207[idx]]
                                                t = t - stor203[stor207[idx]]
                                                continue 
                                            _36441 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _36441 + 68] = mem[idx + _35584 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_36441 + 68] = mem[_36441 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _36441 + -mem[64] + 100
                                        _33377 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33377] = 26
                                        mem[_33377 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _33377 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                _38041 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38041] = 30
                                                mem[_38041 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _41622 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41622] = 30
                                                mem[_41622 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _43472 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _43472 + 68] = mem[idx + _41622 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_43472 + 68] = mem[_43472 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _43472 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _51407 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_51407] = 30
                                                mem[_51407 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                    return 1
                                                _52970 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _52970 + 68] = mem[idx + _51407 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_52970 + 68] = mem[_52970 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _52970 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _38420 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38420] = 30
                                            mem[_38420 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                _39222 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39222 + 68] = mem[idx + _38420 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39222 + 68] = mem[_39222 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39222 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42476 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42476] = 30
                                            mem[_42476 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor203[address(msg.sender)]:
                                                _44404 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44404 + 68] = mem[idx + _42476 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44404 + 68] = mem[_44404 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44404 + -mem[64] + 100
                                            if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _52291 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_52291] = 30
                                            mem[_52291 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _53749 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53749 + 68] = mem[idx + _52291 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53749 + 68] = mem[_53749 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53749 + -mem[64] + 100
                                        if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not _tFeePercent * arg2 / 10000:
                                            _38419 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38419] = 30
                                            mem[_38419 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _39219 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39219 + 68] = mem[idx + _38419 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39219 + 68] = mem[_39219 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39219 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42475 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42475] = 30
                                            mem[_42475 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _44401 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44401 + 68] = mem[idx + _42475 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44401 + 68] = mem[_44401 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44401 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _52290 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_52290] = 30
                                            mem[_52290 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _53746 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53746 + 68] = mem[idx + _52290 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53746 + 68] = mem[_53746 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53746 + -mem[64] + 100
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                            revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _38750 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_38750] = 30
                                        mem[_38750 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                            _39617 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _39617 + 68] = mem[idx + _38750 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_39617 + 68] = mem[_39617 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _39617 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 203
                                        _43471 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_43471] = 30
                                        mem[_43471 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                            _45453 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _45453 + 68] = mem[idx + _43471 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_45453 + 68] = mem[_45453 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _45453 + -mem[64] + 100
                                        stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                        if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 203
                                        stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                        _52969 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_52969] = 30
                                        mem[_52969 + 32] = 'SafeMath: subtraction overflow'
                                        if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                            stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += _tFeePercent * arg2 / 10000
                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                            return 1
                                        _54698 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _54698 + 68] = mem[idx + _52969 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_54698 + 68] = mem[_54698 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _54698 + -mem[64] + 100
                                    _32009 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_32009] = 26
                                    mem[_32009 + 32] = 'SafeMath: division by zero'
                                    if not totalSupply:
                                        revert with 0, 'SafeMath: division by zero'
                                    if t >= stor209 / totalSupply:
                                        _34031 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34031] = 26
                                        mem[_34031 + 32] = 'SafeMath: division by zero'
                                        if not s:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if t / s * _tFeePercent * arg2 / 10000 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                        else:
                                            if t / s * arg2 / arg2 != t / s:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > t / s * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if t / s * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                                if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if t / s * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                                if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                    else:
                                        _34032 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_34032] = 26
                                        mem[_34032 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if not arg2:
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        else:
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not _tFeePercent * arg2 / 10000:
                                                if 0 > stor209 / totalSupply * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                                if 0 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                            else:
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += _tFeePercent * arg2 / 10000
                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                            else:
                                mem[0] = arg1
                                mem[32] = 206
                                if not stor206[address(arg1)]:
                                    if not arg2:
                                        mem[96] = 26
                                        mem[128] = 'SafeMath: division by zero'
                                        mem[64] = 224
                                        mem[160] = 30
                                        mem[192] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        idx = 0
                                        s = totalSupply
                                        t = stor209
                                        while idx < stor207.length:
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            if stor203[stor207[idx]] > t:
                                                _32894 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_32894] = 26
                                                mem[_32894 + 32] = 'SafeMath: division by zero'
                                                if not totalSupply:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                    idx = 32
                                                    while idx < 26:
                                                        mem[idx + mem[64] + 68] = mem[idx + _32894 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 'SafeMath: division by zero'
                                                if not arg2:
                                                    _37788 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_37788] = 30
                                                    mem[_37788 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 203
                                                    _40443 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_40443] = 30
                                                    mem[_40443 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor203[address(msg.sender)]:
                                                        _41648 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _41648 + 68] = mem[idx + _40443 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_41648 + 68] = mem[_41648 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _41648 + -mem[64] + 100
                                                    if stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 203
                                                    stor203[address(arg1)] = stor203[arg1]
                                                    _49143 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_49143] = 30
                                                    mem[_49143 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor209:
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                        return 1
                                                    _51452 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _51452 + 68] = mem[idx + _49143 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_51452 + 68] = mem[_51452 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _51452 + -mem[64] + 100
                                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _37916 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37916] = 30
                                                mem[_37916 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor209 / totalSupply * arg2:
                                                    _38437 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _38437 + 68] = mem[idx + _37916 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_38437 + 68] = mem[_38437 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _38437 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _41010 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41010] = 30
                                                mem[_41010 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    _42515 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _42515 + 68] = mem[idx + _41010 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42515 + 68] = mem[_42515 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42515 + -mem[64] + 100
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                                _50336 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_50336] = 30
                                                mem[_50336 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    return 1
                                                _52318 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _52318 + 68] = mem[idx + _50336 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_52318 + 68] = mem[_52318 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _52318 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            if stor204[stor207[idx]] <= s:
                                                require idx < stor207.length
                                                mem[0] = stor207[idx]
                                                mem[32] = 203
                                                _33098 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33098] = 30
                                                mem[_33098 + 32] = 'SafeMath: subtraction overflow'
                                                if stor203[stor207[idx]] > t:
                                                    _33646 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _33646 + 68] = mem[idx + _33098 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_33646 + 68] = mem[_33646 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _33646 + -mem[64] + 100
                                                require idx < stor207.length
                                                mem[0] = stor207[idx]
                                                mem[32] = 204
                                                _35605 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35605] = 30
                                                mem[_35605 + 32] = 'SafeMath: subtraction overflow'
                                                if stor204[stor207[idx]] <= s:
                                                    idx = idx + 1
                                                    s = s - stor204[stor207[idx]]
                                                    t = t - stor203[stor207[idx]]
                                                    continue 
                                                _36465 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _36465 + 68] = mem[idx + _35605 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_36465 + 68] = mem[_36465 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _36465 + -mem[64] + 100
                                            _33392 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33392] = 26
                                            mem[_33392 + 32] = 'SafeMath: division by zero'
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _33392 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                _38047 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38047] = 30
                                                mem[_38047 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _41653 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41653] = 30
                                                mem[_41653 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _43520 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _43520 + 68] = mem[idx + _41653 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_43520 + 68] = mem[_43520 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _43520 + -mem[64] + 100
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = stor203[arg1]
                                                _51455 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_51455] = 30
                                                mem[_51455 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    return 1
                                                _52994 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _52994 + 68] = mem[idx + _51455 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_52994 + 68] = mem[_52994 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _52994 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _38440 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38440] = 30
                                            mem[_38440 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _39246 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39246 + 68] = mem[idx + _38440 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39246 + 68] = mem[_39246 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39246 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _42518 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42518] = 30
                                            mem[_42518 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _44446 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44446 + 68] = mem[idx + _42518 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44446 + 68] = mem[_44446 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44446 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                            _52321 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_52321] = 30
                                            mem[_52321 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _53779 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _53779 + 68] = mem[idx + _52321 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_53779 + 68] = mem[_53779 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _53779 + -mem[64] + 100
                                        _32024 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32024] = 26
                                        mem[_32024 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if t >= stor209 / totalSupply:
                                            _34052 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34052] = 26
                                            mem[_34052 + 32] = 'SafeMath: division by zero'
                                            if not s:
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = stor203[arg1]
                                            else:
                                                if t / s * arg2 / arg2 != t / s:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 0 > t / s * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if t / s * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                                if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                        else:
                                            _34053 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34053] = 26
                                            mem[_34053 + 32] = 'SafeMath: division by zero'
                                            if not totalSupply:
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = stor203[arg1]
                                            else:
                                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 0 > stor209 / totalSupply * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                        if 0 > stor209:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        if _tFeePercent * arg2 / arg2 != _tFeePercent:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        mem[96] = 26
                                        mem[128] = 'SafeMath: division by zero'
                                        mem[64] = 224
                                        mem[160] = 30
                                        mem[192] = 'SafeMath: subtraction overflow'
                                        if _tFeePercent * arg2 / 10000 > arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        idx = 0
                                        s = totalSupply
                                        t = stor209
                                        while idx < stor207.length:
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            if stor203[stor207[idx]] > t:
                                                _32889 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_32889] = 26
                                                mem[_32889 + 32] = 'SafeMath: division by zero'
                                                if not totalSupply:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                    idx = 32
                                                    while idx < 26:
                                                        mem[idx + mem[64] + 68] = mem[idx + _32889 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 'SafeMath: division by zero'
                                                if not arg2:
                                                    if not _tFeePercent * arg2 / 10000:
                                                        _37787 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_37787] = 30
                                                        mem[_37787 + 32] = 'SafeMath: subtraction overflow'
                                                        mem[0] = msg.sender
                                                        mem[32] = 203
                                                        _40432 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_40432] = 30
                                                        mem[_40432 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 > stor203[address(msg.sender)]:
                                                            _41636 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 30
                                                            idx = 0
                                                            while idx < 30:
                                                                mem[idx + _41636 + 68] = mem[idx + _40432 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_41636 + 68] = mem[_41636 + 70 len 30]
                                                            revert with memory
                                                              from mem[64]
                                                               len _41636 + -mem[64] + 100
                                                        if stor203[arg1] < stor203[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = arg1
                                                        mem[32] = 203
                                                        stor203[address(arg1)] = stor203[arg1]
                                                        _49123 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_49123] = 30
                                                        mem[_49123 + 32] = 'SafeMath: subtraction overflow'
                                                        if 0 <= stor209:
                                                            if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalFees += _tFeePercent * arg2 / 10000
                                                            emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                            return 1
                                                        _51439 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _51439 + 68] = mem[idx + _49123 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_51439 + 68] = mem[_51439 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _51439 + -mem[64] + 100
                                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    _37913 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_37913] = 30
                                                    mem[_37913 + 32] = 'SafeMath: subtraction overflow'
                                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                        _38432 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _38432 + 68] = mem[idx + _37913 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_38432 + 68] = mem[_38432 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _38432 + -mem[64] + 100
                                                    mem[0] = msg.sender
                                                    mem[32] = 203
                                                    _41003 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_41003] = 30
                                                    mem[_41003 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor203[address(msg.sender)]:
                                                        _42502 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _42502 + 68] = mem[idx + _41003 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_42502 + 68] = mem[_42502 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _42502 + -mem[64] + 100
                                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 203
                                                    stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                    _50320 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_50320] = 30
                                                    mem[_50320 + 32] = 'SafeMath: subtraction overflow'
                                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                        stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += _tFeePercent * arg2 / 10000
                                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                        return 1
                                                    _52311 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _52311 + 68] = mem[idx + _50320 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_52311 + 68] = mem[_52311 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _52311 + -mem[64] + 100
                                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not _tFeePercent * arg2 / 10000:
                                                    _37912 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_37912] = 30
                                                    mem[_37912 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor209 / totalSupply * arg2:
                                                        _38429 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _38429 + 68] = mem[idx + _37912 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_38429 + 68] = mem[_38429 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _38429 + -mem[64] + 100
                                                    mem[0] = msg.sender
                                                    mem[32] = 203
                                                    _41002 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_41002] = 30
                                                    mem[_41002 + 32] = 'SafeMath: subtraction overflow'
                                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                        _42499 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _42499 + 68] = mem[idx + _41002 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_42499 + 68] = mem[_42499 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _42499 + -mem[64] + 100
                                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 203
                                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                                    _50319 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_50319] = 30
                                                    mem[_50319 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor209:
                                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += _tFeePercent * arg2 / 10000
                                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                        return 1
                                                    _52308 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _52308 + 68] = mem[idx + _50319 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_52308 + 68] = mem[_52308 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _52308 + -mem[64] + 100
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _38043 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38043] = 30
                                                mem[_38043 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                    _38759 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _38759 + 68] = mem[idx + _38043 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_38759 + 68] = mem[_38759 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _38759 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _41635 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41635] = 30
                                                mem[_41635 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    _43501 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _43501 + 68] = mem[idx + _41635 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_43501 + 68] = mem[_43501 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _43501 + -mem[64] + 100
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                _51438 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_51438] = 30
                                                mem[_51438 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                    return 1
                                                _52983 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _52983 + 68] = mem[idx + _51438 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_52983 + 68] = mem[_52983 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _52983 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            if stor204[stor207[idx]] <= s:
                                                require idx < stor207.length
                                                mem[0] = stor207[idx]
                                                mem[32] = 203
                                                _33095 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33095] = 30
                                                mem[_33095 + 32] = 'SafeMath: subtraction overflow'
                                                if stor203[stor207[idx]] > t:
                                                    _33642 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _33642 + 68] = mem[idx + _33095 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_33642 + 68] = mem[_33642 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _33642 + -mem[64] + 100
                                                require idx < stor207.length
                                                mem[0] = stor207[idx]
                                                mem[32] = 204
                                                _35598 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35598] = 30
                                                mem[_35598 + 32] = 'SafeMath: subtraction overflow'
                                                if stor204[stor207[idx]] <= s:
                                                    idx = idx + 1
                                                    s = s - stor204[stor207[idx]]
                                                    t = t - stor203[stor207[idx]]
                                                    continue 
                                                _36457 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _36457 + 68] = mem[idx + _35598 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_36457 + 68] = mem[_36457 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _36457 + -mem[64] + 100
                                            _33387 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33387] = 26
                                            mem[_33387 + 32] = 'SafeMath: division by zero'
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _33387 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                if not _tFeePercent * arg2 / 10000:
                                                    _38046 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_38046] = 30
                                                    mem[_38046 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 203
                                                    _41645 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_41645] = 30
                                                    mem[_41645 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor203[address(msg.sender)]:
                                                        _43508 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _43508 + 68] = mem[idx + _41645 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_43508 + 68] = mem[_43508 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _43508 + -mem[64] + 100
                                                    if stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 203
                                                    stor203[address(arg1)] = stor203[arg1]
                                                    _51443 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_51443] = 30
                                                    mem[_51443 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor209:
                                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalFees += _tFeePercent * arg2 / 10000
                                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                        return 1
                                                    _52988 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _52988 + 68] = mem[idx + _51443 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_52988 + 68] = mem[_52988 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _52988 + -mem[64] + 100
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _38436 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38436] = 30
                                                mem[_38436 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                    _39240 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _39240 + 68] = mem[idx + _38436 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_39240 + 68] = mem[_39240 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _39240 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _42508 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_42508] = 30
                                                mem[_42508 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _44436 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _44436 + 68] = mem[idx + _42508 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_44436 + 68] = mem[_44436 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _44436 + -mem[64] + 100
                                                if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                _52315 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_52315] = 30
                                                mem[_52315 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                    return 1
                                                _53771 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _53771 + 68] = mem[idx + _52315 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_53771 + 68] = mem[_53771 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _53771 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if not _tFeePercent * arg2 / 10000:
                                                _38435 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38435] = 30
                                                mem[_38435 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor209 / totalSupply * arg2:
                                                    _39237 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _39237 + 68] = mem[idx + _38435 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_39237 + 68] = mem[_39237 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _39237 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 203
                                                _42507 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_42507] = 30
                                                mem[_42507 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    _44433 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _44433 + 68] = mem[idx + _42507 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_44433 + 68] = mem[_44433 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _44433 + -mem[64] + 100
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                                _52314 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_52314] = 30
                                                mem[_52314 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += _tFeePercent * arg2 / 10000
                                                    emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                    return 1
                                                _53768 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _53768 + 68] = mem[idx + _52314 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_53768 + 68] = mem[_53768 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _53768 + -mem[64] + 100
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _38762 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38762] = 30
                                            mem[_38762 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                _39631 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39631 + 68] = mem[idx + _38762 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39631 + 68] = mem[_39631 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39631 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 203
                                            _43507 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_43507] = 30
                                            mem[_43507 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _45491 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _45491 + 68] = mem[idx + _43507 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_45491 + 68] = mem[_45491 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _45491 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                            _52987 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_52987] = 30
                                            mem[_52987 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * _tFeePercent * arg2 / 10000 <= stor209:
                                                stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                                if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += _tFeePercent * arg2 / 10000
                                                emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                                return 1
                                            _54730 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _54730 + 68] = mem[idx + _52987 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_54730 + 68] = mem[_54730 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _54730 + -mem[64] + 100
                                        _32019 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32019] = 26
                                        mem[_32019 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if t >= stor209 / totalSupply:
                                            _34045 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34045] = 26
                                            mem[_34045 + 32] = 'SafeMath: division by zero'
                                            if not s:
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                if not _tFeePercent * arg2 / 10000:
                                                    if 0 > stor203[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor203[address(arg1)] = stor203[arg1]
                                                    if 0 > stor209:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                else:
                                                    if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if t / s * _tFeePercent * arg2 / 10000 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if 0 > stor203[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor203[address(arg1)] = (-1 * t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                    if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                            else:
                                                if t / s * arg2 / arg2 != t / s:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not _tFeePercent * arg2 / 10000:
                                                    if 0 > t / s * arg2:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                                    if (t / s * arg2) + stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor203[address(arg1)] = (t / s * arg2) + stor203[arg1]
                                                    if 0 > stor209:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                else:
                                                    if t / s * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != t / s:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if t / s * _tFeePercent * arg2 / 10000 > t / s * arg2:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if t / s * arg2 > stor203[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor203[address(msg.sender)] += -1 * t / s * arg2
                                                    if (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor203[address(arg1)] = (t / s * arg2) - (t / s * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                    if t / s * _tFeePercent * arg2 / 10000 > stor209:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor209 += -1 * t / s * _tFeePercent * arg2 / 10000
                                        else:
                                            _34046 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34046] = 26
                                            mem[_34046 + 32] = 'SafeMath: division by zero'
                                            if not totalSupply:
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                if not _tFeePercent * arg2 / 10000:
                                                    if 0 > stor203[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor203[address(arg1)] = stor203[arg1]
                                                    if 0 > stor209:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                else:
                                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if 0 > stor203[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor203[address(arg1)] = (-1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                            else:
                                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if not _tFeePercent * arg2 / 10000:
                                                    if 0 > stor209 / totalSupply * arg2:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                    if (stor209 / totalSupply * arg2) + stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) + stor203[arg1]
                                                    if 0 > stor209:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                else:
                                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 / _tFeePercent * arg2 / 10000 != stor209 / totalSupply:
                                                        revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209 / totalSupply * arg2:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                    if (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1] < stor203[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor203[address(arg1)] = (stor209 / totalSupply * arg2) - (stor209 / totalSupply * _tFeePercent * arg2 / 10000) + stor203[arg1]
                                                    if stor209 / totalSupply * _tFeePercent * arg2 / 10000 > stor209:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    stor209 += -1 * stor209 / totalSupply * _tFeePercent * arg2 / 10000
                                        if (_tFeePercent * arg2 / 10000) + totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += _tFeePercent * arg2 / 10000
                                        emit Transfer((arg2 - (_tFeePercent * arg2 / 10000)), msg.sender, arg1);
                                else:
                                    if not arg2:
                                        mem[96] = 26
                                        mem[128] = 'SafeMath: division by zero'
                                        mem[64] = 224
                                        mem[160] = 30
                                        mem[192] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        idx = 0
                                        s = totalSupply
                                        t = stor209
                                        while idx < stor207.length:
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            if stor203[stor207[idx]] > t:
                                                _32904 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_32904] = 26
                                                mem[_32904 + 32] = 'SafeMath: division by zero'
                                                if not totalSupply:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                    idx = 32
                                                    while idx < 26:
                                                        mem[idx + mem[64] + 68] = mem[idx + _32904 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 'SafeMath: division by zero'
                                                if not arg2:
                                                    _37790 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_37790] = 30
                                                    mem[_37790 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 204
                                                    _40463 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_40463] = 30
                                                    mem[_40463 + 32] = 'SafeMath: subtraction overflow'
                                                    if arg2 > stor204[address(msg.sender)]:
                                                        _41664 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _41664 + 68] = mem[idx + _40463 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_41664 + 68] = mem[_41664 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _41664 + -mem[64] + 100
                                                    mem[0] = msg.sender
                                                    stor204[address(msg.sender)] -= arg2
                                                    mem[32] = 203
                                                    _44465 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_44465] = 30
                                                    mem[_44465 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor203[address(msg.sender)]:
                                                        _46779 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _46779 + 68] = mem[idx + _44465 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_46779 + 68] = mem[_46779 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _46779 + -mem[64] + 100
                                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor204[address(arg1)] += arg2
                                                    if stor203[address(arg1)] < stor203[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 203
                                                    _56585 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_56585] = 30
                                                    mem[_56585 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor209:
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                        return 1
                                                    _58320 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _58320 + 68] = mem[idx + _56585 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_58320 + 68] = mem[_58320 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _58320 + -mem[64] + 100
                                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _37918 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37918] = 30
                                                mem[_37918 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor209 / totalSupply * arg2:
                                                    _38445 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _38445 + 68] = mem[idx + _37918 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_38445 + 68] = mem[_38445 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _38445 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 204
                                                _41018 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41018] = 30
                                                mem[_41018 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    _42535 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _42535 + 68] = mem[idx + _41018 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42535 + 68] = mem[_42535 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42535 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                stor204[address(msg.sender)] -= arg2
                                                mem[32] = 203
                                                _45530 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_45530] = 30
                                                mem[_45530 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    _47907 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _47907 + 68] = mem[idx + _45530 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_47907 + 68] = mem[_47907 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _47907 + -mem[64] + 100
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] += stor209 / totalSupply * arg2
                                                _57380 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_57380] = 30
                                                mem[_57380 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    return 1
                                                _59071 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _59071 + 68] = mem[idx + _57380 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_59071 + 68] = mem[_59071 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _59071 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            if stor204[stor207[idx]] <= s:
                                                require idx < stor207.length
                                                mem[0] = stor207[idx]
                                                mem[32] = 203
                                                _33104 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33104] = 30
                                                mem[_33104 + 32] = 'SafeMath: subtraction overflow'
                                                if stor203[stor207[idx]] > t:
                                                    _33654 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _33654 + 68] = mem[idx + _33104 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_33654 + 68] = mem[_33654 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _33654 + -mem[64] + 100
                                                require idx < stor207.length
                                                mem[0] = stor207[idx]
                                                mem[32] = 204
                                                _35619 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35619] = 30
                                                mem[_35619 + 32] = 'SafeMath: subtraction overflow'
                                                if stor204[stor207[idx]] <= s:
                                                    idx = idx + 1
                                                    s = s - stor204[stor207[idx]]
                                                    t = t - stor203[stor207[idx]]
                                                    continue 
                                                _36481 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _36481 + 68] = mem[idx + _35619 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_36481 + 68] = mem[_36481 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _36481 + -mem[64] + 100
                                            _33402 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33402] = 26
                                            mem[_33402 + 32] = 'SafeMath: division by zero'
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _33402 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                _38049 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38049] = 30
                                                mem[_38049 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 204
                                                _41669 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41669] = 30
                                                mem[_41669 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    _43544 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _43544 + 68] = mem[idx + _41669 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_43544 + 68] = mem[_43544 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _43544 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                stor204[address(msg.sender)] -= arg2
                                                mem[32] = 203
                                                _46785 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_46785] = 30
                                                mem[_46785 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _49183 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _49183 + 68] = mem[idx + _46785 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_49183 + 68] = mem[_49183 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _49183 + -mem[64] + 100
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                _58323 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_58323] = 30
                                                mem[_58323 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    return 1
                                                _59657 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _59657 + 68] = mem[idx + _58323 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_59657 + 68] = mem[_59657 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _59657 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _38448 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38448] = 30
                                            mem[_38448 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _39258 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39258 + 68] = mem[idx + _38448 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39258 + 68] = mem[_39258 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39258 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _42538 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42538] = 30
                                            mem[_42538 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _44468 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44468 + 68] = mem[idx + _42538 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44468 + 68] = mem[_44468 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44468 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _47910 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_47910] = 30
                                            mem[_47910 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _50367 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _50367 + 68] = mem[idx + _47910 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_50367 + 68] = mem[_50367 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _50367 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                            _59074 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_59074] = 30
                                            mem[_59074 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _60239 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _60239 + 68] = mem[idx + _59074 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_60239 + 68] = mem[_60239 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _60239 + -mem[64] + 100
                                        _32034 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32034] = 26
                                        mem[_32034 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if t >= stor209 / totalSupply:
                                            _34066 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34066] = 26
                                            mem[_34066 + 32] = 'SafeMath: division by zero'
                                            if not s:
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                if arg2 > stor204[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor204[address(msg.sender)] -= arg2
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if t / s * arg2 / arg2 != t / s:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 0 > t / s * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor204[address(msg.sender)] -= arg2
                                                if t / s * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] += t / s * arg2
                                        else:
                                            _34067 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34067] = 26
                                            mem[_34067 + 32] = 'SafeMath: division by zero'
                                            if not totalSupply:
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                if arg2 > stor204[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor204[address(msg.sender)] -= arg2
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 0 > stor209 / totalSupply * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor204[address(msg.sender)] -= arg2
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] += stor209 / totalSupply * arg2
                                    else:
                                        if 0 / arg2:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                        32,
                                                        33,
                                                        0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[197 len 31]
                                        mem[96] = 26
                                        mem[128] = 'SafeMath: division by zero'
                                        mem[64] = 224
                                        mem[160] = 30
                                        mem[192] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        idx = 0
                                        s = totalSupply
                                        t = stor209
                                        while idx < stor207.length:
                                            mem[0] = stor207[idx]
                                            mem[32] = 203
                                            if stor203[stor207[idx]] > t:
                                                _32899 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_32899] = 26
                                                mem[_32899 + 32] = 'SafeMath: division by zero'
                                                if not totalSupply:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                    idx = 32
                                                    while idx < 26:
                                                        mem[idx + mem[64] + 68] = mem[idx + _32899 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    revert with 0, 'SafeMath: division by zero'
                                                if not arg2:
                                                    _37789 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_37789] = 30
                                                    mem[_37789 + 32] = 'SafeMath: subtraction overflow'
                                                    mem[0] = msg.sender
                                                    mem[32] = 204
                                                    _40453 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_40453] = 30
                                                    mem[_40453 + 32] = 'SafeMath: subtraction overflow'
                                                    if arg2 > stor204[address(msg.sender)]:
                                                        _41656 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _41656 + 68] = mem[idx + _40453 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_41656 + 68] = mem[_41656 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _41656 + -mem[64] + 100
                                                    mem[0] = msg.sender
                                                    stor204[address(msg.sender)] -= arg2
                                                    mem[32] = 203
                                                    _44454 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_44454] = 30
                                                    mem[_44454 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 > stor203[address(msg.sender)]:
                                                        _46763 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 30
                                                        idx = 0
                                                        while idx < 30:
                                                            mem[idx + _46763 + 68] = mem[idx + _44454 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_46763 + 68] = mem[_46763 + 70 len 30]
                                                        revert with memory
                                                          from mem[64]
                                                           len _46763 + -mem[64] + 100
                                                    if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    stor204[address(arg1)] += arg2
                                                    if stor203[address(arg1)] < stor203[address(arg1)]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = arg1
                                                    mem[32] = 203
                                                    _56577 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_56577] = 30
                                                    mem[_56577 + 32] = 'SafeMath: subtraction overflow'
                                                    if 0 <= stor209:
                                                        if totalFees < totalFees:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                        return 1
                                                    _58310 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _58310 + 68] = mem[idx + _56577 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_58310 + 68] = mem[_58310 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _58310 + -mem[64] + 100
                                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _37917 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_37917] = 30
                                                mem[_37917 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor209 / totalSupply * arg2:
                                                    _38441 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _38441 + 68] = mem[idx + _37917 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_38441 + 68] = mem[_38441 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _38441 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                mem[32] = 204
                                                _41014 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41014] = 30
                                                mem[_41014 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    _42525 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _42525 + 68] = mem[idx + _41014 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_42525 + 68] = mem[_42525 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _42525 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                stor204[address(msg.sender)] -= arg2
                                                mem[32] = 203
                                                _45517 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_45517] = 30
                                                mem[_45517 + 32] = 'SafeMath: subtraction overflow'
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    _47894 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _47894 + 68] = mem[idx + _45517 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_47894 + 68] = mem[_47894 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _47894 + -mem[64] + 100
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                stor203[address(arg1)] += stor209 / totalSupply * arg2
                                                _57374 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_57374] = 30
                                                mem[_57374 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    return 1
                                                _59065 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _59065 + 68] = mem[idx + _57374 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_59065 + 68] = mem[_59065 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _59065 + -mem[64] + 100
                                            require idx < stor207.length
                                            mem[0] = stor207[idx]
                                            mem[32] = 204
                                            if stor204[stor207[idx]] <= s:
                                                require idx < stor207.length
                                                mem[0] = stor207[idx]
                                                mem[32] = 203
                                                _33101 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_33101] = 30
                                                mem[_33101 + 32] = 'SafeMath: subtraction overflow'
                                                if stor203[stor207[idx]] > t:
                                                    _33650 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _33650 + 68] = mem[idx + _33101 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_33650 + 68] = mem[_33650 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _33650 + -mem[64] + 100
                                                require idx < stor207.length
                                                mem[0] = stor207[idx]
                                                mem[32] = 204
                                                _35612 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_35612] = 30
                                                mem[_35612 + 32] = 'SafeMath: subtraction overflow'
                                                if stor204[stor207[idx]] <= s:
                                                    idx = idx + 1
                                                    s = s - stor204[stor207[idx]]
                                                    t = t - stor203[stor207[idx]]
                                                    continue 
                                                _36473 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _36473 + 68] = mem[idx + _35612 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_36473 + 68] = mem[_36473 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _36473 + -mem[64] + 100
                                            _33397 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33397] = 26
                                            mem[_33397 + 32] = 'SafeMath: division by zero'
                                            if not totalSupply:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _33397 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                _38048 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_38048] = 30
                                                mem[_38048 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 204
                                                _41661 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_41661] = 30
                                                mem[_41661 + 32] = 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    _43532 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _43532 + 68] = mem[idx + _41661 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_43532 + 68] = mem[_43532 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _43532 + -mem[64] + 100
                                                mem[0] = msg.sender
                                                stor204[address(msg.sender)] -= arg2
                                                mem[32] = 203
                                                _46769 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_46769] = 30
                                                mem[_46769 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor203[address(msg.sender)]:
                                                    _49164 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _49164 + 68] = mem[idx + _46769 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_49164 + 68] = mem[_49164 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _49164 + -mem[64] + 100
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 203
                                                _58313 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_58313] = 30
                                                mem[_58313 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor209:
                                                    if totalFees < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                    return 1
                                                _59651 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _59651 + 68] = mem[idx + _58313 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_59651 + 68] = mem[_59651 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _59651 + -mem[64] + 100
                                            if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _38444 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_38444] = 30
                                            mem[_38444 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor209 / totalSupply * arg2:
                                                _39252 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _39252 + 68] = mem[idx + _38444 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_39252 + 68] = mem[_39252 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _39252 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 204
                                            _42528 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_42528] = 30
                                            mem[_42528 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 > stor204[address(msg.sender)]:
                                                _44457 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _44457 + 68] = mem[idx + _42528 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_44457 + 68] = mem[_44457 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _44457 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            stor204[address(msg.sender)] -= arg2
                                            mem[32] = 203
                                            _47897 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_47897] = 30
                                            mem[_47897 + 32] = 'SafeMath: subtraction overflow'
                                            if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                _50351 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _50351 + 68] = mem[idx + _47897 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_50351 + 68] = mem[_50351 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _50351 + -mem[64] + 100
                                            stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                            if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor204[address(arg1)] += arg2
                                            if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 203
                                            stor203[address(arg1)] += stor209 / totalSupply * arg2
                                            _59068 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_59068] = 30
                                            mem[_59068 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor209:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _60231 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _60231 + 68] = mem[idx + _59068 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_60231 + 68] = mem[_60231 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _60231 + -mem[64] + 100
                                        _32029 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_32029] = 26
                                        mem[_32029 + 32] = 'SafeMath: division by zero'
                                        if not totalSupply:
                                            revert with 0, 'SafeMath: division by zero'
                                        if t >= stor209 / totalSupply:
                                            _34059 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34059] = 26
                                            mem[_34059 + 32] = 'SafeMath: division by zero'
                                            if not s:
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                if arg2 > stor204[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor204[address(msg.sender)] -= arg2
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if t / s * arg2 / arg2 != t / s:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 0 > t / s * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor204[address(msg.sender)] -= arg2
                                                if t / s * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * t / s * arg2
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if (t / s * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] += t / s * arg2
                                        else:
                                            _34060 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_34060] = 26
                                            mem[_34060 + 32] = 'SafeMath: division by zero'
                                            if not totalSupply:
                                                revert with 0, 'SafeMath: division by zero'
                                            if not arg2:
                                                if arg2 > stor204[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor204[address(msg.sender)] -= arg2
                                                if 0 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                            else:
                                                if stor209 / totalSupply * arg2 / arg2 != stor209 / totalSupply:
                                                    revert with 0, 32, 33, 0x74536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                if 0 > stor209 / totalSupply * arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                if arg2 > stor204[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor204[address(msg.sender)] -= arg2
                                                if stor209 / totalSupply * arg2 > stor203[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                stor203[address(msg.sender)] += -1 * stor209 / totalSupply * arg2
                                                if arg2 + stor204[address(arg1)] < stor204[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor204[address(arg1)] += arg2
                                                if (stor209 / totalSupply * arg2) + stor203[address(arg1)] < stor203[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                stor203[address(arg1)] += stor209 / totalSupply * arg2
                                    if 0 > stor209:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
    return 1
}



}
